#include "wl.h"



void _DT_INIT(void)

{
  FUN_004013b4();
  FUN_004e48a0();
  return;
}



void processEntry entry(undefined4 param_1,undefined4 param_2)

{
  undefined1 auStack_20 [16];
  code *local_10;
  undefined4 local_c;
  undefined1 *local_8;
  
  local_8 = auStack_20;
  local_10 = _DT_FINI;
  local_c = param_1;
  __uClibc_main(FUN_004bada4,param_2,&stack0x00000004,_DT_INIT);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x00401268)
// WARNING: Removing unreachable block (ram,0x00401274)

void FUN_00401240(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x004012b0)
// WARNING: Removing unreachable block (ram,0x004012bc)

void FUN_0040127c(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x00401360)
// WARNING: Removing unreachable block (ram,0x00401318)
// WARNING: Removing unreachable block (ram,0x00401354)
// WARNING: Removing unreachable block (ram,0x004013ac)
// WARNING: Removing unreachable block (ram,0x00401370)

void FUN_004012c4(void)

{
  if (DAT_005576e0 == '\0') {
    FUN_00401240();
    DAT_005576e0 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0040143c)
// WARNING: Removing unreachable block (ram,0x004013c8)
// WARNING: Removing unreachable block (ram,0x004013d8)
// WARNING: Removing unreachable block (ram,0x004013e8)
// WARNING: Removing unreachable block (ram,0x00401418)

void FUN_004013b4(void)

{
  FUN_0040127c();
  return;
}



void FUN_00401460(int param_1)

{
  if (param_1 != 0) {
    if (DAT_00559b14 < 0x100) {
      *(int *)(&DAT_00559714 + DAT_00559b14 * 4) = param_1;
      DAT_00559b14 = DAT_00559b14 + 1;
    }
    else {
      fprintf(stderr,"err - module count over %d\n",0x100);
    }
  }
  return;
}



int * FUN_00401514(char *param_1)

{
  int iVar1;
  int local_10;
  int *local_c;
  
  local_c = (int *)0x0;
  for (local_10 = 0; local_10 < DAT_00559b14; local_10 = local_10 + 1) {
    local_c = *(int **)(&DAT_00559714 + local_10 * 4);
    while ((*local_c != 0 && (iVar1 = strcmp((char *)*local_c,param_1), iVar1 != 0))) {
      local_c = local_c + 5;
    }
    if (*local_c != 0) break;
  }
  if (local_c == (int *)0x0) {
    local_c = (int *)0x0;
  }
  else if (*local_c == 0) {
    local_c = (int *)0x0;
  }
  return local_c;
}



undefined4 FUN_00401634(void)

{
  return DAT_00557708;
}



undefined * FUN_0040165c(void)

{
  return PTR_DAT_00551644;
}



void FUN_00401684(void)

{
  DAT_0055970c = 0;
  return;
}



void FUN_004016ac(void)

{
  DAT_0055970c = 0;
  DAT_0055970d = 0;
  FUN_004b9c2c();
  FUN_00401460(0x551e20);
  FUN_004af8c0();
  return;
}



int FUN_00401704(int *param_1)

{
  int iVar1;
  uint local_10 [2];
  
  iVar1 = FUN_004b9f94(param_1,0,(char *)local_10,4);
  if (-1 < iVar1) {
    if (local_10[0] == 0x776ce414) {
      local_10[0] = 0x14e46c77;
      DAT_00557704 = '\x01';
    }
    if (local_10[0] == 0x14e46c77) {
      iVar1 = FUN_004b9f94(param_1,1,(char *)local_10,4);
      if (-1 < iVar1) {
        DAT_00557708 = local_10[0];
        if (DAT_00557704 != '\0') {
          DAT_00557708 = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                         (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
        }
        if ((DAT_00557708 == 2) || (DAT_00557708 == 1)) {
          iVar1 = 0;
        }
        else {
          fprintf(stderr,"Version mismatch, please upgrade. Got %d, expected %d or 1\n",DAT_00557708
                  ,2);
          iVar1 = -1;
        }
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_0040192c(int param_1)

{
  undefined4 local_10;
  
  for (local_10 = 0; *(int *)(param_1 + local_10 * 4) != 0; local_10 = local_10 + 1) {
  }
  return local_10;
}



undefined4 FUN_00401988(int *param_1,int *param_2,undefined4 *param_3)

{
  int iVar1;
  char *param2;
  int local_20;
  undefined4 local_1c;
  undefined4 local_18;
  int *local_14;
  
  local_20 = 0;
  local_1c = 0;
  local_18 = 0;
  local_14 = (int *)*param_1;
  if (*local_14 != 0) {
    iVar1 = strcmp((char *)*local_14,"-a");
    if ((iVar1 == 0) || (iVar1 = strcmp((char *)*local_14,"-i"), iVar1 == 0)) {
      param2 = (char *)*local_14;
      local_14 = local_14 + 1;
      local_20 = *local_14;
      if (local_20 == 0) {
        fprintf(stderr,"error: expected interface name after option %s\n",param2);
        local_18 = 0xffffffff;
        goto LAB_00401c08;
      }
    }
    else {
      iVar1 = strcmp((char *)*local_14,"-d");
      if (iVar1 == 0) {
        DAT_0055970c = 0;
      }
      else {
        iVar1 = strcmp((char *)*local_14,"-u");
        if (iVar1 == 0) {
          DAT_0055970c = 1;
        }
        else {
          iVar1 = strcmp((char *)*local_14,"-x");
          if (iVar1 == 0) {
            DAT_0055970c = 2;
          }
          else {
            iVar1 = strcmp((char *)*local_14,"-h");
            if ((iVar1 == 0) || (iVar1 = strcmp((char *)*local_14,"--help"), iVar1 == 0)) {
              local_1c = 1;
            }
            else {
              iVar1 = strcmp((char *)*local_14,"--clientbatch");
              if (iVar1 == 0) {
                FUN_00483314(1);
              }
              else {
                iVar1 = strcmp((char *)*local_14,"--es");
                if (iVar1 != 0) {
                  local_18 = 1;
                  goto LAB_00401c08;
                }
                DAT_00557704 = 1;
              }
            }
          }
        }
      }
    }
    local_14 = local_14 + 1;
  }
LAB_00401c08:
  *param_3 = local_1c;
  *param_2 = local_20;
  *param_1 = (int)local_14;
  return local_18;
}



void FUN_00401c48(FILE *param_1,undefined4 *param_2)

{
  size_t sVar1;
  
  sVar1 = strlen((char *)*param_2);
  if (sVar1 < 8) {
    fprintf(param_1,"%s\t%s\n\n",(char *)*param_2,(char *)param_2[4]);
  }
  else {
    fprintf(param_1,"%s\n\t%s\n\n",(char *)*param_2,(char *)param_2[4]);
  }
  return;
}



undefined4 FUN_00401cf8(undefined4 param_1,undefined4 *param_2)

{
  FUN_00401c48(stderr,param_2);
  return 0;
}



undefined4 FUN_00401d48(void)

{
  int iVar1;
  size_t sVar2;
  void *__ptr;
  undefined4 uVar3;
  int iVar4;
  char *pcVar5;
  int *local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  local_34 = 0;
  for (local_30 = 0; local_30 < DAT_00559b14; local_30 = local_30 + 1) {
    for (local_38 = *(int **)(&DAT_00559714 + local_30 * 4); *local_38 != 0; local_38 = local_38 + 5
        ) {
      iVar1 = FUN_0045a43c((char *)*local_38);
      if (iVar1 != 0) {
        local_34 = local_34 + 1;
      }
    }
  }
  if (local_34 < 0) {
    local_34 = local_34 + 3;
  }
  iVar1 = (local_34 >> 2) + 1;
  sVar2 = iVar1 * 0x50 + 2;
  __ptr = malloc(sVar2);
  if (__ptr == (void *)0x0) {
    fprintf(stderr,"Failed to allocate buffer of %d bytes\n",sVar2);
    uVar3 = 0xffffffe5;
  }
  else {
    for (local_30 = 0; local_30 < (int)sVar2; local_30 = local_30 + 1) {
      *(undefined1 *)((int)__ptr + local_30) = 0;
    }
    local_28 = 0;
    local_24 = 0;
    for (local_2c = 0x61; local_2c < 0x7a; local_2c = local_2c + 1) {
      for (local_30 = 0; local_30 < DAT_00559b14; local_30 = local_30 + 1) {
        for (local_38 = *(int **)(&DAT_00559714 + local_30 * 4); *local_38 != 0;
            local_38 = local_38 + 5) {
          iVar4 = FUN_0045a43c((char *)*local_38);
          if ((iVar4 != 0) &&
             ((*(char *)*local_38 == local_2c || ((int)*(char *)*local_38 == local_2c + -0x20)))) {
            strcat((char *)((int)__ptr + local_24 * 0x50),(char *)*local_38);
            sVar2 = strlen((char *)((int)__ptr + local_24 * 0x50));
            local_20 = (local_28 + 1) * 0x12 - sVar2;
            if (local_20 < 1) {
              local_20 = 1;
            }
            for (; local_20 != 0; local_20 = local_20 + -1) {
              pcVar5 = (char *)((int)__ptr + local_24 * 0x50);
              sVar2 = strlen(pcVar5);
              pcVar5 = pcVar5 + sVar2;
              *pcVar5 = ' ';
              pcVar5[1] = '\0';
            }
            local_24 = local_24 + 1;
            if (local_24 == iVar1) {
              local_28 = local_28 + 1;
              local_24 = 0;
            }
          }
        }
      }
    }
    for (local_24 = 0; local_24 < iVar1; local_24 = local_24 + 1) {
      puts((char *)((int)__ptr + local_24 * 0x50));
    }
    putchar(10);
    free(__ptr);
    uVar3 = 0;
  }
  return uVar3;
}



void FUN_00402164(FILE *param_1,int *param_2)

{
  int iVar1;
  int *local_18;
  int *local_14;
  int local_10;
  
  for (local_18 = param_2; (local_18 != (int *)0x0 && (*local_18 != 0)); local_18 = local_18 + 5) {
    iVar1 = FUN_0045a43c((char *)*local_18);
    if (iVar1 != 0) {
      FUN_00401c48(param_1,local_18);
    }
  }
  for (local_10 = 0; local_10 < DAT_00559b14; local_10 = local_10 + 1) {
    for (local_14 = *(int **)(&DAT_00559714 + local_10 * 4); local_18 = param_2, *local_14 != 0;
        local_14 = local_14 + 5) {
      while (((local_18 != (int *)0x0 && (*local_18 != 0)) &&
             (iVar1 = strcmp((char *)*local_18,(char *)*local_14), iVar1 != 0))) {
        local_18 = local_18 + 5;
      }
      if (((local_18 == (int *)0x0) || (*local_18 == 0)) &&
         (iVar1 = FUN_0045a43c((char *)*local_14), iVar1 != 0)) {
        FUN_00401c48(param_1,local_14);
      }
    }
  }
  return;
}



void FUN_0040231c(FILE *param_1,int *param_2)

{
  fprintf(param_1,"Usage: %s [-a|i <adapter>] [-h] [-d|u|x] <command> [arguments]\n",DAT_00557690);
  fputc(10,param_1);
  fwrite("  -h        this message and command descriptions\n",1,0x32,param_1);
  fwrite("  -h [cmd]  command description for cmd\n",1,0x28,param_1);
  fwrite("  -a, -i    adapter name or number\n",1,0x23,param_1);
  fwrite("  -d        output format signed integer\n",1,0x29,param_1);
  fwrite("  -u        output format unsigned integer\n",1,0x2b,param_1);
  fwrite("  -x        output format hexdecimal\n",1,0x25,param_1);
  fputc(10,param_1);
  FUN_00402164(param_1,param_2);
  return;
}



void FUN_00402444(uint param_1)

{
  if (DAT_0055970c == '\x01') {
    printf("%u\n",param_1);
  }
  else if (DAT_0055970c == '\x02') {
    printf("0x%x\n",param_1);
  }
  else {
    printf("%d\n",param_1);
  }
  return;
}



undefined4 FUN_004024e8(int *param_1,char *param_2,undefined4 *param_3,undefined4 *param_4)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 auStack_ac [3];
  undefined4 local_a0;
  char local_9c;
  char local_9b;
  char local_9a;
  char acStack_99 [129];
  char *local_18;
  undefined4 local_10;
  
  *param_3 = 0;
  *param_4 = 0;
  FUN_004cbd80(auStack_ac,param_2,0,0);
  iVar1 = FUN_004cbe18(auStack_ac,param_1);
  if (iVar1 == -1) {
    uVar2 = 0;
  }
  else if (local_9c == '\0') {
    if (iVar1 == 1) {
      uVar2 = 0xffffffd4;
    }
    else {
      if ((((local_9a == 'C') || (iVar1 = strcmp(acStack_99,"cfg"), iVar1 == 0)) ||
          (iVar1 = strcmp(acStack_99,"config"), iVar1 == 0)) ||
         (iVar1 = strcmp(acStack_99,"configuration"), iVar1 == 0)) {
        if (local_9b == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an integer for the configuartion index\n",
                  param_2,local_18);
          return 0xfffffffe;
        }
        *param_3 = local_10;
        *param_4 = local_a0;
      }
      uVar2 = 0;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



undefined4 FUN_0040268c(int *param_1,int param_2)

{
  undefined4 uVar1;
  
  if (*(int *)(param_2 + 0xc) < 0) {
    uVar1 = 0xffffffff;
  }
  else {
    uVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)0x0,0);
  }
  return uVar1;
}



int FUN_004026fc(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    if (*(int *)(param_2 + 8) == -1) {
      iVar2 = -1;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_14,4);
      if (-1 < iVar2) {
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
        }
        FUN_00402444(local_14);
      }
    }
  }
  else if (*(int *)(param_2 + 0xc) == -1) {
    iVar2 = -1;
  }
  else {
    iVar2 = strcasecmp((char *)*piVar1,"on");
    if (iVar2 == 0) {
      local_14 = 1;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"off");
      if (iVar2 == 0) {
        local_14 = 0;
      }
      else {
        local_14 = strtol((char *)*piVar1,local_10,0);
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
      }
    }
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_14,4);
  }
  return iVar2;
}



ushort FUN_00402978(ushort param_1)

{
  ushort uVar1;
  int iVar2;
  ushort local_10;
  
  local_10 = param_1 & 0xff;
  if ((param_1 & 0xf000) != 0x2000) {
    local_10 = local_10 | 0xc000;
  }
  if ((param_1 & 0xc00) == 0x800) {
    uVar1 = local_10 | 0x1000;
  }
  else {
    uVar1 = local_10 | 0x1800;
    if ((param_1 & 0x300) != 0x100) {
      uVar1 = local_10 | 0x1900;
    }
  }
  local_10 = uVar1;
  iVar2 = FUN_004c0dc0(local_10);
  if (iVar2 != 0) {
    fprintf(stderr,"wl_chspec_from_legacy: output chanspec (0x%04X) malformed\n",(uint)local_10);
    local_10 = 0xff;
  }
  return local_10;
}



ushort FUN_00402a90(ushort param_1)

{
  FILE *param0;
  int iVar1;
  char *param2;
  ushort local_28;
  char acStack_24 [24];
  
  iVar1 = FUN_004c0dc0(param_1);
  param0 = stderr;
  if (iVar1 == 0) {
    if ((param_1 & 0xc000) == 0) {
      local_28 = param_1 & 0xff | 0x2000;
    }
    else {
      local_28 = param_1 & 0xff | 0x1000;
    }
    if ((param_1 & 0x3800) == 0x1000) {
      local_28 = local_28 | 0xb00;
    }
    else if ((param_1 & 0x3800) == 0x1800) {
      if ((param_1 & 0x700) == 0) {
        local_28 = local_28 | 0xd00;
      }
      else {
        local_28 = local_28 | 0xe00;
      }
    }
    else {
      param2 = FUN_004c02bc(param_1,acStack_24);
      fprintf(param0,
              "wl_chspec_to_legacy: unable to convert chanspec %s (0x%04X) to pre-11ac format\n",
              param2,(uint)param_1);
      local_28 = 0xff;
    }
  }
  else {
    fprintf(stderr,"wl_chspec_to_legacy: input chanspec (0x%04X) malformed\n",(uint)param_1);
    local_28 = 0xff;
  }
  return local_28;
}



ushort FUN_00402c2c(ushort param_1)

{
  ushort local_res0;
  
  local_res0 = param_1;
  if ((((DAT_00557708 != 1) || (local_res0 = FUN_00402a90(param_1), local_res0 != 0xff)) &&
      (DAT_00557704 != '\0')) && (DAT_00557704 != '\0')) {
    local_res0 = local_res0 << 8 | local_res0 >> 8;
  }
  return local_res0;
}



uint FUN_00402d10(ushort param_1)

{
  uint uVar1;
  ushort local_res0;
  
  local_res0 = param_1;
  if ((DAT_00557708 == 1) && (local_res0 = FUN_00402a90(param_1), local_res0 == 0xff)) {
    uVar1 = 0xff;
  }
  else if (DAT_00557704 == '\0') {
    uVar1 = (uint)local_res0;
  }
  else {
    uVar1 = (uint)local_res0 << 0x18 | (local_res0 & 0xff00) << 8;
  }
  return uVar1;
}



ushort FUN_00402de8(ushort param_1)

{
  ushort local_res0;
  
  if ((DAT_00557704 != '\0') && (DAT_00557704 != '\0')) {
    param_1 = param_1 << 8 | param_1 >> 8;
  }
  local_res0 = param_1;
  if (DAT_00557708 == 1) {
    local_res0 = FUN_00402978(param_1);
  }
  return local_res0;
}



ushort FUN_00402eb0(undefined4 param_1)

{
  undefined2 local_10;
  
  if (DAT_00557704 == '\0') {
    local_10 = (ushort)param_1;
  }
  else {
    local_10 = (ushort)((uint)param_1 >> 8) & 0xff00 | (ushort)(byte)((uint)param_1 >> 0x18);
  }
  if (DAT_00557708 == 1) {
    local_10 = FUN_00402978(local_10);
  }
  return local_10;
}



int FUN_00402f70(int *param_1,char *param_2,ushort param_3,ushort param_4,ushort *param_5,
                int param_6)

{
  uint uVar1;
  int iVar2;
  
  *param_5 = param_3 | 0x1000;
  param_5[1] = param_4;
  if (DAT_00557704 == '\0') {
    uVar1 = param_6 - 0xc;
  }
  else {
    uVar1 = param_6 - 0xc;
    uVar1 = uVar1 * 0x1000000 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
  }
  *(uint *)(param_5 + 2) = uVar1;
  param_5[4] = 0;
  param_5[5] = 0;
  iVar2 = FUN_004ba160(param_1,param_2,param_5,(param_6 + 8) - param_6 % 8,PTR_DAT_00551644,0x600);
  return iVar2;
}



int FUN_004030bc(int *param_1,uint param_2,int param_3,undefined4 param_4)

{
  ushort *__s;
  uint uVar1;
  uint local_res4;
  uint local_30;
  uint local_2c;
  int local_28;
  int local_24;
  
  local_28 = 0;
  local_30 = param_2 / 0x580;
  if (param_2 % 0x580 != 0) {
    local_30 = local_30 + 1;
  }
  __s = (ushort *)malloc(0x5a0);
  if (__s == (ushort *)0x0) {
    local_24 = -0x1b;
  }
  else {
    memset(__s,0,0x5a0);
    *(uint *)(__s + 10) = local_30;
    *(uint *)(__s + 8) = param_2;
    *(undefined4 *)(__s + 6) = param_4;
    local_res4 = param_2;
    do {
      if (local_res4 < 0x580) {
        local_2c = local_res4;
      }
      else {
        local_2c = 0x580;
      }
      memset(__s + 0x10,0,0x580);
      uVar1 = local_2c;
      if (DAT_00557704 != '\0') {
        uVar1 = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                local_2c >> 0x18;
      }
      *(uint *)(__s + 0xc) = uVar1;
      memcpy(__s + 0x10,(void *)(param_3 + local_28),local_2c);
      *(int *)(__s + 0xe) = local_28;
      local_28 = local_28 + local_2c;
      local_24 = FUN_00402f70(param_1,"generic_dload",0,2,__s,local_2c + 0x20);
      local_res4 = local_res4 - local_2c;
    } while ((local_res4 != 0) && (local_24 == 0));
    free(__s);
  }
  return local_24;
}



int FUN_00403388(int *param_1,char *param_2,int param_3,uint param_4)

{
  ushort *__s;
  uint local_resc;
  size_t local_28;
  int local_24;
  int local_20;
  ushort local_1c;
  
  local_24 = 0;
  local_1c = 2;
  __s = (ushort *)malloc(0x58c);
  if (__s == (ushort *)0x0) {
    local_20 = -0x1b;
  }
  else {
    memset(__s,0,0x58c);
    local_resc = param_4;
    do {
      if (local_resc < 0x580) {
        local_28 = local_resc;
      }
      else {
        local_28 = 0x580;
      }
      memcpy(__s + 6,(void *)(param_3 + local_24),local_28);
      local_24 = local_24 + local_28;
      if (local_28 == local_resc) {
        local_1c = local_1c | 4;
      }
      local_20 = FUN_00402f70(param_1,param_2,local_1c,2,__s,local_28 + 0xc);
      local_1c = local_1c & 0xfffd;
      local_resc = local_resc - local_28;
    } while ((local_resc != 0) && (local_20 == 0));
    free(__s);
  }
  return local_20;
}



int FUN_0040352c(int *param_1,char *param_2,int param_3)

{
  FILE *param0;
  FILE *__stream;
  int iVar1;
  int *piVar2;
  char *pcVar3;
  size_t sVar4;
  int local_d8;
  void *local_d4;
  stat sStack_b8;
  char local_20 [8];
  undefined4 local_18 [3];
  
  local_d4 = (void *)0x0;
  builtin_strncpy(local_20,"CLM DATA",8);
  local_18[0]._0_1_ = 'B';
  local_18[0]._1_1_ = 'L';
  local_18[0]._2_1_ = 'O';
  local_18[0]._3_1_ = 'B';
  __stream = fopen(param_2,"rb");
  if (__stream == (FILE *)0x0) {
    fprintf(stderr,"unable to open input file %s\n",param_2);
    local_d8 = -2;
  }
  else {
    iVar1 = fileno(__stream);
    iVar1 = fstat(iVar1,&sStack_b8);
    param0 = stderr;
    if (iVar1 == 0) {
      if (sStack_b8.st_blocks == 0) {
        fprintf(stderr,"input file %s is empty (i.e. zero length)\n",param_2);
        local_d8 = -1;
      }
      else {
        local_d4 = malloc(sStack_b8.st_blocks);
        if (local_d4 == (void *)0x0) {
          fprintf(stderr,"unable to allocate %u bytes based on input file size!\n",
                  sStack_b8.st_blocks);
          local_d8 = -0x1b;
        }
        else {
          sVar4 = fread(local_d4,1,sStack_b8.st_blocks,__stream);
          if (sVar4 < 0x20) {
            fprintf(stderr,
                    "size of input file %s is less than %d bytes.  This can\'t be a CLM file!\n",
                    param_2,0x20);
            local_d8 = -1;
          }
          else if (sVar4 == sStack_b8.st_blocks) {
            iVar1 = memcmp(local_d4,local_18,4);
            if (iVar1 == 0) {
              printf("Downloading CLM blob format file %s\n",param_2);
              local_d8 = FUN_00403388(param_1,"clmload",(int)local_d4,sStack_b8.st_blocks);
            }
            else {
              iVar1 = memcmp(local_d4,local_20,8);
              if (iVar1 == 0) {
                if (param_3 == 0) {
                  pcVar3 = "base";
                }
                else {
                  pcVar3 = "incremental";
                }
                printf("Downloading legacy, obsolete CLM binary format file %s as a %s CLM\n",
                       param_2,pcVar3);
                local_d8 = FUN_004030bc(param_1,sStack_b8.st_blocks,(int)local_d4,param_3);
              }
              else {
                fwrite("input file is missing CLM binary or CLM blob magic string\n",1,0x3a,stderr);
                local_d8 = -1;
              }
            }
          }
          else {
            fprintf(stderr,"read of input file %s wasn\'t good based on fstat size %u\n",param_2,
                    sStack_b8.st_blocks);
            local_d8 = -1;
          }
        }
      }
    }
    else {
      piVar2 = __errno_location();
      pcVar3 = strerror(*piVar2);
      fprintf(param0,"fstat on input file %s return error %s\n",param_2,pcVar3);
      local_d8 = -1;
    }
  }
  if (local_d4 != (void *)0x0) {
    free(local_d4);
  }
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
  }
  return local_d8;
}



int FUN_00403910(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  char *local_18;
  
  local_18 = *(char **)(param_3 + 4);
  if (local_18 == (char *)0x0) {
    fwrite("too few arguments (none)\n",1,0x19,stderr);
    iVar1 = -0x2c;
  }
  else if ((*(char **)(param_3 + 8) == (char *)0x0) ||
          (local_18 = *(char **)(param_3 + 8), *(int *)(param_3 + 0xc) == 0)) {
    iVar1 = FUN_0040352c(param_1,local_18,0);
  }
  else {
    fwrite("too mang arguments (3 or more)\n",1,0x1f,stderr);
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00403a48(int *param_1,char *param_2)

{
  FILE *param0;
  FILE *__stream;
  int iVar1;
  int *piVar2;
  char *param3;
  size_t sVar3;
  int local_c8;
  void *local_c4;
  stat sStack_b0;
  char local_18 [12];
  
  local_c4 = (void *)0x0;
  builtin_strncpy(local_18,"BLOB",4);
  __stream = fopen(param_2,"rb");
  if (__stream == (FILE *)0x0) {
    fprintf(stderr,"unable to open input file %s\n",param_2);
    local_c8 = -0x16;
  }
  else {
    iVar1 = fileno(__stream);
    iVar1 = fstat(iVar1,&sStack_b0);
    param0 = stderr;
    if (iVar1 == 0) {
      if (sStack_b0.st_blocks == 0) {
        fprintf(stderr,"input file %s is empty (i.e. zero length)\n",param_2);
        local_c8 = -0x16;
      }
      else {
        local_c4 = malloc(sStack_b0.st_blocks);
        if (local_c4 == (void *)0x0) {
          fprintf(stderr,"unable to allocate %u bytes based on input file size!\n",
                  sStack_b0.st_blocks);
          local_c8 = -0xc;
        }
        else {
          sVar3 = fread(local_c4,1,sStack_b0.st_blocks,__stream);
          if (sVar3 == sStack_b0.st_blocks) {
            if (sVar3 < 0x20) {
              fprintf(stderr,
                      "size of input file %s is less than %d bytes.  This can\'t be a txcap file!\n"
                      ,param_2,0x20);
              local_c8 = -0x16;
            }
            else if (sVar3 == sStack_b0.st_blocks) {
              iVar1 = memcmp(local_c4,local_18,4);
              if (iVar1 == 0) {
                printf("Downloading txcap package format file %s\n",param_2);
                local_c8 = FUN_00403388(param_1,"txcapload",(int)local_c4,sStack_b0.st_blocks);
              }
              else {
                fwrite("input file is missing txcap package magic string\n",1,0x31,stderr);
                local_c8 = -1;
              }
            }
            else {
              fprintf(stderr,"read of input file %s wasn\'t good based on fstat size %u\n",param_2,
                      sStack_b0.st_blocks);
              local_c8 = -0x16;
            }
          }
          else {
            fprintf(stderr,"read of input file %s wasn\'t good based on fstat size %u\n",param_2,
                    sStack_b0.st_blocks);
            local_c8 = -0x16;
          }
        }
      }
    }
    else {
      piVar2 = __errno_location();
      param3 = strerror(*piVar2);
      fprintf(param0,"fstat on input file %s return error %s\n",param_2,param3);
      local_c8 = -0x16;
    }
  }
  if (local_c4 != (void *)0x0) {
    free(local_c4);
  }
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
  }
  return local_c8;
}



int FUN_00403db0(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar1 = -1;
  }
  else if (*(int *)(param_3 + 8) == 0) {
    iVar1 = FUN_00403a48(param_1,*(char **)(param_3 + 4));
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int FUN_00403e60(int *param_1,undefined4 *param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  int *local_res8;
  int local_1c;
  int local_14;
  undefined1 local_10;
  undefined1 auStack_f [7];
  
  local_14 = 0;
  if (param_3[1] == 0) {
    iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
    if (-1 < iVar1) {
      printf("%d %d %d %d %d\n",(uint)*(byte *)(local_14 + 1),(uint)*(byte *)(local_14 + 2),
             (uint)*(byte *)(local_14 + 3),(uint)*(byte *)(local_14 + 4),
             (uint)*(byte *)(local_14 + 5));
    }
  }
  else {
    local_res8 = param_3;
    for (local_1c = 0; local_1c < 5; local_1c = local_1c + 1) {
      local_res8 = local_res8 + 1;
      if (*local_res8 == 0) {
        return -0x2c;
      }
      lVar2 = strtol((char *)*local_res8,(char **)0x0,0);
      auStack_f[local_1c] = (char)lVar2;
    }
    if (local_res8[1] == 0) {
      local_10 = 2;
      iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_10,6);
      if (iVar1 < 0) {
        iVar1 = -1;
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_0040404c(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int local_18;
  int local_14;
  char *local_c;
  
  local_c = (char *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pcVar1 = local_c;
    if (-1 < local_18) {
      if (*local_c == '\x02') {
        printf("current country %c%c, channel(control) %d\n",local_c[2],local_c[3],
               *(int *)(local_c + 4));
        printf("low/high cap config: ");
        for (local_14 = 0; local_14 < 5; local_14 = local_14 + 1) {
          printf(" %d",(uint)(byte)pcVar1[local_14 + 8]);
        }
        putchar(10);
        printf("low/high cap state:  ");
        for (local_14 = 0; local_14 < 5; local_14 = local_14 + 1) {
          printf(" %d",(uint)(byte)pcVar1[local_14 + 0xd]);
        }
        putchar(10);
        printf("high cap state enabled %d\n",(uint)(byte)pcVar1[0x12]);
        printf("wci2 cell status last %d\n",(uint)(byte)pcVar1[0x13]);
        if (pcVar1[0x14] == '\0') {
          puts("txcap download not present");
        }
        else {
          printf("subbands %d, antennas %d, antennas per core",(uint)(byte)pcVar1[0x15],
                 (uint)(byte)pcVar1[0x16]);
          for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {
            printf(" %d",(uint)(byte)pcVar1[local_14 + 0x17]);
          }
          printf(", cc groups %d\n",(uint)(byte)pcVar1[0x1f]);
          printf("current cc group info index %d\n",(uint)(byte)pcVar1[0x20]);
          puts(
              " tx caps (decimal qdbm, per subband, per antenna, e.g. sb0_a0, sb0_a1, sb1_a0, sb1_a1, ...)"
              );
          printf("  low cap:  ");
          for (local_14 = 0; local_14 < (int)((uint)(byte)pcVar1[0x15] * (uint)(byte)pcVar1[0x16]);
              local_14 = local_14 + 1) {
            printf("%4d ",(int)pcVar1[local_14 + 0x21]);
          }
          putchar(10);
          printf("  high cap: ");
          for (local_14 = 0; local_14 < (int)((uint)(byte)pcVar1[0x15] * (uint)(byte)pcVar1[0x16]);
              local_14 = local_14 + 1) {
            printf("%4d ",(int)pcVar1[local_14 + 0x71]);
          }
          putchar(10);
        }
      }
      else {
        local_18 = -0x2c;
      }
    }
  }
  else {
    local_18 = -0x2c;
  }
  return local_18;
}



int FUN_00404448(int *param_1,int param_2,undefined4 *param_3)

{
  char *pcVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  char *local_18;
  uint local_14;
  uint local_10;
  int local_c;
  
  local_18 = (char *)0x0;
  local_14 = 0;
  local_10 = 0;
  pcVar1 = (char *)*param_3;
  local_20 = FUN_004024e8(param_3 + 1,pcVar1,&local_14,&local_c);
  if (local_20 == 0) {
    if ((local_c == 0) && (*(int *)(param_2 + 0xc) != 0x107)) {
      local_20 = FUN_004026fc(param_1,param_2,(int)param_3);
    }
    else {
      piVar2 = param_3 + 1 + local_c;
      if (*piVar2 == 0) {
        if (*(int *)(param_2 + 8) == -1) {
          local_20 = -1;
        }
        else {
          if (local_c == 0) {
            local_20 = FUN_004ba35c(param_1,pcVar1,&local_10);
          }
          else {
            local_20 = FUN_00445a00(param_1,pcVar1,local_14,&local_10);
          }
          if (-1 < local_20) {
            FUN_00402444(local_10);
          }
        }
      }
      else if (*(int *)(param_2 + 0xc) == -1) {
        local_20 = -1;
      }
      else {
        iVar3 = strcasecmp((char *)*piVar2,"on");
        if (iVar3 == 0) {
          local_10 = 1;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar2,"off");
          if (iVar3 == 0) {
            local_10 = 0;
          }
          else {
            local_10 = strtol((char *)*piVar2,&local_18,0);
            if (*local_18 != '\0') {
              return -0x2c;
            }
          }
        }
        if (local_c == 0) {
          local_20 = FUN_004ba428(param_1,pcVar1,local_10);
        }
        else {
          local_20 = FUN_00445ad8(param_1,pcVar1,local_14,local_10);
        }
      }
    }
  }
  return local_20;
}



int FUN_00404708(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  uint local_38;
  char *local_1c;
  uint local_18;
  int local_14;
  uint local_10;
  uint local_c;
  
  local_18 = 0;
  iVar1 = FUN_004024e8((int *)(param_3 + 4),&DAT_004fa2d0,&local_18,&local_14);
  if (iVar1 == 0) {
    piVar2 = (int *)(param_3 + 4) + local_14;
    if (local_14 == 0) {
      local_18 = 0xffffffff;
    }
    if (*piVar2 == 0) {
      if (DAT_00557704 != '\0') {
        local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                   local_18 >> 0x18;
      }
      iVar1 = FUN_004ba0cc(param_1,"bss",&local_18,4,PTR_DAT_00551644,0x2000);
      if (-1 < iVar1) {
        uVar3 = *(uint *)PTR_DAT_00551644;
        if (DAT_00557704 != '\0') {
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        if (uVar3 == 0) {
          puts("down");
        }
        else {
          puts("up");
        }
        iVar1 = 0;
      }
    }
    else {
      iVar1 = strcasecmp((char *)*piVar2,"ap");
      if (iVar1 == 0) {
        local_38 = 3;
      }
      else {
        iVar1 = strcasecmp((char *)*piVar2,"sta");
        if (iVar1 == 0) {
          local_38 = 2;
        }
        else {
          iVar1 = strcasecmp((char *)*piVar2,"up");
          if (iVar1 == 0) {
            local_38 = 1;
          }
          else {
            iVar1 = strcasecmp((char *)*piVar2,"down");
            if (iVar1 == 0) {
              local_38 = 0;
            }
            else {
              iVar1 = strcasecmp((char *)*piVar2,"del");
              if (iVar1 == 0) {
                local_38 = 0xffffffff;
              }
              else {
                local_38 = strtol((char *)*piVar2,&local_1c,0);
                if (*local_1c != '\0') {
                  return -0x2c;
                }
              }
            }
          }
        }
      }
      local_10 = local_18;
      if (DAT_00557704 != '\0') {
        local_10 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                   local_18 >> 0x18;
        local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                   local_38 >> 0x18;
      }
      local_c = local_38;
      iVar1 = FUN_004ba2e4(param_1,"bss",&local_10,8);
    }
  }
  return iVar1;
}



int FUN_00404b44(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  char *local_1c;
  char *local_10;
  uint local_c;
  
  local_10 = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_c,4);
    if (-1 < iVar2) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
      }
      switch(local_c) {
      case 0:
        local_1c = "54g Legacy B";
        break;
      case 1:
        local_1c = "54g Auto";
        break;
      case 2:
        local_1c = "54g Only";
        break;
      case 3:
        local_1c = "54g B Deferred";
        break;
      case 4:
        local_1c = "54g Performance";
        break;
      case 5:
        local_1c = "54g LRS";
        break;
      default:
        local_1c = "unknown";
      }
      printf("%s (%d)\n",local_1c,local_c);
    }
  }
  else {
    iVar2 = strncasecmp((char *)*piVar1,"legacy",6);
    if (iVar2 == 0) {
      local_c = 0;
    }
    else {
      iVar2 = strncasecmp((char *)*piVar1,"auto",4);
      if (iVar2 == 0) {
        local_c = 1;
      }
      else {
        iVar2 = strncasecmp((char *)*piVar1,"gonly",5);
        if (iVar2 == 0) {
          local_c = 2;
        }
        else {
          iVar2 = strncasecmp((char *)*piVar1,"bdefer",6);
          if (iVar2 == 0) {
            local_c = 3;
          }
          else {
            iVar2 = strncasecmp((char *)*piVar1,"perf",4);
            if (iVar2 == 0) {
              local_c = 4;
            }
            else {
              iVar2 = strncasecmp((char *)*piVar1,"lrs",3);
              if (iVar2 == 0) {
                local_c = 5;
              }
              else {
                local_c = strtol((char *)*piVar1,&local_10,0);
                if (*local_10 != '\0') {
                  return -0x2c;
                }
              }
            }
          }
        }
      }
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_c,4);
  }
  return iVar2;
}



int FUN_00404f2c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int *local_res8;
  int local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  char *local_1c;
  char *local_10;
  uint local_c;
  
  local_28 = 0;
  local_24 = 0;
  local_20 = 0;
  local_10 = (char *)0x0;
  iVar1 = FUN_004ba35c(param_1,(char *)*param_2,&local_c);
  if (-1 < iVar1) {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      printf("0x%x ",local_c);
      for (local_30 = 0; uVar2 = *(uint *)(&DAT_00555b24 + local_30 * 8), uVar2 != 0;
          local_30 = local_30 + 1) {
        if (((local_c & uVar2) != 0) && (uVar2 != local_28)) {
          printf(" %s",(&PTR_s_error_00555b28)[local_30 * 2]);
        }
        local_28 = uVar2;
      }
      putchar(10);
      iVar1 = 0;
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_1c = (char *)*local_res8;
        if ((*local_1c == '+') || (*local_1c == '-')) {
          local_1c = local_1c + 1;
        }
        else {
          local_20 = 0xffffffff;
        }
        local_2c = strtoul(local_1c,&local_10,0);
        if (*local_10 != '\0') {
          local_30 = 0;
          while ((local_2c = *(uint *)(&DAT_00555b24 + local_30 * 8), local_2c != 0 &&
                 (iVar1 = strcasecmp((&PTR_s_error_00555b28)[local_30 * 2],local_1c), iVar1 != 0)))
          {
            local_30 = local_30 + 1;
          }
          if (local_2c == 0) {
            fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45,
                   stderr);
            fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
            for (local_30 = 0; uVar2 = *(uint *)(&DAT_00555b24 + local_30 * 8), uVar2 != 0;
                local_30 = local_30 + 1) {
              if (uVar2 == local_28) {
                fprintf(stderr,", %s",(&PTR_s_error_00555b28)[local_30 * 2]);
              }
              else {
                fprintf(stderr,"\n0x%04x %s",uVar2,(&PTR_s_error_00555b28)[local_30 * 2]);
              }
              local_28 = uVar2;
            }
            fputc(10,stderr);
            return 0;
          }
        }
        if (*(char *)*local_res8 == '-') {
          local_20 = local_20 | local_2c;
        }
        else {
          local_24 = local_24 | local_2c;
        }
      }
      local_c = ~local_20 & local_c | local_24;
      iVar1 = FUN_004ba428(param_1,(char *)*param_2,local_c);
    }
  }
  return iVar1;
}



int FUN_0040537c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int local_2c;
  char *local_1c;
  uint *local_18;
  uint local_14;
  uint local_10 [2];
  
  local_1c = (char *)0x0;
  local_18 = (uint *)0x0;
  for (local_2c = 0; *(int *)(param_3 + local_2c * 4) != 0; local_2c = local_2c + 1) {
  }
  local_2c = local_2c + -1;
  if ((local_2c < 1) || (2 < local_2c)) {
    puts("required args: function [size] (size 0 means max)");
    iVar1 = -0x2c;
  }
  else {
    local_14 = strtol(*(char **)(param_3 + 4),&local_1c,0);
    if (*local_1c == '\0') {
      if ((local_2c < 2) ||
         (local_10[0] = strtol(*(char **)(param_3 + 8),&local_1c,0), *local_1c == '\0')) {
        if (local_2c == 1) {
          if (DAT_00557704 != '\0') {
            local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                       local_14 >> 0x18;
          }
          iVar1 = FUN_00445198(param_1,(char *)*param_2,&local_14,4,&local_18);
          if (-1 < iVar1) {
            if (DAT_00557704 == '\0') {
              uVar2 = *local_18;
            }
            else {
              uVar2 = *local_18;
              uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                      uVar2 >> 0x18;
            }
            printf("Function %d block size: %d\n",local_14,uVar2);
          }
        }
        else {
          printf("Setting function %d block size to %d\n",local_14,local_10[0]);
          uVar3 = local_14 << 0x10;
          uVar2 = uVar3 | local_10[0] & 0xffff;
          if (DAT_00557704 != '\0') {
            uVar2 = (local_10[0] & 0xffff) << 0x18 | (local_10[0] & 0xff00) << 8 |
                    (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
          }
          local_10[0] = uVar2;
          iVar1 = FUN_00445444(param_1,(char *)*param_2,local_10,4);
        }
      }
      else {
        printf("Invalid size: %s\n",*(char **)(param_3 + 4));
        iVar1 = -0x2c;
      }
    }
    else {
      printf("Invaild function: %s\n",*(char **)(param_3 + 4));
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_00405708(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  undefined1 *puVar2;
  uint uVar3;
  char *param1;
  int local_14;
  
  for (local_14 = 0; param_3[local_14] != 0; local_14 = local_14 + 1) {
  }
  if (param_3[1] == 0) {
    iVar1 = FUN_00444b10(param_1,param_2,param_3);
    if (iVar1 == 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)PTR_DAT_00551644;
      }
      else {
        uVar3 = *(uint *)PTR_DAT_00551644;
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      if (uVar3 == 0) {
        param1 = "SPI";
      }
      else if (uVar3 == 1) {
        param1 = "SD1";
      }
      else if (uVar3 == 2) {
        param1 = "SD4";
      }
      else {
        param1 = "Unknown";
      }
      printf("SD Mode is: %s\n",param1);
    }
  }
  else {
    iVar1 = strcmp((char *)param_3[1],"spi");
    if (iVar1 == 0) {
      puVar2 = (undefined1 *)param_3[1];
      *puVar2 = 0x30;
      puVar2[1] = 0;
    }
    else {
      iVar1 = strcmp((char *)param_3[1],"sd1");
      if (iVar1 == 0) {
        puVar2 = (undefined1 *)param_3[1];
        *puVar2 = 0x31;
        puVar2[1] = 0;
      }
      else {
        iVar1 = strcmp((char *)param_3[1],"sd4");
        if (iVar1 != 0) {
          return -0x2c;
        }
        puVar2 = (undefined1 *)param_3[1];
        *puVar2 = 0x32;
        puVar2[1] = 0;
      }
    }
    iVar1 = FUN_004449f0(param_1,param_2,param_3);
  }
  return iVar1;
}



int FUN_004059b0(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int *local_res8;
  int local_34;
  uint local_20;
  uint local_1c;
  uint local_18;
  char *local_14;
  uint *local_10 [2];
  
  local_14 = (char *)0x0;
  local_10[0] = (uint *)0x0;
  memset(&local_20,0,0xc);
  for (local_34 = 0; *(int *)(param_3 + local_34 * 4) != 0; local_34 = local_34 + 1) {
  }
  iVar1 = strcmp((char *)*param_2,"sd_hostreg");
  if (iVar1 == 0) {
    local_res8 = (int *)(param_3 + 4);
    if (local_34 == 1) {
      puts("required args: offset [value]");
      return -0x2c;
    }
  }
  else {
    iVar1 = strcmp((char *)*param_2,"sd_devreg");
    if (iVar1 != 0) {
      return -0x2c;
    }
    if (local_34 - 1U < 2) {
      puts("required args: func offset [value]");
      return -0x2c;
    }
    if (DAT_00557704 == '\0') {
      local_20 = strtol(*(char **)(param_3 + 4),&local_14,0);
    }
    else {
      uVar2 = strtol(*(char **)(param_3 + 4),&local_14,0);
      local_20 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    local_res8 = (int *)(param_3 + 8);
    if (*local_14 != '\0') {
      puts("Bad func.");
      return -0x2c;
    }
  }
  if (DAT_00557704 == '\0') {
    local_1c = strtol((char *)*local_res8,&local_14,0);
  }
  else {
    uVar2 = strtol((char *)*local_res8,&local_14,0);
    local_1c = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  local_res8 = local_res8 + 1;
  if (*local_14 == '\0') {
    if (*local_res8 != 0) {
      if (DAT_00557704 == '\0') {
        local_18 = strtol((char *)*local_res8,&local_14,0);
      }
      else {
        uVar2 = strtol((char *)*local_res8,&local_14,0);
        local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      if (*local_14 != '\0') {
        puts("Bad Value");
        return -0x2c;
      }
    }
    if (*local_res8 == 0) {
      iVar1 = FUN_00445198(param_1,(char *)*param_2,&local_20,0xc,local_10);
      if (-1 < iVar1) {
        if (DAT_00557704 == '\0') {
          uVar2 = *local_10[0];
        }
        else {
          uVar2 = *local_10[0];
          uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
        }
        printf("0x%x\n",uVar2);
      }
    }
    else {
      iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_20,0xc);
    }
  }
  else {
    puts("Bad offset");
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00405e88(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int local_28;
  char *local_20;
  int local_1c;
  uint local_18;
  uint local_14;
  int local_10;
  
  local_20 = (char *)0x0;
  local_1c = 0;
  for (local_28 = 0; *(int *)(param_3 + local_28 * 4) != 0; local_28 = local_28 + 1) {
  }
  local_28 = local_28 + -1;
  if ((local_28 < 1) || (3 < local_28)) {
    puts("required args: virt_addr phy_addr size");
    iVar1 = -0x2c;
  }
  else {
    local_18 = strtol(*(char **)(param_3 + 4),&local_20,0);
    if ((*local_20 == '\0') && ((local_18 & 0xffc001ff) == 0)) {
      if (local_28 == 1) {
        iVar1 = FUN_00445198(param_1,(char *)*param_2,&local_18,4,&local_1c);
        if (-1 < iVar1) {
          FUN_0041e248(local_1c,0x200);
        }
      }
      else {
        local_14 = strtol(*(char **)(param_3 + 8),&local_20,0);
        if ((*local_20 == '\0') && ((local_14 & 0xffc001ff) == 0)) {
          if (local_28 == 3) {
            local_10 = strtol(*(char **)(param_3 + 0xc),&local_20,0);
            if (((*local_20 != '\0') || (local_10 < 0)) || (7 < local_10)) {
              printf("Invaild size: %s\n",*(char **)(param_3 + 0xc));
              return -2;
            }
          }
          else {
            local_10 = 0;
          }
          printf("Setting virtual Address 0x%x to physical Address 0x%x, size is %d\n",local_18,
                 local_14,local_10);
          iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_18,0xc);
        }
        else {
          printf("Invaild physical Address: %s\n",*(char **)(param_3 + 8));
          iVar1 = -2;
        }
      }
    }
    else {
      printf("Invaild virtual address: %s\n",*(char **)(param_3 + 4));
      iVar1 = -2;
    }
  }
  return iVar1;
}



int FUN_00406184(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint local_88;
  uint local_80;
  uint local_5c;
  uint local_58;
  char *local_54;
  char acStack_50 [48];
  uint local_20;
  
  local_54 = (char *)0x0;
  for (local_80 = 0; ((undefined4 *)(param_3 + 4))[local_80] != 0; local_80 = local_80 + 1) {
  }
  if (local_80 == 0) {
    iVar2 = -0x2c;
  }
  else {
    local_88 = strtol(*(char **)(param_3 + 4),&local_54,0);
    if (*local_54 == '\0') {
      local_5c = 0;
      local_58 = 0;
      bVar1 = false;
      memset(acStack_50,0,0x44);
      iVar2 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
      if (iVar2 == 0) {
        uVar3 = local_20;
        if (DAT_00557704 != '\0') {
          uVar3 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                  local_20 >> 0x18;
        }
        if (1 < local_80) {
          iVar2 = strcasecmp(*(char **)(param_3 + 8),"a");
          if (iVar2 == 0) {
            local_58 = 1;
          }
          else {
            iVar2 = strcasecmp(*(char **)(param_3 + 8),"b");
            if (iVar2 == 0) {
              local_58 = 2;
            }
            else {
              iVar2 = strcmp((char *)*param_2,"radioreg");
              if (iVar2 == 0) {
                iVar2 = strcmp(*(char **)(param_3 + 8),"syn");
                if (iVar2 == 0) {
                  bVar1 = true;
                }
                else {
                  iVar2 = strcmp(*(char **)(param_3 + 8),"tx0");
                  if (iVar2 == 0) {
                    local_88 = local_88 | 0x2000;
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 8),"tx1");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x3000;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 8),"rx0");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x6000;
                        bVar1 = true;
                      }
                      else {
                        iVar2 = strcmp(*(char **)(param_3 + 8),"rx1");
                        if (iVar2 == 0) {
                          local_88 = local_88 | 0x7000;
                          bVar1 = true;
                        }
                      }
                    }
                  }
                }
              }
              iVar2 = strcmp((char *)*param_2,"radioreg");
              if (iVar2 == 0) {
                if (uVar3 == 0xb) {
                  iVar2 = strcmp(*(char **)(param_3 + 8),"cr0");
                  if (iVar2 == 0) {
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 8),"cr1");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x200;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 8),"cr2");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x400;
                        bVar1 = true;
                      }
                      else {
                        iVar2 = strcmp(*(char **)(param_3 + 8),"pll");
                        if (iVar2 == 0) {
                          local_88 = local_88 | 0x800;
                          bVar1 = true;
                        }
                      }
                    }
                  }
                }
                else {
                  iVar2 = strcmp(*(char **)(param_3 + 8),"cr0");
                  if (iVar2 == 0) {
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 8),"cr1");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x400;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 8),"cr2");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x800;
                        bVar1 = true;
                      }
                    }
                  }
                }
              }
              if ((!bVar1) &&
                 (local_5c = strtol(*(char **)(param_3 + 8),&local_54,0), *local_54 != '\0')) {
                return -0x2c;
              }
            }
          }
        }
        if (2 < local_80) {
          iVar2 = strcasecmp(*(char **)(param_3 + 0xc),"a");
          if (iVar2 == 0) {
            local_58 = 1;
          }
          else {
            iVar2 = strcasecmp(*(char **)(param_3 + 0xc),"b");
            if (iVar2 == 0) {
              local_58 = 2;
            }
            else {
              bVar1 = false;
              iVar2 = strcmp((char *)*param_2,"radioreg");
              if (iVar2 == 0) {
                iVar2 = strcmp(*(char **)(param_3 + 0xc),"syn");
                if (iVar2 == 0) {
                  bVar1 = true;
                }
                else {
                  iVar2 = strcmp(*(char **)(param_3 + 0xc),"tx0");
                  if (iVar2 == 0) {
                    local_88 = local_88 | 0x2000;
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 0xc),"tx1");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x3000;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 0xc),"rx0");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x6000;
                        bVar1 = true;
                      }
                      else {
                        iVar2 = strcmp(*(char **)(param_3 + 0xc),"rx1");
                        if (iVar2 == 0) {
                          local_88 = local_88 | 0x7000;
                          bVar1 = true;
                        }
                      }
                    }
                  }
                }
              }
              if (uVar3 == 0xb) {
                iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr0");
                if (iVar2 == 0) {
                  bVar1 = true;
                }
                else {
                  iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr1");
                  if (iVar2 == 0) {
                    local_88 = local_88 | 0x200;
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr2");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x400;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 0xc),"pll");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x800;
                        bVar1 = true;
                      }
                      else {
                        iVar2 = strcmp(*(char **)(param_3 + 0xc),"all");
                        if (iVar2 == 0) {
                          local_88 = local_88 | 0x600;
                          bVar1 = true;
                        }
                      }
                    }
                  }
                }
              }
              else {
                iVar2 = strcmp((char *)*param_2,"radioreg");
                if (iVar2 == 0) {
                  iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr0");
                  if (iVar2 == 0) {
                    bVar1 = true;
                  }
                  else {
                    iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr1");
                    if (iVar2 == 0) {
                      local_88 = local_88 | 0x400;
                      bVar1 = true;
                    }
                    else {
                      iVar2 = strcmp(*(char **)(param_3 + 0xc),"cr2");
                      if (iVar2 == 0) {
                        local_88 = local_88 | 0x800;
                        bVar1 = true;
                      }
                      else {
                        iVar2 = strcmp(*(char **)(param_3 + 0xc),"all");
                        if (iVar2 == 0) {
                          local_88 = local_88 | 0xc00;
                          bVar1 = true;
                        }
                      }
                    }
                  }
                }
              }
              if (!bVar1) {
                return -0x2c;
              }
            }
          }
        }
        uVar4 = local_5c << 0x10;
        uVar3 = local_88 & 0xffff;
        local_5c = uVar4 | uVar3;
        if ((local_80 == 1) || ((local_80 == 2 && ((local_58 != 0 || (bVar1)))))) {
          if (DAT_00557704 != '\0') {
            local_58 = local_58 << 0x18 | (local_58 & 0xff00) << 8 | (local_58 & 0xff0000) >> 8 |
                       local_58 >> 0x18;
            local_5c = uVar3 << 0x18 | (local_88 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                       uVar4 >> 0x18;
          }
          iVar2 = FUN_004b9f94(param_1,param_2[2],(char *)&local_5c,8);
          if (-1 < iVar2) {
            if (DAT_00557704 == '\0') {
              uVar3 = local_5c & 0xffff;
            }
            else {
              uVar3 = (local_5c & 0xff0000) >> 8 | local_5c >> 0x18;
            }
            printf("0x%04x\n",uVar3);
          }
        }
        else {
          if (DAT_00557704 != '\0') {
            local_58 = local_58 << 0x18 | (local_58 & 0xff00) << 8 | (local_58 & 0xff0000) >> 8 |
                       local_58 >> 0x18;
            local_5c = uVar3 << 0x18 | (local_88 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                       uVar4 >> 0x18;
          }
          iVar2 = FUN_004ba050(param_1,param_2[3],(char *)&local_5c,8);
        }
      }
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_00406e68(int *param_1,undefined4 param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint local_40;
  uint local_14;
  uint local_10;
  char *local_c;
  
  local_c = (char *)0x0;
  local_10 = 0;
  for (local_40 = 0; ((undefined4 *)(param_3 + 4))[local_40] != 0; local_40 = local_40 + 1) {
  }
  if (local_40 == 0) {
    iVar2 = FUN_004ba1f8(param_1,"gpioout",PTR_DAT_00551644,0xc);
    if (-1 < iVar2) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)PTR_DAT_00551644;
        uVar4 = *(uint *)(PTR_DAT_00551644 + 4);
        uVar5 = *(uint *)(PTR_DAT_00551644 + 8);
      }
      else {
        uVar3 = *(uint *)PTR_DAT_00551644;
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        uVar4 = *(uint *)(PTR_DAT_00551644 + 4);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        uVar5 = *(uint *)(PTR_DAT_00551644 + 8);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("gpiocontrol 0x%x gpioout 0x%x gpioouten 0x%x\n",uVar3,uVar4,uVar5);
      iVar2 = 0;
    }
  }
  else if (local_40 < 2) {
    iVar2 = -0x2c;
  }
  else {
    local_14 = strtoul(*(char **)(param_3 + 4),&local_c,0);
    if (*local_c == '\0') {
      local_10 = strtoul(*(char **)(param_3 + 8),&local_c,0);
      puVar1 = PTR_DAT_00551644;
      if (*local_c == '\0') {
        if ((~local_14 & local_10) == 0) {
          if (DAT_00557704 != '\0') {
            local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                       local_14 >> 0x18;
          }
          memcpy(PTR_DAT_00551644,&local_14,4);
          if (DAT_00557704 != '\0') {
            local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                       local_10 >> 0x18;
          }
          memcpy(puVar1 + 4,&local_10,4);
          iVar2 = FUN_004ba2e4(param_1,"gpioout",PTR_DAT_00551644,8);
        }
        else {
          iVar2 = -2;
        }
      }
      else {
        iVar2 = -0x2c;
      }
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_00407298(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint local_50;
  uint local_48;
  char *local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  
  local_1c = (char *)0x0;
  local_50 = 0;
  for (local_48 = 0; ((undefined4 *)(param_3 + 4))[local_48] != 0; local_48 = local_48 + 1) {
  }
  if (local_48 == 0) {
    iVar1 = -0x2c;
  }
  else {
    uVar2 = strtol(*(char **)(param_3 + 4),&local_1c,0);
    if (*local_1c == '\0') {
      if (local_48 < 2) {
        iVar1 = -0x2c;
      }
      else {
        uVar3 = strtol(*(char **)(param_3 + 8),&local_1c,0);
        if (*local_1c == '\0') {
          local_c = 0;
          if (2 < local_48) {
            iVar1 = strcasecmp(*(char **)(param_3 + 0xc),"a");
            if (iVar1 == 0) {
              local_c = 1;
            }
            else {
              iVar1 = strcasecmp(*(char **)(param_3 + 0xc),"b");
              if (iVar1 == 0) {
                local_c = 2;
              }
              else {
                local_50 = strtoul(*(char **)(param_3 + 0xc),&local_1c,0);
                if (*local_1c != '\0') {
                  return -0x2c;
                }
              }
            }
          }
          if (3 < local_48) {
            iVar1 = strcasecmp(*(char **)(param_3 + 0x10),"a");
            if (iVar1 == 0) {
              local_c = 1;
            }
            else {
              iVar1 = strcasecmp(*(char **)(param_3 + 0x10),"b");
              if (iVar1 != 0) {
                return -0x2c;
              }
              local_c = 2;
            }
          }
          local_18 = uVar2;
          if ((local_48 == 2) || ((local_48 == 3 && (local_c != 0)))) {
            if (DAT_00557704 != '\0') {
              local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                        local_c >> 0x18;
              uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 |
                      uVar3 >> 0x18;
              local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                         uVar2 >> 0x18;
            }
            local_10 = uVar3;
            iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_18,0x10);
            if (-1 < iVar1) {
              if (DAT_00557704 != '\0') {
                local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8
                           | local_14 >> 0x18;
              }
              printf("0x%04x\n",local_14);
            }
          }
          else {
            local_10 = uVar3;
            if (DAT_00557704 != '\0') {
              local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                        local_c >> 0x18;
              local_50 = local_50 << 0x18 | (local_50 & 0xff00) << 8 | (local_50 & 0xff0000) >> 8 |
                         local_50 >> 0x18;
              local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                         uVar2 >> 0x18;
              local_10 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 |
                         uVar3 >> 0x18;
            }
            local_14 = local_50;
            iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_18,0x10);
          }
        }
        else {
          iVar1 = -0x2c;
        }
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_004078d0(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 *puVar1;
  int iVar2;
  uint param2;
  uint param3;
  uint local_2c;
  uint local_14;
  uint local_10;
  char *local_c;
  
  local_c = (char *)0x0;
  puVar1 = (undefined4 *)(param_3 + 4);
  for (local_2c = 0; puVar1[local_2c] != 0; local_2c = local_2c + 1) {
  }
  local_14 = 0;
  local_10 = 0;
  if (local_2c != 0) {
    iVar2 = strcasecmp((char *)*puVar1,"a");
    if (iVar2 == 0) {
      local_10 = 1;
    }
    else {
      iVar2 = strcasecmp((char *)*puVar1,"b");
      if (iVar2 == 0) {
        local_10 = 2;
      }
      else {
        iVar2 = strcasecmp((char *)*puVar1,"all");
        if (iVar2 == 0) {
          local_10 = 3;
        }
        else {
          local_14 = strtol((char *)*puVar1,&local_c,0);
          if (*local_c != '\0') {
            return -0x2c;
          }
        }
      }
    }
  }
  if (1 < local_2c) {
    iVar2 = strcasecmp(*(char **)(param_3 + 8),"a");
    if (iVar2 == 0) {
      local_10 = 1;
    }
    else {
      iVar2 = strcasecmp(*(char **)(param_3 + 8),"b");
      if (iVar2 == 0) {
        local_10 = 2;
      }
      else {
        iVar2 = strcasecmp(*(char **)(param_3 + 8),"all");
        if (iVar2 != 0) {
          return -0x2c;
        }
        local_10 = 3;
      }
    }
  }
  if ((local_2c == 0) || ((local_2c == 1 && (local_10 != 0)))) {
    if (local_10 == 3) {
      puts("band option \"all\" is for set only, not get");
      iVar2 = -0x2c;
    }
    else {
      if (DAT_00557704 != '\0') {
        local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                   local_10 >> 0x18;
      }
      iVar2 = FUN_004b9f94(param_1,param_2[2],(char *)&local_14,8);
      if (-1 < iVar2) {
        if (DAT_00557704 == '\0') {
          param2 = local_14 & 0xffff;
          param3 = local_14;
        }
        else {
          param2 = (local_14 & 0xff0000) >> 8 | local_14 >> 0x18;
          param3 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
        }
        printf("%s is 0x%04x(%d)\n",(char *)*param_2,param2,param3);
      }
    }
  }
  else {
    if (DAT_00557704 != '\0') {
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,param_2[3],(char *)&local_14,8);
  }
  return iVar2;
}



int FUN_00407dcc(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined3 extraout_var;
  uint local_1c;
  undefined1 auStack_18 [8];
  uint local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)local_10,4);
    if (-1 < iVar2) {
      if (DAT_00557704 != '\0') {
        local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                      (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
      }
      printf("%d\n",local_10[0]);
      iVar2 = 0;
    }
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_18);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_1c,0xc);
      if (-1 < iVar2) {
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
        }
        printf("%d\n",local_1c);
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



int FUN_00407fc0(int *param_1,undefined4 param_2,int param_3)

{
  int param1;
  int param2;
  int local_20;
  byte local_10;
  byte local_f;
  char local_e;
  char local_d;
  
  memset(&local_10,0,4);
  if (*(int *)(param_3 + 4) == 0) {
    local_20 = FUN_004ba1f8(param_1,"rssi_monitor",(char *)&local_10,4);
    if (local_20 < 0) {
      printf("err %d, %d\n",local_20,(uint)local_10);
    }
    else if (local_10 == 1) {
      printf("max rssi %d min rssi %d flags %x\n",(int)local_e,(int)local_d,(uint)local_f);
    }
    else {
      printf("Incorrect version %d, expected %d\n",(uint)local_10,1);
      local_20 = -0x25;
    }
  }
  else {
    param1 = atoi(*(char **)(param_3 + 4));
    local_10 = 1;
    if ((param1 < 1) && (-0x81 < param1)) {
      local_e = (char)param1;
      if (*(int *)(param_3 + 8) == 0) {
        local_20 = -0x2c;
      }
      else {
        param2 = atoi(*(char **)(param_3 + 8));
        if ((param2 < 1) && (-0x81 < param2)) {
          local_d = (char)param2;
          printf("Setting max_rssi %d, min_rssi %d\n",param1,param2);
          if (param1 < param2) {
            printf("WARNING: min_rssi %d is greater than max_rssi %d threshold!!!\n",param2,param1);
          }
          local_20 = FUN_004ba2e4(param_1,"rssi_monitor",&local_10,4);
        }
        else {
          local_20 = -0x2c;
        }
      }
    }
    else {
      local_20 = -0x2c;
    }
  }
  return local_20;
}



int FUN_00408240(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  int *local_res8;
  uint local_ac;
  uint local_a8;
  uint local_a4;
  char *local_8c [3];
  void *local_80;
  uint local_7c;
  ushort auStack_78 [2];
  byte abStack_74 [108];
  
  local_8c[0] = "   CCA";
  local_8c[1] = "    NF";
  local_8c[2] = "NF_LTE";
  if (*(int *)(param_3 + 4) == 0) {
    local_80 = (void *)0x0;
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_80);
    if (-1 < iVar4) {
      memcpy(&local_7c,local_80,0x74);
      if (DAT_00557704 != '\0') {
        local_7c = local_7c << 0x18 | (local_7c & 0xff00) << 8 | (local_7c & 0xff0000) >> 8 |
                   local_7c >> 0x18;
      }
      printf("rate per %dms\n",local_7c);
      for (local_ac = 0; local_ac < 3; local_ac = local_ac + 1) {
        printf("%s[%d]:",local_8c[local_ac],(uint)abStack_74[local_ac * 0x24]);
        for (local_a8 = 0; (local_a8 < abStack_74[local_ac * 0x24 + 1] && (local_a8 < 8));
            local_a8 = local_a8 + 1) {
          printf(" (%d, %d)",(int)(short)auStack_78[local_ac * 0x12 + local_a8 + 4],
                 (int)(short)auStack_78[local_ac * 0x12 + local_a8 + 0xc]);
        }
        putchar(10);
      }
    }
  }
  else {
    memset(&local_7c,0,0x74);
    local_res8 = (int *)(param_3 + 8);
    local_7c = atoi(*(char **)(param_3 + 4));
    if (DAT_00557704 == '\0') {
      auStack_78[1] = 3;
    }
    else {
      local_7c = local_7c << 0x18 | (local_7c & 0xff00) << 8 | (local_7c & 0xff0000) >> 8 |
                 local_7c >> 0x18;
      auStack_78[1] = 0x300;
    }
    for (local_a4 = 0; local_a4 < 3; local_a4 = local_a4 + 1) {
      abStack_74[local_a4 * 0x24] = (byte)local_a4;
      while ((piVar1 = local_res8, *local_res8 != 0 && (local_res8[1] != 0))) {
        if (DAT_00557704 == '\0') {
          iVar4 = atoi((char *)*local_res8);
          uVar2 = (ushort)iVar4;
        }
        else {
          iVar4 = atoi((char *)*local_res8);
          uVar2 = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
        }
        local_res8 = local_res8 + 1;
        if (DAT_00557704 == '\0') {
          iVar4 = atoi((char *)*local_res8);
          uVar3 = (ushort)iVar4;
        }
        else {
          iVar4 = atoi((char *)*local_res8);
          uVar3 = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
        }
        local_res8 = piVar1 + 2;
        if ((uVar2 == 0) && (uVar3 == 0)) break;
        if ((short)uVar3 < (short)uVar2) {
          return -1;
        }
        if (abStack_74[local_a4 * 0x24 + 1] < 8) {
          auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 4] = uVar2;
          auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 0xc] = uVar3;
          if ((abStack_74[local_a4 * 0x24 + 1] != 0) &&
             (((short)auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 4] <=
               (short)auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 3] ||
              ((short)auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 0xc] <=
               (short)auStack_78[local_a4 * 0x12 + (uint)abStack_74[local_a4 * 0x24 + 1] + 0xb]))))
          {
            return -1;
          }
          abStack_74[local_a4 * 0x24 + 1] = abStack_74[local_a4 * 0x24 + 1] + 1;
        }
      }
    }
    if (*local_res8 == 0) {
      iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_7c,0x74);
    }
    else {
      iVar4 = -1;
    }
  }
  return iVar4;
}



int FUN_00408a64(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  int *local_res8;
  uint local_44;
  void *local_38;
  uint local_34;
  byte local_30;
  char acStack_2f [11];
  undefined4 local_24;
  byte local_20 [16];
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    local_38 = (void *)0x0;
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_38);
    if (-1 < iVar2) {
      memcpy(&local_34,local_38,0x10);
      if (DAT_00557704 != '\0') {
        local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                   local_34 >> 0x18;
      }
      printf("%d",local_34);
      for (local_44 = 0; local_44 < local_30; local_44 = local_44 + 1) {
        printf(" %d",(int)acStack_2f[local_44]);
      }
      putchar(10);
    }
  }
  else {
    memset(&local_24,0,0x10);
    local_24 = atoi((char *)*local_res8);
    do {
      bVar1 = local_20[0];
      local_res8 = local_res8 + 1;
      if ((*local_res8 == 0) || (7 < local_20[0])) {
        if (*local_res8 == 0) {
          if (DAT_00557704 != '\0') {
            local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                       local_24 >> 0x18;
          }
          iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_24,0x10);
          return iVar2;
        }
        return -0x2c;
      }
      uVar3 = (uint)local_20[0];
      iVar2 = atoi((char *)*local_res8);
      local_20[uVar3 + 1] = (byte)iVar2;
      local_20[0] = bVar1 + 1;
    } while ((local_20[0] < 2) || ((char)local_20[local_20[0] - 1] < (char)local_20[local_20[0]]));
    iVar2 = -0x2c;
  }
  return iVar2;
}



int FUN_00408d9c(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  uint uVar2;
  int local_20;
  uint local_1c;
  uint *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (uint *)0x0;
    local_20 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    puVar1 = local_c;
    if (-1 < local_20) {
      if (DAT_00557704 == '\0') {
        uVar2 = *local_c;
      }
      else {
        uVar2 = *local_c;
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      *local_c = uVar2;
      if (DAT_00557704 == '\0') {
        uVar2 = local_c[1];
      }
      else {
        uVar2 = local_c[1];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      local_c[1] = uVar2;
      if (local_c[1] == 0) {
        puts("not supported on this chip");
      }
      else {
        for (local_1c = 0; local_1c < puVar1[1]; local_1c = local_1c + 1) {
          printf("rssi[%d] %d  ",local_1c,(int)*(char *)((int)puVar1 + local_1c + 8));
        }
        putchar(10);
      }
    }
  }
  else {
    local_20 = -0x2c;
  }
  return local_20;
}



int FUN_00408fb8(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  char *__s;
  undefined3 extraout_var;
  char acStack_14 [12];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),acStack_14,6);
    if (-1 < iVar2) {
      __s = FUN_0041d780((int)acStack_14);
      puts(__s);
      iVar2 = 0;
    }
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),acStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),acStack_14,6);
    }
  }
  return iVar2;
}



int FUN_004090c4(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  char *param2;
  char *param1;
  char local_1c [16];
  
  local_1c[0] = '\0';
  local_1c[1] = 0;
  local_1c[2] = 0;
  local_1c[3] = 0;
  local_1c[4] = 0;
  local_1c[5] = 0;
  if (param_3[1] == 0) {
    iVar2 = FUN_004ba1f8(param_1,(char *)*param_2,local_1c,6);
    if (iVar2 < 0) {
      printf("Error getting variable %s\n",(char *)*param_3);
    }
    else {
      param1 = (char *)*param_3;
      param2 = FUN_0041d780((int)local_1c);
      printf("%s %s\n",param1,param2);
      iVar2 = 0;
    }
  }
  else {
    bVar1 = FUN_0041d6ac((char *)param_3[1],local_1c);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      puts(" ERROR: no valid ether addr provided");
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004ba2e4(param_1,(char *)*param_2,local_1c,6);
      if (iVar2 < 0) {
        printf("Error setting variable %s\n",(char *)*param_3);
      }
      else {
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



void FUN_00409268(int *param_1,char param_2,char param_3)

{
  char cVar1;
  float fVar2;
  float fVar3;
  FILE *pFVar4;
  int *__haystack;
  uint uVar5;
  size_t sVar6;
  char *pcVar7;
  byte bVar8;
  byte local_168;
  byte local_167;
  int *local_164;
  int *local_160;
  char *local_15c;
  char *local_158;
  float local_154;
  float local_150;
  float local_14c;
  int local_148;
  float local_144;
  float local_140;
  int local_13c;
  char *local_138;
  char *local_134;
  char *local_128;
  char *local_124;
  char *local_120;
  char *local_11c;
  char local_f4 [36];
  int local_d0;
  int local_b0;
  int local_a4;
  undefined4 local_98;
  undefined4 local_94;
  undefined4 local_90;
  undefined4 local_8c;
  undefined4 local_88;
  undefined4 local_84;
  undefined4 local_80;
  int local_78;
  undefined4 local_74;
  undefined4 local_70;
  undefined4 local_6c;
  undefined4 local_64;
  undefined4 local_60;
  undefined4 local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  double local_30;
  
  local_138 = 
  "prec:   rqstd,  stored,selfsave,   saved,fulldrop, dropped,sacrficd, retried, rtsfail,rtrydrop, psretry,supprssd,   acked,utlisatn,q length,Data Mbits/s,Phy Mbits/s,Rate Mbits/s (+v%d.)\n"
  ;
  local_134 = 
  "prec:   rqstd,  stored, dropped, retried, rtsfail,rtrydrop, psretry,   acked,utlisatn,q length,Data Mbits/s,Phy Mbits/s (+v%d.)\n"
  ;
  local_128 = 
  "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,   %8.2f,    %8.2f\n"
  ;
  local_124 = "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,   %8.2f\n";
  local_120 = 
  "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u,       -,       -, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,          -,           -\n"
  ;
  local_11c = 
  "  %02u: %7u, %7u, %7u,       -,       -, %7u, %7u, %7u, %7u, %7u, %8.2f,          -\n";
  builtin_strncpy(local_f4,"[X]",4);
  local_164 = (int *)0x0;
  local_160 = (int *)0x0;
  if (*param_1 == 4) {
    local_160 = param_1 + 9;
  }
  else {
    if (*param_1 != 5) {
      fprintf(stderr,"Unknown/unsupported binary format (%x)\n",*param_1);
      return;
    }
    local_164 = param_1 + 9;
  }
  if (*param_1 == 4) {
    __haystack = local_160 + 0x549;
  }
  else {
    __haystack = local_164 + 0x589;
  }
  for (local_168 = 0; (uint)local_168 < (param_1[1] & 0xffU); local_168 = local_168 + 1) {
    if (*param_1 == 4) {
      uVar5 = local_160[local_168 + 0x541];
    }
    else {
      uVar5 = local_164[local_168 + 0x581];
    }
    if (*param_1 == 4) {
      bVar8 = *(byte *)((int)local_160 + (uint)local_168);
    }
    else {
      bVar8 = *(byte *)((int)local_164 + (uint)local_168);
    }
    if ((((uVar5 & 0xffff) != 0) || (param_2 == '\0')) && ((bVar8 != 0 || (param_2 == '\0')))) {
      local_f4[1] = local_168 + 0x30;
      local_15c = strstr((char *)__haystack,local_f4);
      if (local_15c != (char *)0x0) {
        sVar6 = strlen(local_f4);
        local_15c = local_15c + sVar6;
        local_158 = strstr(local_15c,local_f4);
        if (local_158 == (char *)0x0) {
          sVar6 = strlen(local_15c);
          local_158 = local_15c + sVar6;
        }
        while (pFVar4 = stdout, local_15c < local_158) {
          if (stdout->_lock == (_IO_lock_t *)0x0) {
            cVar1 = *local_15c;
            local_15c = local_15c + 1;
            fputc((int)cVar1,stdout);
          }
          else if (stdout->_IO_write_base < stdout->_IO_buf_base) {
            pcVar7 = stdout->_IO_write_base;
            *pcVar7 = *local_15c;
            pFVar4->_IO_write_base = pcVar7 + 1;
            local_15c = local_15c + 1;
          }
          else {
            cVar1 = *local_15c;
            local_15c = local_15c + 1;
            __fputc_unlocked((int)cVar1,stdout);
          }
        }
      }
      pFVar4 = stdout;
      if (bVar8 == 0) {
        if (*(char *)((int)param_1 + local_168 + 8) == '\0') {
          bVar8 = 0x20;
        }
        else {
          bVar8 = *(byte *)((int)param_1 + local_168 + 8) & 0x7f;
        }
        pcVar7 = FUN_0041d780((int)param_1 + (uint)local_168 * 6 + 0xc);
        fprintf(pFVar4,"Parameter %c:%s not valid\n",bVar8,pcVar7);
      }
      else {
        if (*(char *)((int)param_1 + local_168 + 8) < '\0') {
          pcVar7 = local_138;
          if (*param_1 != 4) {
            pcVar7 = 
            "prec:   rqstd,  stored,selfsave,   saved,fulldrop, dropped,sacrficd, retried, rtsfail,rtrydrop, psretry,supprssd,   acked,utlisatn,q length,Data Mbits/s,Phy Mbits/s,Rate Mbits/s, %%air, %%effcy  (v%d)\n"
            ;
          }
        }
        else {
          pcVar7 = local_134;
          if (*param_1 != 4) {
            pcVar7 = 
            "prec:   rqstd,  stored, dropped, retried, rtsfail,rtrydrop, psretry,   acked,utlisatn,q length,Data Mbits/s,Phy Mbits/s, %%air, %%effcy  (v%d)\n"
            ;
          }
        }
        fprintf(stdout,pcVar7,*param_1);
        for (local_167 = 0; local_167 < bVar8; local_167 = local_167 + 1) {
          local_154 = 0.0;
          local_14c = 0.0;
          local_148 = 0;
          local_144 = 0.0;
          local_140 = 0.0;
          if ((1 << (local_167 & 0x1f) & uVar5) != 0) {
            if (*param_1 == 5) {
              memcpy(&local_98,local_164 + (uint)local_168 * 0x160 + (uint)local_167 * 0x16 + 1,0x58
                    );
            }
            else {
              memcpy(&local_98,local_160 + (uint)local_168 * 0x150 + (uint)local_167 * 0x15 + 1,0x54
                    );
              local_44 = 0;
            }
            local_13c = local_58;
            local_150 = (float)local_54;
            if (local_54 < 0) {
              local_150 = local_150 + 4.2949673e+09;
            }
            local_150 = local_150 * 0.5;
            if (local_48 != 0) {
              fVar2 = (float)local_4c;
              if (local_4c < 0) {
                fVar2 = fVar2 + 4.2949673e+09;
              }
              if (local_44 != 0) {
                local_140 = (float)local_44;
                if (local_44 < 0) {
                  local_140 = local_140 + 4.2949673e+09;
                }
                local_140 = (fVar2 * 8.0 * 100.0) / local_140;
              }
              local_154 = (float)local_48;
              if (local_48 < 0) {
                local_154 = local_154 + 4.2949673e+09;
              }
              local_154 = (fVar2 * 8.0) / local_154;
              fVar2 = (float)local_44;
              if (local_44 < 0) {
                fVar2 = fVar2 + 4.2949673e+09;
              }
              local_144 = (float)local_48;
              if (local_48 < 0) {
                local_144 = local_144 + 4.2949673e+09;
              }
              local_144 = (fVar2 * 100.0) / local_144;
            }
            if ((param_3 == '\0') || ((local_167 & 1) == 0)) {
              local_148 = local_58 + local_78;
              if ((param_3 != '\0') && ((1 << (local_167 + 1 & 0x1f) & uVar5) != 0)) {
                if (*param_1 == 5) {
                  memcpy(local_f4 + 4,
                         local_164 + (uint)local_168 * 0x160 + (local_167 + 1) * 0x16 + 1,0x58);
                }
                else {
                  memcpy(local_f4 + 4,
                         local_160 + (uint)local_168 * 0x150 + (local_167 + 1) * 0x15 + 1,0x54);
                }
                local_13c = local_13c + local_b0;
                local_148 = local_148 + local_b0 + local_d0;
                if (local_44 != 0) {
                  fVar2 = (float)local_a4;
                  if (local_a4 < 0) {
                    fVar2 = fVar2 + 4.2949673e+09;
                  }
                  fVar3 = (float)local_44;
                  if (local_44 < 0) {
                    fVar3 = fVar3 + 4.2949673e+09;
                  }
                  local_140 = local_140 + (fVar2 / fVar3) * 800.0;
                }
              }
              if (local_13c == 0) {
                local_150 = 0.0;
                local_140 = 0.0;
              }
              else {
                fVar2 = (float)local_13c;
                if (local_13c < 0) {
                  fVar2 = fVar2 + 4.2949673e+09;
                }
                local_150 = local_150 / fVar2;
                if (local_54 == 0) {
                  local_140 = 0.0;
                }
                else {
                  local_140 = local_140 / local_150;
                }
              }
            }
            if (local_148 != 0) {
              fVar2 = (float)local_50;
              if (local_50 < 0) {
                fVar2 = fVar2 + 4.2949673e+09;
              }
              local_14c = (float)local_148;
              if (local_148 < 0) {
                local_14c = local_14c + 4.2949673e+09;
              }
              local_14c = (fVar2 * 0.5) / local_14c;
            }
            if (*(char *)((int)param_1 + local_168 + 8) < '\0') {
              if ((param_3 == '\0') || ((local_167 & 1) == 0)) {
                pcVar7 = local_128;
                if (*param_1 != 4) {
                  pcVar7 = 
                  "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,   %8.2f,    %8.2f,  %6.1f,  %5.1f\n"
                  ;
                }
                local_40 = local_94;
                local_3c = local_8c;
                local_38 = local_90;
                local_30 = (double)local_140;
                fprintf(stdout,pcVar7,(uint)local_167,local_98,local_94,local_8c,local_90,local_88,
                        local_84,local_80,local_78,local_5c,local_6c,local_74,local_70,local_58,
                        local_64,local_60,(double)local_154,(double)local_150,(double)local_14c,
                        (double)local_144,local_30);
              }
              else {
                pcVar7 = local_120;
                if (*param_1 != 4) {
                  pcVar7 = 
                  "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u,       -,       -, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,          -,           -,       -,      -\n"
                  ;
                }
                fprintf(stdout,pcVar7,(uint)local_167,local_98,local_94,local_8c,local_90,local_88,
                        local_84,local_80,local_6c,local_74,local_70,local_58,local_64,local_60,
                        (double)local_154);
              }
            }
            else if ((param_3 == '\0') || ((local_167 & 1) == 0)) {
              pcVar7 = local_124;
              if (*param_1 != 4) {
                pcVar7 = 
                "  %02u: %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %7u, %8.2f,   %8.2f,  %6.1f,  %5.1f\n"
                ;
              }
              fprintf(stdout,pcVar7,(uint)local_167,local_98,local_94,local_84,local_78,local_5c,
                      local_6c,local_74,local_58,local_64,local_60);
            }
            else {
              pcVar7 = local_11c;
              if (*param_1 != 4) {
                pcVar7 = 
                "  %02u: %7u, %7u, %7u,       -,       -, %7u, %7u, %7u, %7u, %7u, %8.2f,          -,       -,      -\n"
                ;
              }
              fprintf(stdout,pcVar7,(uint)local_167,local_98,local_94,local_84,local_6c,local_74,
                      local_58,local_64,local_60);
            }
          }
        }
        fputc(10,stdout);
        if ((*param_1 == 5) && (local_164[local_168 + 0x585] != -1)) {
          fprintf(stdout,"Total time in ps pretend state is %d milliseconds\n\n",
                  (local_164[local_168 + 0x585] + 500U) / 1000);
        }
      }
    }
  }
  return;
}



int FUN_0040a5a0(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  void *local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_1c = (void *)0x0;
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_1c);
  if (-1 < iVar1) {
    memcpy(&local_18,local_1c,0xc);
    if (DAT_00557704 != '\0') {
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
    }
    if (*(int *)(param_3 + 4) == 0) {
      printf("scb_timeout = %d\n",local_18);
      printf("activity_time = %d\n",local_14);
      printf("max_probe = %d\n",local_10);
      putchar(10);
    }
    else {
      local_18 = atoi(*(char **)(param_3 + 4));
      if (*(int *)(param_3 + 8) != 0) {
        local_14 = atoi(*(char **)(param_3 + 8));
      }
      if (*(int *)(param_3 + 0xc) != 0) {
        local_10 = atoi(*(char **)(param_3 + 0xc));
      }
      if (*(int *)(param_3 + 0x10) == 0) {
        if (DAT_00557704 != '\0') {
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
          local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                     local_10 >> 0x18;
        }
        iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_18,0xc);
      }
      else {
        iVar1 = -0x2c;
      }
    }
  }
  return iVar1;
}



int FUN_0040a9c4(int *param_1,undefined4 param_2,int *param_3)

{
  float fVar1;
  bool bVar2;
  bool bVar3;
  undefined *puVar4;
  ushort uVar5;
  int iVar6;
  uint *puVar7;
  char *param1;
  float fVar8;
  float fVar9;
  float fVar10;
  uint uVar11;
  float fVar12;
  double in_f12_13;
  double in_f14_15;
  char *param5;
  int local_78;
  uchar local_70;
  uint local_c;
  
  puVar4 = PTR_DAT_00551644;
  local_c = 0;
  bVar2 = false;
  local_70 = ' ';
  bVar3 = false;
  if (*param_3 == 0) {
    fprintf(stderr,"%s: argv[0] missing\n","wl_scb_bs_data");
    iVar6 = -2;
  }
  else {
    for (local_78 = 1; param_3[local_78] != 0; local_78 = local_78 + 1) {
      iVar6 = strcmp((char *)param_3[local_78],"-noreset");
      if (iVar6 == 0) {
        local_c = local_c | 1;
      }
      else {
        iVar6 = strcmp((char *)param_3[local_78],"-raw");
        if (iVar6 == 0) {
          bVar2 = true;
        }
        else {
          iVar6 = strcmp((char *)param_3[local_78],"-tab");
          if (iVar6 == 0) {
            local_70 = '\t';
          }
          else {
            iVar6 = strcmp((char *)param_3[local_78],"-comma");
            if (iVar6 == 0) {
              local_70 = ',';
            }
            else {
              iVar6 = strcmp((char *)param_3[local_78],"-noidle");
              if (iVar6 != 0) {
                iVar6 = strcmp((char *)param_3[local_78],"-help");
                if ((iVar6 != 0) && (iVar6 = strcmp((char *)param_3[local_78],"-h"), iVar6 != 0)) {
                  fprintf(stderr,"%s: unknown option: %s\n",(char *)*param_3,
                          (char *)param_3[local_78]);
                  return -0x2c;
                }
                return -0x2c;
              }
              bVar3 = true;
            }
          }
        }
      }
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    param5 = (char *)0x2000;
    iVar6 = FUN_004ba0cc(param_1,(char *)*param_3,&local_c,4,PTR_DAT_00551644,0x2000);
    if (iVar6 == 0) {
      if (DAT_00557704 == '\0') {
        uVar5 = *(ushort *)puVar4;
      }
      else {
        uVar5 = *(ushort *)puVar4 << 8 | *(ushort *)puVar4 >> 8;
      }
      *puVar4 = (char)uVar5;
      puVar4[1] = (char)(uVar5 >> 8);
      if (*(short *)puVar4 == 1) {
        if (DAT_00557704 == '\0') {
          uVar5 = *(ushort *)(puVar4 + 2);
        }
        else {
          uVar5 = *(ushort *)(puVar4 + 2) << 8 | *(ushort *)(puVar4 + 2) >> 8;
        }
        puVar4[2] = (char)uVar5;
        puVar4[3] = (char)(uVar5 >> 8);
        if (*(short *)(puVar4 + 2) == 0) {
          puts("No stations are currently associated.");
          iVar6 = 0;
        }
        else {
          printf("%17s%c","Station Address",local_70);
          if (bVar2) {
            if (bVar2) {
              param5 = "txrate_succ";
              printf("%9.9s %9.9s %9.9s %9.9s %9.9s %9.9s %9.9s %9.9s %9.9s\n","retry_drop",
                     "rtsfail","retry","txrate_main","txrate_succ","acked","throughput","time_delta"
                     ,"airtime");
            }
          }
          else {
            param5 = "Air Use";
            printf("%10s%c%10s%c%10s%c%10s%c%10s\n","PHY Mbps",local_70,"Data Mbps",local_70,
                   "Air Use",local_70,"Data Use",local_70,"Retries");
          }
          for (local_78 = 0; local_78 < (int)(uint)*(ushort *)(puVar4 + 2); local_78 = local_78 + 1)
          {
            puVar7 = (uint *)(puVar4 + local_78 * 0x2c + 0xc);
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x10);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x10);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x10) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x14);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x14);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x14) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *puVar7;
            }
            else {
              uVar11 = *puVar7;
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *puVar7 = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x20);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x20);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x20) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x1c);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x1c);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x1c) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x18);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x18);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x18) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x24);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x24);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x24) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x28);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x28);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x28) = uVar11;
            if (DAT_00557704 == '\0') {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x2c);
            }
            else {
              uVar11 = *(uint *)(puVar4 + local_78 * 0x2c + 0x2c);
              uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                       uVar11 >> 0x18;
            }
            *(uint *)(puVar4 + local_78 * 0x2c + 0x2c) = uVar11;
          }
          for (local_78 = 0; local_78 < (int)(uint)*(ushort *)(puVar4 + 2); local_78 = local_78 + 1)
          {
            if ((!bVar3) || (*(int *)(puVar4 + local_78 * 0x2c + 0x18) != 0)) {
              param1 = FUN_0041d780((int)(puVar4 + local_78 * 0x2c + 4));
              printf("%17s%c",param1,local_70);
              if (bVar2) {
                if (bVar2) {
                  param5 = *(char **)(puVar4 + local_78 * 0x2c + 0x1c);
                  printf("%9d %9d %9d %9d %9d %9d %9d %9d %9d\n",
                         *(int *)(puVar4 + local_78 * 0x2c + 0x10),
                         *(int *)(puVar4 + local_78 * 0x2c + 0x14),
                         *(int *)(puVar4 + local_78 * 0x2c + 0xc),
                         *(int *)(puVar4 + local_78 * 0x2c + 0x20),(int)param5,
                         *(int *)(puVar4 + local_78 * 0x2c + 0x18),
                         *(int *)(puVar4 + local_78 * 0x2c + 0x24),
                         *(int *)(puVar4 + local_78 * 0x2c + 0x28),
                         *(int *)(puVar4 + local_78 * 0x2c + 0x2c));
                }
              }
              else {
                if (*(int *)(puVar4 + local_78 * 0x2c + 0x18) == 0) {
                  fVar8 = 0.0;
                }
                else {
                  fVar9 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x1c);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x1c) < 0) {
                    fVar9 = fVar9 + 4.2949673e+09;
                  }
                  fVar8 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x18);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x18) < 0) {
                    fVar8 = fVar8 + 4.2949673e+09;
                  }
                  fVar8 = (fVar9 * 0.5) / fVar8;
                }
                if (*(int *)(puVar4 + local_78 * 0x2c + 0x28) == 0) {
                  fVar9 = 0.0;
                }
                else {
                  fVar10 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x24);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x24) < 0) {
                    fVar10 = fVar10 + 4.2949673e+09;
                  }
                  fVar9 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x28);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x28) < 0) {
                    fVar9 = fVar9 + 4.2949673e+09;
                  }
                  fVar9 = (fVar10 * 8.0) / fVar9;
                }
                if (*(int *)(puVar4 + local_78 * 0x2c + 0x28) == 0) {
                  fVar10 = 0.0;
                }
                else {
                  fVar12 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x2c);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x2c) < 0) {
                    fVar12 = fVar12 + 4.2949673e+09;
                  }
                  fVar10 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x28);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x28) < 0) {
                    fVar10 = fVar10 + 4.2949673e+09;
                  }
                  fVar10 = (fVar12 * 100.0) / fVar10;
                }
                if (*(int *)(puVar4 + local_78 * 0x2c + 0x18) == 0) {
                  fVar12 = 0.0;
                }
                else {
                  iVar6 = *(int *)(puVar4 + local_78 * 0x2c + 0xc);
                  fVar12 = (float)iVar6;
                  if (iVar6 < 0) {
                    fVar12 = fVar12 + 4.2949673e+09;
                  }
                  fVar1 = (float)*(int *)(puVar4 + local_78 * 0x2c + 0x18);
                  if (*(int *)(puVar4 + local_78 * 0x2c + 0x18) < 0) {
                    fVar1 = fVar1 + 4.2949673e+09;
                  }
                  fVar12 = (fVar12 / fVar1) * 100.0;
                }
                printf("%10.1f%c%10.1f%c%9.1f%%%c%9.1f%%%c%9.1f%%\n",in_f12_13,
                       (uchar)((ulonglong)(double)fVar12 >> 0x20),in_f14_15,SUB81((double)fVar8,0),
                       (double)CONCAT44(param5,(int)(char)local_70),
                       (uchar)((ulonglong)(double)fVar8 >> 0x20),(double)fVar9,local_70,
                       (double)fVar10);
              }
            }
          }
          iVar6 = 0;
        }
      }
      else {
        fprintf(stderr,"wlu / wl driver mismatch, expect V%d format, got %d.\n",1,
                (uint)*(ushort *)puVar4);
        iVar6 = -0x2d;
      }
    }
  }
  return iVar6;
}



int FUN_0040bf08(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  bool bVar1;
  bool bVar2;
  undefined *__s;
  bool bVar3;
  undefined4 *puVar4;
  int iVar5;
  uint uVar6;
  char *pcVar7;
  undefined3 extraout_var;
  ulong uVar8;
  uint *__ptr;
  uint uVar9;
  int iVar10;
  int *local_c8;
  uint local_c4;
  char *local_bc;
  uint local_b8;
  uint local_b4;
  uint local_88;
  undefined1 auStack_84 [28];
  uint auStack_68 [4];
  char acStack_58 [16];
  uint local_48;
  char *local_14 [2];
  
  __s = PTR_DAT_00551644;
  local_c8 = param_3 + 1;
  puVar4 = (undefined4 *)(PTR_DAT_00551644 + 0x20);
  bVar2 = false;
  if ((int)param_2[2] < 0) {
    iVar5 = -1;
  }
  else {
    memset(acStack_58,0,0x44);
    iVar5 = FUN_004b9f94(param_1,0x62,acStack_58,0x44);
    if (iVar5 == 0) {
      uVar6 = local_48;
      if (DAT_00557704 != '\0') {
        uVar6 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                local_48 >> 0x18;
      }
      memset(__s,0,0x30);
      memset(&local_88,0,0x20);
      memset(auStack_68,0,0x10);
      while ((*(uint *)__s < 4 && (*local_c8 != 0))) {
        bVar1 = false;
        pcVar7 = (char *)*local_c8;
        local_bc = pcVar7;
        if (pcVar7[1] == ':') {
          iVar10 = *(int *)__s;
          iVar5 = toupper((int)*pcVar7);
          __s[iVar10 + 4] = (char)iVar5;
          local_bc = pcVar7 + 2;
          if (*local_bc == '+') {
            __s[*(int *)__s + 4] = __s[*(int *)__s + 4] | 0x80;
            local_bc = pcVar7 + 3;
          }
          if (((*local_bc == '\0') || (*local_bc == '/')) || (*local_bc == ',')) {
            bVar1 = true;
          }
        }
        if ((__s[*(int *)__s + 4] & 0x7f) == 0x43) {
          bVar1 = false;
LAB_0040c2b8:
          local_b8 = 0;
          while (((local_bc != (char *)0x0 && ((*local_bc == ',' || (*local_bc == '/')))) &&
                 ((('/' < local_bc[1] && (local_bc[1] < ':')) ||
                  ((local_bc[1] == '/' || (local_bc[1] == ','))))))) {
            local_14[0] = (char *)0x0;
            if ((local_bc[1] == '/') || (local_bc[1] == ',')) {
              local_b8 = local_b8 | 0x80000000;
              local_bc = local_bc + 2;
            }
            else {
              uVar8 = strtoul(local_bc + 1,local_14,10);
              if ((byte)uVar8 < 0x10) {
                local_b8 = local_b8 | 1 << (uVar8 & 0x1f);
              }
              else {
                printf("Bad precedence %d (will be ignored)\n",uVar8 & 0xff);
              }
              local_bc = local_14[0];
            }
          }
          if (local_b8 == 0) {
            local_b8 = 0x4000ffff;
          }
          if (bVar1) {
            auStack_68[local_88] = local_b8;
            local_88 = local_88 + 1;
          }
          else {
            puVar4[*(int *)__s] = local_b8;
            *(int *)__s = *(int *)__s + 1;
          }
          local_c8 = local_c8 + 1;
        }
        else {
          if (bVar1) {
            bVar2 = true;
            auStack_84[local_88] = __s[*(int *)__s + 4];
            goto LAB_0040c2b8;
          }
          bVar3 = FUN_0041d6ac(local_bc,__s + *(int *)__s * 6 + 8);
          if (CONCAT31(extraout_var,bVar3) != 0) {
            local_bc = local_bc + 0x11;
            goto LAB_0040c2b8;
          }
          __s[*(int *)__s + 4] = 0;
          printf("Bad parameter \'%s\'\n",(char *)*local_c8);
          local_c8 = local_c8 + 1;
        }
      }
      for (; *local_c8 != 0; local_c8 = local_c8 + 1) {
        printf("Ignoring excess parameter \'%s\' (maximum number of params is %d)\n",
               (char *)*local_c8,4);
      }
      if ((*(int *)__s == 0) && (!bVar2)) {
        __s[4] = 0x43;
        *puVar4 = 0xffff;
        *(undefined4 *)__s = 1;
      }
      if (*(int *)__s != 0) {
        *(uint *)__s = *(uint *)__s | 0x400;
        iVar5 = FUN_004ba0cc(param_1,(char *)*param_2,__s,0x30,PTR_DAT_00551644,0x2000);
        if (iVar5 < 0) {
          fprintf(stderr,"Error getting variable %s\n",(char *)*param_3);
          return iVar5;
        }
        FUN_00409268((int *)PTR_DAT_00551644,'\0',0x27 < uVar6);
      }
      if (bVar2) {
        __ptr = (uint *)malloc(0x600);
        if (__ptr == (uint *)0x0) {
          fwrite("unable to allocate memory\n",1,0x1a,stderr);
          iVar5 = -0xc;
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar9 = 0xff;
          }
          else {
            uVar9 = 0xff000000;
          }
          *__ptr = uVar9;
          iVar5 = FUN_004b9f94(param_1,0x9f,(char *)__ptr,0x600);
          if (iVar5 < 0) {
            fwrite("Cannot get assoclist\n",1,0x15,stderr);
            free(__ptr);
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar9 = *__ptr;
            }
            else {
              uVar9 = *__ptr;
              uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 |
                      uVar9 >> 0x18;
            }
            *__ptr = uVar9;
            if (*__ptr == 0) {
              fwrite("No available addresses in assoclist for automatic operation\n",1,0x3c,stderr);
              free(__ptr);
              iVar5 = 0;
            }
            else {
              for (local_c4 = 0; local_c4 < local_88; local_c4 = local_c4 + 1) {
                local_b4 = 0;
                while (local_b4 < *__ptr) {
                  memset(__s,0,0x30);
                  for (; (*(uint *)__s < 4 && (local_b4 < *__ptr)); local_b4 = local_b4 + 1) {
                    __s[*(int *)__s + 4] = auStack_84[local_c4];
                    iVar5 = *(int *)__s;
                    *(undefined4 *)(__s + iVar5 * 6 + 8) =
                         *(undefined4 *)((int)__ptr + local_b4 * 6 + 4);
                    __s[iVar5 * 6 + 0xc] = *(char *)((int)__ptr + local_b4 * 6 + 8);
                    __s[iVar5 * 6 + 0xd] = *(char *)((int)__ptr + local_b4 * 6 + 9);
                    puVar4[*(int *)__s] = auStack_68[local_c4] | 0x80000000;
                    *(int *)__s = *(int *)__s + 1;
                  }
                  *(uint *)__s = *(uint *)__s | 0x400;
                  iVar5 = FUN_004ba0cc(param_1,(char *)*param_2,__s,0x30,PTR_DAT_00551644,0x2000);
                  if (iVar5 < 0) {
                    fprintf(stderr,"Error getting %s\n",(char *)*param_3);
                    free(__ptr);
                    return iVar5;
                  }
                  FUN_00409268((int *)PTR_DAT_00551644,'\x01',0x27 < uVar6);
                }
              }
              free(__ptr);
              iVar5 = 0;
            }
          }
        }
      }
      else {
        iVar5 = 0;
      }
    }
  }
  return iVar5;
}



int FUN_0040cb14(int *param_1,int param_2,int param_3)

{
  char *__s;
  size_t sVar1;
  int *local_res8;
  int local_18;
  uint local_10 [2];
  
  if (*(int *)(param_2 + 8) < 0) {
    local_18 = -1;
  }
  else {
    __s = (char *)malloc(0x1fc00);
    if (__s == (char *)0x0) {
      fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x1fc00);
      local_18 = -0x1b;
    }
    else {
      memset(__s,0,0x1fc00);
      local_res8 = (int *)(param_3 + 4);
      if (*local_res8 == 0) {
        local_18 = FUN_004ba0cc(param_1,"dump",(void *)0x0,0,__s,0x1fc00);
        if (local_18 != 0) {
          FUN_004ba35c(param_1,"bcmerror",local_10);
          if (local_10[0] == 0xffffffe9) {
            local_18 = FUN_004b9f94(param_1,6,__s,0x1fc00);
            if (local_18 != 0) {
              fwrite("dump: error on query of WLC_DUMP\n",1,0x21,stderr);
            }
          }
          else {
            fwrite("dump: error on query of dump list\n",1,0x22,stderr);
          }
        }
      }
      else {
        for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
          if (*__s != '\0') {
            sVar1 = strlen(__s);
            __s[sVar1] = ' ';
            (__s + sVar1)[1] = '\0';
          }
          strcat(__s,(char *)*local_res8);
        }
        sVar1 = strlen(__s);
        __s[sVar1] = ' ';
        (__s + sVar1)[1] = '\0';
        sVar1 = strlen(__s);
        local_18 = FUN_004ba0cc(param_1,"dump",__s,sVar1,__s,0x1fc00);
      }
      if (local_18 == 0) {
        fputs(__s,stdout);
      }
      free(__s);
    }
  }
  return local_18;
}



int FUN_0040cddc(int *param_1,undefined4 *param_2,int *param_3)

{
  bool bVar1;
  int iVar2;
  char *__s;
  size_t sVar3;
  int *local_res8;
  int local_18;
  size_t local_14;
  
  local_14 = 0x1fc00;
  bVar1 = false;
  if ((int)param_2[2] < 0) {
    local_18 = -1;
  }
  else {
    iVar2 = strcmp((char *)*param_2,"ol_clr");
    if (iVar2 == 0) {
      local_18 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)0x0,0);
    }
    else {
      iVar2 = strcmp((char *)*param_2,"ol_cons");
      local_res8 = param_3;
      if ((iVar2 == 0) && (param_3[1] != 0)) {
        local_res8 = param_3 + 1;
        bVar1 = true;
        local_14 = 0x50;
      }
      __s = (char *)malloc(local_14);
      if (__s == (char *)0x0) {
        fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",local_14);
        local_18 = -1;
      }
      else {
        memset(__s,0,local_14);
        for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
          if (*__s != '\0') {
            sVar3 = strlen(__s);
            __s[sVar3] = ' ';
            (__s + sVar3)[1] = '\0';
          }
          strcat(__s,(char *)*local_res8);
        }
        if (bVar1) {
          local_18 = FUN_004ba2e4(param_1,(char *)*param_2,__s,local_14);
        }
        else {
          local_18 = FUN_004ba1f8(param_1,(char *)*param_2,__s,local_14);
          if (local_18 == 0) {
            fputs(__s,stdout);
          }
        }
        free(__s);
      }
    }
  }
  return local_18;
}



int FUN_0040d044(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  uint uVar2;
  int local_18;
  undefined1 auStack_14 [6];
  byte local_e;
  char *local_c;
  
  local_18 = -0x2c;
  local_c = (char *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = -1;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) != 0) {
      if (*(int *)(param_3 + 8) == 0) {
        local_18 = FUN_004ba0cc(param_1,(char *)*param_2,auStack_14,7,PTR_DAT_00551644,0x600);
        if (-1 < local_18) {
          printf("SCB prio: 0x%x\n",(uint)(byte)PTR_DAT_00551644[6]);
        }
      }
      else {
        uVar2 = strtol(*(char **)(param_3 + 8),&local_c,0);
        local_e = (byte)uVar2;
        if (*local_c == '\0') {
          if (local_e < 4) {
            printf("Set SCB prio: 0x%x\n",uVar2 & 0xff);
            local_18 = FUN_004ba160(param_1,(char *)*param_2,auStack_14,7,PTR_DAT_00551644,0x600);
          }
          else {
            printf("prio %d out of range [0, 3]\n",uVar2 & 0xff);
          }
        }
      }
    }
  }
  return local_18;
}



int FUN_0040d234(int *param_1,undefined4 *param_2,int param_3)

{
  char *__nptr;
  int local_28;
  char local_20 [4];
  ulong local_1c;
  ulong local_18;
  ulong local_14;
  char *local_10 [2];
  
  local_28 = -0x2c;
  if (*(int *)(param_3 + 4) == 0) {
    memset(local_20,0,0x10);
    local_28 = FUN_004ba1f8(param_1,(char *)*param_2,local_20,0x10);
    if (-1 < local_28) {
      printf("AIBSS Initial beacon check duration: %d \r\nAIBSS beacon check duration:%d \r\nAIBSS beacon flood duration:%d\r\n"
             ,local_1c,local_18,local_14);
    }
  }
  else {
    __nptr = *(char **)(param_3 + 4);
    local_10[0] = (char *)0x0;
    if ((__nptr != (char *)0x0) && (*__nptr != '\0')) {
      local_1c = strtoul(__nptr,local_10,0);
      if ((*local_10[0] != '\0') && (local_10[0][1] != '\0')) {
        local_18 = strtoul(local_10[0] + 1,local_10,0);
        if ((*local_10[0] != '\0') && (local_10[0][1] != '\0')) {
          local_14 = strtoul(local_10[0] + 1,local_10,0);
          if (*local_10[0] == '\0') {
            local_20[0] = '\0';
            local_20[1] = '\0';
            local_20[2] = '\x10';
            local_20[3] = '\0';
            local_28 = FUN_004ba2e4(param_1,(char *)*param_2,local_20,0x10);
          }
        }
      }
    }
  }
  return local_28;
}



int FUN_0040d440(int *param_1,int param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  undefined3 extraout_var;
  int iVar3;
  int local_18;
  int local_14;
  undefined1 local_10;
  undefined4 local_f;
  undefined1 local_b;
  undefined1 local_a;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = -0x2c;
  }
  else {
    bVar2 = FUN_0041d6ac(*(char **)(param_3 + 4),&local_f);
    puVar1 = PTR_DAT_00551644;
    if (CONCAT31(extraout_var,bVar2) == 0) {
      local_18 = -0x2c;
    }
    else {
      local_14 = 0xff;
      if (*(int *)(param_3 + 8) == 0) {
        *(undefined4 *)PTR_DAT_00551644 = local_f;
        puVar1[4] = local_b;
        puVar1[5] = local_a;
        local_18 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
        if (-1 < local_18) {
          fputs(PTR_DAT_00551644,stdout);
          local_18 = 0;
        }
      }
      else {
        local_14 = atoi(*(char **)(param_3 + 8));
        if ((local_14 != -1) && ((local_14 < 0 || (3 < local_14)))) {
          printf("ac %d out of range [0, 3] or -1 to indicate all\n",local_14);
        }
        if (*(int *)(param_3 + 0xc) == 0) {
          puts("too few parameters.");
          local_18 = -0x2c;
        }
        else {
          iVar3 = atoi(*(char **)(param_3 + 0xc));
          local_10 = (undefined1)iVar3;
          local_18 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_14,0xc);
        }
      }
    }
  }
  return local_18;
}



int FUN_0040d674(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined3 extraout_var;
  
  if (*(int *)(param_2 + 8) < 0) {
    iVar2 = -1;
  }
  else if (*(int *)(param_3 + 4) == 0) {
    iVar2 = -0x2c;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),PTR_DAT_00551644);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
      if (iVar2 < 0) {
        fwrite("Could not find corresponding scb from given mac address.\n",1,0x39,stderr);
      }
      else {
        fputs(PTR_DAT_00551644,stdout);
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



int FUN_0040d7ac(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined3 extraout_var;
  
  if (*(int *)(param_2 + 8) < 0) {
    iVar2 = -1;
  }
  else if (*(int *)(param_3 + 4) == 0) {
    iVar2 = -1;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),PTR_DAT_00551644);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -1;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
      if (iVar2 < 0) {
        fwrite("Could not find corresponding scb from given mac address.\n",1,0x39,stderr);
      }
      else {
        fputs(PTR_DAT_00551644,stdout);
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



int FUN_0040d8e4(int *param_1,int param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  undefined4 uVar4;
  uint local_30;
  int local_2c;
  
  puVar1 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0;
  if (DAT_00557704 == '\0') {
    uVar4 = 0x1b8;
  }
  else {
    uVar4 = 0xb8010000;
  }
  *(undefined4 *)(puVar1 + 4) = uVar4;
  if (*(int *)(param_2 + 8) < 0) {
    iVar2 = -1;
  }
  else {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
    if (-1 < iVar2) {
      if (*(short *)(puVar1 + 0x88) == -0x7778) {
        local_2c = 0x200;
      }
      else if (*(short *)(puVar1 + 0x88) == 0x634) {
        local_2c = 0xea;
      }
      else if (*(short *)(puVar1 + 0x1be) == 0x5372) {
        local_2c = 0xe6;
      }
      else {
        local_2c = 0xdc;
        if ((*(short *)(puVar1 + 0x48) != 0x5372) && (*(short *)(puVar1 + 0x88) != 0x5372)) {
          local_2c = 0x40;
        }
      }
      if (*(int *)(param_3 + 4) != 0) {
        uVar3 = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
        if ((uVar3 & 1) != 0) {
          printf("Byte count %d is odd\n",uVar3);
          return -2;
        }
        local_2c = (int)uVar3 / 2;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = local_2c << 1;
      }
      else {
        uVar3 = local_2c << 1;
        uVar3 = local_2c << 0x19 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      *(uint *)(puVar1 + 4) = uVar3;
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
      if (-1 < iVar2) {
        for (local_30 = 0; (int)local_30 < local_2c; local_30 = local_30 + 1) {
          if ((local_30 & 7) == 0) {
            printf("\n  srom[%03d]:  ",local_30);
          }
          printf("0x%04x  ",(uint)*(ushort *)(puVar1 + local_30 * 2 + 8));
        }
        putchar(10);
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



int FUN_0040dcdc(int *param_1,int param_2,undefined4 *param_3)

{
  undefined *puVar1;
  int iVar2;
  int iVar3;
  ulong uVar4;
  int *local_res8;
  char *local_30;
  FILE *local_2c;
  int local_24;
  ulong local_20;
  char *local_10 [2];
  
  puVar1 = PTR_DAT_00551644;
  local_2c = (FILE *)0x0;
  iVar2 = strcmp((char *)*param_3,"srclear");
  iVar3 = strcmp((char *)*param_3,"srcrc");
  if (param_3[1] == 0) {
    return 0;
  }
  local_30 = (char *)param_3[1];
  local_res8 = param_3 + 2;
  if (iVar2 == 0) {
    if (*local_res8 != 0) {
      return 0;
    }
    local_20 = strtoul(local_30,local_10,0);
    if (*local_10[0] != '\0') {
      fprintf(stderr,"error parsing value \"%s\" as an integer for byte count\n",local_30);
      return 0;
    }
    *(undefined4 *)puVar1 = 0x55aa;
  }
  else {
    if (*local_res8 != 0) {
      if (iVar3 != 0) {
        uVar4 = strtoul(local_30,local_10,0);
        *(ulong *)puVar1 = uVar4;
        if (*local_10[0] == '\0') {
          local_24 = 0;
          do {
            local_30 = (char *)*local_res8;
            local_res8 = local_res8 + 1;
            if (local_30 == (char *)0x0) {
              if ((*(uint *)puVar1 & 1) == 0) {
                local_20 = local_24 * 2;
                if (*(int *)puVar1 + local_20 < 0x409) goto LAB_0040e250;
                printf("Data extends past %d bytes\n",0x408);
                iVar2 = -0xf;
              }
              else {
                printf("Byte offset (%d) is odd or negative\n",*(int *)puVar1);
                iVar2 = -2;
              }
              goto LAB_0040e348;
            }
            uVar4 = strtoul(local_30,local_10,0);
            *(short *)(puVar1 + (local_24 + 4) * 2) = (short)uVar4;
            local_24 = local_24 + 1;
          } while (*local_10[0] == '\0');
        }
        printf("\n%s is not an integer\n",local_30);
        iVar2 = -0x2c;
      }
      else {
        puts("srcrc only takes one arg");
        iVar2 = -0x2c;
      }
      goto LAB_0040e348;
    }
    local_2c = fopen(local_30,"rb");
    if (local_2c == (FILE *)0x0) {
      fprintf(stderr,"%s: No such file or directory\n",local_30);
      return 0;
    }
    local_20 = fread(puVar1 + 8,1,0x409,local_2c);
    iVar2 = ferror(local_2c);
    if (iVar2 != 0) {
      printf("\nerror %d reading %s\n",iVar2,local_30);
      iVar2 = -1;
      goto LAB_0040e348;
    }
    iVar2 = feof(local_2c);
    if (iVar2 == 0) {
      printf("\nFile %s is too large\n",local_30);
      iVar2 = -1;
      goto LAB_0040e348;
    }
    if (local_20 == 0x1b8) {
      if ((*(short *)(puVar1 + 0x48) != 0x5372) && (*(short *)(puVar1 + 0x88) != 0x5372)) {
        printf("\nFile %s is %d bytes but lacks a REV4/ signature\n",local_30,0x1b8);
        iVar2 = -1;
        goto LAB_0040e348;
      }
    }
    else if (local_20 == 0x1d4) {
      if (*(short *)(puVar1 + 0x88) != 0x634) {
        printf("\nFile %s is %d bytes but lacks a REV11/ signature\n",local_30,0x1d4);
        iVar2 = -1;
        goto LAB_0040e348;
      }
    }
    else if (local_20 == 0x400) {
      if (*(short *)(puVar1 + 0x88) != -0x7778) {
        printf("\nFile %s is %d bytes but lacks a REV12/ signature\n",local_30,0x400);
        iVar2 = -1;
        goto LAB_0040e348;
      }
    }
    else if (((local_20 != 0x80) && (local_20 != 0x1cc)) && (local_20 != 0x408)) {
      printf("\nFile %s is %d bytes, not %d or %d or %d or %d bytes\n",local_30,local_20,0x80,0x1b8,
             0xe6,0x408);
      iVar2 = -1;
      goto LAB_0040e348;
    }
    *(undefined4 *)puVar1 = 0;
  }
LAB_0040e250:
  *(ulong *)(puVar1 + 4) = local_20;
  if (iVar3 != 0) {
    printf("Writing srom. ioctl %d, iolen %d, sroff %d, len %d\n",*(int *)(param_2 + 0xc),
           local_20 + 8,*(int *)puVar1,*(int *)(puVar1 + 4));
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),PTR_DAT_00551644,local_20 + 8);
  }
  else {
    *(undefined4 *)puVar1 = 0x55ab;
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,local_20 + 8);
    if (iVar2 == 0) {
      printf("0x%x\n",(uint)(byte)*PTR_DAT_00551644);
    }
  }
LAB_0040e348:
  fflush(stdout);
  if (local_2c != (FILE *)0x0) {
    fclose(local_2c);
  }
  return iVar2;
}



int FUN_0040e390(int *param_1,undefined4 param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  size_t param1;
  int *local_res8;
  int local_38;
  undefined1 auStack_14 [2];
  ushort local_12;
  size_t local_c;
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    local_38 = -0x2c;
  }
  else {
    memset(auStack_14,0,0xc);
    iVar2 = strcmp((char *)*local_res8,"--pciecis");
    if ((iVar2 == 0) || (iVar2 = strcmp((char *)*local_res8,"-p"), iVar2 == 0)) {
      puts("Writing in PCIe CIS format");
      local_12 = local_12 | 0x8000;
      local_res8 = (int *)(param_3 + 8);
      if (*local_res8 == 0) {
        return -0x2c;
      }
    }
    puVar1 = PTR_DAT_00551644;
    memset(PTR_DAT_00551644,0,0x2000);
    *(undefined4 *)puVar1 = 0x77736963;
    pcVar3 = puVar1 + 4;
    pcVar3[0] = 'r';
    pcVar3[1] = 'i';
    pcVar3[2] = 't';
    pcVar3[3] = 'e';
    puVar1[8] = '\0';
    pcVar3 = (char *)*local_res8;
    __stream = fopen(pcVar3,"rb");
    if (__stream == (FILE *)0x0) {
      fprintf(stderr,"%s: No such file or directory\n",pcVar3);
      local_38 = -2;
    }
    else {
      param1 = fread(puVar1 + 0x15,1,0x409,__stream);
      iVar2 = ferror(__stream);
      if (iVar2 == 0) {
        iVar2 = feof(__stream);
        if (iVar2 == 0) {
          printf("\nFile %s is too large\n",pcVar3);
          local_38 = -1;
        }
        else {
          local_c = param1;
          if (DAT_00557704 != '\0') {
            local_12 = local_12 << 8 | local_12 >> 8;
            local_c = param1 << 0x18 | (param1 & 0xff00) << 8 | (param1 & 0xff0000) >> 8 |
                      param1 >> 0x18;
          }
          memcpy(puVar1 + 9,auStack_14,0xc);
          printf("len %d sizeof(cish) %d total %d\n",param1,0xc,param1 + 0xc);
          local_38 = FUN_004baca0(param_1,0x107,PTR_DAT_00551644,
                                  (uint)(puVar1 + 9 + (param1 - (int)PTR_DAT_00551644) + 0xc));
          if (local_38 < 0) {
            fprintf(stderr,"ciswrite failed: %d\n",local_38);
          }
        }
      }
      else {
        printf("\nerror %d reading %s\n",iVar2,pcVar3);
        local_38 = -1;
      }
      if (__stream != (FILE *)0x0) {
        fclose(__stream);
      }
    }
  }
  return local_38;
}



int FUN_0040e784(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  bool bVar2;
  undefined *puVar3;
  int iVar4;
  long param1;
  size_t sVar5;
  uint param3;
  long lVar6;
  uint param3_00;
  char *local_450;
  int local_44c;
  uint local_444;
  char *local_424;
  char local_420;
  char local_41f;
  undefined1 local_41e;
  byte abStack_41c [1032];
  ushort local_14 [4];
  uint local_c;
  
  local_44c = 0;
  bVar2 = false;
  if ((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) {
    local_44c = -0x2c;
  }
  else {
    if ((*(int *)(param_3 + 0xc) != 0) &&
       (iVar4 = strcmp(*(char **)(param_3 + 0xc),"--preview"), iVar4 == 0)) {
      bVar2 = true;
    }
    param1 = strtol(*(char **)(param_3 + 4),&local_424,0);
    if (*local_424 == '\0') {
      local_450 = *(char **)(param_3 + 8);
      sVar5 = strlen(local_450);
      if ((sVar5 & 1) == 0) {
        param3 = sVar5 >> 1;
        for (local_444 = 0; local_444 < param3; local_444 = local_444 + 1) {
          local_420 = *local_450;
          local_41f = local_450[1];
          if (((*(ushort *)(__ctype_b + local_420 * 2) & 0x10) == 0) ||
             ((*(ushort *)(__ctype_b + local_41f * 2) & 0x10) == 0)) {
            fprintf(stderr,"cisupdate invalid hex digit(s) in %s\n",*(char **)(param_3 + 8));
            return 0;
          }
          local_41e = 0;
          lVar6 = strtol(&local_420,(char **)0x0,0x10);
          abStack_41c[local_444] = (byte)lVar6;
          local_450 = local_450 + 2;
        }
        memset(local_14,0,0xc);
        memset(PTR_DAT_00551644 + 9,0,0x2000);
        puVar3 = PTR_DAT_00551644;
        *(undefined4 *)(PTR_DAT_00551644 + 9) = 0x64736963;
        *(undefined4 *)(puVar3 + 0xd) = 0x706d75;
        puVar3 = PTR_DAT_00551644;
        memcpy(PTR_DAT_00551644 + 0x11,local_14,0xc);
        local_44c = FUN_004bab9c(param_1,0x106,PTR_DAT_00551644 + 9,
                                 (uint)(puVar3 + (0x425 - (int)(PTR_DAT_00551644 + 9))));
        puVar3 = PTR_DAT_00551644;
        if (local_44c < 0) {
          fprintf(stderr,"cisupdate failed to read cis: %d\n",local_44c);
        }
        else {
          memcpy(local_14,PTR_DAT_00551644 + 9,0xc);
          param3_00 = local_c;
          if (DAT_00557704 != '\0') {
            param3_00 = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                        local_c >> 0x18;
          }
          if (param3_00 < param1 + param3) {
            fprintf(stderr,"cisupdate offset %d plus update len %d exceeds CIS len %d\n",param1,
                    param3,param3_00);
          }
          else {
            if (DAT_00557704 != '\0') {
              local_14[0] = local_14[0] << 8 | local_14[0] >> 8;
            }
            if (local_14[0] == 1) {
              for (local_444 = 0; local_444 < param3; local_444 = local_444 + 1) {
                puVar3[param1 + local_444 + 0x15] = abStack_41c[local_444];
              }
            }
            else {
              for (local_444 = 0; local_444 < param3; local_444 = local_444 + 1) {
                if ((~abStack_41c[local_444] & puVar3[param1 + local_444 + 0x15]) != 0) {
                  fprintf(stderr,
                          "cisupdate: OTP update incompatible: update[%d](0x%02x)->cis[%d](0x%02x)\n"
                          ,local_444,(int)(char)abStack_41c[local_444],param1 + local_444,
                          (int)(char)puVar3[param1 + local_444 + 0x15]);
                  return local_44c;
                }
                puVar3[param1 + local_444 + 0x15] =
                     puVar3[param1 + local_444 + 0x15] | abStack_41c[local_444];
              }
            }
            puVar3 = PTR_DAT_00551644;
            *(undefined4 *)PTR_DAT_00551644 = 0x77736963;
            pcVar1 = puVar3 + 4;
            pcVar1[0] = 'r';
            pcVar1[1] = 'i';
            pcVar1[2] = 't';
            pcVar1[3] = 'e';
            puVar3[8] = '\0';
            memset(local_14,0,0xc);
            local_c = param3_00;
            if (DAT_00557704 != '\0') {
              local_c = param3_00 << 0x18 | (param3_00 & 0xff00) << 8 | (param3_00 & 0xff0000) >> 8
                        | param3_00 >> 0x18;
            }
            memcpy(puVar3 + 9,local_14,0xc);
            printf("offset %d data %s cislen %d\n",param1,*(char **)(param_3 + 8),param3_00);
            if (bVar2) {
              for (local_444 = 0; local_444 < param3_00; local_444 = local_444 + 1) {
                if ((local_444 & 7) == 0) {
                  printf("\nByte %3d: ",local_444);
                }
                printf("0x%02x ",(uint)(byte)puVar3[local_444 + 0x15]);
              }
              putchar(10);
            }
            else {
              local_44c = FUN_004baca0(param_1,0x107,PTR_DAT_00551644,
                                       (uint)(puVar3 + 9 + (param3_00 - (int)PTR_DAT_00551644) + 0xc
                                             ));
              if (local_44c < 0) {
                fprintf(stderr,"cisupdate cis write failed: %d\n",local_44c);
              }
            }
          }
        }
      }
      else {
        fwrite("cisupdate hex string must contain an even number of digits\n",1,0x3b,stderr);
      }
    }
    else {
      local_44c = -0x2c;
    }
  }
  return local_44c;
}



int FUN_0040efcc(int *param_1,undefined4 param_2,int param_3)

{
  undefined *puVar1;
  FILE *param0;
  int iVar2;
  uint uVar3;
  char *pcVar4;
  FILE *__s;
  size_t param1;
  int *piVar5;
  int local_res8;
  uint local_48;
  int local_44;
  uint local_40;
  char *local_3c;
  ushort local_20;
  ushort local_1e;
  uint local_1c;
  uint local_18;
  
  local_40 = 0;
  local_3c = (char *)0x0;
  local_res8 = param_3;
  if ((*(int *)(param_3 + 4) != 0) && (iVar2 = strcmp(*(char **)(param_3 + 4),"-b"), iVar2 == 0)) {
    local_3c = *(char **)(param_3 + 8);
    local_res8 = param_3 + 8;
  }
  if (*(int *)(local_res8 + 4) != 0) {
    local_40 = strtol(*(char **)(local_res8 + 4),(char **)0x0,0);
    if ((local_40 & 1) != 0) {
      printf("Invalid byte count %d, must be even\n",local_40);
      return -2;
    }
    if (0x408 < local_40) {
      printf("Count %d too large\n",local_40);
      return -0xf;
    }
  }
  memset(&local_20,0,0xc);
  local_18 = local_40;
  if (DAT_00557704 != '\0') {
    local_18 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
               local_40 >> 0x18;
  }
  memset(PTR_DAT_00551644,0,0x2000);
  puVar1 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x64736963;
  *(undefined4 *)(puVar1 + 4) = 0x706d75;
  puVar1 = PTR_DAT_00551644;
  memcpy(PTR_DAT_00551644 + 8,&local_20,0xc);
  uVar3 = local_40;
  if (local_40 == 0) {
    uVar3 = 0x408;
  }
  local_44 = FUN_004bab9c(param_1,0x106,PTR_DAT_00551644,
                          (uint)(puVar1 + uVar3 + (0x14 - (int)PTR_DAT_00551644)));
  puVar1 = PTR_DAT_00551644;
  if (local_44 < 0) {
    fprintf(stderr,"Failed cisdump request: %d\n",local_44);
  }
  else {
    memcpy(&local_20,PTR_DAT_00551644,0xc);
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 8 | local_20 >> 8;
      local_1e = local_1e << 8 | local_1e >> 8;
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
    }
    if (local_20 == 0) {
      pcVar4 = "Built-in default";
    }
    else if (local_20 == 1) {
      pcVar4 = "External SPROM";
    }
    else if (local_20 == 2) {
      pcVar4 = "Internal OTP";
    }
    else {
      pcVar4 = "Unknown?";
    }
    printf("Source: %d (%s)",(uint)local_20,pcVar4);
    if (local_40 == 0) {
      printf("\nMaximum length: %d bytes",local_18);
    }
    for (local_48 = 0; (int)local_48 < (int)local_18; local_48 = local_48 + 1) {
      if ((local_48 & 7) == 0) {
        printf("\nByte %3d: ",local_48);
      }
      printf("0x%02x ",(uint)(byte)(puVar1 + 0xc)[local_48]);
    }
    putchar(10);
    if (local_3c != (char *)0x0) {
      if (local_40 == 0) {
        local_40 = local_18;
      }
      __s = fopen(local_3c,"wb");
      param0 = stderr;
      if (__s == (FILE *)0x0) {
        piVar5 = __errno_location();
        pcVar4 = strerror(*piVar5);
        fprintf(param0,"Problem creating file %s: %s\n",local_3c,pcVar4);
        local_44 = -2;
      }
      else {
        param1 = fwrite(puVar1 + 0xc,1,local_40,__s);
        if (local_40 == param1) {
          printf("Wrote %d bytes to %s\n",param1,local_3c);
          local_44 = 0;
        }
        else {
          fprintf(stderr,"Error writing %d bytes to file, rc %d!\n",local_40,param1);
          local_44 = -1;
        }
        fclose(__s);
      }
    }
  }
  return local_44;
}



char * FUN_0040f668(undefined4 *param_1,char *param_2,ulong *param_3)

{
  size_t sVar1;
  ulong uVar2;
  char *pcVar3;
  char *local_20;
  undefined4 *local_1c;
  char *local_10 [2];
  
  local_20 = (char *)0x0;
  local_1c = param_1;
  if (param_3 != (ulong *)0x0) {
    *param_3 = 0;
  }
  while( true ) {
    do {
      pcVar3 = (char *)*local_1c;
      local_1c = local_1c + 1;
      if (pcVar3 == (char *)0x0) {
        return local_20;
      }
      local_20 = strstr(pcVar3,param_2);
    } while (local_20 == (char *)0x0);
    local_10[0] = (char *)0x0;
    sVar1 = strlen(param_2);
    pcVar3 = local_20 + sVar1;
    if (*pcVar3 == '=') break;
    local_20 = (char *)0x0;
  }
  if (param_3 != (ulong *)0x0) {
    uVar2 = strtoul(pcVar3 + 1,local_10,0);
    *param_3 = uVar2;
    if (pcVar3 + 1 != local_10[0]) {
      return local_20;
    }
    printf("Bad value: %s\n",local_20);
    return (char *)0x0;
  }
  sVar1 = strlen(param_2);
  return local_20 + sVar1 + 1;
}



char * FUN_0040f7f4(undefined4 *param_1,char *param_2,int param_3,int param_4)

{
  size_t sVar1;
  ulong uVar2;
  char *__haystack;
  char *local_28;
  undefined4 *local_24;
  int local_20;
  char *local_1c;
  char *local_14 [2];
  
  local_28 = (char *)0x0;
  local_24 = param_1;
  while( true ) {
    do {
      __haystack = (char *)*local_24;
      local_24 = local_24 + 1;
      if (__haystack == (char *)0x0) {
        return local_28;
      }
      local_28 = strstr(__haystack,param_2);
    } while (local_28 == (char *)0x0);
    local_14[0] = (char *)0x0;
    sVar1 = strlen(param_2);
    if (local_28[sVar1] == '=') break;
    local_28 = (char *)0x0;
  }
  if (param_3 == 0) {
    sVar1 = strlen(param_2);
    return local_28 + sVar1 + 1;
  }
  local_20 = 0;
  local_1c = local_28 + sVar1;
  while( true ) {
    local_1c = local_1c + 1;
    if (param_4 <= local_20) {
      return local_28;
    }
    uVar2 = strtoul(local_1c,local_14,0);
    *(ulong *)(param_3 + local_20 * 4) = uVar2;
    if (local_1c == local_14[0]) break;
    local_20 = local_20 + 1;
    local_1c = local_14[0];
  }
  printf("Bad value: %s\n",local_28);
  return (char *)0x0;
}



undefined4 FUN_0040f9bc(undefined1 *param_1,int *param_2,undefined1 param_3,undefined1 *param_4)

{
  memset(param_1,0,(byte)param_4[8] + 2);
  *param_1 = param_3;
  param_1[1] = param_4[8];
  param_1[2] = *param_4;
  if (param_2 != (int *)0x0) {
    *param_2 = *param_2 + 3;
  }
  return 0;
}



int FUN_0040fa78(int param_1,undefined4 *param_2,uint param_3)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  ulong uVar5;
  char *pcVar6;
  undefined3 extraout_var;
  size_t sVar7;
  undefined4 *puVar8;
  char *__s1;
  int iVar9;
  undefined1 *puVar10;
  char *local_b0;
  char *local_ac;
  int local_a8;
  size_t local_a4;
  size_t local_a0;
  char *local_9c;
  char *local_98;
  bool local_92;
  bool local_91;
  bool local_90;
  ushort local_8e;
  ushort local_8c;
  char *local_88;
  bool local_84;
  bool local_83;
  ushort local_82;
  ushort local_80;
  bool local_7e;
  ushort local_7c;
  ushort local_7a;
  bool local_78;
  ushort local_76;
  ushort local_74;
  bool local_72;
  ushort local_70;
  ushort local_6e;
  bool local_6c;
  ushort local_6a;
  undefined1 *local_64;
  int local_5c;
  char *local_48;
  char local_44 [4];
  int local_40;
  ulong local_3c [3];
  undefined2 local_30;
  undefined1 local_2e;
  undefined2 local_2c;
  undefined2 local_28;
  char local_24;
  char local_23;
  undefined1 local_22;
  undefined4 local_20;
  undefined2 local_1c;
  char *local_18 [2];
  
  local_b0 = &DAT_004eb360;
  local_48 = (char *)0x0;
  local_44[0] = ' ';
  local_44[1] = '\0';
  local_40 = 0;
  if (((int)param_3 < 1) || (0x1f < (int)param_3)) {
    printf("Invalid sromrev %d.\n",param_3);
    local_40 = -2;
  }
  else {
    while (*local_b0 != -1) {
      local_3c[0] = 0;
      if ((*(uint *)(local_b0 + 4) & 1 << (param_3 & 0x1f)) == 0) {
        local_b0 = local_b0 + 0x10;
      }
      else {
        if (*local_b0 == -2) {
          local_48 = FUN_0040f668(param_2,(char *)&PTR_DAT_0050f844,local_3c);
          if (local_48 == (char *)0x0) {
            local_48 = (char *)0x0;
          }
          else {
            local_48 = local_48 + 4;
            do {
              iVar9 = local_40;
              puVar10 = (undefined1 *)(param_1 + local_40);
              uVar5 = strtoul(local_48,&local_48,0x10);
              *puVar10 = (char)uVar5;
              local_40 = iVar9 + 1;
              cVar1 = *local_48;
              local_48 = local_48 + 1;
            } while (cVar1 != '\0');
          }
        }
        else if (*local_b0 == -5) {
          local_48 = FUN_0040f668(param_2,"RAW1",(ulong *)0x0);
          if (local_48 != (char *)0x0) {
            do {
              iVar9 = local_40;
              puVar10 = (undefined1 *)(param_1 + local_40);
              uVar5 = strtoul(local_48,&local_48,0x10);
              *puVar10 = (char)uVar5;
              local_40 = iVar9 + 1;
              cVar1 = *local_48;
              local_48 = local_48 + 1;
            } while (cVar1 != '\0');
          }
        }
        else if (*local_b0 == -3) {
          local_a4 = 1;
          local_a0 = 1;
          local_48 = FUN_0040f668(param_2,"manf",(ulong *)0x0);
          if (local_48 != (char *)0x0) {
            local_a4 = strlen(local_48);
            local_a4 = local_a4 + 1;
          }
          pcVar6 = FUN_0040f668(param_2,"productname",(ulong *)0x0);
          if (pcVar6 != (char *)0x0) {
            local_a0 = strlen(pcVar6);
            local_a0 = local_a0 + 1;
          }
          if (local_48 != (char *)0x0 || pcVar6 != (char *)0x0) {
            *(undefined1 *)(param_1 + local_40) = 0x15;
            *(char *)(param_1 + local_40 + 1) = (char)local_a4 + (char)local_a0 + '\x02';
            *(undefined1 *)(param_1 + local_40 + 2) = 8;
            *(undefined1 *)(param_1 + local_40 + 3) = 0;
            local_40 = local_40 + 4;
            if (local_48 == (char *)0x0) {
              *(undefined1 *)(param_1 + local_40) = 0;
            }
            else {
              local_9c = local_48;
              while (local_9c = strchr(local_9c,0x5f), local_9c != (char *)0x0) {
                *local_9c = ' ';
              }
              memcpy((void *)(param_1 + local_40),local_48,local_a4);
            }
            local_40 = local_40 + local_a4;
            local_98 = pcVar6;
            if (pcVar6 == (char *)0x0) {
              *(undefined1 *)(param_1 + local_40) = 0;
            }
            else {
              while (local_98 = strchr(local_98,0x5f), local_98 != (char *)0x0) {
                *local_98 = ' ';
              }
              memcpy((void *)(param_1 + local_40),pcVar6,local_a0);
            }
            local_40 = local_40 + local_a0;
          }
        }
        else if (*local_b0 == -4) {
          local_3c[1] = 0;
          local_3c[2] = 0;
          local_48 = FUN_0040f668(param_2,"manfid",local_3c + 1);
          bVar4 = local_48 != (char *)0x0;
          local_48 = FUN_0040f668(param_2,"prodid",local_3c + 2);
          if (local_48 != (char *)0x0 || bVar4) {
            *(undefined1 *)(param_1 + local_40) = 0x20;
            *(char *)(param_1 + local_40 + 1) = local_b0[8];
            *(char *)(param_1 + local_40 + 2) = (char)local_3c[1];
            *(char *)(param_1 + local_40 + 3) = (char)(local_3c[1] >> 8);
            *(char *)(param_1 + local_40 + 4) = (char)local_3c[2];
            *(char *)(param_1 + local_40 + 5) = (char)(local_3c[2] >> 8);
            local_40 = local_40 + 6;
          }
        }
        else if (*local_b0 == '\x19') {
          local_48 = FUN_0040f668(param_2,"macaddr",(ulong *)0x0);
          if (local_48 != (char *)0x0) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            bVar4 = FUN_0041d6ac(local_48,(void *)(param_1 + local_40));
            if (CONCAT31(extraout_var,bVar4) == 0) {
              printf("Argument does not look like a MAC address: %s\n",local_48);
            }
            local_40 = local_40 + 6;
          }
        }
        else if (*local_b0 == '\n') {
          local_30 = 0;
          local_2e = 0;
          local_48 = FUN_0040f668(param_2,"ccode",(ulong *)0x0);
          bVar4 = local_48 != (char *)0x0;
          if (bVar4) {
            local_30 = *(undefined2 *)local_48;
            local_48 = local_48 + 2;
          }
          local_48 = FUN_0040f668(param_2,"cctl",local_3c);
          if (local_48 != (char *)0x0) {
            local_2e = (undefined1)local_3c[0];
          }
          if (local_48 != (char *)0x0 || bVar4) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            puVar10 = (undefined1 *)(param_1 + local_40);
            *puVar10 = (undefined1)local_30;
            puVar10[1] = local_30._1_1_;
            puVar10[2] = local_2e;
            local_40 = local_40 + 3;
          }
        }
        else if (*local_b0 == '\x11') {
          local_2c = 0;
          local_48 = FUN_0040f668(param_2,"rssismf2g",local_3c);
          local_92 = local_48 != (char *)0x0;
          if (local_92) {
            local_2c = CONCAT11(local_2c._1_1_,(byte)local_2c | (byte)local_3c[0] & 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rssismc2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_2c = CONCAT11(local_2c._1_1_,(byte)local_2c | (byte)((local_3c[0] & 0xf) << 4));
          }
          local_92 = local_48 != (char *)0x0 || local_92;
          local_48 = FUN_0040f668(param_2,"rssisav2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_92 = true;
            local_2c = CONCAT11(local_2c._1_1_ | (byte)local_3c[0] & 7,(byte)local_2c);
          }
          local_48 = FUN_0040f668(param_2,"bxa2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_92 = true;
            local_2c = CONCAT11(local_2c._1_1_ | (byte)((local_3c[0] & 3) << 3),(byte)local_2c);
          }
          if (local_92) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(undefined1 *)(param_1 + local_40) = (byte)local_2c;
            ((undefined1 *)(param_1 + local_40))[1] = local_2c._1_1_;
            local_40 = local_40 + 2;
          }
        }
        else if (*local_b0 == '\x12') {
          local_28 = 0;
          local_48 = FUN_0040f668(param_2,"rssismf5g",local_3c);
          local_91 = local_48 != (char *)0x0;
          if (local_91) {
            local_28 = CONCAT11(local_28._1_1_,(byte)local_28 | (byte)local_3c[0] & 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rssismc5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_28 = CONCAT11(local_28._1_1_,(byte)local_28 | (byte)((local_3c[0] & 0xf) << 4));
          }
          local_91 = local_48 != (char *)0x0 || local_91;
          local_48 = FUN_0040f668(param_2,"rssisav5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_91 = true;
            local_28 = CONCAT11(local_28._1_1_ | (byte)local_3c[0] & 7,(byte)local_28);
          }
          local_48 = FUN_0040f668(param_2,"bxa5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_91 = true;
            local_28 = CONCAT11(local_28._1_1_ | (byte)((local_3c[0] & 3) << 3),(byte)local_28);
          }
          if (local_91) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(undefined1 *)(param_1 + local_40) = (byte)local_28;
            ((undefined1 *)(param_1 + local_40))[1] = local_28._1_1_;
            local_40 = local_40 + 2;
          }
        }
        else if (*local_b0 == '#') {
          local_8e = 0;
          local_8c = 0;
          local_48 = FUN_0040f668(param_2,"antswctl2g",local_3c);
          local_90 = local_48 != (char *)0x0;
          if (local_90) {
            local_8e = (ushort)((local_3c[0] & 0x1f) << 0xb);
          }
          local_48 = FUN_0040f668(param_2,"triso2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_8e = (ushort)((local_3c[0] & 7) << 8) | local_8e;
          }
          local_90 = local_48 != (char *)0x0 || local_90;
          local_48 = FUN_0040f668(param_2,"pdetrange2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8e = (ushort)((local_3c[0] & 0x1f) << 3) | local_8e;
          }
          local_48 = FUN_0040f668(param_2,"extpagain2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8e = (ushort)((local_3c[0] & 3) << 1) | local_8e;
          }
          local_48 = FUN_0040f668(param_2,"tssipos2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8e = (ushort)local_3c[0] & 1 | local_8e;
          }
          local_48 = FUN_0040f668(param_2,"antswctl5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8c = (ushort)((local_3c[0] & 0x1f) << 0xb);
          }
          local_48 = FUN_0040f668(param_2,"triso5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8c = (ushort)((local_3c[0] & 7) << 8) | local_8c;
          }
          local_48 = FUN_0040f668(param_2,"pdetrange5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8c = (ushort)((local_3c[0] & 0x1f) << 3) | local_8c;
          }
          local_48 = FUN_0040f668(param_2,"extpagain5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8c = (ushort)((local_3c[0] & 3) << 1) | local_8c;
          }
          local_48 = FUN_0040f668(param_2,"tssipos5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_90 = true;
            local_8c = (ushort)local_3c[0] & 1 | local_8c;
          }
          if (local_90) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_8e;
            *(char *)(param_1 + local_40 + 1) = (char)(local_8e >> 8);
            *(char *)(param_1 + local_40 + 2) = (char)local_8c;
            *(char *)(param_1 + local_40 + 3) = (char)(local_8c >> 8);
            local_40 = local_40 + 4;
          }
        }
        else if (*local_b0 == ';') {
          local_24 = '\0';
          local_23 = '\0';
          local_22 = 0;
          local_88 = FUN_0040f668(param_2,"uuid",(ulong *)0x0);
          if ((local_88 != (char *)0x0) && (sVar7 = strlen(local_88), sVar7 == 0x24)) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            while (iVar9 = local_40, *local_88 != '\0') {
              if (*local_88 == '-') {
                local_88 = local_88 + 1;
              }
              else {
                local_24 = *local_88;
                local_23 = local_88[1];
                local_88 = local_88 + 2;
                puVar10 = (undefined1 *)(param_1 + local_40);
                uVar5 = strtoul(&local_24,(char **)0x0,0x10);
                *puVar10 = (char)uVar5;
                local_40 = iVar9 + 1;
              }
            }
          }
        }
        else if (*local_b0 == ':') {
          local_20 = 0;
          local_1c = 0;
          local_48 = FUN_0040f668(param_2,"tempthresh",local_3c);
          local_84 = local_48 != (char *)0x0;
          if (local_84) {
            local_20 = CONCAT31(local_20._1_3_,(char)local_3c[0]);
          }
          local_48 = FUN_0040f668(param_2,"temps_period",local_3c);
          if (local_48 != (char *)0x0) {
            local_20._0_2_ =
                 CONCAT11(local_20._1_1_ | (byte)((local_3c[0] & 0xf) << 4),(undefined1)local_20);
          }
          local_84 = local_48 != (char *)0x0 || local_84;
          local_48 = FUN_0040f668(param_2,"temps_hysteresis",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_20._0_2_ = CONCAT11(local_20._1_1_ | (byte)local_3c[0] & 0xf,(undefined1)local_20)
            ;
          }
          local_48 = FUN_0040f668(param_2,"tempoffset",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_20._0_3_ = CONCAT12((char)local_3c[0],(undefined2)local_20);
          }
          local_48 = FUN_0040f668(param_2,"tempsense_slope",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_20 = CONCAT13((char)local_3c[0],(undefined3)local_20);
          }
          local_48 = FUN_0040f668(param_2,"tempcorrx",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_1c = CONCAT11(local_1c._1_1_,(byte)local_1c | (byte)((local_3c[0] & 0x3f) << 2));
          }
          local_48 = FUN_0040f668(param_2,"tempsense_option",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_1c = CONCAT11(local_1c._1_1_,(byte)local_1c | (byte)local_3c[0] & 3);
          }
          local_48 = FUN_0040f668(param_2,"phycal_tempdelta",local_3c);
          if (local_48 != (char *)0x0) {
            local_84 = true;
            local_1c = CONCAT11((char)local_3c[0],(byte)local_1c);
          }
          if (local_84) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            puVar8 = (undefined4 *)(param_1 + local_40);
            *puVar8 = local_20;
            *(byte *)(puVar8 + 1) = (byte)local_1c;
            *(undefined1 *)((int)puVar8 + 5) = local_1c._1_1_;
            local_40 = local_40 + 6;
          }
        }
        else if (*local_b0 == 'X') {
          local_82 = 0;
          local_80 = 0;
          local_48 = FUN_0040f668(param_2,"femctrl",local_3c);
          local_83 = local_48 != (char *)0x0;
          if (local_83) {
            local_82 = (ushort)((local_3c[0] & 0x1f) << 0xb);
          }
          local_48 = FUN_0040f668(param_2,"papdcap2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_82 = (ushort)((local_3c[0] & 1) << 10) | local_82;
          }
          local_83 = local_48 != (char *)0x0 || local_83;
          local_48 = FUN_0040f668(param_2,"tworangetssi2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_82 = (ushort)((local_3c[0] & 1) << 9) | local_82;
          }
          local_48 = FUN_0040f668(param_2,"pdgain2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_82 = (ushort)((local_3c[0] & 0x1f) << 4) | local_82;
          }
          local_48 = FUN_0040f668(param_2,"epagain2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_82 = (ushort)((local_3c[0] & 7) << 1) | local_82;
          }
          local_48 = FUN_0040f668(param_2,"tssiposslope2g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_82 = (ushort)local_3c[0] & 1 | local_82;
          }
          local_48 = FUN_0040f668(param_2,"gainctrlsph",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)((local_3c[0] & 0x1f) << 0xb);
          }
          local_48 = FUN_0040f668(param_2,"papdcap5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)((local_3c[0] & 1) << 10) | local_80;
          }
          local_48 = FUN_0040f668(param_2,"tworangetssi5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)((local_3c[0] & 1) << 9) | local_80;
          }
          local_48 = FUN_0040f668(param_2,"pdgain5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)((local_3c[0] & 0x1f) << 4) | local_80;
          }
          local_48 = FUN_0040f668(param_2,"epagain5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)((local_3c[0] & 7) << 1) | local_80;
          }
          local_48 = FUN_0040f668(param_2,"tssiposslope5g",local_3c);
          if (local_48 != (char *)0x0) {
            local_83 = true;
            local_80 = (ushort)local_3c[0] & 1 | local_80;
          }
          if (local_83) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_82;
            *(char *)(param_1 + local_40 + 1) = (char)(local_82 >> 8);
            *(char *)(param_1 + local_40 + 2) = (char)local_80;
            *(char *)(param_1 + local_40 + 3) = (char)(local_80 >> 8);
            local_40 = local_40 + 4;
          }
        }
        else if (*local_b0 == 'g') {
          local_7c = 0;
          local_7a = 0;
          local_48 = FUN_0040f668(param_2,"rxgains5gtrelnabypa0",local_3c);
          local_7e = local_48 != (char *)0x0;
          if (local_7e) {
            local_7c = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gtrisoa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7c = (ushort)((local_3c[0] & 0xf) << 0xb) | local_7c;
          }
          local_7e = local_48 != (char *)0x0 || local_7e;
          local_48 = FUN_0040f668(param_2,"rxgains5gelnagaina0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7c = (ushort)((local_3c[0] & 7) << 8) | local_7c;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrelnabypa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7c = (ushort)((local_3c[0] & 1) << 7) | local_7c;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrisoa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7c = (ushort)((local_3c[0] & 0xf) << 3) | local_7c;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gelnagaina0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7c = (ushort)local_3c[0] & 7 | local_7c;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrelnabypa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrisoa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)((local_3c[0] & 0xf) << 0xb) | local_7a;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghelnagaina0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)((local_3c[0] & 7) << 8) | local_7a;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrelnabypa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)((local_3c[0] & 1) << 7) | local_7a;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrisoa0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)((local_3c[0] & 0xf) << 3) | local_7a;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmelnagaina0",local_3c);
          if (local_48 != (char *)0x0) {
            local_7e = true;
            local_7a = (ushort)local_3c[0] & 7 | local_7a;
          }
          if (local_7e) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_7c;
            *(char *)(param_1 + local_40 + 1) = (char)(local_7c >> 8);
            *(char *)(param_1 + local_40 + 2) = (char)local_7a;
            *(char *)(param_1 + local_40 + 3) = (char)(local_7a >> 8);
            local_40 = local_40 + 4;
          }
        }
        else if (*local_b0 == 'h') {
          local_76 = 0;
          local_74 = 0;
          local_48 = FUN_0040f668(param_2,"rxgains5gtrelnabypa1",local_3c);
          local_78 = local_48 != (char *)0x0;
          if (local_78) {
            local_76 = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gtrisoa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_76 = (ushort)((local_3c[0] & 0xf) << 0xb) | local_76;
          }
          local_78 = local_48 != (char *)0x0 || local_78;
          local_48 = FUN_0040f668(param_2,"rxgains5gelnagaina1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_76 = (ushort)((local_3c[0] & 7) << 8) | local_76;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrelnabypa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_76 = (ushort)((local_3c[0] & 1) << 7) | local_76;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrisoa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_76 = (ushort)((local_3c[0] & 0xf) << 3) | local_76;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gelnagaina1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_76 = (ushort)local_3c[0] & 7 | local_76;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrelnabypa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrisoa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)((local_3c[0] & 0xf) << 0xb) | local_74;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghelnagaina1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)((local_3c[0] & 7) << 8) | local_74;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrelnabypa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)((local_3c[0] & 1) << 7) | local_74;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrisoa1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)((local_3c[0] & 0xf) << 3) | local_74;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmelnagaina1",local_3c);
          if (local_48 != (char *)0x0) {
            local_78 = true;
            local_74 = (ushort)local_3c[0] & 7 | local_74;
          }
          if (local_78) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_76;
            *(char *)(param_1 + local_40 + 1) = (char)(local_76 >> 8);
            *(char *)(param_1 + local_40 + 2) = (char)local_74;
            *(char *)(param_1 + local_40 + 3) = (char)(local_74 >> 8);
            local_40 = local_40 + 4;
          }
        }
        else if (*local_b0 == 'i') {
          local_70 = 0;
          local_6e = 0;
          local_48 = FUN_0040f668(param_2,"rxgains5gtrelnabypa2",local_3c);
          local_72 = local_48 != (char *)0x0;
          if (local_72) {
            local_70 = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gtrisoa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_70 = (ushort)((local_3c[0] & 0xf) << 0xb) | local_70;
          }
          local_72 = local_48 != (char *)0x0 || local_72;
          local_48 = FUN_0040f668(param_2,"rxgains5gelnagaina2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_70 = (ushort)((local_3c[0] & 7) << 8) | local_70;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrelnabypa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_70 = (ushort)((local_3c[0] & 1) << 7) | local_70;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gtrisoa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_70 = (ushort)((local_3c[0] & 0xf) << 3) | local_70;
          }
          local_48 = FUN_0040f668(param_2,"rxgains2gelnagaina2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_70 = (ushort)local_3c[0] & 7 | local_70;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrelnabypa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)((local_3c[0] & 1) << 0xf);
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghtrisoa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)((local_3c[0] & 0xf) << 0xb) | local_6e;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5ghelnagaina2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)((local_3c[0] & 7) << 8) | local_6e;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrelnabypa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)((local_3c[0] & 1) << 7) | local_6e;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmtrisoa2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)((local_3c[0] & 0xf) << 3) | local_6e;
          }
          local_48 = FUN_0040f668(param_2,"rxgains5gmelnagaina2",local_3c);
          if (local_48 != (char *)0x0) {
            local_72 = true;
            local_6e = (ushort)local_3c[0] & 7 | local_6e;
          }
          if (local_72) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_70;
            *(char *)(param_1 + local_40 + 1) = (char)(local_70 >> 8);
            *(char *)(param_1 + local_40 + 2) = (char)local_6e;
            *(char *)(param_1 + local_40 + 3) = (char)(local_6e >> 8);
            local_40 = local_40 + 4;
          }
        }
        else if (*local_b0 == 'l') {
          local_6a = 0;
          local_48 = FUN_0040f668(param_2,"pdoffset2g40ma0",local_3c);
          local_6c = local_48 != (char *)0x0;
          if (local_6c) {
            local_6a = (ushort)local_3c[0] & 0xf;
          }
          local_48 = FUN_0040f668(param_2,"pdoffset2g40ma1",local_3c);
          if (local_48 != (char *)0x0) {
            local_6a = (ushort)((local_3c[0] & 0xf) << 4) | local_6a;
          }
          local_6c = local_48 != (char *)0x0 || local_6c;
          local_48 = FUN_0040f668(param_2,"pdoffset2g40ma2",local_3c);
          if (local_48 != (char *)0x0) {
            local_6c = true;
            local_6a = (ushort)((local_3c[0] & 0xf) << 8) | local_6a;
          }
          local_48 = FUN_0040f668(param_2,"pdoffset2g40mvalid",local_3c);
          if (local_48 != (char *)0x0) {
            local_6c = true;
            local_6a = (ushort)((local_3c[0] & 1) << 0xf) | local_6a;
          }
          if (local_6c) {
            FUN_0040f9bc((undefined1 *)(param_1 + local_40),&local_40,0x80,local_b0);
            *(char *)(param_1 + local_40) = (char)local_6a;
            *(char *)(param_1 + local_40 + 1) = (char)(local_6a >> 8);
            local_40 = local_40 + 2;
          }
        }
        else {
          bVar3 = false;
          local_64 = (undefined1 *)(param_1 + local_40);
          bVar4 = true;
          sVar7 = strlen(*(char **)(local_b0 + 0xc));
          pcVar6 = (char *)malloc(sVar7 + 1);
          if (pcVar6 == (char *)0x0) {
            return -0x1b;
          }
          strcpy(pcVar6,*(char **)(local_b0 + 0xc));
          local_ac = strtok(pcVar6,local_44);
          while (local_ac != (char *)0x0) {
            local_5c = 1;
            local_3c[0] = 0;
            if (bVar4) {
              FUN_0040f9bc(local_64,(int *)0x0,0x80,local_b0);
              local_64 = local_64 + 3;
              bVar4 = false;
            }
            cVar1 = *local_ac;
            local_ac = local_ac + 1;
            if (*local_ac == '*') {
              local_5c = 0;
              while ((local_ac = local_ac + 1, '/' < *local_ac && (*local_ac < ':'))) {
                local_5c = local_5c * 10 + (int)*local_ac + -0x30;
              }
            }
            local_48 = FUN_0040f668(param_2,local_ac,local_3c);
            if (local_48 == (char *)0x0) {
              local_3c[0] = 0;
            }
            else {
              bVar3 = true;
            }
            while ((bVar3 && (bVar2 = local_5c != 0, local_5c = local_5c + -1, bVar2))) {
              *local_64 = (char)local_3c[0];
              puVar10 = local_64 + 1;
              if (1 < cVar1 + -0x30) {
                local_64[1] = (char)(local_3c[0] >> 8);
                puVar10 = local_64 + 2;
              }
              local_64 = puVar10;
              if (3 < cVar1 + -0x30) {
                *local_64 = (char)(local_3c[0] >> 0x10);
                local_64[1] = (char)(local_3c[0] >> 0x18);
                local_64 = local_64 + 2;
              }
              if ((local_48 != (char *)0x0) && (local_5c != 0)) {
                local_18[0] = (char *)0x0;
                local_48 = strchr(local_48,0x2c);
                if (local_48 == (char *)0x0) {
                  printf("Input array size error!");
                  free(pcVar6);
                  return -2;
                }
                __s1 = local_48 + 1;
                local_48 = __s1;
                iVar9 = strncmp(__s1,"0x",2);
                if (iVar9 == 0) {
                  iVar9 = 0x10;
                }
                else {
                  iVar9 = 10;
                }
                local_3c[0] = strtoul(__s1,local_18,iVar9);
              }
            }
            local_ac = strtok((char *)0x0,local_44);
          }
          free(pcVar6);
          if (bVar3) {
            local_40 = (int)local_64 - param_1;
          }
        }
        local_b0 = local_b0 + 0x10;
      }
    }
    printf("sromrev %d buffer size %d bytes:\n",param_3,local_40);
    for (local_a8 = 0; local_a8 < local_40; local_a8 = local_a8 + 1) {
      printf("0x%.02x ",(uint)*(byte *)(param_1 + local_a8));
      if (local_a8 % 8 == 7) {
        putchar(10);
      }
    }
    putchar(10);
  }
  return local_40;
}



int * FUN_004129f8(int *param_1,char *param_2,size_t param_3,uint param_4)

{
  uint uVar1;
  int iVar2;
  uint local_18;
  int *local_14;
  
  uVar1 = 1 << (param_4 & 0x1f);
  local_18 = uVar1;
  local_14 = param_1;
  if (param_4 == 0xc) {
    local_18 = 0x1800;
  }
  for (; (*local_14 != 0 &&
         (((iVar2 = strncmp(param_2,(char *)*local_14,param_3), iVar2 != 0 ||
           ((local_14[1] & local_18) == 0)) ||
          ((param_4 == 0xc && ((local_14[1] & local_18) != uVar1)))))); local_14 = local_14 + 4) {
    for (; (local_14[2] & 1U) != 0; local_14 = local_14 + 4) {
    }
  }
  return local_14;
}



int FUN_00412b54(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_00444b10(param_1,param_2,param_3);
  if (iVar1 == 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = *(uint *)PTR_DAT_00551644;
    }
    else {
      uVar2 = *(uint *)PTR_DAT_00551644;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    if (uVar2 == 1) {
      puts((char *)&PTR_s__0050fa9c);
    }
    else if (uVar2 == 2) {
      puts("NVRAM");
    }
    else if (uVar2 == 0) {
      puts("SROM");
    }
    else {
      printf("Unrecognized source %d\n",uVar2);
    }
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00412cb0(int *param_1,int param_2,undefined4 *param_3)

{
  ushort uVar1;
  bool bVar2;
  undefined *puVar3;
  undefined *puVar4;
  bool bVar5;
  int iVar6;
  int iVar7;
  size_t sVar8;
  int iVar9;
  char *pcVar10;
  ulong uVar11;
  char *pcVar12;
  undefined3 extraout_var;
  uint uVar13;
  undefined4 uVar14;
  uint uVar15;
  int *local_res8;
  int local_98;
  uint local_94;
  uint local_8c;
  uint local_84;
  char *local_80;
  int *local_7c;
  int local_78;
  uint local_74;
  char *local_24;
  undefined1 local_20;
  undefined1 local_1f;
  undefined1 local_1e;
  undefined1 local_1d;
  undefined1 local_1c;
  undefined1 local_1b;
  char *local_18;
  char *local_14 [2];
  
  puVar3 = PTR_DAT_00551644;
  local_84 = 0;
  iVar6 = strcmp((char *)*param_3,"rdvar");
  bVar2 = iVar6 == 0;
  iVar6 = strcmp((char *)*param_3,"wrvar");
  iVar7 = strcmp((char *)*param_3,"cisconvert");
  local_res8 = param_3 + 1;
  if (*local_res8 == 0) {
    return -0x2c;
  }
  memset(PTR_DAT_00551644,0,0x2000);
  puVar4 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f736963;
  pcVar10 = puVar4 + 4;
  pcVar10[0] = 's';
  pcVar10[1] = 'o';
  pcVar10[2] = 'u';
  pcVar10[3] = 'r';
  puVar4[8] = 'c';
  puVar4[9] = 'e';
  puVar4[10] = '\0';
  puVar4 = PTR_DAT_00551644;
  sVar8 = strlen(PTR_DAT_00551644);
  iVar9 = FUN_004bab9c(param_1,0x106,puVar4,sVar8 + 1);
  puVar4 = PTR_DAT_00551644;
  if ((*PTR_DAT_00551644 == '\x02') && (bVar2)) {
    FUN_00445fb0(param_1,param_2,(int)param_3);
    return iVar9;
  }
  if (((*PTR_DAT_00551644 == '\x02') && (iVar6 == 0)) || (iVar7 == 0)) {
    local_18 = (char *)0x0;
    local_78 = FUN_00445198(param_1,"nvram_dump",(void *)0x0,0,&local_18);
    if (local_78 < 0) {
      local_78 = FUN_004b9f94(param_1,0x10a,PTR_DAT_00551644,0x2000);
    }
    if (local_78 != 0) {
      puts("Fail to get sromrev from nvram file!");
      return local_78;
    }
    local_18 = strstr(local_18,"sromrev");
    if (local_18 == (char *)0x0) {
      puts("sromrev not defined in nvram file!");
      return -1;
    }
    local_14[0] = (char *)0x0;
    pcVar10 = local_18 + 8;
    local_18 = pcVar10;
    iVar6 = strncmp(pcVar10,"0x",2);
    if (iVar6 == 0) {
      iVar6 = 0x10;
    }
    else {
      iVar6 = 10;
    }
    uVar11 = strtoul(pcVar10,local_14,iVar6);
    sVar8 = FUN_0040fa78((int)PTR_DAT_00551644,local_res8,uVar11);
    if (0 < (int)sVar8) {
      if (iVar7 == 0) {
        return iVar9;
      }
      iVar6 = FUN_004ba2e4(param_1,"cisvar",PTR_DAT_00551644,sVar8);
      return iVar6;
    }
    puts("CIS parse failure!");
    return -1;
  }
  *(undefined4 *)PTR_DAT_00551644 = 0;
  if (DAT_00557704 == '\0') {
    uVar14 = 0x1b8;
  }
  else {
    uVar14 = 0xb8010000;
  }
  *(undefined4 *)(puVar4 + 4) = uVar14;
  if (*(int *)(param_2 + 8) < 0) {
    return -1;
  }
  local_98 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
  if (local_98 < 0) {
    return local_98;
  }
  if (*(short *)(puVar3 + 0x88) == 0x634) {
    local_8c = 0xb;
    *(undefined4 *)puVar4 = 0;
    if (DAT_00557704 == '\0') {
      uVar14 = 0x1d4;
    }
    else {
      uVar14 = 0xd4010000;
    }
    *(undefined4 *)(puVar4 + 4) = uVar14;
    local_98 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
  }
  else {
    if (*(short *)(puVar3 + 0x88) != -0x7778) {
      if ((*(short *)(puVar3 + 0x48) == 0x5372) || (*(short *)(puVar3 + 0x88) == 0x5372)) {
        local_94 = 0xdb;
      }
      else {
        local_94 = 0x3f;
      }
      local_8c = *(ushort *)(puVar3 + local_94 * 2 + 8) & 0xff;
      goto LAB_00413464;
    }
    local_8c = 0xc;
    *(undefined4 *)puVar4 = 0;
    if (DAT_00557704 == '\0') {
      uVar14 = 0x400;
    }
    else {
      uVar14 = 0x40000;
    }
    *(undefined4 *)(puVar4 + 4) = uVar14;
    local_98 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
  }
  if (local_98 < 0) {
    return local_98;
  }
LAB_00413464:
  if ((local_8c < 2) || (0xc < local_8c)) {
    return -1;
  }
  local_94 = 0;
LAB_00413f14:
  do {
    pcVar10 = (char *)*local_res8;
    local_res8 = local_res8 + 1;
    if (pcVar10 == (char *)0x0) {
LAB_00413f40:
      if (bVar2) {
        return local_98;
      }
      iVar6 = local_94 + 1;
      *(undefined4 *)puVar4 = 0;
      if (DAT_00557704 == '\0') {
        uVar15 = iVar6 * 2;
      }
      else {
        uVar15 = iVar6 * 0x2000000 | (iVar6 * 2 & 0xff00U) << 8 | (iVar6 * 2 & 0xff0000U) >> 8;
      }
      *(uint *)(puVar4 + 4) = uVar15;
      iVar6 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),PTR_DAT_00551644,(local_94 + 5) * 2);
      if (-1 < iVar6) {
        return iVar6;
      }
      printf("Error %d writing the srom\n",iVar6);
      return iVar6;
    }
    local_80 = strchr(pcVar10,0x3d);
    if (local_80 != (char *)0x0) {
      *local_80 = '\0';
      local_80 = local_80 + 1;
    }
    sVar8 = strlen(pcVar10);
    if ((sVar8 == 0) || (0x10 < (int)sVar8)) {
      printf("Bad variable name: %s\n",pcVar10);
      goto LAB_00413f14;
    }
    local_74 = 0;
    local_7c = FUN_004129f8((int *)&PTR_s_devid_004e5d00,pcVar10,sVar8 + 1,local_8c);
    if (*local_7c == 0) {
      local_7c = FUN_004129f8((int *)&PTR_s_maxp2ga_004e905c,pcVar10,sVar8 - 1,local_8c);
      iVar6 = (int)pcVar10[sVar8 - 1];
      iVar7 = iVar6 + -0x30;
      if (((*local_7c != 0) && (-1 < iVar7)) && (iVar7 < 4)) {
        if (local_8c == 0xc) {
          if (iVar6 == 0x30) {
            local_74 = 0x100;
          }
          else if (iVar7 == 1) {
            local_74 = 0x148;
          }
          else if (iVar7 == 2) {
            local_74 = 400;
          }
        }
        else if (local_8c == 0xb) {
          if (iVar6 == 0x30) {
            local_74 = 0x6c;
          }
          else if (iVar7 == 1) {
            local_74 = 0x80;
          }
          else if (iVar7 == 2) {
            local_74 = 0x94;
          }
        }
        else if (local_8c < 8) {
          if (iVar6 == 0x30) {
            local_74 = 0x40;
          }
          else {
            local_74 = 0x57;
          }
        }
        else if (iVar6 == 0x30) {
          local_74 = 0x60;
        }
        else if (iVar7 == 1) {
          local_74 = 0x70;
        }
        else if (iVar7 == 2) {
          local_74 = 0x80;
        }
        else if (iVar7 == 3) {
          local_74 = 0x90;
        }
        goto LAB_00413768;
      }
      printf("Variable %s does not exist in sromrev %d\n",pcVar10,local_8c);
    }
    else {
LAB_00413768:
      uVar15 = local_74 + *(ushort *)(local_7c + 3);
      if (bVar2) {
        if ((local_7c[2] & 0x20U) == 0) {
          if ((local_7c[2] & 1U) == 0) {
            iVar6 = ffs((uint)*(ushort *)((int)local_7c + 0xe));
            local_84 = (int)(uint)(*(ushort *)(puVar3 + uVar15 * 2 + 8) &
                                  *(ushort *)((int)local_7c + 0xe)) >> (iVar6 - 1U & 0x1f);
          }
          else {
            local_84 = CONCAT22(*(undefined2 *)(puVar3 + (uint)*(ushort *)(local_7c + 7) * 2 + 8),
                                *(undefined2 *)(puVar3 + uVar15 * 2 + 8));
          }
        }
        else {
          local_20 = (undefined1)((ushort)*(undefined2 *)(puVar3 + uVar15 * 2 + 8) >> 8);
          local_1f = (undefined1)*(undefined2 *)(puVar3 + uVar15 * 2 + 8);
          local_1e = (undefined1)((ushort)*(undefined2 *)(puVar3 + (uVar15 + 1) * 2 + 8) >> 8);
          local_1d = (undefined1)*(undefined2 *)(puVar3 + (uVar15 + 1) * 2 + 8);
          local_1c = (undefined1)((ushort)*(undefined2 *)(puVar3 + (uVar15 + 2) * 2 + 8) >> 8);
          local_1b = (undefined1)*(undefined2 *)(puVar3 + (uVar15 + 2) * 2 + 8);
        }
        if ((local_7c[2] & 0x20U) == 0) {
          if ((local_7c[2] & 4U) == 0) {
            if ((local_7c[2] & 8U) == 0) {
              printf("%s=%u",pcVar10,local_84);
            }
            else {
              printf("%s=%d",pcVar10,local_84);
            }
          }
          else {
            printf("%s=0x%x",pcVar10,local_84);
          }
        }
        else {
          pcVar12 = FUN_0041d780((int)&local_20);
          printf("%s=%s",pcVar10,pcVar12);
        }
        uVar15 = local_7c[2];
        while ((uVar15 & 0x100) != 0) {
          uVar1 = *(ushort *)(local_7c + 7);
          if (local_7c[4] == 0) break;
          iVar6 = ffs((uint)*(ushort *)((int)local_7c + 0x1e));
          local_84 = (int)(uint)(*(ushort *)(puVar3 + (uVar1 + local_74) * 2 + 8) &
                                *(ushort *)((int)local_7c + 0x1e)) >> (iVar6 - 1U & 0x1f);
          if ((local_7c[6] & 4U) == 0) {
            if ((local_7c[6] & 8U) == 0) {
              printf(",%u",local_84);
            }
            else {
              printf(",%d",local_84);
            }
          }
          else {
            printf(",0x%x",local_84);
          }
          uVar15 = local_7c[6];
          local_7c = local_7c + 4;
        }
        putchar(10);
      }
      else {
        if (local_80 == (char *)0x0) {
          printf("wrvar missing value to write for variable %s\n",pcVar10);
          bVar2 = true;
          goto LAB_00413f40;
        }
        if ((local_7c[2] & 0x20U) == 0) {
          local_84 = strtoul(local_80,&local_24,0);
          if (local_24 == local_80) {
            printf("Bad value: %s for variable %s\n",local_80,pcVar10);
            bVar2 = true;
            goto LAB_00413f40;
          }
          if ((local_7c[2] & 1U) == 0) {
            iVar6 = ffs((uint)*(ushort *)((int)local_7c + 0xe));
            *(ushort *)(puVar3 + uVar15 * 2 + 8) =
                 (ushort)(local_84 << (iVar6 - 1U & 0x1f)) & *(ushort *)((int)local_7c + 0xe) |
                 *(ushort *)(puVar3 + uVar15 * 2 + 8) & ~*(ushort *)((int)local_7c + 0xe);
            uVar13 = local_7c[2];
            while ((uVar13 & 0x100) != 0) {
              uVar15 = *(ushort *)(local_7c + 7) + local_74;
              if (local_7c[4] == 0) break;
              pcVar12 = local_24 + 1;
              local_84 = strtoul(pcVar12,&local_24,0);
              if (local_24 == pcVar12) {
                printf("Bad value: %s for variable %s\n",pcVar12,pcVar10);
                bVar2 = true;
                break;
              }
              iVar6 = ffs((uint)*(ushort *)((int)local_7c + 0x1e));
              *(ushort *)(puVar3 + uVar15 * 2 + 8) =
                   (ushort)(local_84 << (iVar6 - 1U & 0x1f)) & *(ushort *)((int)local_7c + 0x1e) |
                   *(ushort *)(puVar3 + uVar15 * 2 + 8) & ~*(ushort *)((int)local_7c + 0x1e);
              uVar13 = local_7c[6];
              local_7c = local_7c + 4;
            }
          }
          else {
            *(short *)(puVar3 + uVar15 * 2 + 8) = (short)local_84;
            *(short *)(puVar3 + (uVar15 + 1) * 2 + 8) = (short)(local_84 >> 0x10);
            uVar15 = uVar15 + 1;
          }
        }
        else {
          bVar5 = FUN_0041d6ac(local_80,&local_20);
          if (CONCAT31(extraout_var,bVar5) == 0) {
            printf("Argument does not look like a MAC address: %s\n",local_80);
            local_98 = -0x2c;
            bVar2 = true;
            goto LAB_00413f40;
          }
          *(ushort *)(puVar3 + uVar15 * 2 + 8) = CONCAT11(local_20,local_1f);
          *(ushort *)(puVar3 + (uVar15 + 1) * 2 + 8) = CONCAT11(local_1e,local_1d);
          *(ushort *)(puVar3 + (uVar15 + 2) * 2 + 8) = CONCAT11(local_1c,local_1b);
          uVar15 = uVar15 + 2;
        }
        local_74 = uVar15;
        if (local_94 < local_74) {
          local_94 = local_74;
        }
      }
    }
  } while( true );
}



int FUN_00414040(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  uint *puVar3;
  int iVar4;
  uint uVar5;
  size_t sVar6;
  char *__nptr;
  int *local_res8;
  int local_c0;
  ulong local_bc;
  ulong local_b8;
  uint local_b0;
  uint local_ac;
  uint local_a8;
  uint local_a4;
  uint local_a0;
  char *local_98;
  char *local_94;
  uint local_60;
  char *local_5c;
  uint *local_58;
  uint local_54;
  uint local_50;
  char local_4c [68];
  
  local_bc = 0;
  local_b0 = 0;
  local_60 = 0;
  local_ac = 0;
  local_a8 = 0;
  local_a4 = 0;
  local_a0 = 0;
  bVar2 = true;
  local_5c = (char *)0x0;
  local_58 = (uint *)0x0;
  iVar4 = FUN_0044527c(param_1,"msglevel",&local_54,8,&local_58);
  puVar3 = local_58;
  if (iVar4 < 0) {
    iVar4 = FUN_004b9f94(param_1,7,(char *)&local_60,4);
    if (-1 < iVar4) {
      bVar2 = false;
      if (DAT_00557704 != '\0') {
        local_60 = local_60 << 0x18 | (local_60 & 0xff00) << 8 | (local_60 & 0xff0000) >> 8 |
                   local_60 >> 0x18;
      }
      local_res8 = (int *)(param_3 + 4);
      if (*local_res8 == 0) {
        printf("0x%x ",local_60);
        for (local_c0 = 0; uVar5 = *(uint *)(&DAT_00555b4c + local_c0 * 8), uVar5 != 0;
            local_c0 = local_c0 + 1) {
          if (((local_60 & uVar5) != 0) && (uVar5 != local_b0)) {
            printf(" %s",(&PTR_s_error_00555b50)[local_c0 * 2]);
          }
          local_b0 = uVar5;
        }
        putchar(10);
        iVar4 = 0;
      }
      else {
        for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
          local_98 = (char *)*local_res8;
          if ((*local_98 == '+') || (*local_98 == '-')) {
            local_98 = local_98 + 1;
          }
          else {
            local_a0 = 0xffffffff;
          }
          local_b8 = strtoul(local_98,&local_5c,0);
          if (local_b8 == 0xffffffff) {
            fwrite("Bits >32 are not supported on this driver version\n",1,0x32,stderr);
            local_b8 = 1;
          }
          if (*local_5c != '\0') {
            local_c0 = 0;
            while ((local_b8 = *(ulong *)(&DAT_00555b4c + local_c0 * 8), local_b8 != 0 &&
                   (iVar4 = strcasecmp((&PTR_s_error_00555b50)[local_c0 * 2],local_98), iVar4 != 0))
                  ) {
              if (local_b8 == 0) goto LAB_00414c74;
              local_c0 = local_c0 + 1;
            }
          }
          if (*(char *)*local_res8 == '-') {
            local_a0 = local_a0 | local_b8;
          }
          else {
            local_a4 = local_a4 | local_b8;
          }
        }
        local_60 = ~local_a0 & local_60 | local_a4;
        if (DAT_00557704 != '\0') {
          local_60 = local_60 << 0x18 | (local_60 & 0xff00) << 8 | (local_60 & 0xff0000) >> 8 |
                     local_60 >> 0x18;
        }
        iVar4 = FUN_004ba050(param_1,8,(char *)&local_60,4);
      }
    }
  }
  else {
    if (DAT_00557704 == '\0') {
      uVar5 = *local_58;
    }
    else {
      uVar5 = *local_58;
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    *local_58 = uVar5;
    if (DAT_00557704 == '\0') {
      uVar5 = local_58[1];
    }
    else {
      uVar5 = local_58[1];
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    local_58[1] = uVar5;
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      if (local_58[1] == 0) {
        printf("0x%x ",*local_58);
      }
      else {
        printf("0x%x%08x",local_58[1],*local_58);
      }
      for (local_c0 = 0; uVar5 = *(uint *)(&DAT_00555c5c + local_c0 * 8), uVar5 != 0;
          local_c0 = local_c0 + 1) {
        if (((puVar3[1] & uVar5) != 0) && (uVar5 != local_b0)) {
          printf(" %s",(&PTR_DAT_00555c60)[local_c0 * 2]);
        }
        local_b0 = uVar5;
      }
      local_b0 = 0;
      for (local_c0 = 0; uVar5 = *(uint *)(&DAT_00555b4c + local_c0 * 8), uVar5 != 0;
          local_c0 = local_c0 + 1) {
        if (((*puVar3 & uVar5) != 0) && (uVar5 != local_b0)) {
          printf(" %s",(&PTR_s_error_00555b50)[local_c0 * 2]);
        }
        local_b0 = uVar5;
      }
      putchar(10);
      iVar4 = 0;
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_94 = (char *)*local_res8;
        bVar1 = false;
        if ((*local_94 == '+') || (*local_94 == '-')) {
          local_94 = local_94 + 1;
        }
        else {
          local_a0 = 0xffffffff;
          local_a8 = 0xffffffff;
        }
        local_b8 = strtoul(local_94,&local_5c,0);
        if (local_b8 == 0xffffffff) {
          if ((*local_94 == '0') && (local_94[1] == 'x')) {
            local_4c[0] = '0';
            local_4c[1] = 'x';
            local_4c[2] = '\0';
            local_4c[3] = '\0';
            local_4c[4] = '\0';
            local_4c[5] = '\0';
            local_4c[6] = '\0';
            local_4c[7] = '\0';
            local_4c[8] = '\0';
            local_4c[9] = '\0';
            local_4c[10] = '\0';
            local_4c[0xb] = '\0';
            local_4c[0xc] = '\0';
            local_4c[0xd] = '\0';
            local_4c[0xe] = '\0';
            local_4c[0xf] = '\0';
            local_4c[0x10] = '\0';
            local_4c[0x11] = '\0';
            local_4c[0x12] = '\0';
            local_4c[0x13] = '\0';
            local_4c[0x14] = '\0';
            local_4c[0x15] = '\0';
            local_4c[0x16] = '\0';
            local_4c[0x17] = '\0';
            local_4c[0x18] = '\0';
            local_4c[0x19] = '\0';
            local_4c[0x1a] = '\0';
            local_4c[0x1b] = '\0';
            local_4c[0x1c] = '\0';
            local_4c[0x1d] = '\0';
            local_4c[0x1e] = '\0';
            local_4c[0x1f] = '\0';
            sVar6 = strlen(local_94);
            __nptr = strncpy(local_4c + 0x20,local_94,sVar6 - 8);
            local_bc = strtoul(__nptr,&local_5c,0);
            *local_5c = '\0';
            sVar6 = strlen(local_4c + 0x20);
            local_94 = strcat(local_4c,local_94 + sVar6);
            local_b8 = strtoul(local_94,&local_5c,0);
            if (local_bc == 0xffffffff) {
              fwrite("Invalid entry for msglevel\n",1,0x1b,stderr);
              local_bc = 0;
              local_b8 = 0;
            }
          }
          else {
            fwrite("Msg bits >32 take only numerical input in hex\n",1,0x2e,stderr);
            local_b8 = 0;
          }
        }
        if (*local_5c != '\0') {
          for (local_c0 = 0; local_b8 = *(ulong *)(&DAT_00555b4c + local_c0 * 8), local_b8 != 0;
              local_c0 = local_c0 + 1) {
            iVar4 = strcasecmp((&PTR_s_error_00555b50)[local_c0 * 2],local_94);
            if (iVar4 == 0) {
              bVar1 = true;
              break;
            }
          }
          if (!bVar1) {
            local_c0 = 0;
            while ((local_bc = *(ulong *)(&DAT_00555c5c + local_c0 * 8), local_bc != 0 &&
                   (iVar4 = strcasecmp((&PTR_DAT_00555c60)[local_c0 * 2],local_94), iVar4 != 0))) {
              local_c0 = local_c0 + 1;
            }
          }
          if ((local_b8 == 0) && (local_bc == 0)) {
LAB_00414c74:
            fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45,
                   stderr);
            fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
            for (local_c0 = 0; uVar5 = *(uint *)(&DAT_00555b4c + local_c0 * 8), uVar5 != 0;
                local_c0 = local_c0 + 1) {
              if (uVar5 == local_b0) {
                fprintf(stderr,", %s",(&PTR_s_error_00555b50)[local_c0 * 2]);
              }
              else {
                fprintf(stderr,"\n0x%04x %s",uVar5,(&PTR_s_error_00555b50)[local_c0 * 2]);
              }
              local_b0 = uVar5;
            }
            if (bVar2) {
              for (local_c0 = 0; uVar5 = *(uint *)(&DAT_00555c5c + local_c0 * 8), uVar5 != 0;
                  local_c0 = local_c0 + 1) {
                if (uVar5 == local_b0) {
                  fprintf(stderr,", %s",(&PTR_DAT_00555c60)[local_c0 * 2]);
                }
                else {
                  fprintf(stderr,"\n0x%x00000000 %s",uVar5,(&PTR_DAT_00555c60)[local_c0 * 2]);
                }
                local_b0 = uVar5;
              }
            }
            fputc(10,stderr);
            return 0;
          }
        }
        if (*(char *)*local_res8 == '-') {
          local_a0 = local_a0 | local_b8;
          if (!bVar1) {
            local_a8 = local_a8 | local_bc;
          }
        }
        else {
          local_a4 = local_a4 | local_b8;
          if (!bVar1) {
            local_ac = local_ac | local_bc;
          }
        }
      }
      *puVar3 = *puVar3 & ~local_a0;
      puVar3[1] = puVar3[1] & ~local_a8;
      *puVar3 = *puVar3 | local_a4;
      puVar3[1] = puVar3[1] | local_ac;
      if (DAT_00557704 == '\0') {
        uVar5 = *puVar3;
      }
      else {
        uVar5 = *puVar3;
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      *puVar3 = uVar5;
      if (DAT_00557704 == '\0') {
        uVar5 = puVar3[1];
      }
      else {
        uVar5 = puVar3[1];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      puVar3[1] = uVar5;
      local_54 = *puVar3;
      local_50 = puVar3[1];
      iVar4 = FUN_00445444(param_1,"msglevel",&local_54,8);
    }
  }
  return iVar4;
}



int FUN_00414e8c(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int *local_res8;
  int local_40;
  ulong local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  char *local_2c;
  uint local_14;
  char *local_10 [2];
  
  local_38 = 0;
  local_14 = 0;
  local_34 = 0;
  local_30 = 0;
  iVar1 = FUN_004ba35c(param_1,"phymsglevel",&local_14);
  iVar1 = -(iVar1 >> 0x1f);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      printf("0x%x ",local_14);
      for (local_40 = 0; uVar2 = *(uint *)(&DAT_00555d3c + local_40 * 8), uVar2 != 0;
          local_40 = local_40 + 1) {
        if (((local_14 & uVar2) != 0) && (uVar2 != local_38)) {
          printf(" %s",(&PTR_s_error_00555d40)[local_40 * 2]);
        }
        local_38 = uVar2;
      }
      putchar(10);
      iVar1 = 0;
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_2c = (char *)*local_res8;
        if ((*local_2c == '+') || (*local_2c == '-')) {
          local_2c = local_2c + 1;
        }
        else {
          local_30 = 0xffffffff;
        }
        local_3c = strtoul(local_2c,local_10,0);
        if (local_3c == 0xffffffff) {
          fwrite("Bits >32 are not supported on this driver version\n",1,0x32,stderr);
          local_3c = 1;
        }
        if (*local_10[0] != '\0') {
          local_40 = 0;
          while ((local_3c = *(ulong *)(&DAT_00555d3c + local_40 * 8), local_3c != 0 &&
                 (iVar1 = strcasecmp((&PTR_s_error_00555d40)[local_40 * 2],local_2c), iVar1 != 0)))
          {
            if (local_3c == 0) {
              fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45
                     ,stderr);
              fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
              for (local_40 = 0; uVar2 = *(uint *)(&DAT_00555d3c + local_40 * 8), uVar2 != 0;
                  local_40 = local_40 + 1) {
                if (uVar2 == local_38) {
                  fprintf(stderr,", %s",(&PTR_s_error_00555d40)[local_40 * 2]);
                }
                else {
                  fprintf(stderr,"\n0x%04x %s",uVar2,(&PTR_s_error_00555d40)[local_40 * 2]);
                }
                local_38 = uVar2;
              }
              return 0;
            }
            local_40 = local_40 + 1;
          }
        }
        if (*(char *)*local_res8 == '-') {
          local_30 = local_30 | local_3c;
        }
        else {
          local_34 = local_34 | local_3c;
        }
      }
      local_14 = ~local_30 & local_14 | local_34;
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
      }
      iVar1 = FUN_004ba428(param_1,"phymsglevel",local_14);
    }
  }
  return iVar1;
}



uint FUN_004153c0(uint param_1,int param_2,int param_3,int param_4)

{
  uint uVar1;
  uint local_20;
  
  if (param_1 == 0x20) {
    if (param_4 == 0) {
      local_20 = 6000;
    }
    else {
      local_20 = 0x1a2c;
    }
  }
  else if (param_1 < 10) {
    if (param_3 == 0x14) {
      local_20 = 0x34;
    }
    else if (param_3 == 0x28) {
      local_20 = 0x6c;
    }
    else if (param_3 == 0x50) {
      local_20 = 0xea;
    }
    else if (param_3 == 0xa0) {
      local_20 = 0x1d4;
    }
    else {
      local_20 = 1;
    }
    uVar1 = ((uint)(byte)(&DAT_0050fe15)[param_1 * 3] *
            local_20 * (byte)(&DAT_0050fe14)[param_1 * 3] * param_2) /
            (uint)(byte)(&DAT_0050fe16)[param_1 * 3];
    if ((byte)(&DAT_0050fe16)[param_1 * 3] == 0) {
      trap(7);
    }
    local_20 = uVar1 * 0xfa;
    if (param_4 != 0) {
      local_20 = (uVar1 * 0x9c4 + 4) / 9;
    }
  }
  else {
    local_20 = 0;
  }
  return local_20;
}



uint FUN_004155dc(uint param_1)

{
  uint uVar1;
  uint param3;
  uint local_28;
  
  local_28 = 0xffffffff;
  uVar1 = (uint)((param_1 & 0x800000) != 0);
  if ((param_1 & 0x3000000) == 0) {
    local_28 = param_1 & 0xff;
  }
  else if ((param_1 & 0x3000000) == 0x1000000) {
    param3 = param_1 & 0xff;
    if (param3 < 0x21) {
      if (param3 == 0x20) {
        local_28 = FUN_004153c0(0x20,1,0x28,uVar1);
        local_28 = local_28 / 500;
      }
      else {
        local_28 = FUN_004153c0(param_1 & 7,(param3 >> 3) + 1,0x14,uVar1);
        local_28 = local_28 / 500;
      }
    }
    else {
      fprintf(stderr,"%s: MCS %u out of range (>32) in ratespec 0x%X\n","wl_ratespec2rate",param3,
              param_1);
    }
  }
  else if ((param_1 & 0x3000000) == 0x2000000) {
    local_28 = FUN_004153c0(param_1 & 0xf,(param_1 & 0xf0) >> 4,0x14,uVar1);
    local_28 = local_28 / 500;
  }
  else {
    fprintf(stderr,"%s: expected rate encoding in ratespec 0x%X\n","wl_ratespec2rate",param_1);
  }
  return local_28;
}



void FUN_00415800(uint param_1)

{
  char *__s;
  char acStack_28 [32];
  
  __s = FUN_004158d8(acStack_28,param_1);
  puts(__s);
  return;
}



int FUN_0041584c(char *param_1)

{
  int iVar1;
  
  iVar1 = strcasecmp(param_1,"-1");
  if (iVar1 == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = strcasecmp(param_1,"5.5");
    if (iVar1 == 0) {
      iVar1 = 0xb;
    }
    else {
      iVar1 = atoi(param_1);
      iVar1 = iVar1 << 1;
    }
  }
  return iVar1;
}



char * FUN_004158d8(char *param_1,uint param_2)

{
  char *param3;
  
  if ((param_2 == 0xffffffff) || (param_2 == 0)) {
    builtin_strncpy(param_1,"auto",5);
  }
  else {
    if ((param_2 & 1) == 0) {
      param3 = "";
    }
    else {
      param3 = ".5";
    }
    sprintf(param_1,"%d%s Mbps",(int)param_2 / 2,param3);
  }
  return param_1;
}



void FUN_004159a8(uint param_1)

{
  bool bVar1;
  uint uVar2;
  char *param2;
  char *local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  char *local_30;
  char *local_2c;
  char *local_28;
  char *local_24;
  char *local_20;
  uint local_1c;
  
  local_40 = "auto";
  local_34 = 0;
  local_30 = "";
  local_2c = "";
  local_28 = "";
  local_24 = "";
  local_20 = "";
  if (param_1 == 0) {
    local_3c = 0;
  }
  else if (DAT_00557708 == 1) {
    if ((param_1 & 0x80) == 0) {
      local_3c = 0;
    }
    else {
      local_3c = 0x1000000;
    }
    local_1c = (param_1 & 0xff00) >> 8;
    local_38 = param_1 & 0x7f;
    if ((int)param_1 < 0) {
      if ((param_1 & 0x40000000) == 0) {
        local_40 = "fixed";
      }
      else {
        local_40 = "fixed mcs only";
      }
    }
  }
  else {
    local_3c = param_1 & 0x3000000;
    local_38 = param_1 & 0xff;
    local_34 = (param_1 & 0x300) >> 8;
    if ((param_1 & 0x100000) == 0) {
      local_30 = "";
    }
    else {
      local_30 = " stbc";
    }
    if ((param_1 & 0x400000) == 0) {
      local_2c = "";
    }
    else {
      local_2c = " ldpc";
    }
    if ((param_1 & 0x800000) == 0) {
      local_28 = "";
    }
    else {
      local_28 = " sgi";
    }
    if ((param_1 & 0x200000) == 0) {
      local_24 = "";
    }
    else {
      local_24 = " txbf";
    }
    uVar2 = param_1 & 0x70000;
    if (uVar2 == 0x10000) {
      local_20 = "bw20";
    }
    else if (uVar2 == 0x20000) {
      local_20 = "bw40";
    }
    else if (uVar2 == 0x30000) {
      local_20 = "bw80";
    }
    else if (uVar2 == 0x40000) {
      local_20 = "bw160";
    }
    local_1c = 0xffffffff;
    if ((local_3c == 0) || ((local_3c == 0x1000000 && (local_38 < 8)))) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    if (local_34 == 0) {
      if (((param_1 & 0x100000) == 0) || (!bVar1)) {
        if (bVar1) {
          local_1c = 0;
        }
        else {
          local_1c = 3;
        }
      }
      else {
        local_1c = 2;
      }
    }
    else if ((local_34 == 1) && (bVar1)) {
      local_1c = 1;
    }
    if ((param_1 & 0x40000000) != 0) {
      local_40 = "fixed";
    }
  }
  if (local_3c == 0) {
    if (param_1 == 0) {
      puts("auto");
    }
    else {
      if ((local_38 & 1) == 0) {
        param2 = "";
      }
      else {
        param2 = ".5";
      }
      printf("legacy rate %d%s Mbps stf mode %d %s\n",local_38 >> 1,param2,local_1c,local_40);
    }
  }
  else if (local_3c == 0x1000000) {
    printf("mcs index %d stf mode %d %s\n",local_38,local_1c,local_40);
  }
  else {
    printf("vht mcs %d Nss %d Tx Exp %d %s%s%s%s%s %s\n",param_1 & 0xf,(param_1 & 0xf0) >> 4,
           local_34,local_20,local_30,local_24,local_2c,local_28,local_40);
  }
  return;
}



char * FUN_00415e70(char *param_1,uint param_2)

{
  uint uVar1;
  uint param4;
  uint uVar2;
  char *pcVar3;
  char *param8;
  char *param9;
  char *param7;
  char *local_38;
  
  uVar1 = param_2 & 0x3000000;
  param4 = (param_2 & 0x300) >> 8;
  uVar2 = param_2 & 0x70000;
  if ((param_2 & 0x100000) == 0) {
    pcVar3 = "";
  }
  else {
    pcVar3 = " stbc";
  }
  if ((param_2 & 0x400000) == 0) {
    param8 = "";
  }
  else {
    param8 = " ldpc";
  }
  if ((param_2 & 0x800000) == 0) {
    param9 = "";
  }
  else {
    param9 = " sgi";
  }
  if ((param_2 & 0x200000) == 0) {
    param7 = "";
  }
  else {
    param7 = " txbf";
  }
  if (uVar2 == 0) {
    local_38 = "auto";
  }
  else if (uVar2 == 0x10000) {
    local_38 = "20";
  }
  else if (uVar2 == 0x20000) {
    local_38 = "40";
  }
  else if (uVar2 == 0x30000) {
    local_38 = "80";
  }
  else if (uVar2 == 0x40000) {
    local_38 = "160";
  }
  else {
    local_38 = "???";
  }
  if ((param_2 & 0xfffffcff) == 0) {
    builtin_strncpy(param_1,"auto",5);
  }
  else if (uVar1 == 0) {
    if ((param_2 & 1) == 0) {
      pcVar3 = "";
    }
    else {
      pcVar3 = ".5";
    }
    sprintf(param_1,"rate %d%s Mbps Tx Exp %d",(param_2 & 0xff) >> 1,pcVar3,param4);
  }
  else if (uVar1 == 0x1000000) {
    sprintf(param_1,"ht mcs %d Tx Exp %d BW %s%s%s%s%s",param_2 & 0xff,param4,local_38,pcVar3,param7
            ,param8,param9);
  }
  else if (uVar1 == 0x2000000) {
    sprintf(param_1,"vht mcs %d Nss %d Tx Exp %d BW %s%s%s%s%s",param_2 & 0xf,(param_2 & 0xf0) >> 4,
            param4,local_38,pcVar3,param7,param8,param9);
  }
  else {
    sprintf(param_1,"<unknown encoding for ratespec 0x%08X>",param_2);
  }
  return param_1;
}



int FUN_004161f4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  char *param3;
  uint uVar3;
  char *local_5c;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  char acStack_24 [12];
  char acStack_18 [16];
  
  sprintf(acStack_24,"5g_%s",(char *)*param_2);
  sprintf(acStack_18,"2g_%s",(char *)*param_2);
  iVar1 = FUN_004b9f94(param_1,0x8d,(char *)&local_34,4);
  if (-1 < iVar1) {
    if (DAT_00557704 != '\0') {
      local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                 local_34 >> 0x18;
    }
    iVar1 = FUN_004b9f94(param_1,0x8c,(char *)&local_30,0xc);
    if (-1 < iVar1) {
      if (DAT_00557704 != '\0') {
        local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                   local_30 >> 0x18;
        local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                   local_2c >> 0x18;
        local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                   local_28 >> 0x18;
      }
      if (local_30 == 0) {
        iVar1 = -1;
      }
      else {
        if (2 < (int)local_30) {
          local_30 = 2;
        }
        piVar2 = (int *)(param_3 + 4);
        iVar1 = strcmp((char *)*param_2,"rate");
        if ((iVar1 == 0) && (*piVar2 == 0)) {
          iVar1 = FUN_004b9f94(param_1,param_2[2],(char *)&local_38,4);
          if (-1 < iVar1) {
            if (DAT_00557704 != '\0') {
              local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                         local_38 >> 0x18;
            }
            FUN_00415800(local_38);
            iVar1 = 0;
          }
        }
        else {
          if (local_34 == 1) {
            local_5c = acStack_24;
          }
          else if (local_34 == 2) {
            local_5c = acStack_18;
          }
          else {
            if (local_34 != 0) {
              return -1;
            }
            if (1 < (int)local_30) {
              if (*piVar2 == 0) {
                param3 = "get";
              }
              else {
                param3 = "set";
              }
              fprintf(stderr,"%s: driver band must be locked to %s %s, use %s/%s instead\n",
                      "wl_rate_mrate",param3,(char *)*param_2,acStack_18,acStack_24);
              return -2;
            }
            if (local_2c == 1) {
              local_5c = acStack_24;
            }
            else {
              if (local_2c != 2) {
                return -1;
              }
              local_5c = acStack_18;
            }
          }
          if (*piVar2 == 0) {
            iVar1 = FUN_004ba35c(param_1,local_5c,&local_38);
            iVar1 = -(iVar1 >> 0x1f);
            if (iVar1 == 0) {
              if (DAT_00557704 != '\0') {
                local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8
                           | local_38 >> 0x18;
              }
              if (DAT_00557708 == 1) {
                FUN_00415800(local_38);
              }
              else {
                uVar3 = FUN_004155dc(local_38);
                FUN_00415800(uVar3);
              }
            }
          }
          else {
            if (DAT_00557708 == 1) {
              local_38 = FUN_0041584c((char *)*piVar2);
            }
            else {
              local_38 = FUN_0041584c((char *)*piVar2);
            }
            if (DAT_00557704 != '\0') {
              local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                         local_38 >> 0x18;
            }
            iVar1 = FUN_004ba428(param_1,local_5c,local_38);
          }
        }
      }
    }
  }
  return iVar1;
}



undefined4 FUN_00416880(char *param_1,long *param_2,int *param_3)

{
  undefined4 uVar1;
  long lVar2;
  char *local_res0;
  char *local_20;
  int local_1c;
  char local_18;
  char *local_c;
  
  if ((param_1 == (char *)0x0) || (*param_1 == '\0')) {
    uVar1 = 0;
  }
  else {
    if (*param_1 == 'c') {
      local_20 = param_1 + 1;
      local_18 = 's';
    }
    else {
      local_18 = 'x';
      local_20 = param_1;
    }
    lVar2 = strtol(local_20,&local_c,10);
    if (((lVar2 < 0) || (9 < lVar2)) || (local_18 != *local_c)) {
      uVar1 = 0;
    }
    else {
      local_1c = 0;
      if ((*(ushort *)(__ctype_b + local_c[1] * 2) & 8) != 0) {
        local_1c = local_c[1] + -0x30;
      }
      local_res0 = local_c + 2;
      while ((*(ushort *)(__ctype_b + *local_res0 * 2) & 0x20) != 0) {
        local_res0 = local_res0 + 1;
      }
      if (*local_res0 == '\0') {
        if ((local_1c < 1) || (8 < local_1c)) {
          uVar1 = 0;
        }
        else {
          *param_2 = lVar2;
          *param_3 = local_1c;
          uVar1 = 1;
        }
      }
      else {
        uVar1 = 0;
      }
    }
  }
  return uVar1;
}



int FUN_00416a5c(int *param_1,int param_2,undefined4 *param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  char *pcVar9;
  char *param0;
  size_t __n;
  int iVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int *local_res8;
  uint local_f0;
  uint local_ec;
  uint local_e8;
  int local_e0;
  uint local_dc;
  undefined4 auStack_b8 [3];
  int local_ac;
  char local_a8;
  char local_a7;
  uchar local_a6;
  char local_a5 [129];
  char *local_24;
  uint local_1c;
  char *local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  
  bVar1 = false;
  bVar2 = false;
  bVar3 = false;
  bVar4 = false;
  bVar5 = false;
  local_f0 = 0;
  local_14 = 0;
  local_10 = 0;
  local_ec = 0;
  bVar6 = false;
  bVar7 = false;
  bVar8 = false;
  local_e8 = 0;
  pcVar9 = (char *)*param_3;
  local_res8 = param_3 + 1;
  if (DAT_00557708 == 1) {
    fprintf(stderr,"cmd %s not supported in this version of the driver, ioctl version 1.\n",pcVar9);
    local_e0 = -0x2c;
  }
  else if (*local_res8 == 0) {
    local_c = 0;
    if (*(int *)(param_2 + 8) < 0) {
      local_e0 = -1;
    }
    else {
      local_e0 = FUN_004ba35c(param_1,pcVar9,&local_c);
      if (-1 < local_e0) {
        pcVar9 = (char *)malloc(0x40);
        if (pcVar9 == (char *)0x0) {
          fprintf(stderr,"%s: malloc failure for rate string buffer.\n","wl_rate");
          local_e0 = -0x1b;
        }
        else {
          memset(pcVar9,0,0x40);
          FUN_00415e70(pcVar9,local_c);
          puts(pcVar9);
          free(pcVar9);
          local_e0 = 0;
        }
      }
    }
  }
  else {
    local_e0 = -0x2c;
    param0 = (char *)malloc(0x40);
    if (param0 == (char *)0x0) {
      fprintf(stderr,"%s: malloc failure for option_name buffer.\n","wl_rate");
      local_e0 = -0x1b;
    }
    else {
      memset(param0,0,0x40);
      FUN_004cbd80(auStack_b8,"wl_rate",0x510140,1);
      while (iVar10 = FUN_004cbe18(auStack_b8,local_res8), iVar10 != -1) {
        if (iVar10 == 1) {
          local_e0 = -0x2c;
          goto LAB_00417a1c;
        }
        local_res8 = local_res8 + local_ac;
        if (local_a8 == '\0') {
          bVar1 = true;
        }
        else {
          if (bVar1) {
            fprintf(stderr,
                    "%s: cannot mix positional args and options. Got positional arg \"%s\" after options.\n"
                    ,"wl_rate",local_24);
            goto LAB_00417a1c;
          }
          if (*local_res8 != 0) {
            fprintf(stderr,"%s: unexpected parameter \"%s\" after rate value.\n","wl_rate",
                    (char *)*local_res8);
            goto LAB_00417a1c;
          }
          iVar10 = strcmp(local_24,"auto");
          if (iVar10 == 0) {
            bVar2 = true;
          }
          else {
            local_a6 = 'r';
          }
        }
        if (local_a5[0] == '\0') {
          sprintf(param0,"-%c",local_a6);
        }
        else {
          __n = strlen(local_a5);
          if (0x3c < __n) {
            __n = 0x3d;
          }
          memcpy(param0,&DAT_005101cc,2);
          memcpy(param0 + 2,local_a5,__n);
          param0[__n + 2] = '\0';
        }
        if ((local_a6 == 'r') || (iVar10 = strcmp(local_a5,"rate"), iVar10 == 0)) {
          if (local_24 == (char *)0x0) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          iVar10 = strcmp(local_24,"5.5");
          if (iVar10 == 0) {
            local_f0 = 0xb;
          }
          else {
            if (local_a7 == '\0') {
              fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                      local_24,param0);
              goto LAB_00417a1c;
            }
            local_f0 = local_1c << 1;
          }
          bVar3 = true;
        }
        if ((local_a6 == 'h') || (iVar10 = strcmp(local_a5,"ht"), iVar10 == 0)) {
          if (local_24 == (char *)0x0) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                    local_24,param0);
            goto LAB_00417a1c;
          }
          local_14 = local_1c;
          bVar4 = true;
        }
        if ((local_a6 == 'v') || (iVar10 = strcmp(local_a5,"vht"), iVar10 == 0)) {
          if ((local_24 == (char *)0x0) || (*local_24 == 'c')) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          local_14 = strtol(local_24,&local_18,10);
          if (*local_18 == '\0') {
            local_14 = local_1c;
            bVar5 = true;
          }
          else {
            iVar10 = FUN_00416880(local_24,(long *)&local_14,(int *)&local_10);
            if (iVar10 == 0) {
              fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                      local_24,param0);
              goto LAB_00417a1c;
            }
            bVar5 = true;
          }
        }
        if (local_a6 == 'c') {
          if ((local_24 == (char *)0x0) || (*local_24 != 'c')) {
            fprintf(stderr,"%s: expected a value start with c for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          local_14 = strtol(local_24 + 1,&local_18,10);
          if (*local_18 == '\0') {
            bVar5 = true;
          }
          else {
            iVar10 = FUN_00416880(local_24,(long *)&local_14,(int *)&local_10);
            if (iVar10 == 0) {
              fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                      local_24,param0);
              goto LAB_00417a1c;
            }
            bVar5 = true;
          }
        }
        if ((local_a6 == 's') || (iVar10 = strcmp(local_a5,"ss"), iVar10 == 0)) {
          if (local_24 == (char *)0x0) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                    local_24,param0);
            goto LAB_00417a1c;
          }
          local_10 = local_1c;
        }
        if ((local_a6 == 'x') || (iVar10 = strcmp(local_a5,"exp"), iVar10 == 0)) {
          if (local_24 == (char *)0x0) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                    local_24,param0);
            goto LAB_00417a1c;
          }
          local_ec = local_1c;
          if (((int)local_1c < 0) || (3 < (int)local_1c)) {
            fprintf(stderr,"%s: tx expansion %d out of range [0-3]\n","wl_rate",local_1c);
            local_e0 = -0x1d;
            goto LAB_00417a1c;
          }
        }
        iVar10 = strcmp(local_a5,"stbc");
        if (iVar10 == 0) {
          if (local_24 != (char *)0x0) {
            fprintf(stderr,"%s: unexpected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          bVar6 = true;
        }
        if ((local_a6 == 'l') || (iVar10 = strcmp(local_a5,"ldpc"), iVar10 == 0)) {
          if (local_24 != (char *)0x0) {
            fprintf(stderr,"%s: unexpected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          bVar7 = true;
        }
        if ((local_a6 == 'g') || (iVar10 = strcmp(local_a5,"sgi"), iVar10 == 0)) {
          if (local_24 != (char *)0x0) {
            fprintf(stderr,"%s: unexpected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          bVar8 = true;
        }
        if ((local_a6 == 'b') || (iVar10 = strcmp(local_a5,"bandwidth"), iVar10 == 0)) {
          if (local_24 == (char *)0x0) {
            fprintf(stderr,"%s: expected a value for %s option\n","wl_rate",param0);
            goto LAB_00417a1c;
          }
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as a value for %s option\n","wl_rate",
                    local_24,param0);
            goto LAB_00417a1c;
          }
          if (local_1c == 0x14) {
            local_e8 = 0x10000;
          }
          else if (local_1c == 0x28) {
            local_e8 = 0x20000;
          }
          else if (local_1c == 0x50) {
            local_e8 = 0x30000;
          }
          else {
            if (local_1c != 0xa0) {
              fprintf(stderr,
                      "%s: unexpected bandwidth specified \"%s\", expected 20, 40, 80, or 160\n",
                      "wl_rate",local_24);
              goto LAB_00417a1c;
            }
            local_e8 = 0x40000;
          }
        }
      }
      if ((((bVar2) || (bVar3)) || (bVar4)) || (bVar5)) {
        if ((bVar3) && (bVar4)) {
          fprintf(stderr,
                  "%s: cannot use legacy rate -r/--rate and HT rate -h/--ht at the same time\n",
                  "wl_rate");
        }
        else if ((bVar3) && (bVar5)) {
          fprintf(stderr,
                  "%s: cannot use legacy rate -r/--rate and HT rate -v/--vht at the same time\n",
                  "wl_rate");
        }
        else if ((bVar4) && (bVar5)) {
          fprintf(stderr,"%s: cannot use HT rate -h/--ht and HT rate -v/--vht at the same time\n",
                  "wl_rate");
        }
        else if ((bVar5) || (local_10 == 0)) {
          if ((((!bVar6) && (!bVar7)) && (!bVar8)) || ((bVar4 || (bVar5)))) {
            if (bVar2) {
              local_dc = 0;
            }
            else if (bVar3) {
              local_dc = local_f0;
            }
            else if (bVar4) {
              local_dc = local_14 | 0x1000000;
            }
            else {
              if (local_10 == 0) {
                local_10 = 1;
              }
              local_dc = local_10 << 4 | local_14 | 0x2000000;
            }
            if (bVar6) {
              uVar11 = 0x100000;
            }
            else {
              uVar11 = 0;
            }
            if (bVar7) {
              uVar12 = 0x400000;
            }
            else {
              uVar12 = 0;
            }
            if (bVar8) {
              uVar13 = 0x800000;
            }
            else {
              uVar13 = 0;
            }
            local_e0 = FUN_004ba428(param_1,pcVar9,
                                    local_dc | local_ec << 8 | local_e8 | uVar11 | uVar12 | uVar13);
          }
          else {
            fprintf(stderr,"%s: cannot use STBC/LDPC/SGI options with non HT/VHT rates\n","wl_rate")
            ;
          }
        }
        else {
          fprintf(stderr,"%s: cannot use -s/--ss option with non VHT rate\n","wl_rate");
        }
      }
      else {
        fprintf(stderr,
                "%s: must specify one of \"auto\", legacy rate -r/--rate, HT (11n) rate -h/--ht, or VHT (11ac) rate -v/--vht\n"
                ,"wl_rate");
      }
LAB_00417a1c:
      if (param0 != (char *)0x0) {
        free(param0);
      }
    }
  }
  return local_e0;
}



int FUN_00417a50(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint local_10;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba35c(param_1,"wsec",&local_10);
    iVar1 = -(iVar1 >> 0x1f);
    if (iVar1 == 0) {
      printf("%d\n",local_10);
      iVar1 = 0;
    }
  }
  else {
    local_10 = atoi(*(char **)(param_3 + 4));
    iVar1 = FUN_004ba35c(param_1,"wsec",&local_c);
    iVar1 = -(iVar1 >> 0x1f);
    if (iVar1 == 0) {
      if (local_10 == 0) {
        local_c = local_c & 0xfffffffe;
      }
      else {
        local_c = local_c | 1;
      }
      iVar1 = FUN_004ba428(param_1,"wsec",local_c);
    }
  }
  return iVar1;
}



int FUN_00417ba8(int *param_1,int param_2)

{
  int iVar1;
  char *pcVar2;
  int local_10;
  
  local_10 = 1;
  *(undefined4 *)PTR_DAT_00551644 = 0x706163;
  iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x600);
  if (-1 < iVar1) {
    PTR_DAT_00551644[0x600] = 0;
    pcVar2 = strstr(PTR_DAT_00551644,"mbss16");
    if (pcVar2 == (char *)0x0) {
      pcVar2 = strstr(PTR_DAT_00551644,"mbss4");
      if (pcVar2 != (char *)0x0) {
        local_10 = 4;
      }
    }
    else {
      local_10 = 0x10;
    }
    printf("%d\n",local_10);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00417cc8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  char *local_1c;
  int local_18;
  uint local_c;
  
  local_1c = (char *)*param_2;
  piVar1 = (int *)(param_3 + 4);
  if (1 < DAT_00557708) {
    for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
      iVar2 = strcmp(local_1c,(&PTR_s_bg_rate_00524998)[local_18 * 2]);
      if (iVar2 == 0) {
        local_1c = (&PTR_s_2g_rate_0052499c)[local_18 * 2];
        break;
      }
    }
  }
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba35c(param_1,local_1c,&local_c);
    if (-1 < iVar2) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
      }
      if (DAT_00557708 < 2) {
        FUN_00415800(local_c);
      }
      else {
        uVar3 = FUN_004155dc(local_c);
        FUN_00415800(uVar3);
      }
    }
  }
  else {
    if (DAT_00557708 == 1) {
      local_c = FUN_0041584c((char *)*piVar1);
    }
    else {
      local_c = FUN_0041584c((char *)*piVar1);
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    iVar2 = FUN_004ba428(param_1,local_1c,local_c);
  }
  return iVar2;
}



// WARNING: Removing unreachable block (ram,0x004183e8)
// WARNING: Removing unreachable block (ram,0x00418408)

int FUN_00417f64(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  int *local_res8;
  int local_cc;
  uint local_c8;
  uint local_c4;
  uint local_c0;
  uint local_bc;
  int local_b8;
  undefined4 auStack_ac [3];
  int local_a0;
  char local_9b;
  char local_9a;
  char *local_18;
  uint local_10;
  uint local_c;
  
  bVar1 = false;
  bVar2 = false;
  bVar4 = false;
  bVar3 = false;
  local_c = 0;
  local_c8 = 0;
  local_c0 = 0;
  local_bc = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      local_cc = -1;
    }
    else {
      local_cc = FUN_004ba35c(param_1,"nrate",&local_c);
      if (-1 < local_cc) {
        FUN_004159a8(local_c);
        local_cc = 0;
      }
    }
  }
  else {
    iVar5 = strcmp((char *)*local_res8,"auto");
    if (((iVar5 == 0) || (iVar5 = strcmp((char *)*local_res8,"-1"), iVar5 == 0)) &&
       (*(int *)(param_3 + 8) == 0)) {
      local_cc = FUN_004ba428(param_1,"nrate",0);
    }
    else {
      FUN_004cbd80(auStack_ac,"wl_nrate",0x510500,0);
      while (iVar5 = FUN_004cbe18(auStack_ac,local_res8), iVar5 != -1) {
        if (iVar5 == 1) {
          return -0x2c;
        }
        local_res8 = local_res8 + local_a0;
        if (local_9a == 'r') {
          if (local_9b == '\0') {
            iVar5 = strcmp(local_18,"5.5");
            if (iVar5 != 0) {
              fprintf(stderr,"%s: could not parse \"%s\" as a rate value\n","wl_nrate",local_18);
              return -2;
            }
            local_10 = 0xb;
          }
          else {
            local_10 = local_10 << 1;
          }
          if (bVar1) {
            fprintf(stderr,"%s: cannot use -r and -m\n","wl_nrate");
            return -0x2c;
          }
          bVar2 = true;
          local_c8 = local_10;
        }
        if (local_9a == 'm') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for mcs\n","wl_nrate",local_18);
            return -2;
          }
          if (bVar2) {
            fprintf(stderr,"%s: cannot use -r and -m\n","wl_nrate");
            return -0x2c;
          }
          bVar1 = true;
          local_c0 = local_10;
        }
        if (local_9a == 's') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for stf mode\n","wl_nrate",local_18
                   );
            return -2;
          }
          local_bc = local_10;
          bVar4 = true;
        }
        if (local_9a == 'w') {
          bVar3 = true;
        }
      }
      if (((bVar3) && (!bVar1)) || ((bVar3 && ((bVar4 || (bVar2)))))) {
        fprintf(stderr,"%s: can use -w only with -m\n","wl_nrate");
        local_cc = -0x2c;
      }
      else {
        if (!bVar4) {
          if (bVar2) {
            local_bc = 0;
          }
          else if (bVar1) {
            local_bc = 0;
          }
        }
        if ((bVar2) || (bVar1)) {
          if (DAT_00557708 == 1) {
            if (bVar2) {
              local_c4 = local_c8;
            }
            else {
              local_c4 = local_c0 | 0x80;
              if (bVar3) {
                local_c4 = local_c0 | 0x40000080;
              }
            }
            local_c4 = local_c4 | (local_bc & 0xff) << 8;
          }
          else {
            local_b8 = 0;
            if (bVar2) {
              local_c4 = local_c8;
            }
            else {
              local_c4 = local_c0 | 0x1000000;
            }
            if (local_bc == 1) {
              local_b8 = 1;
            }
            else if (local_bc == 2) {
              local_c4 = local_c4 | 0x100000;
            }
            local_c4 = local_c4 | local_b8 << 8;
          }
          local_cc = FUN_004ba428(param_1,"nrate",local_c4);
        }
        else {
          fprintf(stderr,"%s: you need to set a legacy or mcs rate\n","wl_nrate");
          local_cc = -0x2c;
        }
      }
    }
  }
  return local_cc;
}



int FUN_004185ac(int *param_1,undefined4 *param_2)

{
  byte bVar1;
  undefined *puVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  uint local_48;
  uint local_44;
  uint local_40;
  byte *local_3c;
  uint local_28;
  uint local_24;
  uint local_20;
  ushort local_1c;
  ushort local_1a;
  undefined1 auStack_18 [6];
  ushort local_12;
  ushort local_10;
  ushort local_e;
  
  local_44 = 0;
  local_40 = 0;
  strcpy(PTR_DAT_00551644,(char *)*param_2);
  iVar4 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x100);
  if (-1 < iVar4) {
    memcpy(&local_28,PTR_DAT_00551644,0x1c);
    if (DAT_00557704 != '\0') {
      local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                 local_28 >> 0x18;
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
    }
    puts("Assoc req:");
    printf("\tlen 0x%x\n",local_28);
    if (local_28 != 0) {
      printf("\tcapab  0x%x\n",(uint)local_1c);
      printf("\tlisten 0x%x\n",(uint)local_1a);
      uVar3 = local_28;
      local_44 = local_28 - 4;
      if ((local_20 & 1) != 0) {
        pcVar5 = FUN_0041d780((int)auStack_18);
        printf("\treassoc bssid %s\n",pcVar5);
        local_44 = uVar3 - 10;
      }
    }
    puVar2 = PTR_DAT_00551644;
    if (local_44 != 0) {
      *(undefined4 *)PTR_DAT_00551644 = 0x6f737361;
      pcVar5 = puVar2 + 4;
      pcVar5[0] = 'c';
      pcVar5[1] = '_';
      pcVar5[2] = 'r';
      pcVar5[3] = 'e';
      pcVar5 = puVar2 + 8;
      pcVar5[0] = 'q';
      pcVar5[1] = '_';
      pcVar5[2] = 'i';
      pcVar5[3] = 'e';
      puVar2[0xc] = 's';
      puVar2[0xd] = '\0';
      iVar4 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x100);
      if (iVar4 < 0) {
        return iVar4;
      }
      printf("assoc req IEs:\n\t");
      local_3c = PTR_DAT_00551644;
      for (local_48 = 1; local_48 <= local_44; local_48 = local_48 + 1) {
        bVar1 = *local_3c;
        local_3c = local_3c + 1;
        printf("0x%02x ",(uint)bVar1);
        if ((local_48 & 7) == 0) {
          printf("\n\t");
        }
      }
    }
    puts("\nAssoc resp:");
    printf("\tlen 0x%x\n",local_24);
    if (local_24 != 0) {
      printf("\tcapab  0x%x\n",(uint)local_12);
      printf("\tstatus 0x%x\n",(uint)local_10);
      printf("\taid    0x%x\n",(uint)local_e);
      local_40 = local_24 - 6;
    }
    puVar2 = PTR_DAT_00551644;
    if (local_40 != 0) {
      *(undefined4 *)PTR_DAT_00551644 = 0x6f737361;
      pcVar5 = puVar2 + 4;
      pcVar5[0] = 'c';
      pcVar5[1] = '_';
      pcVar5[2] = 'r';
      pcVar5[3] = 'e';
      pcVar5 = puVar2 + 8;
      pcVar5[0] = 's';
      pcVar5[1] = 'p';
      pcVar5[2] = '_';
      pcVar5[3] = 'i';
      puVar2[0xc] = 'e';
      puVar2[0xd] = 's';
      puVar2[0xe] = '\0';
      iVar4 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x100);
      if (iVar4 < 0) {
        return iVar4;
      }
      printf("assoc resp IEs:\n\t");
      local_3c = PTR_DAT_00551644;
      for (local_48 = 1; local_48 <= local_40; local_48 = local_48 + 1) {
        bVar1 = *local_3c;
        local_3c = local_3c + 1;
        printf(" 0x%02x ",(uint)bVar1);
        if ((local_48 & 7) == 0) {
          printf("\n\t");
        }
      }
    }
    putchar(10);
    iVar4 = 0;
  }
  return iVar4;
}



void FUN_00418b40(byte *param_1,int param_2)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *local_res0;
  int local_res4;
  int local_58;
  uint local_54;
  byte *local_50;
  byte abStack_48 [64];
  
  local_res0 = param_1;
  local_res4 = param_2;
  while (0 < local_res4) {
    bVar1 = *local_res0;
    local_54 = (uint)local_res0[1];
    pbVar2 = local_res0 + 2;
    uVar3 = local_res4 - 2;
    printf("Tag:%d Len:%d - ",(uint)bVar1,local_54);
    switch(bVar1) {
    case 0:
      for (local_58 = 0; local_58 < (int)local_54; local_58 = local_58 + 1) {
        abStack_48[local_58] = pbVar2[local_58];
      }
      if (local_58 < 0x40) {
        abStack_48[local_58] = 0;
      }
      printf("SSID: \'%s\'\n",(char *)abStack_48);
      break;
    case 1:
      puts("Supported Rates");
      break;
    case 2:
      puts("FH Parameter Set");
      break;
    case 3:
      puts("DS Parameter Set");
      break;
    case 4:
      puts("CF Parameter Set");
      break;
    case 5:
      puts("Traffic Indication Map (TIM)");
      break;
    case 6:
      puts("IBSS Parameter Set");
      break;
    case 7:
      printf("Country \'%c%c%c\'\n",*pbVar2,local_res0[3],local_res0[4]);
      for (local_50 = local_res0 + 5; 2 < (int)(pbVar2 + (local_54 - (int)local_50));
          local_50 = local_50 + 3) {
        printf("Start Channel: %d, Channels: %d, Max TX Power: %d dBm\n",(uint)*local_50,
               (uint)local_50[1],(uint)local_50[2]);
      }
      break;
    case 8:
      puts("Hopping Pattern Parameters");
      break;
    case 9:
      puts("Hopping Pattern Table");
      break;
    case 10:
      puts("Request");
      break;
    case 0xb:
      puts("QBSS Load");
      break;
    case 0xc:
      puts("EDCA Parameter");
      break;
    default:
      if ((int)uVar3 < (int)local_54) {
        puts("Unsupported tag error/malformed");
        local_54 = uVar3;
      }
      else {
        puts("Unsupported tag");
      }
      break;
    case 0x10:
      puts("Challenge text");
      break;
    case 0x20:
      puts("Power Constraint");
      break;
    case 0x21:
      puts("Power Capability");
      break;
    case 0x22:
      puts("Transmit Power Control (TPC) Request");
      break;
    case 0x23:
      puts("Transmit Power Control (TPC) Report");
      break;
    case 0x24:
      puts("Supported Channels");
      break;
    case 0x25:
      puts("Channel Switch Announcement");
      break;
    case 0x26:
      puts("Measurement Request");
      break;
    case 0x27:
      puts("Measurement Report");
      break;
    case 0x28:
      puts("Quiet");
      break;
    case 0x29:
      puts("IBSS DFS");
      break;
    case 0x2a:
      puts("ERP Information");
      break;
    case 0x2b:
      puts("TS Delay");
      break;
    case 0x2d:
      puts("HT Capabilities");
      break;
    case 0x2e:
      puts("QoS Capability");
      break;
    case 0x2f:
      puts("NON-ERP");
      break;
    case 0x30:
      puts((char *)&PTR_s__00510944);
      break;
    case 0x32:
      puts("Extended Supported Rates");
      break;
    case 0x33:
      puts("AP Channel Report");
      break;
    case 0x34:
      puts("Neighbor Report");
      break;
    case 0x36:
      puts("Mobility Domain");
      break;
    case 0x37:
      puts("Fast BSS Transition");
      break;
    case 0x38:
      puts("802.11R Timeout Interval");
      break;
    case 0x3b:
      puts("Regulatory Class");
      break;
    case 0x3c:
      puts("Extended CSA");
      break;
    case 0x3d:
      puts("HT Information");
      break;
    case 0x3e:
      puts("Ext Channel");
      break;
    case 0x46:
      puts("Radio Measurement");
      break;
    case 0x48:
      puts("OBSS Coexistence INFO");
      break;
    case 0x49:
      puts("OBSS Intolerant Channel List");
      break;
    case 0x4a:
      puts("OBSS HT Info");
      break;
    case 0x61:
      puts("Channel Usage");
      break;
    case 0x65:
      puts("TDLS Link Identifier");
      break;
    case 0x66:
      puts("TDLS Wakeup Schedule");
      break;
    case 0x68:
      puts("TDLS Channel Switch Timing");
      break;
    case 0x69:
      puts("TDLS PTI Control");
      break;
    case 0x6a:
      puts("TDLS PU Buffer Status");
      break;
    case 0x7f:
      puts("Management Ext Capability");
      break;
    case 0xdd:
      puts("Proprietary");
    }
    FUN_0041e248((int)pbVar2,local_54);
    local_res0 = pbVar2 + local_54;
    local_res4 = uVar3 - local_54;
  }
  return;
}



void FUN_004192a4(uint *param_1,int param_2)

{
  uint uVar1;
  uint param2;
  uint uVar2;
  uint param1;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  if (0x24 < param_2) {
    uVar6 = *param_1;
    uVar4 = param_1[1];
    uVar3 = param_1[2];
    uVar2 = param_1[3];
    uVar1 = param_1[4];
    uVar7 = param_1[5];
    param1 = param_1[6];
    param2 = param_1[7];
    uVar5 = param_1[8];
    printf("Frame Ctl: 0x%04x\n",uVar6 & 0xffff);
    printf("Duration : 0x%04x\n",uVar6 >> 0x10);
    printf("Dest addr: %02x:%02x:%02x:%02x:%02x:%02x\n",uVar4 & 0xff,uVar4 >> 8 & 0xff,
           uVar4 >> 0x10 & 0xff,uVar4 >> 0x18,uVar3 & 0xff,uVar3 >> 8 & 0xff);
    printf("Src addr : %02x:%02x:%02x:%02x:%02x:%02x\n",uVar3 >> 0x10 & 0xff,uVar3 >> 0x18,
           uVar2 & 0xff,uVar2 >> 8 & 0xff,uVar2 >> 0x10 & 0xff,uVar2 >> 0x18);
    printf("BSSID    : %02x:%02x:%02x:%02x:%02x:%02x\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,
           uVar1 >> 0x10 & 0xff,uVar1 >> 0x18,uVar7 & 0xff,uVar7 >> 8 & 0xff);
    printf("Seq ctl  : 0x%04x\n",uVar7 >> 0x10);
    printf("Timestamp: 0x%08x%08x\n",param1,param2);
    printf("Beacon Interval: 0x%04x\n",uVar5 & 0xffff);
    printf("Capabilities: 0x%04x\n",uVar5 >> 0x10);
    FUN_00418b40((byte *)(param_1 + 9),param_2 + -0x24);
  }
  return;
}



size_t FUN_00419538(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  char *__s1;
  int iVar2;
  uint uVar3;
  size_t __n;
  uint *param1;
  int *local_res8;
  size_t local_28;
  FILE *local_24;
  char *local_20;
  
  local_24 = (FILE *)0x0;
  local_20 = (char *)0x0;
  bVar1 = false;
  local_res8 = (int *)(param_3 + 4);
  while( true ) {
    while( true ) {
      if (*local_res8 == 0) {
        strcpy(PTR_DAT_00551644,(char *)*param_2);
        local_28 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
        if (-1 < (int)local_28) {
          if (DAT_00557704 == '\0') {
            __n = *(size_t *)PTR_DAT_00551644;
          }
          else {
            uVar3 = *(uint *)PTR_DAT_00551644;
            __n = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
          }
          if (0 < (int)__n) {
            param1 = (uint *)(PTR_DAT_00551644 + 4);
            printf("Data: %p Len: %d bytes\n",param1,__n);
            if (local_20 == (char *)0x0) {
              if (bVar1) {
                FUN_0041e248((int)param1,__n);
              }
              else {
                FUN_004192a4(param1,__n);
              }
            }
            else {
              local_24 = fopen(local_20,"wb");
              if (local_24 == (FILE *)0x0) {
                fprintf(stderr,"Failed to open file %s\n",local_20);
                local_28 = 0xfffffffe;
              }
              else {
                local_28 = fwrite(param1,1,__n,local_24);
                if (local_28 != __n) {
                  fprintf(stderr,"Error write %d bytes to file %s, rc %d!\n",__n,local_20,local_28);
                  local_28 = 0xffffffff;
                }
              }
            }
            if (local_24 != (FILE *)0x0) {
              fclose(local_24);
            }
          }
        }
        return local_28;
      }
      __s1 = (char *)*local_res8;
      iVar2 = strcmp(__s1,"-f");
      if ((iVar2 != 0) || (local_res8[1] == 0)) break;
      local_20 = (char *)local_res8[1];
      local_res8 = local_res8 + 2;
    }
    iVar2 = strcmp(__s1,"-r");
    if (iVar2 != 0) break;
    bVar1 = true;
    local_res8 = local_res8 + 1;
  }
  return 0xffffffd4;
}



int FUN_00419874(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  char *param2;
  int local_20;
  int local_1c;
  
  if (*(int *)(param_3 + 4) == 0) {
    strcpy(PTR_DAT_00551644,(char *)*param_2);
    iVar2 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x100);
    puVar1 = PTR_DAT_00551644;
    if (iVar2 < 0) {
      return iVar2;
    }
    if (DAT_00557704 == '\0') {
      uVar3 = *(uint *)PTR_DAT_00551644;
    }
    else {
      uVar3 = *(uint *)PTR_DAT_00551644;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *(uint *)PTR_DAT_00551644 = uVar3;
    printf("\npmkid entries : %d\n",*(int *)puVar1);
    for (local_20 = 0; local_20 < *(int *)puVar1; local_20 = local_20 + 1) {
      param2 = FUN_0041d780((int)(puVar1 + local_20 * 0x16 + 4));
      printf("\tPMKID[%d]: %s =",local_20,param2);
      for (local_1c = 0; local_1c < 0x10; local_1c = local_1c + 1) {
        printf("%02x ",(uint)(byte)puVar1[local_20 * 0x16 + local_1c + 10]);
      }
      putchar(10);
    }
  }
  else {
    puts("\tset cmd ignored");
  }
  return 0;
}



int FUN_00419ad8(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int local_90;
  uint local_8c;
  uint local_74;
  undefined1 auStack_70 [16];
  undefined1 auStack_60 [16];
  undefined1 auStack_50 [16];
  uint local_40;
  byte abStack_3c [52];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    local_90 = FUN_004ba1f8(param_1,"cur_rateset",(char *)&local_74,0x34);
    if (-1 < local_90) {
      if (DAT_00557704 != '\0') {
        local_74 = local_74 << 0x18 | (local_74 & 0xff00) << 8 | (local_74 & 0xff0000) >> 8 |
                   local_74 >> 0x18;
      }
      FUN_004226f4((int)auStack_70,local_74);
      putchar(10);
      FUN_00494a88((int)auStack_60);
      FUN_00494b5c((int)auStack_50);
    }
  }
  else {
    local_90 = FUN_004ba1f8(param_1,"rateset",(char *)&local_40,0x34);
    if (-1 < local_90) {
      if (DAT_00557704 != '\0') {
        local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                   local_40 >> 0x18;
      }
      iVar2 = strcasecmp((char *)*piVar1,"all");
      if (iVar2 == 0) {
        for (local_8c = 0; local_8c < local_40; local_8c = local_8c + 1) {
          abStack_3c[local_8c] = abStack_3c[local_8c] | 0x80;
        }
        if (DAT_00557704 != '\0') {
          local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                     local_40 >> 0x18;
        }
        local_90 = FUN_004ba2e4(param_1,"rateset",&local_40,0x34);
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"default");
        if (iVar2 == 0) {
          if (DAT_00557704 != '\0') {
            local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                       local_40 >> 0x18;
          }
          local_90 = FUN_004ba2e4(param_1,"rateset",&local_40,0x34);
        }
        else {
          local_90 = FUN_0041b074(param_1,&local_40,piVar1);
          if (local_90 == 0) {
            for (local_8c = 0; (local_8c < local_40 && (-1 < (char)abStack_3c[local_8c]));
                local_8c = local_8c + 1) {
            }
            if (local_8c < local_40) {
              if (DAT_00557704 != '\0') {
                local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8
                           | local_40 >> 0x18;
              }
              local_90 = FUN_004ba2e4(param_1,"rateset",&local_40,0x34);
            }
            else {
              local_90 = -2;
              fwrite("Bad Args: at least one rate must be marked Basic\n",1,0x31,stderr);
            }
          }
        }
      }
    }
  }
  return local_90;
}



int FUN_00419fb8(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint local_38;
  undefined1 auStack_34 [16];
  undefined4 local_24;
  undefined4 local_20;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 local_1a;
  undefined1 local_19;
  uint local_14;
  uint local_10 [2];
  
  memset(&local_38,0,0x14);
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    fwrite("Can\'t parse phy type\n",1,0x15,stderr);
    iVar2 = -0x2c;
  }
  else {
    iVar2 = strcasecmp((char *)*piVar1,"a");
    if (iVar2 == 0) {
      local_24 = 0;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"b");
      if (iVar2 == 0) {
        local_24 = 2;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"g");
        if (iVar2 == 0) {
          local_24 = 2;
        }
        else {
          iVar2 = strcasecmp((char *)*piVar1,"n");
          if (iVar2 == 0) {
            local_24 = 4;
          }
          else {
            iVar2 = strcasecmp((char *)*piVar1,"lp");
            if (iVar2 == 0) {
              local_24 = 5;
            }
            else {
              iVar2 = strcasecmp((char *)*piVar1,"ssn");
              if (iVar2 == 0) {
                local_24 = 6;
              }
              else {
                iVar2 = strcasecmp((char *)*piVar1,"ht");
                if (iVar2 == 0) {
                  local_24 = 7;
                }
                else {
                  iVar2 = strcasecmp((char *)*piVar1,"lcn");
                  if (iVar2 == 0) {
                    local_24 = 8;
                  }
                  else {
                    iVar2 = strcasecmp((char *)*piVar1,"lcn40");
                    if (iVar2 == 0) {
                      local_24 = 10;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*piVar1,"ac");
                      if (iVar2 != 0) {
                        fprintf(stderr,"Wrong phy type: %s\n",(char *)*piVar1);
                        return -0x2c;
                      }
                      local_24 = 0xb;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    piVar1 = (int *)(param_3 + 8);
    if (*piVar1 == 0) {
      fwrite("Can\'t parse band type\n",1,0x16,stderr);
      iVar2 = -0x2c;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"5");
      if (iVar2 == 0) {
        local_20 = 1;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"2");
        if (iVar2 != 0) {
          fprintf(stderr,"Wrong band type: %s\n",(char *)*piVar1);
          return -0x2c;
        }
        local_20 = 2;
      }
      piVar1 = (int *)(param_3 + 0xc);
      if (*piVar1 == 0) {
        fwrite("Can\'t parse cck\n",1,0x10,stderr);
        iVar2 = -0x2c;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"0");
        if (iVar2 == 0) {
          local_1c = 0;
        }
        else {
          iVar2 = strcasecmp((char *)*piVar1,"1");
          if (iVar2 != 0) {
            fprintf(stderr,"Wrong cck: %s\n",(char *)*piVar1);
            return -0x2c;
          }
          local_1c = 1;
        }
        piVar1 = (int *)(param_3 + 0x10);
        if (*piVar1 == 0) {
          fwrite("Can\'t parse basic rates\n",1,0x18,stderr);
          iVar2 = -0x2c;
        }
        else {
          iVar2 = strcasecmp((char *)*piVar1,"0");
          if (iVar2 == 0) {
            local_1b = 0x7f;
          }
          else {
            iVar2 = strcasecmp((char *)*piVar1,"1");
            if (iVar2 != 0) {
              fprintf(stderr,"Wrong basic rates: %s\n",(char *)*piVar1);
              return -0x2c;
            }
            local_1b = 0xff;
          }
          piVar1 = (int *)(param_3 + 0x14);
          if (*piVar1 == 0) {
            fwrite("Can\'t parse mcs\n",1,0x10,stderr);
            iVar2 = -0x2c;
          }
          else {
            iVar2 = strcasecmp((char *)*piVar1,"0");
            if (iVar2 == 0) {
              local_1a = 0;
            }
            else {
              iVar2 = strcasecmp((char *)*piVar1,"1");
              if (iVar2 != 0) {
                fprintf(stderr,"Wrong mcs: %s\n",(char *)*piVar1);
                return -0x2c;
              }
              local_1a = 1;
            }
            piVar1 = (int *)(param_3 + 0x18);
            if (*piVar1 == 0) {
              fwrite("Can\'t parse bandwidth\n",1,0x16,stderr);
              iVar2 = -0x2c;
            }
            else {
              iVar2 = strcasecmp((char *)*piVar1,"10");
              if (iVar2 == 0) {
                local_19 = 10;
              }
              else {
                iVar2 = strcasecmp((char *)*piVar1,"20");
                if (iVar2 == 0) {
                  local_19 = 0x14;
                }
                else {
                  iVar2 = strcasecmp((char *)*piVar1,"40");
                  if (iVar2 == 0) {
                    local_19 = 0x28;
                  }
                  else {
                    iVar2 = strcasecmp((char *)*piVar1,"80");
                    if (iVar2 == 0) {
                      local_19 = 0x50;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*piVar1,"160");
                      if (iVar2 != 0) {
                        fprintf(stderr,"Wrong bandwidth: %s\n",(char *)*piVar1);
                        return -0x2c;
                      }
                      local_19 = 0xa0;
                    }
                  }
                }
              }
              piVar1 = (int *)(param_3 + 0x1c);
              if (*piVar1 == 0) {
                fwrite("Can\'t parse tx/rx streams\n",1,0x1a,stderr);
                iVar2 = -0x2c;
              }
              else {
                iVar2 = strcasecmp((char *)*piVar1,"tx");
                if (iVar2 == 0) {
                  iVar2 = FUN_004ba35c(param_1,"txstreams",&local_14);
                  if (iVar2 < 0) {
                    fwrite("Can\'t get tx streams\n",1,0x15,stderr);
                    return -0x2c;
                  }
                }
                else {
                  iVar2 = strcasecmp((char *)*piVar1,"rx");
                  if (iVar2 != 0) {
                    fprintf(stderr,"Wrong tx/rx streams: %s\n",(char *)*piVar1);
                    return -0x2c;
                  }
                  iVar2 = FUN_004ba35c(param_1,"rxstreams",local_10);
                  if (iVar2 < 0) {
                    fwrite("Can\'t get rx streams\n",1,0x15,stderr);
                    return -0x2c;
                  }
                }
                iVar2 = FUN_004ba0cc(param_1,"default_rateset",(void *)0x0,0,(char *)&local_38,0x24)
                ;
                if (iVar2 == 0) {
                  if (DAT_00557704 != '\0') {
                    local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 |
                               (local_38 & 0xff0000) >> 8 | local_38 >> 0x18;
                  }
                  FUN_004226f4((int)auStack_34,local_38);
                }
                else {
                  fwrite("default_rateset failed\n",1,0x17,stderr);
                }
              }
            }
          }
        }
      }
    }
  }
  return iVar2;
}



int FUN_0041aa34(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  char acStack_34 [4];
  undefined1 auStack_30 [4];
  undefined1 auStack_2c [8];
  undefined1 auStack_24 [8];
  undefined1 auStack_1c [8];
  undefined1 auStack_14 [8];
  byte local_c;
  byte local_b;
  
  iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_34,0x2a);
  if (-1 < iVar1) {
    if (*(int *)(param_3 + 4) == 0) {
      printf("    OFDM: ");
      if (DAT_00557704 == '\0') {
        uVar2 = (uint)local_c;
      }
      else {
        uVar2 = (uint)local_c << 0x18;
      }
      FUN_004226f4((int)auStack_1c,uVar2);
      putchar(10);
      FUN_00494c8c((int)acStack_34,&DAT_005112a4);
      FUN_00494d68((int)auStack_2c,&DAT_005112a4);
      printf("BCM OFDM: ");
      if (DAT_00557704 == '\0') {
        uVar2 = (uint)local_b;
      }
      else {
        uVar2 = (uint)local_b << 0x18;
      }
      FUN_004226f4((int)auStack_14,uVar2);
      putchar(10);
      FUN_00494c8c((int)auStack_30,&DAT_005112b4);
      FUN_00494d68((int)auStack_24,&DAT_005112b4);
    }
    else {
      iVar1 = FUN_0041b798((int)acStack_34,(int *)(param_3 + 4));
      if (iVar1 == 0) {
        if (DAT_00557704 != '\0') {
          local_c = 0;
          local_b = 0;
        }
        iVar1 = FUN_004ba2e4(param_1,(char *)*param_2,acStack_34,0x2a);
      }
    }
  }
  return iVar1;
}



int FUN_0041ad74(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  uint local_48;
  uint local_3c;
  byte abStack_38 [48];
  
  memset(&local_3c,0,0x34);
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = FUN_004b9f94(param_1,param_2[2],(char *)&local_3c,0x14);
    if (-1 < iVar3) {
      if (DAT_00557704 != '\0') {
        local_3c = local_3c << 0x18 | (local_3c & 0xff00) << 8 | (local_3c & 0xff0000) >> 8 |
                   local_3c >> 0x18;
      }
      FUN_004226f4((int)abStack_38,local_3c);
      putchar(10);
    }
  }
  else {
    iVar3 = strcasecmp((char *)*piVar2,"-1");
    if ((iVar3 == 0) || (iVar3 = strcasecmp((char *)*piVar2,"0"), iVar3 == 0)) {
      iVar3 = FUN_004ba050(param_1,param_2[3],(char *)&local_3c,0x14);
    }
    else {
      FUN_0041b074(param_1,&local_3c,piVar2);
      bVar1 = false;
      for (local_48 = 0; local_48 < local_3c; local_48 = local_48 + 1) {
        if ((char)abStack_38[local_48] < '\0') {
          abStack_38[local_48] = abStack_38[local_48] & 0x7f;
          bVar1 = true;
        }
      }
      if (bVar1) {
        fprintf(stderr,"Warning: Basic rate attribute ignored for \"%s\" command\n",(char *)*param_2
               );
      }
      if (DAT_00557704 != '\0') {
        local_3c = local_3c << 0x18 | (local_3c & 0xff00) << 8 | (local_3c & 0xff0000) >> 8 |
                   local_3c >> 0x18;
      }
      iVar3 = FUN_004ba050(param_1,param_2[3],(char *)&local_3c,0x14);
    }
  }
  return iVar3;
}



int FUN_0041b074(int *param_1,uint *param_2,undefined4 *param_3)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  uint uVar4;
  char *pcVar5;
  ulong uVar6;
  undefined4 *local_res8;
  uint local_58;
  int local_54;
  int local_50;
  char *local_40;
  uint local_3c;
  undefined1 auStack_38 [16];
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  
  local_40 = (char *)0x0;
  local_54 = 0;
  local_50 = 0;
  bVar2 = false;
  bVar1 = false;
  memset(param_2,0,0x34);
  local_res8 = param_3;
  do {
    pcVar5 = (char *)*local_res8;
    local_res8 = local_res8 + 1;
    if (pcVar5 == (char *)0x0) {
LAB_0041b388:
      if (local_50 == 0) {
        if (((bVar1) || (bVar2)) || (*param_2 != 0)) {
          local_50 = FUN_004ba1f8(param_1,"cur_rateset",(char *)&local_3c,0x34);
          if (local_50 == 0) {
            if (*param_2 == 0) {
              *param_2 = local_3c;
              memcpy(param_2 + 1,auStack_38,*param_2);
            }
            if (!bVar1) {
              param_2[5] = local_28;
              param_2[6] = local_24;
              param_2[7] = local_20;
              param_2[8] = local_1c;
            }
            if (!bVar2) {
              param_2[9] = local_18;
              param_2[10] = local_14;
              param_2[0xb] = local_10;
              param_2[0xc] = local_c;
            }
            if (pcVar5 != (char *)0x0) {
              while( true ) {
                pcVar5 = (char *)*local_res8;
                local_res8 = local_res8 + 1;
                if (pcVar5 == (char *)0x0) break;
                if (bVar1) {
                  if (0xf < local_54) {
                    fprintf(stderr,"parsing \"%s\", too many mcs rates specified, max is %d rates\n"
                            ,pcVar5,0x10);
                    return -0x2c;
                  }
                  uVar6 = strtoul(pcVar5,&local_40,0x10);
                  if (local_40 == pcVar5) {
                    fprintf(stderr,"unable to convert the mcs parameter \"%s\"\n",pcVar5);
                    return -2;
                  }
                  if (uVar6 == 0) {
                    memset(param_2 + 5,0,0x10);
                    return 0;
                  }
                  *(char *)((int)param_2 + local_54 + 0x14) = (char)uVar6;
                  local_54 = local_54 + 1;
                }
                else {
                  if (7 < local_54) {
                    fprintf(stderr,"Error: Too many VHT rate masks specified, max %d\n",8);
                    return -0x2c;
                  }
                  uVar6 = strtoul(pcVar5,&local_40,0x10);
                  if ((*pcVar5 == '\0') || (*local_40 != '\0')) {
                    fprintf(stderr,"Error converting VHT rate mask value \'%s\'\n",pcVar5);
                    return -0x2c;
                  }
                  if (((uVar6 != 0) && (uVar6 != 0xff)) && ((uVar6 != 0x1ff && (uVar6 != 0x3ff)))) {
                    fwrite("Error: VHT rate mask must be 0 (disabled), 0xff (MCS0-7), 0x1ff (MCS0-8), or 0x3ff (MCS0-9).\n"
                           ,1,0x5d,stderr);
                    return -2;
                  }
                  *(short *)((int)param_2 + (local_54 + 0x10) * 2 + 4) = (short)uVar6;
                  local_54 = local_54 + 1;
                }
              }
            }
          }
        }
        else {
          local_50 = -0x2c;
        }
      }
      return local_50;
    }
    iVar3 = strcasecmp(pcVar5,"-m");
    if (iVar3 == 0) {
      bVar1 = true;
      goto LAB_0041b388;
    }
    iVar3 = strcasecmp(pcVar5,"-v");
    if (iVar3 == 0) {
      bVar2 = true;
      goto LAB_0041b388;
    }
    if (0xf < *param_2) {
      fprintf(stderr,"parsing \"%s\", too many rates specified, max is %d rates\n",pcVar5,0x10);
      local_50 = -0x2c;
      goto LAB_0041b388;
    }
    uVar6 = strtoul(pcVar5,&local_40,0);
    local_58 = uVar6 * 2;
    if (local_40 == pcVar5) {
      fprintf(stderr,"unable to convert the rate parameter \"%s\"\n",pcVar5);
      local_50 = -0x2c;
      goto LAB_0041b388;
    }
    iVar3 = strncmp(local_40,".5",2);
    if (iVar3 == 0) {
      local_58 = local_58 + 1;
      local_40 = local_40 + 2;
    }
    while ((*(ushort *)(__ctype_b + *local_40 * 2) & 0x20) != 0) {
      local_40 = local_40 + 1;
    }
    iVar3 = strcasecmp(local_40,"b");
    if ((iVar3 == 0) || (iVar3 = strcasecmp(local_40,"(b)"), iVar3 == 0)) {
      local_58 = local_58 | 0x80;
    }
    else if (*local_40 != '\0') {
      fprintf(stderr,"unable to convert trailing characters \"%s\" in the rate parameter \"%s\"\n",
              local_40,pcVar5);
      local_50 = -0x2c;
      goto LAB_0041b388;
    }
    if ((*param_2 == 0) && (local_58 == 0)) {
      fwrite("empty legacy rateset not supported\n",1,0x23,stderr);
      local_50 = -0x2c;
      goto LAB_0041b388;
    }
    uVar4 = *param_2;
    *(char *)((int)param_2 + uVar4 + 4) = (char)local_58;
    *param_2 = uVar4 + 1;
  } while( true );
}



undefined4 FUN_0041b798(int param_1,undefined4 *param_2)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  char *pcVar5;
  int iVar6;
  ulong uVar7;
  undefined4 *local_res4;
  uint local_40;
  int local_3c;
  byte local_38;
  byte local_37;
  byte local_36;
  uint local_34;
  char *local_20;
  undefined1 auStack_1c [4];
  ushort auStack_18 [4];
  undefined1 auStack_10 [8];
  
  local_20 = (char *)0x0;
  local_3c = 0;
  local_38 = 0;
  local_37 = 0;
  bVar4 = false;
  bVar1 = false;
  bVar3 = false;
  bVar2 = false;
  pcVar5 = (char *)*param_2;
  iVar6 = strcasecmp(pcVar5,"-m");
  local_res4 = param_2;
  if ((iVar6 != 0) && (iVar6 = strcasecmp(pcVar5,"-v"), iVar6 != 0)) {
    local_3c = 0;
    bVar4 = true;
    local_36 = 0;
  }
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            pcVar5 = (char *)*local_res4;
            local_res4 = local_res4 + 1;
            if (pcVar5 == (char *)0x0) {
              if ((bVar1) && (!bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_38; local_40 = local_40 + 1) {
                  *(undefined1 *)(param_1 + local_40) = auStack_1c[local_40];
                }
                if (local_38 != 0) {
                  for (local_40 = (uint)local_38; (int)local_40 < 4; local_40 = local_40 + 1) {
                    *(undefined1 *)(param_1 + local_40) = 0;
                  }
                }
              }
              if ((bVar3) && (!bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_37; local_40 = local_40 + 1) {
                  *(ushort *)(param_1 + (local_40 + 4) * 2) = auStack_18[local_40];
                }
                if (local_37 != 0) {
                  for (local_40 = (uint)local_37; (int)local_40 < 4; local_40 = local_40 + 1) {
                    *(undefined2 *)(param_1 + (local_40 + 4) * 2) = 0;
                  }
                }
              }
              if ((bVar4) && (!bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_36; local_40 = local_40 + 1) {
                  *(undefined1 *)(param_1 + local_40 + 0x18) = auStack_10[local_40];
                }
                *(byte *)(param_1 + 0x28) = local_36;
              }
              if ((bVar1) && (bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_38; local_40 = local_40 + 1) {
                  *(undefined1 *)(param_1 + local_40 + 4) = auStack_1c[local_40];
                }
                if (local_38 != 0) {
                  for (local_40 = (uint)local_38; (int)local_40 < 4; local_40 = local_40 + 1) {
                    *(undefined1 *)(param_1 + local_40 + 4) = 0;
                  }
                }
              }
              if ((bVar3) && (bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_37; local_40 = local_40 + 1) {
                  *(ushort *)(param_1 + (local_40 + 8) * 2) = auStack_18[local_40];
                }
                if (local_37 != 0) {
                  for (local_40 = (uint)local_37; (int)local_40 < 4; local_40 = local_40 + 1) {
                    *(undefined2 *)(param_1 + (local_40 + 8) * 2) = 0;
                  }
                }
              }
              if ((bVar4) && (bVar2)) {
                for (local_40 = 0; (int)local_40 < (int)(uint)local_36; local_40 = local_40 + 1) {
                  *(undefined1 *)(param_1 + local_40 + 0x20) = auStack_10[local_40];
                }
                *(byte *)(param_1 + 0x29) = local_36;
              }
              return 0;
            }
            iVar6 = strcasecmp(pcVar5,"-m");
            if (iVar6 != 0) break;
            local_3c = 1;
            bVar1 = true;
            local_38 = 0;
          }
          iVar6 = strcasecmp(pcVar5,"-v");
          if (iVar6 != 0) break;
          local_3c = 2;
          bVar3 = true;
          local_37 = 0;
        }
        iVar6 = strcasecmp(pcVar5,"-b");
        if (iVar6 != 0) break;
        bVar2 = true;
      }
      if (local_3c == 0) break;
      if (local_3c == 1) {
        if (3 < local_38) {
          fprintf(stderr,"ERR: exceed max. %d bitmask bytes; parsing %s\n",4,pcVar5);
          return 0xfffffffe;
        }
        uVar7 = strtoul(pcVar5,&local_20,0x10);
        if (local_20 == pcVar5) {
          fprintf(stderr,"ERR: failed to convert %s\n",pcVar5);
          return 0xffffffd4;
        }
        auStack_1c[local_38] = (char)uVar7;
        local_38 = local_38 + 1;
      }
      else if (local_3c == 2) {
        if (3 < local_37) {
          fprintf(stderr,"ERR: exceed max. %d bitmasks; parsing %s\n",4,pcVar5);
          return 0xfffffffe;
        }
        uVar7 = strtoul(pcVar5,&local_20,0x10);
        if (local_20 == pcVar5) {
          fprintf(stderr,"ERR: failed to convert %s\n",pcVar5);
          return 0xffffffd4;
        }
        if (0x3ff < (ushort)uVar7) {
          fwrite("ERR: vht bitmask must be 0 (disabled) or up to a maximum of 3ff (MCS0-9).\n",1,
                 0x4a,stderr);
          return 0xfffffffe;
        }
        auStack_18[local_37] = (ushort)uVar7;
        local_37 = local_37 + 1;
      }
    }
    if (7 < local_36) {
      fprintf(stderr,"ERR: more than max. of %d ofdm rates\n",8);
      return 0xffffffd4;
    }
    uVar7 = strtoul(pcVar5,&local_20,0);
    local_34 = uVar7 << 1;
    if (local_20 == pcVar5) {
      fprintf(stderr,"ERR: failed to convert %s\n",pcVar5);
      return 0xffffffd4;
    }
    for (local_40 = 0; (int)local_40 < 8; local_40 = local_40 + 1) {
      if (((byte)(&DAT_004ed834)[local_40] & 0x7f) == local_34) {
        local_34 = (uint)(byte)(&DAT_004ed834)[local_40];
        break;
      }
    }
    if (7 < (int)local_40) {
      fprintf(stderr,"ERR: %s is an invalid ofdm rate\n",pcVar5);
      return 0xffffffd4;
    }
    while ((*(ushort *)(__ctype_b + *local_20 * 2) & 0x20) != 0) {
      local_20 = local_20 + 1;
    }
    if ((*(char *)(param_1 + 0x28) == '\0') && (local_34 == 0)) {
      fwrite("ERR: no ofdm rate specified\n",1,0x1c,stderr);
      return 0xffffffd4;
    }
    auStack_10[local_36] = (char)local_34;
    local_36 = local_36 + 1;
  } while( true );
}



int FUN_0041c0b8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  long lVar3;
  int local_1c;
  byte local_18;
  byte local_17;
  byte local_16;
  byte local_15;
  byte local_14;
  byte local_13;
  char *apcStack_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_18,6);
    if (-1 < iVar2) {
      puts("- Link Power Control parameters -");
      printf("rate_stab_thresh\t= %d\npwr_stab_thresh\t\t= %d\n",(uint)local_18,(uint)local_17);
      printf("lpc_exp_time\t\t= %d\npwrup_slow_step\t\t= %d\n",(uint)local_16,(uint)local_15);
      printf("pwrup_fast_step\t\t= %d\npwrdn_slow_step\t\t= %d\n",(uint)local_14,(uint)local_13);
    }
  }
  else {
    for (local_1c = 0; piVar1[local_1c] != 0; local_1c = local_1c + 1) {
    }
    if (local_1c == 6) {
      lVar3 = strtol((char *)*piVar1,apcStack_10,0);
      local_18 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 8),apcStack_10,0);
      local_17 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0xc),apcStack_10,0);
      local_16 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0x10),apcStack_10,0);
      local_15 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0x14),apcStack_10,0);
      local_14 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0x18),apcStack_10,0);
      local_13 = (byte)lVar3;
      iVar2 = FUN_004ba2e4(param_1,(char *)*param_2,&local_18,6);
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_0041c3c0(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int local_20;
  undefined4 local_1c;
  ulong local_18;
  char *local_14;
  uint *local_10 [2];
  
  local_1c = 0;
  local_18 = 0;
  local_14 = (char *)0x0;
  local_10[0] = (uint *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    fprintf(stderr,"%s: band unspecified\n",(char *)*param_2);
    local_20 = -0x2c;
  }
  else {
    iVar2 = strcmp((char *)*piVar1,"a");
    if (((iVar2 == 0) || (iVar2 = strcmp((char *)*piVar1,"5"), iVar2 == 0)) ||
       (iVar2 = strcmp((char *)*piVar1,"5g"), iVar2 == 0)) {
      local_1c = 1;
    }
    else {
      iVar2 = strcmp((char *)*piVar1,"b");
      if (((iVar2 != 0) && (iVar2 = strcmp((char *)*piVar1,"2"), iVar2 != 0)) &&
         (iVar2 = strcmp((char *)*piVar1,"2g"), iVar2 != 0)) {
        fprintf(stderr,"%s: invalid band %s\n",(char *)*param_2,(char *)*piVar1);
        return -0x2c;
      }
      local_1c = 2;
    }
    piVar1 = (int *)(param_3 + 8);
    if (*piVar1 != 0) {
      local_14 = (char *)0x0;
      local_18 = strtoul((char *)*piVar1,&local_14,0);
      if ((local_14 != (char *)0x0) && (*local_14 != '\0')) {
        fprintf(stderr,"%s: invalid bandwidth \'%s\'\n",(char *)*param_2,(char *)*piVar1);
        return -0x2c;
      }
    }
    if (local_18 == 0) {
      local_20 = FUN_00445198(param_1,(char *)*param_2,&local_1c,8,local_10);
      if (-1 < local_20) {
        printf("0x%x\n",*local_10[0]);
      }
    }
    else {
      local_20 = FUN_00445444(param_1,(char *)*param_2,&local_1c,8);
    }
  }
  return local_20;
}



int FUN_0041c6d8(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_14;
  uint local_10;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    memset(&local_14,0,0xc);
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_14,0xc);
    if (-1 < iVar2) {
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
        local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                   local_10 >> 0x18;
      }
      if (local_c == 0) {
        puts("No scan in progress.");
      }
      else {
        puts("Scan in progress.");
        printf("current scan channel\t%d\n",local_c);
      }
      printf("current mac channel\t%d\n",local_14);
      printf("target channel\t%d\n",local_10);
      iVar2 = 0;
    }
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10 = atoi((char *)*piVar1);
    }
    else {
      uVar3 = atoi((char *)*piVar1);
      local_10 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_10,4);
  }
  return iVar2;
}



int FUN_0041c9d8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  ushort uVar5;
  int iVar6;
  int *local_res8;
  int local_bc;
  ushort local_b8;
  undefined4 auStack_ac [3];
  int local_a0;
  char local_9b;
  char local_9a;
  char *local_18;
  int local_10;
  uint local_c;
  
  bVar3 = false;
  bVar2 = false;
  bVar4 = false;
  bVar1 = false;
  local_c = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    if ((int)param_2[2] < 0) {
      local_bc = -1;
    }
    else {
      local_bc = FUN_004ba35c(param_1,(char *)*param_2,&local_c);
      if (-1 < local_bc) {
        uVar5 = FUN_00402eb0(local_c);
        FUN_004c02bc(uVar5,PTR_DAT_00551644);
        printf("%s (0x%x)\n",PTR_DAT_00551644,(uint)uVar5);
        local_bc = 0;
      }
    }
  }
  else {
    local_b8 = FUN_004c0638((char *)*local_res8);
    if (local_b8 == 0) {
      FUN_004cbd80(auStack_ac,"wl_chanspec",0,0);
      while (iVar6 = FUN_004cbe18(auStack_ac,local_res8), iVar6 != -1) {
        if (iVar6 == 1) {
          return -0x2c;
        }
        local_res8 = local_res8 + local_a0;
        if (local_9a == 'c') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for the channel\n","wl_chanspec",
                    local_18);
            return -2;
          }
          if (0xe0 < local_10) {
            fprintf(stderr,"%s: invalid channel %d\n","wl_chanspec",local_10);
            return -2;
          }
          local_b8 = (ushort)local_10 | local_b8;
          bVar2 = true;
        }
        if (local_9a == 'b') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for band\n","wl_chanspec",local_18)
            ;
            return -2;
          }
          if ((local_10 != 5) && (local_10 != 2)) {
            fprintf(stderr,"%s: invalid band %d\n","wl_chanspec",local_10);
            return -2;
          }
          if (local_10 == 5) {
            local_b8 = local_b8 | 0xc000;
          }
          bVar3 = true;
        }
        if (local_9a == 'w') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for bandwidth\n","wl_chanspec",
                    local_18);
            return -2;
          }
          if (((local_10 != 0x14) && (local_10 != 0x28)) && (local_10 != 0x50)) {
            fprintf(stderr,"%s: invalid bandwidth %d\n","wl_chanspec",local_10);
            return -2;
          }
          if (local_10 == 0x14) {
            local_b8 = local_b8 | 0x1000;
          }
          else if (local_10 == 0x28) {
            local_b8 = local_b8 | 0x1800;
          }
          else {
            local_b8 = local_b8 | 0x2000;
          }
          bVar4 = true;
        }
        if (local_9a == 's') {
          if (local_9b == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for ctl sideband\n","wl_chanspec",
                    local_18);
            return -2;
          }
          if (((local_10 != 1) && (local_10 != 0)) && (local_10 != -1)) {
            fprintf(stderr,"%s: invalid ctl sideband %d\n","wl_chanspec",local_10);
            return -2;
          }
          if ((local_10 != -1) && (local_10 == 1)) {
            local_b8 = local_b8 | 0x100;
          }
          bVar1 = true;
        }
      }
      if ((!bVar1) && ((local_b8 & 0x3800) == 0x1000)) {
        bVar1 = true;
      }
      if ((((bVar2) && (bVar3)) && (bVar4)) && (bVar1)) {
        local_c = FUN_00402d10(local_b8);
        if (local_c == 0xff) {
          local_bc = -0x2c;
        }
        else {
          local_bc = FUN_004ba428(param_1,(char *)*param_2,local_c);
        }
      }
      else {
        if (!bVar2) {
          fprintf(stderr,"%s: you need to set a channel, \'-c <ch>\'\n","wl_chanspec");
        }
        if (!bVar3) {
          fprintf(stderr,"%s: you need to set a band, \'-b <5|2>\'\n","wl_chanspec");
        }
        if (!bVar4) {
          fprintf(stderr,"%s: you need to set a bandwidth, \'-w <20|40>\'\n","wl_chanspec");
        }
        if (!bVar1) {
          fprintf(stderr,"%s: you need to set a ctl sideband, \'-s <-1|0|1>\'\n","wl_chanspec");
        }
        local_bc = -0x2c;
      }
    }
    else {
      local_c = FUN_00402d10(local_b8);
      if (local_c == 0xff) {
        local_bc = -0x2c;
      }
      else {
        local_bc = FUN_004ba428(param_1,(char *)*param_2,local_c);
      }
    }
    if (local_bc == 0) {
      printf("Chanspec set to 0x%x\n",(uint)local_b8);
    }
  }
  return local_bc;
}



int FUN_0041d140(int *param_1,undefined4 *param_2,int param_3)

{
  int local_18;
  ushort local_14 [2];
  uint *local_10 [2];
  
  local_18 = -0x2c;
  local_14[0] = 0;
  if (*(int *)(param_3 + 4) != 0) {
    local_14[0] = FUN_004c0638(*(char **)(param_3 + 4));
    if (local_14[0] != 0) {
      local_18 = FUN_00445198(param_1,(char *)*param_2,local_14,2,local_10);
      if (local_18 == 0) {
        printf("rclass=0x%x\n",*local_10[0]);
      }
      else {
        printf("Read rclass fails: chanspec:0x%x\n",(uint)local_14[0]);
      }
    }
  }
  return local_18;
}



int FUN_0041d23c(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  int iVar2;
  undefined2 extraout_var;
  uint param1;
  int local_20;
  uint local_10 [2];
  
  for (local_20 = 0; ((undefined4 *)(param_3 + 4))[local_20] != 0; local_20 = local_20 + 1) {
  }
  if (local_20 == 1) {
    uVar1 = FUN_004c0638(*(char **)(param_3 + 4));
    local_10[0] = CONCAT22(extraout_var,uVar1);
    local_10[0] = FUN_00402d10(uVar1);
    if (local_10[0] == 0xff) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,local_10,4,PTR_DAT_00551644,0x100);
      if (-1 < iVar2) {
        param1 = *(uint *)PTR_DAT_00551644;
        if (DAT_00557704 != '\0') {
          param1 = param1 << 0x18 | (param1 & 0xff00) << 8 | (param1 & 0xff0000) >> 8 |
                   param1 >> 0x18;
        }
        printf("%d\n",param1);
        iVar2 = 0;
      }
    }
  }
  else {
    iVar2 = -0x2c;
  }
  return iVar2;
}



int FUN_0041d3f4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char *local_14;
  uint local_10 [2];
  
  if (*(int *)(param_3 + 4) != 0) {
    local_10[0] = 1;
    lVar2 = strtol(*(char **)(param_3 + 4),&local_14,0);
    if (*local_14 != '\0') {
      return -0x2c;
    }
    if (lVar2 == 1) {
      local_10[0] = 1;
    }
    else if (lVar2 < 2) {
      if (lVar2 != 0) {
        return -2;
      }
      local_10[0] = 0;
    }
    else if (lVar2 == 2) {
      local_10[0] = 2;
    }
    else {
      if (lVar2 != 3) {
        return -2;
      }
      local_10[0] = 3;
    }
    if (DAT_00557704 != '\0') {
      local_10[0] = local_10[0] << 0x18;
    }
    iVar1 = FUN_004ba428(param_1,(char *)*param_2,local_10[0]);
    return iVar1;
  }
  if ((int)param_2[2] < 0) {
    return -1;
  }
  iVar1 = FUN_004ba35c(param_1,(char *)*param_2,local_10);
  if (-1 < iVar1) {
    if (local_10[0] == 1) {
      puts("CHANIM mode: detect only.");
    }
    else if ((int)local_10[0] < 2) {
      if (local_10[0] == 0) {
        puts("CHANIM mode: disabled.");
      }
    }
    else if (local_10[0] == 2) {
      puts("CHANIM mode: external (acsd).");
    }
    else if (local_10[0] == 3) {
      puts("CHANIM mode: detect + act.");
    }
    return 0;
  }
  return iVar1;
}



bool FUN_0041d6ac(char *param_1,void *param_2)

{
  ulong uVar1;
  char *local_res0;
  int local_10;
  char *local_c;
  
  local_c = (char *)0x0;
  local_10 = 0;
  memset(param_2,0,6);
  local_res0 = param_1;
  do {
    uVar1 = strtoul(local_res0,&local_c,0x10);
    *(char *)((int)param_2 + local_10) = (char)uVar1;
    local_10 = local_10 + 1;
    local_res0 = local_c + 1;
    if (*local_c == '\0') break;
    local_c = local_res0;
  } while (local_10 != 6);
  return local_10 == 6;
}



undefined1 * FUN_0041d780(int param_1)

{
  int iVar1;
  char *local_10;
  int local_c;
  
  local_10 = &DAT_00559c98;
  for (local_c = 0; local_c < 6; local_c = local_c + 1) {
    if (local_c != 0) {
      *local_10 = ':';
      local_10 = local_10 + 1;
    }
    iVar1 = sprintf(local_10,"%02X",(uint)*(byte *)(param_1 + local_c));
    local_10 = local_10 + iVar1;
  }
  return &DAT_00559c98;
}



bool FUN_0041d840(char *param_1,int param_2)

{
  ulong uVar1;
  char *local_res0;
  int local_10;
  char *local_c;
  
  local_c = (char *)0x0;
  local_10 = 0;
  local_res0 = param_1;
  do {
    uVar1 = strtoul(local_res0,&local_c,0);
    *(char *)(param_2 + local_10) = (char)uVar1;
    local_10 = local_10 + 1;
    local_res0 = local_c + 1;
    if (*local_c != '.') break;
    local_c = local_res0;
  } while (local_10 != 4);
  return local_10 == 4;
}



undefined4 FUN_0041d904(char *param_1,char *param_2)

{
  undefined4 uVar1;
  char *local_res4;
  int local_20;
  char *local_1c;
  int local_18;
  int local_14;
  
  local_18 = 0;
  local_14 = 0;
  local_1c = param_1;
  if ((*param_1 == ':') && (param_1[1] != ':')) {
    uVar1 = 1;
  }
  else {
    while (local_1c = strstr(local_1c,"::"), local_1c != (char *)0x0) {
      local_1c = local_1c + 1;
      local_14 = local_14 + 1;
    }
    if (local_14 == 0) {
      strcpy(param_2,param_1);
      uVar1 = 0;
    }
    else {
      local_1c = param_1;
      if (local_14 < 2) {
        while (local_1c = strchr(local_1c,0x3a), local_1c != (char *)0x0) {
          local_1c = local_1c + 1;
          local_18 = local_18 + 1;
        }
        local_res4 = param_2;
        local_1c = param_1;
        if (-local_18 == -8) {
          strcpy(param_2,param_1);
        }
        else {
          while (*local_1c != '\0') {
            if ((*local_1c == ':') && (local_1c[1] == ':')) {
              if (local_1c == param_1) {
                *local_res4 = '0';
                local_res4 = local_res4 + 1;
              }
              *local_res4 = *local_1c;
              local_res4 = local_res4 + 1;
              for (local_20 = 0; local_20 < -local_18 + 8; local_20 = local_20 + 1) {
                *local_res4 = '0';
                local_res4[1] = ':';
                local_res4 = local_res4 + 2;
              }
              local_1c = local_1c + 2;
            }
            else {
              *local_res4 = *local_1c;
              local_res4 = local_res4 + 1;
              local_1c = local_1c + 1;
            }
          }
        }
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
    }
  }
  return uVar1;
}



bool FUN_0041dbbc(char *param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  ulong uVar3;
  int local_60;
  char *local_5c;
  char *local_50;
  char acStack_4c [68];
  
  local_50 = (char *)0x0;
  local_60 = 0;
  local_5c = acStack_4c;
  memset(acStack_4c,0,0x40);
  iVar2 = FUN_0041d904(param_1,acStack_4c);
  if (iVar2 == 1) {
    bVar1 = false;
  }
  else {
    do {
      uVar3 = strtoul(local_5c,&local_50,0x10);
      *(ushort *)(param_2 + local_60) = (ushort)uVar3 << 8 | (ushort)uVar3 >> 8;
      local_60 = local_60 + 2;
      local_5c = local_50 + 1;
      if (*local_50 != ':') break;
      local_50 = local_5c;
    } while (local_60 != 0x10);
    bVar1 = local_60 == 0x10;
  }
  return bVar1;
}



undefined * FUN_0041dd00(int param_1)

{
  ushort uVar1;
  int iVar2;
  char *local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  byte *local_14;
  
  local_28 = &DAT_00559b98 + (DAT_00559b94 % 4) * 0x40;
  DAT_00559b94 = DAT_00559b94 + 1;
  local_20 = -1;
  local_1c = 0;
  local_18 = 1;
  local_14 = (byte *)0x0;
  for (local_24 = 0; local_24 < 8; local_24 = local_24 + 1) {
    if (*(short *)(param_1 + local_24 * 2) == 0) {
      local_1c = local_1c + 1;
    }
    else {
      if (local_18 < local_1c) {
        local_18 = local_1c;
        local_20 = local_24 - local_1c;
      }
      local_1c = 0;
    }
  }
  if (local_18 < local_1c) {
    local_18 = local_1c;
    local_20 = local_24 - local_1c;
  }
  if ((local_20 == 0) &&
     ((((local_18 == 4 && (*(short *)(param_1 + 8) == -1)) && (*(short *)(param_1 + 10) == 0)) ||
      ((local_18 == 5 && (*(short *)(param_1 + 10) == -1)))))) {
    local_14 = (byte *)(param_1 + 0xc);
  }
  local_24 = 0;
  do {
    if (7 < local_24) {
LAB_0041e028:
      return &DAT_00559b98 + ((uint)(local_28 + -0x559b98) & 0xffffffc0);
    }
    if ((byte *)(param_1 + local_24 * 2) == local_14) {
      sprintf(local_28,":%u.%u.%u.%u",(uint)*local_14,(uint)local_14[1],(uint)local_14[2],
              (uint)local_14[3]);
      goto LAB_0041e028;
    }
    if (local_24 == local_20) {
      *local_28 = ':';
      local_24 = local_24 + local_18 + -1;
      local_28[1] = ':';
      local_28[2] = '\0';
      local_28 = local_28 + 1;
    }
    else {
      if (local_24 != 0) {
        *local_28 = ':';
        local_28 = local_28 + 1;
      }
      uVar1 = *(ushort *)(param_1 + local_24 * 2);
      iVar2 = sprintf(local_28,"%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
      local_28 = local_28 + iVar2;
    }
    local_24 = local_24 + 1;
  } while( true );
}



undefined * FUN_0041e064(byte *param_1)

{
  sprintf(&DAT_00559b84,"%u.%u.%u.%u",(uint)*param_1,(uint)param_1[1],(uint)param_1[2],
          (uint)param_1[3]);
  return &DAT_00559b84;
}



int FUN_0041e0e8(byte *param_1,int param_2,int param_3)

{
  uint param2;
  int iVar1;
  int local_res8;
  int local_18;
  byte *local_14;
  
  local_res8 = param_3;
  if (0x20 < param_3) {
    local_res8 = 0x20;
  }
  local_14 = param_1;
  for (local_18 = 0; local_18 < local_res8; local_18 = local_18 + 1) {
    param2 = (uint)*(byte *)(param_2 + local_18);
    if (param2 == 0x5c) {
      *local_14 = 0x5c;
      local_14[1] = 0x5c;
      local_14 = local_14 + 2;
    }
    else if ((*(ushort *)(__ctype_b + param2 * 2) & 0x40) == 0) {
      iVar1 = sprintf((char *)local_14,"\\x%02X",param2);
      local_14 = local_14 + iVar1;
    }
    else {
      *local_14 = *(byte *)(param_2 + local_18);
      local_14 = local_14 + 1;
    }
  }
  *local_14 = 0;
  return (int)local_14 - (int)param_1;
}



void FUN_0041e248(int param_1,uint param_2)

{
  int iVar1;
  char *local_110;
  uint local_10c;
  char acStack_108 [256];
  
  if (param_2 == 0) {
    putchar(10);
  }
  else {
    local_110 = acStack_108;
    for (local_10c = 0; local_10c < param_2; local_10c = local_10c + 1) {
      if (((local_10c & 0xf) == 0) && (0x10 < param_2)) {
        iVar1 = sprintf(local_110,"%04d: ",local_10c);
        local_110 = local_110 + iVar1;
      }
      iVar1 = sprintf(local_110,"%02x ",(uint)*(byte *)(param_1 + local_10c));
      local_110 = local_110 + iVar1;
      if ((local_10c & 0xf) == 0xf) {
        puts(acStack_108);
        local_110 = acStack_108;
      }
    }
    if (local_110 != acStack_108) {
      puts(acStack_108);
    }
  }
  return;
}



int FUN_0041e390(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_c,4);
    if (-1 < iVar2) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
      }
      if (local_c == 0xffffffff) {
        printf("long");
      }
      else if (local_c == 0) {
        printf("auto");
      }
      else if (local_c == 1) {
        printf("debug");
      }
      else {
        printf("unknown");
      }
      putchar(10);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = strcasecmp((char *)*piVar1,"long");
    if (iVar2 == 0) {
      local_c = 0xffffffff;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"auto");
      if (iVar2 == 0) {
        local_c = 0;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"debug");
        if (iVar2 != 0) {
          return -0x2c;
        }
        local_c = 1;
      }
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_c,4);
  }
  return iVar2;
}



int FUN_0041e644(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      iVar2 = -1;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_14,4);
      if (-1 < iVar2) {
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
        }
        printf("0x%04x\n",local_14);
        iVar2 = 0;
      }
    }
  }
  else if (*(int *)(param_2 + 0xc) < 0) {
    iVar2 = -1;
  }
  else {
    iVar2 = strcasecmp((char *)*piVar1,"on");
    if (iVar2 == 0) {
      local_14 = 0x10000;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"off");
      if (iVar2 == 0) {
        local_14 = 0x10001;
      }
      else {
        local_14 = strtol((char *)*piVar1,local_10,0);
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
        if (local_14 >> 0x10 == 0) {
          local_14 = local_14 << 0x10 | local_14;
        }
      }
    }
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_14,4);
  }
  return iVar2;
}



undefined * FUN_0041e8e8(uint param_1,uint param_2)

{
  if (param_1 >> 0x10 < 0x3e9) {
    sprintf(&DAT_00559b20,"%d.%d RC%d.%d",param_1 >> 0x10,param_1 & 0xffff,param_2 >> 0x10,
            param_2 & 0xffff);
  }
  else {
    sprintf(&DAT_00559b20,"%d/%d/%d build %d",param_1 & 0xffff,param_2 >> 0x10,param_1 >> 0x10,
            param_2 & 0xffff);
  }
  return &DAT_00559b20;
}



int FUN_0041e9ec(int *param_1)

{
  char *pcVar1;
  char *pcVar2;
  int local_18;
  uint local_c;
  
  local_c = 0;
  pcVar1 = FUN_0041e8e8(0x7002d,0x600000);
  puts(pcVar1);
  pcVar1 = (char *)malloc(0x100);
  if (pcVar1 == (char *)0x0) {
    fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x100);
    local_18 = -0x1b;
  }
  else {
    memset(pcVar1,0,0x100);
    local_18 = FUN_004ba1f8(param_1,"ver",pcVar1,0x100);
    if ((local_18 != 0) && (FUN_004ba35c(param_1,"bcmerror",&local_c), local_c == 0xffffffe9)) {
      local_18 = FUN_004b9f94(param_1,6,pcVar1,0x100);
    }
    if (local_18 == 0) {
      pcVar2 = strchr(pcVar1,10);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '\0';
      }
      puts(pcVar1);
      free(pcVar1);
      local_18 = 0;
    }
    else {
      fprintf(stderr,"Error %d on query of driver dump\n",local_18);
      free(pcVar1);
    }
  }
  return local_18;
}



undefined4 FUN_0041eba0(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  uint uVar3;
  uint local_10;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10 = atoi((char *)*piVar1);
    }
    else {
      uVar3 = atoi((char *)*piVar1);
      local_10 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    piVar1 = (int *)(param_3 + 8);
    if (*piVar1 == 0) {
      uVar2 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_c = atoi((char *)*piVar1);
      }
      else {
        uVar3 = atoi((char *)*piVar1);
        local_c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      uVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_10,0x10);
    }
  }
  return uVar2;
}



int FUN_0041ed48(char *param_1,int param_2,int param_3,int param_4)

{
  size_t sVar1;
  int local_res8;
  char *local_18;
  char *local_14;
  
  local_res8 = param_3;
  local_18 = param_1;
  if (param_1 == (char *)0x0) {
    local_res8 = -1;
  }
  else {
    while (local_18 != (char *)0x0) {
      local_14 = strchr(local_18,0x2c);
      if (local_14 != (char *)0x0) {
        *local_14 = '\0';
        local_14 = local_14 + 1;
      }
      sVar1 = strlen(local_18);
      if (0x20 < sVar1) {
        fprintf(stderr,"ssid <%s> exceeds %d\n",local_18,0x20);
        return -1;
      }
      if (*local_18 == '\0') {
        *(undefined4 *)(param_2 + local_res8 * 0x24) = 0;
      }
      if (local_res8 < param_4) {
        strcpy((char *)(param_2 + local_res8 * 0x24 + 4),local_18);
        sVar1 = strlen(local_18);
        *(size_t *)(param_2 + local_res8 * 0x24) = sVar1;
      }
      local_res8 = local_res8 + 1;
      local_18 = local_14;
    }
  }
  return local_res8;
}



undefined4
FUN_0041eee4(undefined4 param_1,undefined4 param_2,int param_3,void *param_4,uint *param_5)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  ushort uVar4;
  int *piVar5;
  char *pcVar6;
  size_t sVar7;
  int iVar8;
  undefined3 extraout_var;
  char *__s1;
  uint uVar9;
  int *local_res8;
  long local_1f8;
  size_t local_1f4;
  void *local_1f0;
  char *local_1ec;
  char local_1e8;
  int local_1e0;
  uint local_1dc;
  int local_1d8;
  char acStack_1b4 [64];
  char *local_174;
  uint auStack_170 [90];
  
  local_1f8 = 0;
  local_174 = (char *)0x0;
  local_1dc = 0;
  local_1d8 = 0;
  *(undefined4 *)((int)param_4 + 0x24) = 0xffffffff;
  *(undefined1 *)((int)param_4 + 0x28) = 0xff;
  *(undefined1 *)((int)param_4 + 0x29) = 0xff;
  *(undefined1 *)((int)param_4 + 0x2a) = 2;
  *(undefined1 *)((int)param_4 + 0x2b) = 0;
  *(undefined4 *)((int)param_4 + 0x2c) = 0xffffffff;
  *(undefined4 *)((int)param_4 + 0x30) = 0xffffffff;
  *(undefined4 *)((int)param_4 + 0x34) = 0xffffffff;
  *(undefined4 *)((int)param_4 + 0x38) = 0xffffffff;
  *(undefined4 *)((int)param_4 + 0x3c) = 0;
  memset(auStack_170,0,0x168);
  bVar1 = false;
  local_res8 = (int *)(param_3 + 4);
LAB_0041f858:
  do {
    __s1 = (char *)*local_res8;
    if (__s1 == (char *)0x0) {
      if (10 < local_1d8) {
        fprintf(stderr,"ssid count %d exceeds max of %d\n",local_1d8,10);
        return 0xfffffffe;
      }
      if (DAT_00557704 == '\0') {
        uVar9 = *(uint *)((int)param_4 + 0x2c);
      }
      else {
        uVar9 = *(uint *)((int)param_4 + 0x2c);
        uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
      }
      *(uint *)((int)param_4 + 0x2c) = uVar9;
      if (DAT_00557704 == '\0') {
        uVar9 = *(uint *)((int)param_4 + 0x30);
      }
      else {
        uVar9 = *(uint *)((int)param_4 + 0x30);
        uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
      }
      *(uint *)((int)param_4 + 0x30) = uVar9;
      if (DAT_00557704 == '\0') {
        uVar9 = *(uint *)((int)param_4 + 0x34);
      }
      else {
        uVar9 = *(uint *)((int)param_4 + 0x34);
        uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
      }
      *(uint *)((int)param_4 + 0x34) = uVar9;
      if (DAT_00557704 == '\0') {
        uVar9 = *(uint *)((int)param_4 + 0x38);
      }
      else {
        uVar9 = *(uint *)((int)param_4 + 0x38);
        uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
      }
      *(uint *)((int)param_4 + 0x38) = uVar9;
      for (local_1e0 = 0; local_1e0 < (int)local_1dc; local_1e0 = local_1e0 + 1) {
        if (DAT_00557704 == '\0') {
          uVar4 = *(ushort *)((int)param_4 + (local_1e0 + 0x20) * 2);
        }
        else if (DAT_00557704 == '\0') {
          uVar4 = *(ushort *)((int)param_4 + (local_1e0 + 0x20) * 2);
        }
        else {
          uVar4 = *(ushort *)((int)param_4 + (local_1e0 + 0x20) * 2);
          uVar4 = uVar4 << 8 | uVar4 >> 8;
        }
        *(ushort *)((int)param_4 + (local_1e0 + 0x20) * 2) = uVar4;
      }
      for (local_1e0 = 0; local_1e0 < local_1d8; local_1e0 = local_1e0 + 1) {
        if (DAT_00557704 == '\0') {
          uVar9 = auStack_170[local_1e0 * 9];
        }
        else {
          uVar9 = auStack_170[local_1e0 * 9];
          uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
        }
        auStack_170[local_1e0 * 9] = uVar9;
      }
      if (local_1d8 == 1) {
        local_1d8 = 0;
        memcpy(param_4,auStack_170,0x24);
      }
      if (local_1d8 < 1) {
        local_1f0 = (void *)((int)param_4 + (local_1dc + 0x20) * 2);
      }
      else {
        uVar9 = (local_1dc + 0x20) * 2 + 3 & 0xfffffffc;
        if (*param_5 < local_1d8 * 0x24 + uVar9) {
          fwrite("additional ssids exceed params_size\n",1,0x24,stderr);
          return 0xfffffffe;
        }
        local_1f0 = (void *)((int)param_4 + uVar9);
        memcpy(local_1f0,auStack_170,local_1d8 * 0x24);
        local_1f0 = (void *)((int)local_1f0 + local_1d8 * 0x24);
      }
      if (DAT_00557704 == '\0') {
        uVar9 = local_1d8 << 0x10 | local_1dc & 0xffff;
      }
      else {
        uVar9 = local_1dc << 0x18 | (local_1dc & 0xff00) << 8 | (local_1d8 << 0x10 & 0xff0000U) >> 8
                | (uint)(local_1d8 << 0x10) >> 0x18;
      }
      *(uint *)((int)param_4 + 0x3c) = uVar9;
      *param_5 = (int)local_1f0 + (local_1d8 * 0x24 - (int)param_4);
      return 0;
    }
    piVar5 = local_res8 + 1;
    bVar3 = false;
    memset(acStack_1b4,0,0x40);
    local_1e8 = '\0';
    bVar2 = false;
    local_1ec = __s1;
    if (bVar1) {
      bVar3 = true;
      local_res8 = piVar5;
    }
    else {
      iVar8 = strcmp(__s1,"--");
      if (iVar8 == 0) {
        bVar1 = true;
        local_res8 = piVar5;
        goto LAB_0041f858;
      }
      iVar8 = strncmp(__s1,"--",2);
      if (iVar8 == 0) {
        pcVar6 = strchr(__s1,0x3d);
        if (pcVar6 == (char *)0x0) {
          fprintf(stderr,"wl_scan: missing \" = \" in long param \"%s\"\n",__s1);
          return 0xffffffd4;
        }
        local_1f4 = (int)pcVar6 - (int)(__s1 + 2);
        if (0x3f < (int)local_1f4) {
          local_1f4 = 0x3f;
        }
        memcpy(acStack_1b4,__s1 + 2,local_1f4);
        local_res8 = piVar5;
        local_1ec = pcVar6 + 1;
        if (pcVar6[1] == '\0') {
          fprintf(stderr,"wl_scan: missing value after \" = \" in long param \"%s\"\n",__s1);
          return 0xffffffd4;
        }
      }
      else if (*__s1 == '-') {
        local_1e8 = __s1[1];
        sVar7 = strlen(__s1);
        if (2 < sVar7) {
          fprintf(stderr,"wl_scan: only single char options, error on param \"%s\"\n",__s1);
          return 0xfffffffe;
        }
        if (*piVar5 == 0) {
          fprintf(stderr,"wl_scan: missing value parameter after \"%s\"\n",__s1);
          return 0xffffffd4;
        }
        local_res8 = local_res8 + 2;
        local_1ec = (char *)*piVar5;
      }
      else {
        bVar3 = true;
        local_res8 = piVar5;
      }
    }
    if ((local_1ec != (char *)0x0) &&
       (local_1f8 = strtol(local_1ec,&local_174,0), *local_174 == '\0')) {
      bVar2 = true;
    }
    if ((((local_1e8 == 's') || (iVar8 = strcmp(acStack_1b4,"ssid"), iVar8 == 0)) || (bVar3)) &&
       (local_1d8 = FUN_0041ed48(local_1ec,(int)auStack_170,local_1d8,10), local_1d8 < 0)) {
      return 0xfffffffe;
    }
    if (((local_1e8 == 't') || (iVar8 = strcmp(acStack_1b4,"scan_type"), iVar8 == 0)) &&
       (iVar8 = strcmp(local_1ec,"active"), iVar8 != 0)) {
      iVar8 = strcmp(local_1ec,"passive");
      if (iVar8 == 0) {
        *(byte *)((int)param_4 + 0x2b) = *(byte *)((int)param_4 + 0x2b) | 1;
      }
      else {
        iVar8 = strcmp(local_1ec,"prohibit");
        if (iVar8 == 0) {
          *(byte *)((int)param_4 + 0x2b) = *(byte *)((int)param_4 + 0x2b) | 4;
        }
        else {
          iVar8 = strcmp(local_1ec,"offchan");
          if (iVar8 == 0) {
            *(byte *)((int)param_4 + 0x2b) = *(byte *)((int)param_4 + 0x2b) | 8;
          }
          else {
            iVar8 = strcmp(local_1ec,"hotspot");
            if (iVar8 != 0) {
              fprintf(stderr,
                      "scan_type value should be \"active\", \"passive\", \"prohibit\", \"offchan\" or \"hotspot\", but got \"%s\"\n"
                      ,local_1ec);
              return 0xffffffd4;
            }
            *(byte *)((int)param_4 + 0x2b) = *(byte *)((int)param_4 + 0x2b) | 0x10;
          }
        }
      }
    }
    iVar8 = strcmp(acStack_1b4,"bss_type");
    if (iVar8 == 0) {
      iVar8 = strcmp(local_1ec,"bss");
      if ((iVar8 == 0) || (iVar8 = strcmp(local_1ec,"infra"), iVar8 == 0)) {
        *(undefined1 *)((int)param_4 + 0x2a) = 0;
      }
      else {
        iVar8 = strcmp(local_1ec,"ibss");
        if ((iVar8 == 0) || (iVar8 = strcmp(local_1ec,"adhoc"), iVar8 == 0)) {
          *(undefined1 *)((int)param_4 + 0x2a) = 1;
        }
        else {
          iVar8 = strcmp(local_1ec,"any");
          if (iVar8 != 0) {
            fprintf(stderr,
                    "bss_type value should be \"bss\", \"ibss\", or \"any\", but got \"%s\"\n",
                    local_1ec);
            return 0xffffffd4;
          }
          *(undefined1 *)((int)param_4 + 0x2a) = 2;
        }
      }
    }
    if (((local_1e8 == 'b') || (iVar8 = strcmp(acStack_1b4,"bssid"), iVar8 == 0)) &&
       (bVar3 = FUN_0041d6ac(local_1ec,(void *)((int)param_4 + 0x24)),
       CONCAT31(extraout_var,bVar3) == 0)) {
      fprintf(stderr,"could not parse \"%s\" as an ethernet MAC address\n",local_1ec);
      return 0xffffffd4;
    }
    if ((local_1e8 == 'n') || (iVar8 = strcmp(acStack_1b4,"nprobes"), iVar8 == 0)) {
      if (!bVar2) {
        fprintf(stderr,"could not parse \"%s\" as an int for value nprobes\n",local_1ec);
        return 0xfffffffe;
      }
      *(long *)((int)param_4 + 0x2c) = local_1f8;
    }
    if ((local_1e8 == 'a') || (iVar8 = strcmp(acStack_1b4,"active"), iVar8 == 0)) {
      if (!bVar2) {
        fprintf(stderr,"could not parse \"%s\" as an int for active dwell time\n",local_1ec);
        return 0xfffffffe;
      }
      *(long *)((int)param_4 + 0x30) = local_1f8;
    }
    if ((local_1e8 == 'p') || (iVar8 = strcmp(acStack_1b4,"passive"), iVar8 == 0)) {
      if (!bVar2) {
        fprintf(stderr,"could not parse \"%s\" as an int for passive dwell time\n",local_1ec);
        return 0xfffffffe;
      }
      *(long *)((int)param_4 + 0x34) = local_1f8;
    }
    if ((local_1e8 == 'h') || (iVar8 = strcmp(acStack_1b4,"home"), iVar8 == 0)) {
      if (!bVar2) {
        fprintf(stderr,"could not parse \"%s\" as an int for home channel dwell time\n",local_1ec);
        return 0xfffffffe;
      }
      *(long *)((int)param_4 + 0x38) = local_1f8;
    }
    if (((local_1e8 == 'c') || (iVar8 = strcmp(acStack_1b4,"channels"), iVar8 == 0)) &&
       (local_1dc = FUN_0042232c(local_1ec,(int)param_4 + 0x40,0x40), local_1dc == 0xffffffff)) {
      fwrite("error parsing channel list arg\n",1,0x1f,stderr);
      return 0xfffffffe;
    }
  } while( true );
}



int FUN_0041fe2c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  bool bVar3;
  void *__s;
  int *piVar4;
  char *pcVar5;
  size_t sVar6;
  int iVar7;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  char *__s1;
  int *local_res8;
  int local_90;
  size_t local_88;
  char *local_84;
  char local_80;
  undefined1 auStack_6c [36];
  char acStack_48 [64];
  
  __s = malloc(0x30);
  if (__s == (void *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for probe params\n",0x30);
    return -0x1b;
  }
  memset(__s,0,0x30);
  bVar1 = false;
  local_res8 = (int *)(param_3 + 4);
LAB_00420388:
  __s1 = (char *)*local_res8;
  if (__s1 == (char *)0x0) {
    if (((((*(char *)((int)__s + 0x2a) == '\0' && *(char *)((int)__s + 0x2b) == '\0') &&
          *(char *)((int)__s + 0x2c) == '\0') && *(char *)((int)__s + 0x2d) == '\0') &&
        *(char *)((int)__s + 0x2e) == '\0') && *(char *)((int)__s + 0x2f) == '\0') {
      *(undefined4 *)((int)__s + 0x2a) = 0xffffffff;
      *(undefined1 *)((int)__s + 0x2e) = 0xff;
      *(undefined1 *)((int)__s + 0x2f) = 0xff;
    }
    if (((((*(char *)((int)__s + 0x24) == '\0' && *(char *)((int)__s + 0x25) == '\0') &&
          *(char *)((int)__s + 0x26) == '\0') && *(char *)((int)__s + 0x27) == '\0') &&
        *(char *)((int)__s + 0x28) == '\0') && *(char *)((int)__s + 0x29) == '\0') {
      *(undefined4 *)((int)__s + 0x24) = 0xffffffff;
      *(undefined1 *)((int)__s + 0x28) = 0xff;
      *(undefined1 *)((int)__s + 0x29) = 0xff;
    }
    local_90 = FUN_004ba160(param_1,"sendprb",__s,0x30,PTR_DAT_00551644,0x2000);
LAB_00420544:
    free(__s);
    return local_90;
  }
  piVar4 = local_res8 + 1;
  memset(acStack_48,0,0x40);
  local_80 = '\0';
  piVar2 = piVar4;
  local_84 = __s1;
  if (!bVar1) {
    iVar7 = strcmp(__s1,"--");
    if (iVar7 == 0) {
      bVar1 = true;
      local_res8 = piVar4;
      goto LAB_00420388;
    }
    iVar7 = strncmp(__s1,"--",2);
    if (iVar7 == 0) {
      pcVar5 = strchr(__s1,0x3d);
      if (pcVar5 == (char *)0x0) {
        fprintf(stderr,"missing \" = \" in long param \"%s\"\n",__s1);
        local_90 = -0x2c;
        goto LAB_00420544;
      }
      local_88 = (int)pcVar5 - (int)(__s1 + 2);
      if (0x3f < (int)local_88) {
        local_88 = 0x3f;
      }
      memcpy(acStack_48,__s1 + 2,local_88);
      local_84 = pcVar5 + 1;
      if (pcVar5[1] == '\0') {
        fprintf(stderr,"missing value after \" = \" in long param \"%s\"\n",__s1);
        local_90 = -0x2c;
        goto LAB_00420544;
      }
    }
    else if (*__s1 == '-') {
      local_80 = __s1[1];
      sVar6 = strlen(__s1);
      if (sVar6 < 3) {
        if (*piVar4 != 0) {
          piVar2 = local_res8 + 2;
          local_84 = (char *)*piVar4;
          goto LAB_00420128;
        }
        fprintf(stderr,"missing value parameter after \"%s\"\n",__s1);
        local_90 = -0x2c;
      }
      else {
        fprintf(stderr,"only single char options, error on param \"%s\"\n",__s1);
        local_90 = -2;
      }
      goto LAB_00420544;
    }
  }
LAB_00420128:
  local_res8 = piVar2;
  if ((local_80 == 's') || (iVar7 = strcmp(acStack_48,"ssid"), iVar7 == 0)) {
    iVar7 = FUN_0041ed48(local_84,(int)auStack_6c,0,10);
    if (iVar7 != 1) {
      fwrite("doesn\'t support multiple ssids\n",1,0x1f,stderr);
      local_90 = -2;
      goto LAB_00420544;
    }
    memcpy(__s,auStack_6c,0x24);
    fprintf(stderr,"\"%s\" ssid\n",local_84);
  }
  else if ((local_80 == 'b') || (iVar7 = strcmp(acStack_48,"bssid"), iVar7 == 0)) {
    bVar3 = FUN_0041d6ac(local_84,(void *)((int)__s + 0x24));
    if (CONCAT31(extraout_var,bVar3) == 0) {
      fprintf(stderr,"could not parse \"%s\" as an ethernet MAC address\n",local_84);
      local_90 = -0x2c;
      goto LAB_00420544;
    }
    fprintf(stderr,"\"%s\" bssid address\n",local_84);
  }
  else if ((local_80 == 'd') || (iVar7 = strcmp(acStack_48,"da"), iVar7 == 0)) {
    bVar3 = FUN_0041d6ac(local_84,(void *)((int)__s + 0x2a));
    if (CONCAT31(extraout_var_00,bVar3) == 0) {
      fprintf(stderr,"could not parse \"%s\" as an ethernet MAC address\n",local_84);
      local_90 = -0x2c;
      goto LAB_00420544;
    }
    fprintf(stderr,"\"%s\" MAC address\n",local_84);
  }
  else {
    fprintf(stderr,"\"%s\" ignored\n",local_84);
  }
  goto LAB_00420388;
}



void FUN_0042056c(int *param_1)

{
  FUN_004ba160(param_1,"send_frame",&DAT_005561e0,0x71,PTR_DAT_00551644,0x2000);
  return;
}



int FUN_004205d4(int *param_1,undefined4 param_2,int param_3)

{
  void *__s;
  int local_28;
  size_t local_20;
  byte local_1c [4];
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  
  local_20 = 0x228;
  __s = malloc(0x228);
  if (__s == (void *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",local_20);
    local_28 = -0x1b;
  }
  else {
    memset(__s,0,local_20);
    memset(local_1c,0,0x14);
    if (*(int *)(param_3 + 4) == 0) {
      puts("GET roam scan params");
      local_28 = FUN_004ba0cc(param_1,"roamscan_parms",local_1c,0x14,PTR_DAT_00551644,0x100);
      FUN_004be9f4((char *)0x0,(int)PTR_DAT_00551644,0x40);
      memset(local_1c,0,0x14);
      memcpy(local_1c,PTR_DAT_00551644,0x14);
      puts("Roam Scan Parameters:");
      printf("scan_type: %d\n",(uint)local_1c[0]);
      printf("nprobes: %d\n",local_18);
      printf("active_time: %d\n",local_14);
      printf("passive_time: %d\n",local_10);
      printf("home_time: %d\n",local_c);
    }
    else {
      puts("Setting Roam Scan parameters ");
      local_28 = FUN_0041eee4(param_1,param_2,param_3,__s,&local_20);
      if (local_28 == 0) {
        local_1c[0] = *(byte *)((int)__s + 0x2b);
        local_18 = *(int *)((int)__s + 0x2c);
        local_14 = *(int *)((int)__s + 0x30);
        local_10 = *(int *)((int)__s + 0x34);
        local_c = *(int *)((int)__s + 0x38);
        local_28 = FUN_004ba160(param_1,"roamscan_parms",local_1c,0x14,PTR_DAT_00551644,0x100);
      }
    }
    free(__s);
  }
  return local_28;
}



int FUN_004208b0(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  int *piVar2;
  int iVar3;
  int *piVar4;
  int *local_res8;
  uint local_64;
  void *local_54;
  ushort local_50 [4];
  char acStack_48 [6];
  ushort auStack_42 [29];
  
  local_54 = (void *)0x0;
  piVar2 = (int *)(param_3 + 4);
  local_50[2] = 0;
  if ((*piVar2 == 0) ||
     ((iVar3 = strcmp((char *)*piVar2,"b"), iVar3 != 0 &&
      (iVar3 = strcmp((char *)*piVar2,"2g"), iVar3 != 0)))) {
    if ((*piVar2 == 0) ||
       ((iVar3 = strcmp((char *)*piVar2,"a"), iVar3 != 0 &&
        (iVar3 = strcmp((char *)*piVar2,"5g"), iVar3 != 0)))) {
      return -1;
    }
    local_50[0] = 1;
    local_50[1] = 0;
  }
  else {
    local_50[0] = 2;
    local_50[1] = 0;
  }
  local_res8 = (int *)(param_3 + 8);
  if (*local_res8 == 0) {
    local_50[3] = 0;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,local_50,8,&local_54);
    if (-1 < iVar3) {
      if (local_50[2] != 0) {
        printf("bad version (=%d) in return data\n",(uint)local_50[2]);
      }
      if ((local_50[3] & 0xf) != 0) {
        printf("bad length (=%d) in return data\n",(uint)local_50[3]);
      }
      memcpy(local_50,local_54,0x48);
      local_64 = 0;
      while (((local_64 < 4 && (local_64 << 4 <= (uint)local_50[3])) &&
             (local_50[(local_64 + 1) * 8] != 0))) {
        printf("flag:%02x RSSI[%d,%d] delta:%d boost:%d.by.%d nfscan:%d period(full:%ds partial:%ds.x%d.%ds)\n"
               ,(int)acStack_48[local_64 * 0x10],(int)acStack_48[local_64 * 0x10 + 1],
               (int)acStack_48[local_64 * 0x10 + 2],(int)acStack_48[local_64 * 0x10 + 3],
               (int)(char)auStack_42[local_64 * 8 + -1],
               (int)*(char *)((int)auStack_42 + local_64 * 0x10 + -1),(uint)auStack_42[local_64 * 8]
               ,(uint)local_50[(local_64 + 1) * 8],(uint)local_50[(local_64 + 1) * 8 + 1],
               (uint)local_50[(local_64 + 1) * 8 + 2],
               (uint)*(ushort *)(acStack_48 + (local_64 + 1) * 0x10 + -2));
        local_64 = local_64 + 1;
      }
    }
  }
  else {
    memset(acStack_48,0,0x40);
    local_64 = 0;
    while ((piVar2 = local_res8, local_64 < 4 && (*local_res8 != 0))) {
      iVar3 = atoi((char *)*local_res8);
      acStack_48[local_64 * 0x10] = (char)iVar3;
      if (local_res8[1] == 0) {
        return -1;
      }
      iVar3 = atoi((char *)local_res8[1]);
      acStack_48[local_64 * 0x10 + 1] = (char)iVar3;
      if (local_res8[2] == 0) {
        return -1;
      }
      iVar3 = atoi((char *)local_res8[2]);
      acStack_48[local_64 * 0x10 + 2] = (char)iVar3;
      if (local_res8[3] == 0) {
        return -1;
      }
      iVar3 = atoi((char *)local_res8[3]);
      acStack_48[local_64 * 0x10 + 3] = (char)iVar3;
      if (local_res8[4] == 0) {
        return -1;
      }
      iVar3 = atoi((char *)local_res8[4]);
      *(char *)(auStack_42 + local_64 * 8 + -1) = (char)iVar3;
      if (local_res8[5] == 0) {
        return -1;
      }
      piVar4 = local_res8 + 6;
      iVar3 = atoi((char *)local_res8[5]);
      *(char *)((int)auStack_42 + local_64 * 0x10 + -1) = (char)iVar3;
      if (*piVar4 == 0) {
        return -1;
      }
      if (DAT_00557704 == '\0') {
        iVar3 = atoi((char *)*piVar4);
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = atoi((char *)*piVar4);
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      local_res8 = local_res8 + 7;
      auStack_42[local_64 * 8] = uVar1;
      if (*local_res8 == 0) {
        return -1;
      }
      if (DAT_00557704 == '\0') {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      local_res8 = piVar2 + 8;
      local_50[(local_64 + 1) * 8] = uVar1;
      if (*local_res8 == 0) {
        return -1;
      }
      if (DAT_00557704 == '\0') {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      local_res8 = piVar2 + 9;
      local_50[(local_64 + 1) * 8 + 1] = uVar1;
      if (*local_res8 == 0) {
        return -1;
      }
      if (DAT_00557704 == '\0') {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      local_res8 = piVar2 + 10;
      local_50[(local_64 + 1) * 8 + 2] = uVar1;
      if (*local_res8 == 0) {
        return -1;
      }
      if (DAT_00557704 == '\0') {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = atoi((char *)*local_res8);
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      local_res8 = piVar2 + 0xb;
      *(ushort *)(acStack_48 + (local_64 + 1) * 0x10 + -2) = uVar1;
      local_64 = local_64 + 1;
    }
    if (local_64 == 0) {
      iVar3 = -1;
    }
    else if (*local_res8 == 0) {
      iVar3 = (local_64 & 0xfff) * 0x10;
      local_50[3] = (ushort)iVar3;
      iVar3 = FUN_00445444(param_1,(char *)*param_2,local_50,iVar3 + 8);
    }
    else {
      iVar3 = -1;
    }
  }
  return iVar3;
}



int FUN_004212e0(int *param_1,int param_2,int param_3)

{
  char *__s;
  int local_18;
  size_t local_10 [2];
  
  local_10[0] = 0x228;
  __s = (char *)malloc(0x228);
  if (__s == (char *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",local_10[0]);
    local_18 = -0x1b;
  }
  else {
    memset(__s,0,local_10[0]);
    local_18 = FUN_0041eee4(param_1,param_2,param_3,__s,local_10);
    if (local_18 == 0) {
      local_18 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),__s,local_10[0]);
    }
    free(__s);
  }
  return local_18;
}



int FUN_004213fc(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  ushort uVar1;
  int iVar2;
  undefined4 *__s;
  uint __seed;
  undefined4 uVar3;
  int local_20;
  short local_1c;
  uint local_c;
  
  local_c = 200;
  iVar2 = strcasecmp((char *)*param_3,"escan");
  if (iVar2 == 0) {
    local_1c = 1;
  }
  else {
    iVar2 = strcasecmp((char *)*param_3,"escanabort");
    if (iVar2 != 0) {
      printf("unknown escan command: %s\n",(char *)*param_3);
      return -0x2c;
    }
    local_1c = 3;
  }
  local_c = local_c + 0x168;
  __s = (undefined4 *)malloc(local_c);
  if (__s == (undefined4 *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",local_c);
    local_20 = -0x1b;
  }
  else {
    memset(__s,0,local_c);
    local_20 = FUN_0041eee4(param_1,param_2,(int)param_3,__s + 2,&local_c);
    if (local_20 == 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = 1;
      }
      else {
        uVar3 = 0x1000000;
      }
      *__s = uVar3;
      if (DAT_00557704 != '\0') {
        local_1c = local_1c << 8;
      }
      *(short *)(__s + 1) = local_1c;
      __seed = time((time_t *)0x0);
      srand(__seed);
      if (DAT_00557704 == '\0') {
        iVar2 = rand();
        uVar1 = (ushort)iVar2;
      }
      else {
        iVar2 = rand();
        uVar1 = (ushort)iVar2 << 8 | (ushort)iVar2 >> 8;
      }
      *(ushort *)((int)__s + 6) = uVar1;
      local_c = local_c + 8;
      local_20 = FUN_004ba160(param_1,"escan",__s,local_c,PTR_DAT_00551644,0x2000);
    }
    free(__s);
  }
  return local_20;
}



int FUN_00421704(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  undefined4 *__s;
  undefined4 uVar3;
  int local_38;
  short local_34;
  int *local_30;
  ushort local_2c;
  char *local_28;
  uint local_14;
  char *local_10 [2];
  
  local_14 = 200;
  local_2c = 0;
  iVar1 = strcasecmp((char *)*param_3,"iscan_s");
  local_30 = param_3;
  if (iVar1 == 0) {
    local_34 = 1;
  }
  else {
    iVar1 = strcasecmp((char *)*param_3,"iscan_c");
    if (iVar1 != 0) {
      printf("unknown iscan command: %s\n",(char *)*param_3);
      return -0x2c;
    }
    local_34 = 2;
  }
  do {
    if (*local_30 == 0) {
LAB_00421900:
      local_14 = local_14 + 0x168;
      __s = (undefined4 *)malloc(local_14);
      if (__s == (undefined4 *)0x0) {
        fprintf(stderr,"Error allocating %d bytes for scan params\n",local_14);
        local_38 = -0x1b;
      }
      else {
        memset(__s,0,local_14);
        local_38 = FUN_0041eee4(param_1,param_2,(int)param_3,__s + 2,&local_14);
        if (local_38 == 0) {
          if (DAT_00557704 == '\0') {
            uVar3 = 1;
          }
          else {
            uVar3 = 0x1000000;
          }
          *__s = uVar3;
          if (DAT_00557704 != '\0') {
            local_34 = local_34 << 8;
          }
          *(short *)(__s + 1) = local_34;
          if (DAT_00557704 != '\0') {
            local_2c = local_2c << 8 | local_2c >> 8;
          }
          *(ushort *)((int)__s + 6) = local_2c;
          local_14 = local_14 + 8;
          local_38 = FUN_004ba160(param_1,"iscan",__s,local_14,PTR_DAT_00551644,0x2000);
        }
        free(__s);
      }
      return local_38;
    }
    iVar1 = strcmp((char *)*local_30,"-d");
    if ((iVar1 == 0) || (iVar1 = strncmp((char *)*local_30,"--duration=",0xb), iVar1 == 0)) {
      iVar1 = strcmp((char *)*local_30,"-d");
      if (iVar1 == 0) {
        local_28 = (char *)local_30[1];
      }
      else {
        local_28 = (char *)(*local_30 + 0xb);
      }
      lVar2 = strtol(local_28,local_10,0);
      if (*local_10[0] != '\0') {
        fprintf(stderr,"could not parse \"%s\" as an int for duration\n",local_28);
        return -1;
      }
      local_2c = (ushort)lVar2;
      goto LAB_00421900;
    }
    local_30 = local_30 + 1;
  } while( true );
}



undefined4 FUN_00421b24(int *param_1,void *param_2,char *param_3)

{
  bool bVar1;
  bool bVar2;
  int *piVar3;
  bool bVar4;
  ushort uVar5;
  int *piVar6;
  char *pcVar7;
  size_t sVar8;
  int iVar9;
  undefined3 extraout_var;
  char *__s1;
  uint uVar10;
  int *local_res0;
  undefined4 local_70;
  char *local_6c;
  char local_68;
  size_t local_64;
  int local_60;
  char acStack_48 [64];
  
  local_70 = 0;
  bVar4 = false;
  bVar2 = false;
  bVar1 = false;
  local_res0 = param_1;
LAB_00421f2c:
  do {
    while( true ) {
      __s1 = (char *)*local_res0;
      if (__s1 == (char *)0x0) {
        if (((param_3 == (char *)0x0) || (*param_3 == '\0')) || ((!bVar2 && (!bVar4)))) {
          for (local_60 = 0; local_60 < *(int *)((int)param_2 + 8); local_60 = local_60 + 1) {
            uVar5 = FUN_00402c2c(*(ushort *)((int)param_2 + (local_60 + 4) * 2 + 4));
            if (uVar5 == 0xff) {
              return 0xffffffd4;
            }
            *(ushort *)((int)param_2 + (local_60 + 4) * 2 + 4) = uVar5;
          }
          if (DAT_00557704 == '\0') {
            uVar10 = *(uint *)((int)param_2 + 8);
          }
          else {
            uVar10 = *(uint *)((int)param_2 + 8);
            uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                     uVar10 >> 0x18;
          }
          *(uint *)((int)param_2 + 8) = uVar10;
        }
        else {
          fwrite("cannot use bssid/channel options with prescan option\n",1,0x35,stderr);
          local_70 = 0xfffffffe;
        }
        return local_70;
      }
      piVar6 = local_res0 + 1;
      memset(acStack_48,0,0x40);
      local_68 = '\0';
      piVar3 = piVar6;
      local_6c = __s1;
      if (!bVar1) break;
LAB_00421de8:
      local_res0 = piVar3;
      if ((local_68 == 'b') || (iVar9 = strcasecmp(acStack_48,"bssid"), iVar9 == 0)) {
        bVar4 = FUN_0041d6ac(local_6c,param_2);
        if (CONCAT31(extraout_var,bVar4) == 0) {
          fwrite("could not parse as an ethernet MAC address\n",1,0x2b,stderr);
          return 0xffffffd4;
        }
        bVar4 = true;
      }
      else if ((local_68 == 'c') || (iVar9 = strcmp(acStack_48,"chanspecs"), iVar9 == 0)) {
        iVar9 = FUN_00422494(local_6c,(int)param_2 + 0xc,0x40);
        *(int *)((int)param_2 + 8) = iVar9;
        if (*(int *)((int)param_2 + 8) == -1) {
          fwrite("error parsing chanspec list arg\n",1,0x20,stderr);
          return 0xfffffffe;
        }
        bVar2 = true;
      }
    }
    iVar9 = strcmp(__s1,"--");
    if (iVar9 != 0) {
      iVar9 = strcmp(__s1,"prescanned");
      if (iVar9 != 0) {
        iVar9 = strncmp(__s1,"--",2);
        if (iVar9 == 0) {
          pcVar7 = strchr(__s1,0x3d);
          if (pcVar7 == (char *)0x0) {
            fprintf(stderr,"wl_parse_assoc_params: missing \" = \" in long param \"%s\"\n",__s1);
            return 0xffffffd4;
          }
          local_64 = (int)pcVar7 - (int)(__s1 + 2);
          if (0x3f < (int)local_64) {
            local_64 = 0x3f;
          }
          memcpy(acStack_48,__s1 + 2,local_64);
          local_6c = pcVar7 + 1;
          if (pcVar7[1] == '\0') {
            fprintf(stderr,
                    "wl_parse_assoc_params: missing value after \" = \" in long param \"%s\"\n",__s1
                   );
            return 0xffffffd4;
          }
        }
        else if (*__s1 == '-') {
          local_68 = __s1[1];
          sVar8 = strlen(__s1);
          if (2 < sVar8) {
            fprintf(stderr,
                    "wl_parse_assoc_params: only single char options, error on param \"%s\"\n",__s1)
            ;
            return 0xfffffffe;
          }
          if (*piVar6 == 0) {
            fprintf(stderr,"wl_parse_assoc_params: missing value parameter after \"%s\"\n",__s1);
            return 0xffffffd4;
          }
          piVar3 = local_res0 + 2;
          local_6c = (char *)*piVar6;
        }
        goto LAB_00421de8;
      }
      local_res0 = piVar6;
      if (param_3 != (char *)0x0) {
        *param_3 = '\x01';
      }
      goto LAB_00421f2c;
    }
    bVar1 = true;
    local_res0 = piVar6;
  } while( true );
}



int FUN_004220c8(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  char *__s;
  undefined3 extraout_var;
  uint uVar3;
  size_t local_18;
  int local_14;
  
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    fwrite("no arguments to wl_reassoc\n",1,0x1b,stderr);
    return -0x2c;
  }
  __s = (char *)malloc(0x8c);
  if (__s == (char *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",0x8c);
    return -0x1b;
  }
  memset(__s,0,0x8c);
  bVar1 = FUN_0041d6ac((char *)*piVar2,__s);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    fprintf(stderr,"could not parse %s as an Ethernet MAC address\n",(char *)*piVar2);
    local_14 = -0x2c;
  }
  else {
    local_18 = 6;
    if (*(int *)(param_3 + 8) != 0) {
      local_14 = FUN_00421b24((int *)(param_3 + 8),__s,(char *)0x0);
      if (local_14 != 0) {
        fwrite("could not parse reassociation parameters\n",1,0x29,stderr);
        goto LAB_00422304;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)(__s + 8);
      }
      else {
        uVar3 = *(uint *)(__s + 8);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      local_18 = (uVar3 + 6) * 2;
    }
    local_14 = FUN_004ba050(param_1,0x35,__s,local_18);
  }
LAB_00422304:
  free(__s);
  return local_14;
}



int FUN_0042232c(char *param_1,int param_2,int param_3)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  int local_20;
  char *local_1c;
  char *local_14 [2];
  
  local_14[0] = (char *)0x0;
  if (param_1 == (char *)0x0) {
    local_20 = -1;
  }
  else {
    local_20 = 0;
    local_1c = param_1;
    while (*local_1c != '\0') {
      lVar2 = strtol(local_1c,local_14,0);
      pcVar1 = local_14[0];
      if (local_14[0] == local_1c) {
        fprintf(stderr,"could not parse channel number starting at substring \"%s\" in list:\n%s\n",
                local_1c,param_1);
        return -1;
      }
      sVar3 = strspn(local_14[0]," ,");
      local_1c = pcVar1 + sVar3;
      if (local_20 == param_3) {
        fprintf(stderr,"too many channels (more than %d) in channel list:\n%s\n",param_3,param_1);
        return -1;
      }
      *(short *)(param_2 + local_20 * 2) = (short)lVar2;
      local_20 = local_20 + 1;
    }
  }
  return local_20;
}



int FUN_00422494(char *param_1,int param_2,int param_3)

{
  ushort uVar1;
  size_t sVar2;
  size_t __n;
  int local_20;
  char *local_1c;
  char acStack_10 [8];
  
  local_20 = 0;
  local_1c = param_1;
  if (param_1 == (char *)0x0) {
    local_20 = -1;
  }
  else {
    while (__n = strcspn(local_1c," ,"), __n != 0) {
      if (7 < __n) {
        fprintf(stderr,"string \"%s\" before \',\' or \' \' is too long\n",local_1c);
        return -1;
      }
      strncpy(acStack_10,local_1c,__n);
      acStack_10[__n] = '\0';
      uVar1 = FUN_004c0638(acStack_10);
      if (uVar1 == 0) {
        fprintf(stderr,"could not parse chanspec starting at \"%s\" in list:\n%s\n",acStack_10,
                param_1);
        return -1;
      }
      if (local_20 == param_3) {
        fprintf(stderr,"too many chanspecs (more than %d) in chanspec list:\n%s\n",param_3,param_1);
        return -1;
      }
      *(ushort *)(param_2 + local_20 * 2) = uVar1;
      local_20 = local_20 + 1;
      sVar2 = strspn(local_1c + __n," ,");
      local_1c = local_1c + __n + sVar2;
    }
  }
  return local_20;
}



undefined4 FUN_00422660(int param_1)

{
  int local_10;
  
  local_10 = 0;
  while( true ) {
    if (0x2f < local_10) {
      return 0;
    }
    if (*(int *)(&DAT_00555db0 + local_10 * 8) == param_1) break;
    local_10 = local_10 + 1;
  }
  return *(undefined4 *)(&DAT_00555dac + local_10 * 8);
}



void FUN_004226f4(int param_1,uint param_2)

{
  byte bVar1;
  char *param3;
  char *param2;
  uint local_18;
  
  printf("[ ");
  for (local_18 = 0; local_18 < param_2; local_18 = local_18 + 1) {
    bVar1 = *(byte *)(param_1 + local_18);
    if ((bVar1 & 0x7f) == 0) break;
    if ((bVar1 & 1) == 0) {
      param2 = "";
    }
    else {
      param2 = ".5";
    }
    if ((*(byte *)(param_1 + local_18) & 0x80) == 0) {
      param3 = "";
    }
    else {
      param3 = "(b)";
    }
    printf("%d%s%s ",(bVar1 & 0x7f) >> 1,param2,param3);
  }
  putchar(0x5d);
  return;
}



char * FUN_00422824(ushort param_1)

{
  char *pcVar1;
  
  if ((param_1 & 3) == 1) {
    pcVar1 = "Managed";
  }
  else if ((param_1 & 3) == 2) {
    pcVar1 = "Ad Hoc";
  }
  else {
    pcVar1 = "<unknown>";
  }
  return pcVar1;
}



byte * FUN_004228a0(byte *param_1,int param_2,uint param_3)

{
  uint uVar1;
  byte *local_18;
  int local_14;
  
  local_18 = param_1;
  local_14 = param_2;
  while( true ) {
    if (local_14 < 2) {
      return (byte *)0x0;
    }
    uVar1 = (uint)local_18[1];
    if ((*local_18 == param_3) && ((int)(uVar1 + 2) <= local_14)) break;
    local_18 = local_18 + uVar1 + 2;
    local_14 = local_14 + (-2 - uVar1);
  }
  return local_18;
}



void FUN_00422974(void *param_1,void *param_2,size_t param_3)

{
  memcmp(param_1,param_2,param_3);
  return;
}



undefined4 FUN_004229c0(int *param_1,int *param_2,int *param_3)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  
  iVar1 = *param_1;
  if ((*(byte *)(iVar1 + 1) < 6) ||
     (iVar2 = FUN_00422974((void *)(iVar1 + 2),&DAT_005124fc,4), iVar2 != 0)) {
    iVar1 = iVar1 + *(byte *)(iVar1 + 1) + 2;
    *param_3 = *param_3 + (*param_2 - iVar1);
    *param_2 = iVar1;
    uVar3 = 0;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



void FUN_00422aa0(byte *param_1,int param_2)

{
  int iVar1;
  byte *pbVar2;
  byte *local_14;
  int local_10;
  byte *local_c;
  
  local_14 = param_1;
  local_10 = param_2;
  do {
    local_c = FUN_004228a0(local_14,local_10,0xdd);
    if (local_c == (byte *)0x0) break;
    iVar1 = FUN_004229c0((int *)&local_c,(int *)&local_14,&local_10);
  } while (iVar1 == 0);
  if (local_c != (byte *)0x0) {
    FUN_00422b94((char *)local_c);
  }
  pbVar2 = FUN_004228a0(param_1,param_2,0x30);
  if (pbVar2 != (byte *)0x0) {
    FUN_00422b94((char *)pbVar2);
  }
  return;
}



void FUN_00422b94(char *param_1)

{
  char cVar1;
  byte bVar2;
  bool bVar3;
  ushort uVar4;
  ushort *puVar5;
  int iVar6;
  undefined **ppuVar7;
  ushort *puVar8;
  char *pcVar9;
  uint uVar10;
  int local_50;
  int local_48;
  short local_20 [2];
  byte *local_1c;
  ushort *local_18;
  ushort *local_14;
  ushort *local_10;
  undefined2 local_c;
  undefined1 local_a;
  
  cVar1 = *param_1;
  if (cVar1 != '0') {
    local_c = 0x5000;
    local_a = 0xf2;
    local_48 = FUN_004236a4((undefined2 *)(param_1 + 6),(byte)param_1[1] - 4,local_20);
  }
  else {
    local_c = 0xf00;
    local_a = 0xac;
    local_48 = FUN_004236a4((undefined2 *)(param_1 + 2),(uint)(byte)param_1[1],local_20);
  }
  bVar3 = cVar1 == '0';
  if ((local_48 == 0) && (local_20[0] == 1)) {
    if (bVar3) {
      puts("RSN (WPA2):");
    }
    else {
      puts("WPA:");
    }
    if (local_1c != (byte *)0x0) {
      printf("\tmulticast cipher: ");
      iVar6 = FUN_00422974(local_1c,&local_c,3);
      if (iVar6 == 0) {
        switch(local_1c[3]) {
        case 0:
          puts("NONE");
          break;
        case 1:
          puts("WEP64");
          break;
        case 2:
          puts("TKIP");
          break;
        case 3:
          puts("AES-OCB");
          break;
        case 4:
          puts("AES-CCMP");
          break;
        case 5:
          puts("WEP128");
          break;
        default:
          if (bVar3) {
            ppuVar7 = &PTR_s__00510944;
          }
          else {
            ppuVar7 = (undefined **)&DAT_00512568;
          }
          printf("Unknown-%s(#%d)\n",(char *)ppuVar7,(uint)local_1c[3]);
        }
      }
      else {
        iVar6 = FUN_00422974(local_1c,&DAT_00512580,3);
        if (iVar6 == 0) {
          bVar2 = local_1c[3];
          if (bVar2 == 1) {
            puts("CKIP+CMIC");
          }
          else if (bVar2 == 2) {
            puts("CMIC");
          }
          else if (bVar2 == 0) {
            puts("CKIP");
          }
        }
        else {
          printf("Unknown-%02X:%02X:%02X(#%d) ",(uint)*local_1c,(uint)local_1c[1],(uint)local_1c[2],
                 (uint)local_1c[3]);
        }
      }
    }
    if (local_18 != (ushort *)0x0) {
      uVar4 = *local_18;
      printf("\tunicast ciphers(%d): ",(uint)uVar4);
      for (local_50 = 0; puVar5 = local_18, local_50 < (int)(uint)uVar4; local_50 = local_50 + 1) {
        puVar8 = local_18 + local_50 * 2 + 1;
        iVar6 = FUN_00422974(puVar8,&local_c,3);
        if (iVar6 == 0) {
          switch(*(undefined1 *)((int)puVar5 + local_50 * 4 + 5)) {
          case 0:
            printf("NONE ");
            break;
          case 1:
            printf("WEP64 ");
            break;
          case 2:
            printf("TKIP ");
            break;
          case 3:
            printf("AES-OCB ");
            break;
          case 4:
            printf("AES-CCMP ");
            break;
          case 5:
            printf("WEP128 ");
            break;
          default:
            if (bVar3) {
              ppuVar7 = &PTR_s__00510944;
            }
            else {
              ppuVar7 = (undefined **)&DAT_00512568;
            }
            printf("WPA-Unknown-%s(#%d) ",(char *)ppuVar7,
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
          }
        }
        else {
          iVar6 = FUN_00422974(puVar8,&DAT_00512580,3);
          if (iVar6 == 0) {
            cVar1 = *(char *)((int)puVar5 + local_50 * 4 + 5);
            if (cVar1 == '\x01') {
              printf("CKIP+CMIC ");
            }
            else if (cVar1 == '\x02') {
              printf("CMIC ");
            }
            else if (cVar1 == '\0') {
              printf("CKIP ");
            }
            else {
              printf("Cisco-Unknown(#%d) ",(uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
            }
          }
          else {
            printf("Unknown-%02X:%02X:%02X(#%d) ",(uint)(byte)*puVar8,
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 3),
                   (uint)(byte)puVar5[local_50 * 2 + 2],
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
          }
        }
      }
      putchar(10);
    }
    if (local_14 != (ushort *)0x0) {
      uVar4 = *local_14;
      printf("\tAKM Suites(%d): ",(uint)uVar4);
      for (local_50 = 0; puVar5 = local_14, local_50 < (int)(uint)uVar4; local_50 = local_50 + 1) {
        puVar8 = local_14 + local_50 * 2 + 1;
        iVar6 = FUN_00422974(puVar8,&local_c,3);
        if (iVar6 == 0) {
          switch(*(undefined1 *)((int)puVar5 + local_50 * 4 + 5)) {
          case 0:
            printf("None ");
            break;
          case 1:
            if (bVar3) {
              pcVar9 = "WPA2";
            }
            else {
              pcVar9 = "WPA";
            }
            printf("%s ",pcVar9);
            break;
          case 2:
            if (bVar3) {
              pcVar9 = "WPA2-PSK";
            }
            else {
              pcVar9 = "WPA-PSK";
            }
            printf("%s ",pcVar9);
            break;
          case 3:
            printf("FT-802.1x ");
            break;
          case 4:
            printf("FT-PSK ");
            break;
          default:
            if (bVar3) {
              ppuVar7 = &PTR_s__00510944;
            }
            else {
              ppuVar7 = (undefined **)&DAT_00512568;
            }
            printf("Unknown-%s(#%d)  ",(char *)ppuVar7,
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
          }
        }
        else {
          iVar6 = FUN_00422974(puVar8,&DAT_00512580,3);
          if (iVar6 == 0) {
            if (*(char *)((int)puVar5 + local_50 * 4 + 5) == '\0') {
              printf("CCKM ");
            }
            else {
              printf("Cisco-Unknown(#%d)  ",(uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
            }
          }
          else {
            printf("Unknown-%02X:%02X:%02X(#%d)  ",(uint)(byte)*puVar8,
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 3),
                   (uint)(byte)puVar5[local_50 * 2 + 2],
                   (uint)*(byte *)((int)puVar5 + local_50 * 4 + 5));
          }
        }
      }
      putchar(10);
    }
    if (local_10 == (ushort *)0x0) {
      if (bVar3) {
        ppuVar7 = &PTR_s__00510944;
      }
      else {
        ppuVar7 = (undefined **)&DAT_00512568;
      }
      printf("\tNo %s Capabilities advertised\n",(char *)ppuVar7);
    }
    else {
      uVar4 = *local_10;
      printf("\tCapabilities(0x%04x): ",(uint)uVar4);
      if (bVar3) {
        if ((uVar4 & 1) == 0) {
          pcVar9 = "No ";
        }
        else {
          pcVar9 = "";
        }
        printf("%sPre-Auth, ",pcVar9);
      }
      if ((uVar4 & 2) == 0) {
        pcVar9 = "";
      }
      else {
        pcVar9 = "No ";
      }
      printf("%sPairwise, ",pcVar9);
      uVar10 = FUN_00423918((int)(uVar4 & 0xc) >> 2);
      if (uVar10 < 2) {
        pcVar9 = "";
      }
      else {
        pcVar9 = "s";
      }
      printf("%d PTK Replay Ctr%s",uVar10,pcVar9);
      if (bVar3) {
        uVar10 = FUN_00423918((int)(uVar4 & 0x30) >> 4);
        if (uVar10 < 2) {
          pcVar9 = "";
        }
        else {
          pcVar9 = "s";
        }
        printf("%d GTK Replay Ctr%s\n",uVar10,pcVar9);
      }
      else {
        putchar(10);
      }
    }
  }
  return;
}



undefined4 FUN_004236a4(undefined2 *param_1,uint param_2,undefined2 *param_3)

{
  ushort uVar1;
  undefined4 uVar2;
  uint uVar3;
  ushort *puVar4;
  
  memset(param_3,0,0x14);
  if (param_2 < 2) {
    uVar2 = 1;
  }
  else {
    *param_3 = *param_1;
    if (param_2 - 2 < 4) {
      uVar2 = 0;
    }
    else {
      *(undefined2 **)(param_3 + 2) = param_1 + 1;
      uVar3 = param_2 - 6;
      puVar4 = param_1 + 3;
      if (uVar3 < 2) {
        uVar2 = 0;
      }
      else {
        uVar1 = *puVar4;
        if (uVar3 < (uint)uVar1 * 4 + 2) {
          uVar2 = 1;
        }
        else {
          *(ushort **)(param_3 + 4) = puVar4;
          uVar3 = (uVar3 + (uint)uVar1 * -4) - 2;
          puVar4 = puVar4 + (uint)uVar1 * 2 + 1;
          if (uVar3 < 2) {
            uVar2 = 0;
          }
          else {
            uVar1 = *puVar4;
            if (uVar3 < (uint)uVar1 * 4 + 2) {
              uVar2 = 1;
            }
            else {
              *(ushort **)(param_3 + 6) = puVar4;
              if ((uVar3 + (uint)uVar1 * -4) - 2 < 2) {
                uVar2 = 0;
              }
              else {
                *(ushort **)(param_3 + 8) = puVar4 + (uint)uVar1 * 2 + 1;
                uVar2 = 0;
              }
            }
          }
        }
      }
    }
  }
  return uVar2;
}



undefined4 FUN_00423918(int param_1)

{
  undefined4 local_10;
  
  if (param_1 == 1) {
    local_10 = 2;
  }
  else if (param_1 == 0) {
    local_10 = 1;
  }
  else if (param_1 == 2) {
    local_10 = 4;
  }
  else if (param_1 == 3) {
    local_10 = 0x10;
  }
  else {
    local_10 = 0;
  }
  return local_10;
}



void FUN_004239c4(byte *param_1,uint param_2)

{
  uint local_10;
  
  if (param_2 != 0) {
    if (param_2 == 1) {
      printf("IE header truncated: ID: 0x%02X\n",(uint)*param_1);
    }
    else {
      if (param_2 < param_1[1] + 2) {
        printf("IE data truncated: ID: 0x%02X Len: %d\n",(uint)*param_1,(uint)param_1[1]);
        local_10 = param_2 - 2;
      }
      else {
        printf("ID: 0x%02X Len: %d\n",(uint)*param_1,(uint)param_1[1]);
        local_10 = (uint)param_1[1];
      }
      if (local_10 < 0x11) {
        if (local_10 != 0) {
          printf("Data: ");
        }
      }
      else {
        puts("Data:");
      }
      if (local_10 != 0) {
        FUN_0041e248((int)(param_1 + 2),local_10);
      }
      if (local_10 < param_1[1]) {
        printf("<missing %d bytes>\n",param_1[1] - local_10);
      }
    }
  }
  return;
}



void FUN_00423b90(int param_1)

{
  uint uVar1;
  uint *local_18;
  uint local_14;
  
  if (*(int *)(param_1 + 8) != 0) {
    if (((*(int *)(param_1 + 4) == 0x6d) || (*(int *)(param_1 + 4) == 0x6c)) ||
       (*(int *)(param_1 + 4) == 0x6b)) {
      local_18 = (uint *)(param_1 + 0xc);
      local_14 = 0;
      while (local_14 < *(uint *)(param_1 + 8)) {
        FUN_004242c8(local_18);
        local_14 = local_14 + 1;
        if (DAT_00557704 == '\0') {
          uVar1 = local_18[1];
        }
        else {
          uVar1 = local_18[1];
          uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
        }
        local_18 = (uint *)((int)local_18 + uVar1);
      }
    }
    else {
      fprintf(stderr,
              "Sorry, your driver has bss_info_version %d but this program supports only version %d.\n"
              ,*(int *)(param_1 + 4),0x6d);
    }
  }
  return;
}



void FUN_00423d08(int param_1)

{
  byte bVar1;
  ushort uVar2;
  int iVar3;
  ushort local_18;
  byte local_16;
  
  bVar1 = *(byte *)(param_1 + 1);
  local_18 = 0x10;
  local_16 = 1;
  do {
    if (((uint)bVar1 < local_18 + 2) || (local_16 == 0)) {
      printf("V1.0 ");
      return;
    }
    if ((ushort)((ushort)*(byte *)(param_1 + (uint)local_18) * 0x100 +
                (ushort)*(byte *)(param_1 + local_18 + 1)) == 0x1049) {
      uVar2 = local_18 + 4;
      iVar3 = FUN_00422974((void *)(param_1 + (uint)uVar2),&DAT_005128a8,3);
      if ((iVar3 == 0) && (*(char *)(param_1 + uVar2 + 3) == '\0')) {
        printf("V%d.%d ",(uint)(*(byte *)(param_1 + uVar2 + 5) >> 4),
               *(byte *)(param_1 + uVar2 + 5) & 0xf);
        return;
      }
    }
    local_16 = *(byte *)(param_1 + local_18 + 3);
    local_18 = local_16 + local_18 + 4;
  } while( true );
}



void FUN_00423eb4(int param_1)

{
  if ((0x10 < *(byte *)(param_1 + 1)) &&
     ((ushort)((ushort)*(byte *)(param_1 + 0xb) * 0x100 + (ushort)*(byte *)(param_1 + 0xc)) ==
      0x1044)) {
    if (*(char *)(param_1 + 0xf) == '\x01') {
      puts("Unconfigured");
    }
    else if (*(char *)(param_1 + 0xf) == '\x02') {
      puts("Configured");
    }
    else {
      puts("Unknown State");
    }
  }
  return;
}



undefined1 FUN_00423f9c(int param_1,int *param_2,int *param_3)

{
  int iVar1;
  undefined1 local_10;
  
  local_10 = 0;
  if ((4 < *(byte *)(param_1 + 1)) &&
     (iVar1 = FUN_00422974((void *)(param_1 + 2),&DAT_005128e8,4), iVar1 == 0)) {
    local_10 = 1;
  }
  iVar1 = param_1 + *(byte *)(param_1 + 1) + 2;
  *param_3 = *param_3 + (*param_2 - iVar1);
  *param_2 = iVar1;
  return local_10;
}



void FUN_00424070(byte *param_1,int param_2)

{
  undefined1 uVar1;
  undefined3 extraout_var;
  byte *pbVar2;
  byte *local_14;
  int local_10 [2];
  
  local_14 = param_1;
  local_10[0] = param_2;
  do {
    pbVar2 = FUN_004228a0(local_14,local_10[0],0xdd);
    if (pbVar2 == (byte *)0x0) {
      return;
    }
    uVar1 = FUN_00423f9c((int)pbVar2,(int *)&local_14,local_10);
  } while (CONCAT31(extraout_var,uVar1) == 0);
  printf("WPS: ");
  FUN_00423d08((int)pbVar2);
  FUN_00423eb4((int)pbVar2);
  return;
}



undefined4 FUN_00424138(int param_1,void *param_2,size_t param_3,char param_4)

{
  int iVar1;
  undefined4 uVar2;
  
  if ((((int)(uint)*(byte *)(param_1 + 1) < (int)(param_3 + 1)) ||
      (iVar1 = FUN_00422974((void *)(param_1 + 2),param_2,param_3), iVar1 != 0)) ||
     (param_4 != *(char *)(param_1 + param_3 + 2))) {
    uVar2 = 0;
  }
  else {
    uVar2 = 1;
  }
  return uVar2;
}



byte * FUN_004241ec(byte *param_1,int param_2,void *param_3,byte param_4,char param_5)

{
  int iVar1;
  byte *pbVar2;
  int local_res4;
  void *local_res8;
  byte local_resc;
  
  local_res4 = param_2;
  local_res8 = param_3;
  local_resc = param_4;
  while( true ) {
    pbVar2 = FUN_004be3d8(param_1,local_res4,0xdd);
    if (pbVar2 == (byte *)0x0) {
      return (byte *)0x0;
    }
    iVar1 = FUN_00424138((int)pbVar2,local_res8,(uint)local_resc,param_5);
    if (iVar1 != 0) break;
    iVar1 = FUN_004be2ec((int)pbVar2,&local_res4);
    if (iVar1 == 0) {
      return (byte *)0x0;
    }
  }
  return pbVar2;
}



void FUN_004242c8(uint *param_1)

{
  bool bVar1;
  byte bVar2;
  ushort uVar3;
  uint uVar4;
  char *pcVar5;
  int iVar6;
  byte *pbVar7;
  int local_108;
  int local_104;
  byte abStack_a4 [132];
  char acStack_20 [24];
  
  if (DAT_00557704 == '\0') {
    uVar4 = *param_1;
  }
  else {
    uVar4 = *param_1;
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  if (uVar4 == 0x6b) {
    if ((byte)param_1[0x12] < 0xf) {
      uVar3 = 0;
    }
    else {
      uVar3 = 0xc000;
    }
    *(ushort *)(param_1 + 0x12) = (byte)param_1[0x12] | 0x1000 | uVar3;
    param_1[0x1e] = param_1[0x15];
    *(undefined2 *)(param_1 + 0x1d) = 0x58;
  }
  else {
    uVar3 = FUN_00402de8((ushort)param_1[0x12]);
    *(ushort *)(param_1 + 0x12) = uVar3;
  }
  FUN_0041e0e8(abStack_a4,(int)param_1 + 0x13,(uint)*(byte *)((int)param_1 + 0x12));
  printf("SSID: \"%s\"\n",(char *)abStack_a4);
  if (DAT_00557704 == '\0') {
    uVar3 = (ushort)param_1[4];
  }
  else {
    uVar3 = (ushort)param_1[4] << 8 | (ushort)param_1[4] >> 8;
  }
  pcVar5 = FUN_00422824(uVar3);
  printf("Mode: %s\t",pcVar5);
  if (DAT_00557704 == '\0') {
    uVar3 = *(ushort *)((int)param_1 + 0x4e);
  }
  else {
    uVar3 = *(ushort *)((int)param_1 + 0x4e) << 8 | *(ushort *)((int)param_1 + 0x4e) >> 8;
  }
  printf("RSSI: %d dBm\t",(int)(short)uVar3);
  if (DAT_00557704 == '\0') {
    uVar4 = *param_1;
  }
  else {
    uVar4 = *param_1;
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  if (uVar4 == 0x6d) {
    if (DAT_00557704 == '\0') {
      uVar3 = (ushort)param_1[0x1f];
    }
    else {
      uVar3 = (ushort)param_1[0x1f] << 8 | (ushort)param_1[0x1f] >> 8;
    }
    printf("SNR: %d dB\t",(int)(short)uVar3);
  }
  printf("noise: %d dBm\t",(int)(char)param_1[0x14]);
  if ((char)param_1[0x18] != '\0') {
    if (DAT_00557704 == '\0') {
      bVar2 = (byte)param_1[0x18];
    }
    else {
      bVar2 = 0;
    }
    printf("Flags: ");
    if ((bVar2 & 1) != 0) {
      printf("FromBcn ");
    }
    if ((bVar2 & 2) != 0) {
      printf("Cached ");
    }
    if ((bVar2 & 4) != 0) {
      printf("RSSI on-channel ");
    }
    putchar(9);
  }
  pcVar5 = FUN_004c02bc((ushort)param_1[0x12],acStack_20);
  printf("Channel: %s\n",pcVar5);
  pcVar5 = FUN_0041d780((int)(param_1 + 2));
  printf("BSSID: %s\t",pcVar5);
  printf("Capability: ");
  if (DAT_00557704 == '\0') {
    uVar3 = (ushort)param_1[4];
  }
  else {
    uVar3 = (ushort)param_1[4] << 8 | (ushort)param_1[4] >> 8;
  }
  if ((uVar3 & 1) != 0) {
    printf("ESS ");
  }
  if ((uVar3 & 2) != 0) {
    printf("IBSS ");
  }
  if ((uVar3 & 4) != 0) {
    printf("Pollable ");
  }
  if ((uVar3 & 8) != 0) {
    printf("PollReq ");
  }
  if ((uVar3 & 0x10) != 0) {
    printf("WEP ");
  }
  if ((uVar3 & 0x20) != 0) {
    printf("ShortPre ");
  }
  if ((uVar3 & 0x40) != 0) {
    printf("PBCC ");
  }
  if ((uVar3 & 0x80) != 0) {
    printf("Agility ");
  }
  if ((uVar3 & 0x400) != 0) {
    printf("ShortSlot ");
  }
  if ((uVar3 & 0x1000) != 0) {
    printf("RRM ");
  }
  if ((uVar3 & 0x2000) != 0) {
    printf("CCK-OFDM ");
  }
  putchar(10);
  printf("Supported Rates: ");
  if (DAT_00557704 == '\0') {
    uVar4 = param_1[0xd];
  }
  else {
    uVar4 = param_1[0xd];
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  FUN_004226f4((int)(param_1 + 0xe),uVar4);
  putchar(10);
  if (DAT_00557704 == '\0') {
    bVar1 = param_1[0x1e] != 0;
  }
  else {
    uVar4 = param_1[0x1e];
    bVar1 = (((uVar4 & 0xff) != 0 || (uVar4 & 0xff00) != 0) || (uVar4 & 0xff0000) != 0) ||
            uVar4 >> 0x18 != 0;
  }
  if (bVar1) {
    if (DAT_00557704 == '\0') {
      uVar3 = (ushort)param_1[0x1d];
    }
    else {
      uVar3 = (ushort)param_1[0x1d] << 8 | (ushort)param_1[0x1d] >> 8;
    }
    if (DAT_00557704 == '\0') {
      uVar4 = param_1[0x1e];
    }
    else {
      uVar4 = param_1[0x1e];
      uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    FUN_00422aa0((byte *)((int)param_1 + (uint)uVar3),uVar4);
  }
  if (DAT_00557704 == '\0') {
    uVar4 = *param_1;
  }
  else {
    uVar4 = *param_1;
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  if ((uVar4 != 0x6b) && (*(char *)((int)param_1 + 0x51) != '\0')) {
    if (*(char *)((int)param_1 + 0x61) == '\0') {
      puts("HT Capable:");
    }
    else {
      puts("VHT Capable:");
    }
    if ((param_1[0x12] & 0xc000) == 0) {
      pcVar5 = "2.4";
    }
    else {
      pcVar5 = "5";
    }
    if ((param_1[0x12] & 0x3800) == 0x2000) {
      iVar6 = 0x50;
    }
    else if ((param_1[0x12] & 0x3800) == 0x1800) {
      iVar6 = 0x28;
    }
    else if ((param_1[0x12] & 0x3800) == 0x1000) {
      iVar6 = 0x14;
    }
    else {
      iVar6 = 10;
    }
    printf("\tChanspec: %sGHz channel %d %dMHz (0x%x)\n",pcVar5,(ushort)param_1[0x12] & 0xff,iVar6,
           (uint)(ushort)param_1[0x12]);
    printf("\tPrimary channel: %d\n",(uint)(byte)param_1[0x16]);
    printf("\tHT Capabilities: ");
    if (DAT_00557704 == '\0') {
      uVar4 = param_1[0x15];
    }
    else {
      uVar4 = param_1[0x15] >> 0x18;
    }
    if ((uVar4 & 2) != 0) {
      printf("40Mhz ");
    }
    if (DAT_00557704 == '\0') {
      uVar4 = param_1[0x15];
    }
    else {
      uVar4 = param_1[0x15] >> 0x18;
    }
    if ((uVar4 & 0x20) != 0) {
      printf("SGI20 ");
    }
    if (DAT_00557704 == '\0') {
      uVar4 = param_1[0x15];
    }
    else {
      uVar4 = param_1[0x15] >> 0x18;
    }
    if ((uVar4 & 0x40) != 0) {
      printf("SGI40 ");
    }
    printf("\n\tSupported MCS : [ ");
    for (local_108 = 0; local_108 < 0x80; local_108 = local_108 + 1) {
      iVar6 = local_108;
      if (local_108 < 0) {
        iVar6 = local_108 + 7;
      }
      if (((int)(uint)*(byte *)((int)param_1 + (iVar6 >> 3) + 100) >> (local_108 % 8 & 0x1fU) & 1U)
          != 0) {
        printf("%d ",local_108);
      }
    }
    puts("]");
    if (*(char *)((int)param_1 + 0x61) != '\0') {
      puts("\tVHT Capabilities: ");
      puts("\tSupported VHT (tx) Rates:");
      for (local_104 = 1; local_104 < 9; local_104 = local_104 + 1) {
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)((int)param_1 + 0x5e);
        }
        else {
          uVar3 = *(ushort *)((int)param_1 + 0x5e) << 8 | *(ushort *)((int)param_1 + 0x5e) >> 8;
        }
        uVar4 = (int)(uint)uVar3 >> ((local_104 + -1) * 2 & 0x1fU) & 3;
        if (uVar4 != 3) {
          if (uVar4 == 2) {
            pcVar5 = "0-9";
          }
          else if (uVar4 == 1) {
            pcVar5 = "0-8";
          }
          else {
            pcVar5 = "0-7";
          }
          printf("\t\tNSS: %d MCS: %s\n",local_104,pcVar5);
        }
      }
      puts("\tSupported VHT (rx) Rates:");
      for (local_104 = 1; local_104 < 9; local_104 = local_104 + 1) {
        if (DAT_00557704 == '\0') {
          uVar3 = (ushort)param_1[0x17];
        }
        else {
          uVar3 = (ushort)param_1[0x17] << 8 | (ushort)param_1[0x17] >> 8;
        }
        uVar4 = (int)(uint)uVar3 >> ((local_104 + -1) * 2 & 0x1fU) & 3;
        if (uVar4 != 3) {
          if (uVar4 == 2) {
            pcVar5 = "0-9";
          }
          else if (uVar4 == 1) {
            pcVar5 = "0-8";
          }
          else {
            pcVar5 = "0-7";
          }
          printf("\t\tNSS: %d MCS: %s\n",local_104,pcVar5);
        }
      }
    }
    uVar3 = FUN_00402c2c((ushort)param_1[0x12]);
    *(ushort *)(param_1 + 0x12) = uVar3;
  }
  if (DAT_00557704 == '\0') {
    bVar1 = param_1[0x1e] != 0;
  }
  else {
    uVar4 = param_1[0x1e];
    bVar1 = (((uVar4 & 0xff) != 0 || (uVar4 & 0xff00) != 0) || (uVar4 & 0xff0000) != 0) ||
            uVar4 >> 0x18 != 0;
  }
  if (bVar1) {
    if (DAT_00557704 == '\0') {
      uVar3 = (ushort)param_1[0x1d];
    }
    else {
      uVar3 = (ushort)param_1[0x1d] << 8 | (ushort)param_1[0x1d] >> 8;
    }
    if (DAT_00557704 == '\0') {
      uVar4 = param_1[0x1e];
    }
    else {
      uVar4 = param_1[0x1e];
      uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    FUN_00424070((byte *)((int)param_1 + (uint)uVar3),uVar4);
  }
  if (DAT_00557704 == '\0') {
    bVar1 = (param_1[0x18] & 8) != 0;
  }
  else {
    bVar1 = false;
  }
  if (bVar1) {
    puts("Hotspot 2.0 capable");
  }
  if (DAT_00557704 == '\0') {
    uVar3 = (ushort)param_1[0x1d];
  }
  else {
    uVar3 = (ushort)param_1[0x1d] << 8 | (ushort)param_1[0x1d] >> 8;
  }
  if (DAT_00557704 == '\0') {
    uVar4 = param_1[0x1e];
  }
  else {
    uVar4 = param_1[0x1e];
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  pbVar7 = FUN_004241ec((byte *)((int)param_1 + (uint)uVar3),uVar4,&DAT_00512b4c,3,'\x12');
  if (pbVar7 != (byte *)0x0) {
    puts("OSEN supported");
  }
  putchar(10);
  return;
}



int FUN_004254b0(int *param_1)

{
  int param1;
  uint uVar1;
  uint local_10;
  uint *local_c;
  
  local_10 = 0;
  local_c = (uint *)0x0;
  memset(PTR_DAT_00551644,0,0x1c);
  param1 = FUN_004b9f94(param_1,0x87,(char *)&local_10,4);
  if (param1 < 0) {
    printf("wlc_get noise failed with retcode:%d\n",param1);
  }
  else {
    param1 = FUN_0044527c(param_1,"monitor_lq_status",(void *)0x0,0,&local_c);
    if (param1 < 0) {
      printf("wlc_get lq_status failed with retcode:%d\n",param1);
    }
    else if (local_c[6] == 0) {
      puts(
          "Stats collection currently disabled[\'wl monitor_lq 1\' to enable statistics collection]"
          );
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar1 = *local_c;
      }
      else {
        local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                   local_10 >> 0x18;
        uVar1 = *local_c;
        uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
      }
      *local_c = uVar1;
      if (DAT_00557704 == '\0') {
        uVar1 = local_c[1];
      }
      else {
        uVar1 = local_c[1];
        uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
      }
      local_c[1] = uVar1;
      if (DAT_00557704 == '\0') {
        uVar1 = local_c[2];
      }
      else {
        uVar1 = local_c[2];
        uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
      }
      local_c[2] = uVar1;
      printf("rss: %d, %d, %d\nsnr: %d, %d, %d\n",*local_c,local_c[2],local_c[1],*local_c - local_10
             ,local_c[2] - local_10,local_c[1] - local_10);
    }
  }
  return param1;
}



int FUN_004257f0(int *param_1,undefined4 param_2,int param_3)

{
  undefined4 local_10;
  
  local_10 = 0;
  if (*(int *)(param_3 + 4) == 0) {
    local_10 = FUN_004254b0(param_1);
  }
  return local_10;
}



int FUN_00425858(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  uint uVar2;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (param_3[1] == 0) {
    iVar1 = FUN_00445120(param_1,param_2,param_3);
  }
  else {
    uVar2 = strtol((char *)param_3[1],local_10,0);
    if (*local_10[0] == '\0') {
      if (DAT_00557704 != '\0') {
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      if ((uVar2 != 0) || (iVar1 = FUN_004254b0(param_1), iVar1 == 0)) {
        iVar1 = FUN_00445120(param_1,param_2,param_3);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_004259d8(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  char *__s;
  int local_20;
  uint local_1c;
  int local_18;
  
  __s = (char *)malloc(0x100);
  if (__s == (char *)0x0) {
    fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x100);
    local_18 = -1;
  }
  else {
    memset(__s,0,0x100);
    if (*(int *)(param_3 + 4) == 0) {
      local_18 = FUN_004ba0cc(param_1,"bcnlenhist",(void *)0x0,0,__s,0x100);
    }
    else {
      local_18 = FUN_004ba0cc(param_1,"bcnlenhist",*(void **)(param_3 + 4),1,__s,0x100);
    }
    if (local_18 == 0) {
      local_1c = (uint)*(ushort *)(__s + 2);
      local_20 = *(int *)(__s + 0xc);
      printf("LAST %d BEACON LENGTH\'s:  ",local_20);
      while (local_1c = local_1c - 1, bVar1 = local_20 != 0, local_20 = local_20 + -1, bVar1) {
        if ((int)local_1c < 0) {
          local_1c = *(int *)(__s + 0xc) - 1;
        }
        printf("%d  ",*(int *)(__s + local_1c * 4 + 0x10));
      }
      printf("\nMAX BCNLEN: %d\n",*(int *)(__s + 4));
      if (*(int *)(__s + 8) == 0x7fffffff) {
        puts("MIN BCNLEN: 0\n");
      }
      else {
        printf("MIN BCNLEN: %d\n\n",*(int *)(__s + 8));
      }
    }
    free(__s);
  }
  return local_18;
}



int FUN_00425c50(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  uint *__ptr;
  uint uVar2;
  int local_28;
  uint *local_24;
  uint local_20;
  uint local_1c;
  char *local_c;
  
  local_20 = 0;
  __ptr = (uint *)malloc(0x1fc00);
  if (__ptr == (uint *)0x0) {
    fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x1fc00);
    return -0x1b;
  }
  bVar1 = *(int *)(param_2 + 8) != 0x33;
  if (bVar1) {
    local_1c = 0x780;
    if (*(int *)(param_3 + 4) != 0) {
      local_c = (char *)0x0;
      local_1c = strtol(*(char **)(param_3 + 4),&local_c,0);
      if (*local_c != '\0') {
        local_28 = -0x2c;
        goto LAB_00425ef8;
      }
    }
    local_28 = FUN_00427390(param_1,(char *)__ptr,local_1c);
  }
  else {
    local_28 = FUN_004270c8(param_1,0x33,__ptr,0x1fc00);
  }
  if (local_28 == 0) {
    local_24 = __ptr;
    if (bVar1) {
      if (DAT_00557704 == '\0') {
        local_20 = *__ptr;
      }
      else {
        uVar2 = *__ptr;
        local_20 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      local_24 = __ptr + 1;
    }
    FUN_00423b90((int)local_24);
    if (bVar1) {
      if (local_20 == 1) {
        puts("iscanresults incomplete");
      }
      else if (local_20 == 0) {
        puts("iscanresults complete");
      }
      else if (local_20 == 2) {
        puts("iscanresults pending");
      }
      else if (local_20 == 3) {
        puts("iscanresults aborted");
      }
      else {
        printf("iscanresults returned unknown status %d\n",local_20);
      }
    }
  }
LAB_00425ef8:
  free(__ptr);
  return local_28;
}



int FUN_00425f20(int *param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  uint local_128;
  uint local_110;
  uint auStack_10c [65];
  
  if (DAT_00557704 == '\0') {
    local_110 = 0x40;
  }
  else {
    local_110 = 0x40000000;
  }
  iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_110,0x104);
  if (-1 < iVar1) {
    local_128 = 0;
    while( true ) {
      uVar2 = local_110;
      if (DAT_00557704 != '\0') {
        uVar2 = local_110 << 0x18 | (local_110 & 0xff00) << 8 | (local_110 & 0xff0000) >> 8 |
                local_110 >> 0x18;
      }
      if (uVar2 <= local_128) break;
      if (DAT_00557704 == '\0') {
        uVar2 = auStack_10c[local_128];
      }
      else {
        uVar2 = auStack_10c[local_128];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      printf("%d ",uVar2);
      local_128 = local_128 + 1;
    }
    putchar(10);
  }
  return iVar1;
}



int FUN_0042612c(int *param_1)

{
  int iVar1;
  
  memset(PTR_DAT_00551644,0,0x100);
  iVar1 = FUN_004ba1f8(param_1,"cur_mcsset",PTR_DAT_00551644,0x10);
  if (-1 < iVar1) {
    FUN_00494a88((int)PTR_DAT_00551644);
  }
  return iVar1;
}



int FUN_004261d4(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  ushort uVar3;
  size_t sVar4;
  int iVar5;
  uint uVar6;
  undefined4 uVar7;
  uint local_48;
  char acStack_20 [24];
  
  memset(PTR_DAT_00551644,0,0x2000);
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x6e616863;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 's';
  pcVar1[1] = 'p';
  pcVar1[2] = 'e';
  pcVar1[3] = 'c';
  pcVar1 = puVar2 + 8;
  pcVar1[0] = 's';
  pcVar1[1] = '_';
  pcVar1[2] = 'd';
  pcVar1[3] = 'e';
  pcVar1 = puVar2 + 0xc;
  pcVar1[0] = 'f';
  pcVar1[1] = 's';
  pcVar1[2] = 'e';
  pcVar1[3] = 't';
  puVar2[0x10] = '\0';
  sVar4 = strlen(PTR_DAT_00551644);
  if (*(int *)(param_3 + 4) == 0) {
    if (DAT_00557704 == '\0') {
      uVar7 = 0x6e;
    }
    else {
      uVar7 = 0x6e000000;
    }
    *(undefined4 *)(PTR_DAT_00551644 + sVar4 + 1) = uVar7;
    iVar5 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,sVar4 + 0x1bd);
    puVar2 = PTR_DAT_00551644;
    if (-1 < iVar5) {
      local_48 = 0;
      while( true ) {
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)puVar2;
        }
        else {
          uVar6 = *(uint *)puVar2;
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        }
        if (uVar6 <= local_48) break;
        if (DAT_00557704 == '\0') {
          uVar3 = (ushort)*(undefined4 *)(puVar2 + local_48 * 4 + 4);
        }
        else {
          uVar3 = (ushort)((uint)*(undefined4 *)(puVar2 + local_48 * 4 + 4) >> 8) & 0xff00 |
                  (ushort)(byte)((uint)*(undefined4 *)(puVar2 + local_48 * 4 + 4) >> 0x18);
        }
        FUN_004c02bc(uVar3,acStack_20);
        printf("%s (0x%04x)\n",acStack_20,(uint)uVar3);
        local_48 = local_48 + 1;
      }
      putchar(10);
    }
  }
  else {
    fprintf(stderr,"%s: This IOVAR doesn\'t take any arguments.\n","wl_dump_chanspecs_defset");
    iVar5 = -0x2c;
  }
  return iVar5;
}



int FUN_00426520(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  undefined *puVar3;
  ushort uVar4;
  size_t sVar5;
  int iVar6;
  uint uVar7;
  undefined4 uVar8;
  int *local_res8;
  ushort local_f0;
  uint local_ec;
  int local_e8;
  undefined4 auStack_c0 [3];
  int local_b4;
  char local_af;
  char local_ae;
  char *local_2c;
  int local_24;
  uint local_20;
  char acStack_1c [20];
  
  local_f0 = 0;
  bVar2 = false;
  bVar1 = false;
  local_20 = 0;
  memset(PTR_DAT_00551644,0,0x2000);
  strcpy(PTR_DAT_00551644,(char *)*param_2);
  sVar5 = strlen(PTR_DAT_00551644);
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 != 0) {
    FUN_004cbd80(auStack_c0,"wl_dump_chanspecs",0,0);
    while (iVar6 = FUN_004cbe18(auStack_c0,local_res8), iVar6 != -1) {
      if (iVar6 == 1) {
        return -0x2c;
      }
      local_res8 = local_res8 + local_b4;
      if (local_ae == 'b') {
        if (local_af == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for band\n","wl_dump_chanspecs",
                  local_2c);
          return -2;
        }
        if ((local_24 != 5) && (local_24 != 2)) {
          fprintf(stderr,"%s: invalid band %d\n","wl_dump_chanspecs",local_24);
          return -2;
        }
        if (local_24 == 5) {
          local_f0 = local_f0 | 0xc000;
        }
        bVar2 = true;
      }
      if (local_ae == 'w') {
        if (local_af == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for bandwidth\n","wl_dump_chanspecs",
                  local_2c);
          return -2;
        }
        if (((local_24 != 0x14) && (local_24 != 0x28)) && (local_24 != 0x50)) {
          fprintf(stderr,"%s: invalid bandwidth %d\n","wl_dump_chanspecs",local_24);
          return -2;
        }
        if (local_24 == 0x14) {
          local_f0 = local_f0 | 0x1000;
        }
        else if (local_24 == 0x28) {
          local_f0 = local_f0 | 0x1800;
        }
        else {
          if (DAT_00557708 == 1) {
            fprintf(stderr,"%s: bandwidth 80 MHz is not supported by this version driver.\n",
                    "wl_dump_chanspecs");
            return -0x2c;
          }
          local_f0 = local_f0 | 0x2000;
        }
        bVar1 = true;
      }
      if (local_ae == 'c') {
        if (local_2c == (char *)0x0) {
          fprintf(stderr,"%s: please provide country abbrev \n","wl_dump_chanspecs");
          return -0x2c;
        }
        strncpy((char *)&local_20,local_2c,3);
        local_20 = local_20 & 0xffffff;
      }
    }
    if ((!bVar1) || (!bVar2)) {
      if (!bVar2) {
        fprintf(stderr,"%s: you need to set a band, \'-b <5|2>\'\n","wl_dump_chanspecs");
      }
      if (!bVar1) {
        fprintf(stderr,"%s: you need to set a bandwidth, \'-w <20|40|80>\'\n","wl_dump_chanspecs");
      }
      return -0x2c;
    }
  }
  if ((local_f0 == 0) || (local_f0 = FUN_00402c2c(local_f0), local_f0 != 0xff)) {
    *(ushort *)(PTR_DAT_00551644 + sVar5 + 1) = local_f0;
    strncpy(PTR_DAT_00551644 + sVar5 + 3,(char *)&local_20,4);
    if (DAT_00557704 == '\0') {
      uVar8 = 0x6e;
    }
    else {
      uVar8 = 0x6e000000;
    }
    *(undefined4 *)(PTR_DAT_00551644 + sVar5 + 7) = uVar8;
    local_e8 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,sVar5 + 0x1c3);
    puVar3 = PTR_DAT_00551644;
    if (-1 < local_e8) {
      local_ec = 0;
      while( true ) {
        if (DAT_00557704 == '\0') {
          uVar7 = *(uint *)puVar3;
        }
        else {
          uVar7 = *(uint *)puVar3;
          uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
        }
        if (uVar7 <= local_ec) break;
        uVar4 = FUN_00402eb0(*(undefined4 *)(puVar3 + local_ec * 4 + 4));
        FUN_004c02bc(uVar4,acStack_1c);
        printf("%s (0x%04x)\n",acStack_1c,(uint)uVar4);
        local_ec = local_ec + 1;
      }
      putchar(10);
    }
  }
  else {
    local_e8 = -0x2c;
  }
  return local_e8;
}



int FUN_00426bf0(int *param_1,int param_2,int param_3)

{
  undefined *puVar1;
  int *piVar2;
  int iVar3;
  size_t sVar4;
  uint uVar5;
  uint local_30;
  
  puVar1 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x2000;
  *(undefined4 *)(puVar1 + 0xc) = 0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    fwrite("missing country abbrev\n",1,0x17,stderr);
    iVar3 = -0x2c;
  }
  else {
    sVar4 = strlen((char *)*piVar2);
    if ((sVar4 < 4) && (1 < sVar4)) {
      strcpy(puVar1 + 8,(char *)*piVar2);
      piVar2 = (int *)(param_3 + 8);
      if (*piVar2 == 0) {
        fwrite("missing band\n",1,0xd,stderr);
        iVar3 = -0x2c;
      }
      else {
        iVar3 = strcasecmp((char *)*piVar2,"a");
        if (iVar3 == 0) {
          *(undefined4 *)(puVar1 + 4) = 1;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar2,"b");
          if (iVar3 != 0) {
            fprintf(stderr,"unsupported band: %s\n",(char *)*piVar2);
            return -0x17;
          }
          *(undefined4 *)(puVar1 + 4) = 2;
        }
        if (DAT_00557704 == '\0') {
          uVar5 = *(uint *)puVar1;
        }
        else {
          uVar5 = *(uint *)puVar1;
          uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        }
        *(uint *)puVar1 = uVar5;
        if (DAT_00557704 == '\0') {
          uVar5 = *(uint *)(puVar1 + 4);
        }
        else {
          uVar5 = *(uint *)(puVar1 + 4);
          uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        }
        *(uint *)(puVar1 + 4) = uVar5;
        if (DAT_00557704 == '\0') {
          uVar5 = *(uint *)(puVar1 + 0xc);
        }
        else {
          uVar5 = *(uint *)(puVar1 + 0xc);
          uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        }
        *(uint *)(puVar1 + 0xc) = uVar5;
        iVar3 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
        if (-1 < iVar3) {
          local_30 = 0;
          while( true ) {
            if (DAT_00557704 == '\0') {
              uVar5 = *(uint *)(puVar1 + 0xc);
            }
            else {
              uVar5 = *(uint *)(puVar1 + 0xc);
              uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                      uVar5 >> 0x18;
            }
            if (uVar5 <= local_30) break;
            if (DAT_00557704 == '\0') {
              uVar5 = *(uint *)(puVar1 + (local_30 + 4) * 4);
            }
            else {
              uVar5 = *(uint *)(puVar1 + (local_30 + 4) * 4);
              uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                      uVar5 >> 0x18;
            }
            printf("%d ",uVar5);
            local_30 = local_30 + 1;
          }
          putchar(10);
        }
      }
    }
    else {
      fprintf(stderr,"invalid country abbrev: %s\n",(char *)*piVar2);
      iVar3 = -2;
    }
  }
  return iVar3;
}



int FUN_004270c8(int *param_1,int param_2,uint *param_3,uint param_4)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = param_4;
  if (DAT_00557704 != '\0') {
    uVar2 = param_4 << 0x18 | (param_4 & 0xff00) << 8 | (param_4 & 0xff0000) >> 8 | param_4 >> 0x18;
  }
  *param_3 = uVar2;
  iVar1 = FUN_004b9f94(param_1,param_2,(char *)param_3,param_4);
  if (-1 < iVar1) {
    if (DAT_00557704 == '\0') {
      uVar2 = *param_3;
    }
    else {
      uVar2 = *param_3;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    *param_3 = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = param_3[1];
    }
    else {
      uVar2 = param_3[1];
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    param_3[1] = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = param_3[2];
    }
    else {
      uVar2 = param_3[2];
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    param_3[2] = uVar2;
    if (*param_3 == 0) {
      param_3[1] = 0;
      param_3[2] = 0;
    }
    else if (((param_3[1] != 0x6d) && (param_3[1] != 0x6c)) && (param_3[1] != 0x6b)) {
      fprintf(stderr,
              "Sorry, your driver has bss_info_version %d but this program supports only version %d.\n"
              ,param_3[1],0x6d);
      *param_3 = 0;
      param_3[2] = 0;
    }
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00427390(int *param_1,char *param_2,uint param_3)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  undefined1 auStack_98 [4];
  uint local_94;
  
  memset(auStack_98,0,0x90);
  if (DAT_00557704 != '\0') {
    param_3 = param_3 << 0x18 | (param_3 & 0xff00) << 8 | (param_3 & 0xff0000) >> 8 |
              param_3 >> 0x18;
  }
  local_94 = param_3;
  iVar1 = FUN_004ba0cc(param_1,"iscanresults",auStack_98,0x10,param_2,0x2000);
  if (-1 < iVar1) {
    puVar2 = (uint *)(param_2 + 4);
    if (DAT_00557704 == '\0') {
      uVar3 = *puVar2;
    }
    else {
      uVar3 = *puVar2;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *puVar2 = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = *(uint *)(param_2 + 8);
    }
    else {
      uVar3 = *(uint *)(param_2 + 8);
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *(uint *)(param_2 + 8) = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = *(uint *)(param_2 + 0xc);
    }
    else {
      uVar3 = *(uint *)(param_2 + 0xc);
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *(uint *)(param_2 + 0xc) = uVar3;
    if (*puVar2 == 0) {
      puts("wl_get_iscan buflen 0");
      param_2[8] = '\0';
      param_2[9] = '\0';
      param_2[10] = '\0';
      param_2[0xb] = '\0';
      param_2[0xc] = '\0';
      param_2[0xd] = '\0';
      param_2[0xe] = '\0';
      param_2[0xf] = '\0';
    }
    else if (((*(int *)(param_2 + 8) != 0x6d) && (*(int *)(param_2 + 8) != 0x6c)) &&
            (*(int *)(param_2 + 8) != 0x6b)) {
      fprintf(stderr,
              "Sorry, your driver has bss_info_version %d but this program supports only version %d.\n"
              ,*(int *)(param_2 + 8),0x6d);
      *puVar2 = 0;
      param_2[0xc] = '\0';
      param_2[0xd] = '\0';
      param_2[0xe] = '\0';
      param_2[0xf] = '\0';
    }
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00427690(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_14,4);
    if (-1 < iVar1) {
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
      }
      switch(local_14) {
      case 0:
        puts("Off");
        break;
      case 1:
        puts("Loose interpretation of 11h spec - may join non 11h AP.");
        break;
      case 2:
        puts("Strict interpretation of 11h spec - may not join non 11h AP.");
        break;
      case 3:
        puts("802.11d mode");
        break;
      case 4:
        puts("Loose interpretation of 11h+d spec - may join non-11h APs");
        break;
      default:
        printf("invalid value 0x%x\n",local_14);
        return -2;
      }
      iVar1 = 0;
    }
  }
  else {
    local_14 = strtol(*(char **)(param_3 + 4),local_10,0);
    if (*local_10[0] == '\0') {
      if (((int)local_14 < 0) || (4 < (int)local_14)) {
        iVar1 = -2;
      }
      else {
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
        }
        iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_14,4);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_00427944(int *param_1)

{
  int iVar1;
  undefined4 uVar2;
  uint *puVar3;
  uint uVar4;
  char acStack_bc [8];
  uint local_b4;
  undefined1 auStack_b0 [32];
  byte abStack_90 [136];
  
  iVar1 = FUN_004b9f94(param_1,0x17,acStack_bc,6);
  if (iVar1 == 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = 0x2000;
    }
    else {
      uVar2 = 0x200000;
    }
    *(undefined4 *)PTR_DAT_00551644 = uVar2;
    iVar1 = FUN_004b9f94(param_1,0x88,PTR_DAT_00551644,0x2000);
    if (iVar1 < 0) {
      return iVar1;
    }
    puVar3 = (uint *)(PTR_DAT_00551644 + 4);
    if (DAT_00557704 == '\0') {
      uVar4 = *puVar3;
    }
    else {
      uVar4 = *puVar3;
      uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    if (uVar4 != 0x6d) {
      if (DAT_00557704 == '\0') {
        uVar4 = *puVar3;
      }
      else {
        uVar4 = *puVar3;
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      if (uVar4 != 0x6c) {
        if (DAT_00557704 == '\0') {
          uVar4 = *puVar3;
        }
        else {
          uVar4 = *puVar3;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        if (uVar4 != 0x6b) {
          fprintf(stderr,
                  "Sorry, your driver has bss_info_version %d but this program supports only version %d.\n"
                  ,*puVar3,0x6d);
          return 0;
        }
      }
    }
    FUN_004242c8(puVar3);
  }
  else {
    printf("Not associated. Last associated with ");
    iVar1 = FUN_004b9f94(param_1,0x19,(char *)&local_b4,0x24);
    if (iVar1 < 0) {
      putchar(10);
      return iVar1;
    }
    if (DAT_00557704 != '\0') {
      local_b4 = local_b4 << 0x18 | (local_b4 & 0xff00) << 8 | (local_b4 & 0xff0000) >> 8 |
                 local_b4 >> 0x18;
    }
    FUN_0041e0e8(abStack_90,(int)auStack_b0,local_b4);
    printf("SSID: \"%s\"\n",(char *)abStack_90);
  }
  return 0;
}



undefined4 FUN_00427cfc(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  int *piVar2;
  ulong uVar3;
  undefined4 local_20;
  uint local_18;
  char acStack_14 [12];
  
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("STA MAC not specified, deauth all\n",1,0x22,stderr);
    local_20 = FUN_004ba050(param_1,0x8f,(char *)&DAT_004e4940,6);
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),acStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      fwrite("Malformed STA MAC parameter\n",1,0x1c,stderr);
      local_20 = 0xffffffd4;
    }
    else {
      piVar2 = (int *)(param_3 + 8);
      if (*piVar2 == 0) {
        local_20 = FUN_004ba050(param_1,0x8f,acStack_14,6);
      }
      else {
        if (DAT_00557704 == '\0') {
          local_18 = strtoul((char *)*piVar2,(char **)0x0,0);
        }
        else {
          uVar3 = strtoul((char *)*piVar2,(char **)0x0,0);
          local_18 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        local_20 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_18,0xc);
      }
    }
  }
  return local_20;
}



int FUN_00427efc(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  int *local_res8;
  int local_38;
  int local_34;
  uint local_30;
  int local_2c;
  int *local_28;
  int local_24;
  uint local_20;
  uint local_18;
  int local_14;
  uint local_10 [2];
  
  local_18 = 0;
  local_10[0] = 0;
  local_38 = FUN_004024e8((int *)(param_3 + 4),*param_2,&local_18,&local_14);
  if (local_38 == 0) {
    piVar2 = (int *)(param_3 + 4) + local_14;
    if (*piVar2 == 0) {
      if (local_14 == 0) {
        local_38 = FUN_004ba35c(param_1,"wpa_auth",local_10);
      }
      else {
        local_38 = FUN_00445a00(param_1,"wpa_auth",local_18,local_10);
      }
      if (-1 < local_38) {
        printf("0x%x",local_10[0]);
        if (local_10[0] == 0) {
          printf(" Disabled");
        }
        for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
          if ((*(uint *)(&DAT_00556198 + local_34 * 8) & local_10[0]) != 0) {
            printf(" %s",(&PTR_s_WPA_NONE_0055619c)[local_34 * 2]);
          }
        }
        putchar(10);
      }
    }
    else {
      local_38 = 1;
      local_res8 = piVar2;
      if ((*(ushort *)(__ctype_b + *(char *)*piVar2 * 2) & 8) == 0) {
        local_2c = 0;
        local_20 = 0;
        local_10[0] = 0;
        for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
          local_20 = local_20 | *(uint *)(&DAT_00556198 + local_34 * 8);
        }
        for (local_28 = piVar2; *local_28 != 0; local_28 = local_28 + 1) {
          local_2c = local_2c + 1;
        }
        for (local_24 = 0; local_24 < local_2c; local_24 = local_24 + 1) {
          bVar1 = false;
          local_res8 = piVar2 + local_24;
          for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
            iVar3 = strcasecmp((&PTR_s_WPA_NONE_0055619c)[local_34 * 2],(char *)*local_res8);
            if (iVar3 == 0) {
              bVar1 = true;
              local_10[0] = *(uint *)(&DAT_00556198 + local_34 * 8) | local_10[0];
              local_38 = 0;
              local_res8 = local_res8 + 1;
              if (*local_res8 == 0) break;
            }
          }
          if ((!bVar1) || ((local_10[0] & ~local_20 & 0xffff) != 0)) goto LAB_00428428;
        }
      }
      else {
        local_30 = 0;
        local_10[0] = strtoul((char *)*piVar2,(char **)0x0,0);
        for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
          local_30 = local_30 | *(uint *)(&DAT_00556198 + local_34 * 8);
        }
        if ((local_10[0] & ~local_30 & 0xffff) != 0) {
          local_38 = 1;
LAB_00428428:
          fwrite("Inavlid user argument.\n",1,0x17,stderr);
          fwrite("Values may be a bitvector or list of names from the set.\n",1,0x39,stderr);
          for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
            fprintf(stderr,"\n0x%04x  %s",*(uint *)(&DAT_00556198 + local_34 * 8),
                    (&PTR_s_WPA_NONE_0055619c)[local_34 * 2]);
          }
          putchar(10);
          return local_38;
        }
        local_38 = 0;
      }
      if (local_38 == 0) {
        if (local_14 == 0) {
          local_38 = FUN_004ba428(param_1,"wpa_auth",local_10[0]);
        }
        else {
          local_38 = FUN_00445ad8(param_1,"wpa_auth",local_18,local_10[0]);
        }
      }
      else {
        fprintf(stderr,"%s is not a valid WPA auth mode\n",(char *)*local_res8);
      }
    }
  }
  return local_38;
}



undefined4 FUN_00428510(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  size_t __n;
  ushort local_50;
  undefined2 local_4e;
  undefined1 auStack_4c [68];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    __n = strlen((char *)*piVar1);
    if ((__n < 8) || (0x40 < __n)) {
      fprintf(stderr,"passphrase must be between %d and %d characters long\n",8,0x40);
      uVar2 = 0xfffffffe;
    }
    else {
      local_50 = (ushort)__n;
      if (DAT_00557704 == '\0') {
        local_4e = 1;
      }
      else {
        local_50 = local_50 << 8 | local_50 >> 8;
        local_4e = 0x100;
      }
      memcpy(auStack_4c,(void *)*piVar1,__n);
      uVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_50,0x44);
    }
  }
  return uVar2;
}



int FUN_004286c0(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int local_28;
  uint local_1c;
  uint local_18;
  int local_14;
  char *local_10 [2];
  
  local_18 = 0;
  local_10[0] = (char *)0x0;
  local_28 = FUN_004024e8((int *)(param_3 + 4),&DAT_004f36d8,&local_18,&local_14);
  if (local_28 == 0) {
    piVar1 = (int *)(param_3 + 4) + local_14;
    if (*piVar1 == 0) {
      if (local_14 == 0) {
        local_28 = FUN_004b9f94(param_1,0x85,(char *)&local_1c,4);
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
        }
      }
      else {
        local_28 = FUN_00445a00(param_1,"wsec",local_18,&local_1c);
      }
      if (local_28 == 0) {
        FUN_00402444(local_1c);
      }
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"off");
      if (iVar2 == 0) {
        local_1c = 0;
      }
      else {
        local_1c = strtol((char *)*piVar1,local_10,0);
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
      }
      if (local_14 == 0) {
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
        }
        local_28 = FUN_004ba050(param_1,0x86,(char *)&local_1c,4);
      }
      else {
        local_28 = FUN_00445ad8(param_1,"wsec",local_18,local_1c);
      }
    }
  }
  return local_28;
}



undefined4 FUN_0042897c(int *param_1,int param_2,char param_3)

{
  bool bVar1;
  size_t sVar2;
  int iVar3;
  ulong uVar4;
  uint uVar5;
  undefined3 extraout_var;
  int *local_res0;
  undefined1 *local_18;
  char *local_14;
  char local_10 [8];
  
  local_10[0] = 'X';
  local_10[1] = 'X';
  local_10[2] = 0;
  local_18 = (undefined1 *)(param_2 + 8);
  local_14 = (char *)*param_1;
  sVar2 = strlen(local_14);
  switch(sVar2) {
  case 5:
  case 0xd:
  case 0x10:
    sVar2 = strlen(local_14);
    *(size_t *)(param_2 + 4) = sVar2;
    memcpy(local_18,local_14,*(int *)(param_2 + 4) + 1);
    break;
  default:
    return 0xffffffff;
  case 0xc:
  case 0x1c:
  case 0x22:
  case 0x42:
    iVar3 = strncasecmp(local_14,"0x",2);
    if (iVar3 != 0) {
      return 0xffffffff;
    }
    local_14 = local_14 + 2;
  case 10:
  case 0x1a:
  case 0x20:
  case 0x40:
    sVar2 = strlen(local_14);
    *(size_t *)(param_2 + 4) = sVar2 >> 1;
    for (; *local_14 != '\0'; local_14 = local_14 + 2) {
      strncpy(local_10,local_14,2);
      uVar4 = strtoul(local_10,(char **)0x0,0x10);
      *local_18 = (char)uVar4;
      local_18 = local_18 + 1;
    }
  }
  uVar5 = *(uint *)(param_2 + 4);
  if (uVar5 == 0xd) {
    *(undefined4 *)(param_2 + 0x70) = 3;
  }
  else if (uVar5 < 0xe) {
    if (uVar5 != 5) {
      return 0xffffffff;
    }
    *(undefined4 *)(param_2 + 0x70) = 1;
  }
  else if (uVar5 == 0x10) {
    *(undefined4 *)(param_2 + 0x70) = 4;
  }
  else {
    if (uVar5 != 0x20) {
      return 0xffffffff;
    }
    *(undefined4 *)(param_2 + 0x70) = 2;
  }
  *(uint *)(param_2 + 0x74) = *(uint *)(param_2 + 0x74) | 2;
  local_res0 = param_1;
  if (param_3 != '\0') {
    while (local_res0 = local_res0 + 1, *local_res0 != 0) {
      iVar3 = strncasecmp("ccm",(char *)*local_res0,3);
      if ((iVar3 == 0) && (*(int *)(param_2 + 4) == 0x10)) {
        *(undefined4 *)(param_2 + 0x70) = 4;
      }
      else {
        iVar3 = strncasecmp("wapi",(char *)*local_res0,4);
        if ((iVar3 == 0) && (*(int *)(param_2 + 4) == 0x20)) {
          *(undefined4 *)(param_2 + 0x70) = 0xb;
        }
        else {
          iVar3 = strncasecmp("ocb",(char *)*local_res0,3);
          if ((iVar3 == 0) && (*(int *)(param_2 + 4) == 0x10)) {
            *(undefined4 *)(param_2 + 0x70) = 6;
          }
          else {
            iVar3 = strncasecmp("notx",(char *)*local_res0,4);
            if (iVar3 == 0) {
              *(uint *)(param_2 + 0x74) = *(uint *)(param_2 + 0x74) & 0xfffffffd;
            }
            else {
              bVar1 = FUN_0041d6ac((char *)*local_res0,(void *)(param_2 + 0x9c));
              if (CONCAT31(extraout_var,bVar1) == 0) {
                memset((void *)(param_2 + 0x9c),0,6);
              }
            }
          }
        }
      }
    }
  }
  return 0;
}



int FUN_00428d9c(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  uint local_20;
  uint local_c;
  
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_20 = 0;
    do {
      local_c = local_20;
      if (DAT_00557704 != '\0') {
        local_c = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                  local_20 >> 0x18;
      }
      iVar3 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_c,4);
      if (iVar3 < 0) {
        return iVar3;
      }
      if (DAT_00557704 == '\0') {
        bVar1 = local_c != 0;
      }
      else {
        bVar1 = (((local_c & 0xff) != 0 || (local_c & 0xff00) != 0) || (local_c & 0xff0000) != 0) ||
                local_c >> 0x18 != 0;
      }
      if (bVar1) {
        printf("Key %d is primary\n",local_20);
        return 0;
      }
      local_20 = local_20 + 1;
    } while ((int)local_20 < 4);
    puts("No primary key set");
  }
  else {
    if (DAT_00557704 == '\0') {
      local_c = atoi((char *)*piVar2);
    }
    else {
      uVar4 = atoi((char *)*piVar2);
      local_c = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    iVar3 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_c,4);
  }
  return iVar3;
}



int FUN_00429008(int *param_1,int param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  uint local_b4;
  uint local_b0;
  uint local_44;
  uint local_40;
  uint local_10;
  int local_c;
  
  local_10 = 0;
  memset(&local_b4,0,0xa4);
  iVar1 = FUN_004024e8((int *)(param_3 + 4),"addwep",&local_10,&local_c);
  if (iVar1 == 0) {
    piVar2 = (int *)(param_3 + 4) + local_c;
    if (*piVar2 == 0) {
      iVar1 = -0x2c;
    }
    else {
      local_b4 = atoi((char *)*piVar2);
      if (piVar2[1] == 0) {
        fwrite("No key specified\n",1,0x11,stderr);
        iVar1 = -0x2c;
      }
      else {
        iVar1 = FUN_0042897c(piVar2 + 1,(int)&local_b4,'\x01');
        if (iVar1 == 0) {
          if (DAT_00557704 != '\0') {
            local_b4 = local_b4 << 0x18 | (local_b4 & 0xff00) << 8 | (local_b4 & 0xff0000) >> 8 |
                       local_b4 >> 0x18;
            local_b0 = local_b0 << 0x18 | (local_b0 & 0xff00) << 8 | (local_b0 & 0xff0000) >> 8 |
                       local_b0 >> 0x18;
            local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                       local_44 >> 0x18;
            local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                       local_40 >> 0x18;
          }
          if (local_c == 0) {
            iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_b4,0xa4);
          }
          else {
            iVar1 = FUN_00445758(param_1,"wsec_key",local_10,&local_b4,0xa4,PTR_DAT_00551644,0x2000)
            ;
          }
        }
        else {
          iVar1 = -2;
        }
      }
    }
  }
  return iVar1;
}



int FUN_00429368(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  undefined3 extraout_var;
  int *local_res8;
  uint local_b8 [39];
  undefined1 auStack_1c [8];
  undefined4 local_14;
  int local_10 [2];
  
  local_14 = 0;
  memset(local_b8,0,0xa4);
  iVar2 = FUN_004024e8((int *)(param_3 + 4),"rmwep",&local_14,local_10);
  if (iVar2 == 0) {
    local_res8 = (int *)(param_3 + 4) + local_10[0];
    if (*local_res8 == 0) {
      iVar2 = -0x2c;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_b8[0] = atoi((char *)*local_res8);
      }
      else {
        uVar3 = atoi((char *)*local_res8);
        local_b8[0] = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 |
                      uVar3 >> 0x18;
      }
      local_res8 = local_res8 + 1;
      if ((*local_res8 == 0) ||
         (bVar1 = FUN_0041d6ac((char *)*local_res8,auStack_1c), CONCAT31(extraout_var,bVar1) != 0))
      {
        if (local_10[0] == 0) {
          iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)local_b8,0xa4);
        }
        else {
          iVar2 = FUN_00445444(param_1,"wsec_key",local_b8,0xa4);
        }
      }
      else {
        iVar2 = -0x2c;
      }
    }
  }
  return iVar2;
}



undefined4 FUN_00429574(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  uint *__ptr;
  undefined3 extraout_var;
  undefined4 uVar4;
  uint uVar5;
  int local_30;
  uint local_2c;
  uint local_28;
  undefined4 local_24;
  char *local_c;
  
  local_c = (char *)0x0;
  local_24 = 0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_24 = 0xffffffd4;
  }
  else {
    local_2c = strtol((char *)*piVar2,&local_c,0);
    if ((char *)*piVar2 == local_c) {
      for (local_30 = 0; *(int *)(&DAT_00555f2c + local_30 * 8) != 0; local_30 = local_30 + 1) {
        iVar3 = strcasecmp((&PTR_s_mic_error_00555f30)[local_30 * 2],(char *)*piVar2);
        if (iVar3 == 0) {
          local_2c = *(uint *)(&DAT_00555f2c + local_30 * 8);
          break;
        }
      }
      if (*(int *)(&DAT_00555f2c + local_30 * 8) == 0) {
        local_24 = 0xfffffffe;
        goto LAB_0042992c;
      }
    }
    piVar2 = (int *)(param_3 + 8);
    if ((local_2c - 1 < 0x20) && (-0x2efeffff << (local_2c - 1 & 0x1f) < 0)) {
      if (*piVar2 == 0) {
        fwrite("insufficient arguments\n",1,0x17,stderr);
        return 0xffffffd4;
      }
      __ptr = (uint *)malloc(0xa8);
      if (__ptr != (uint *)0x0) {
        if (DAT_00557704 != '\0') {
          local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                     local_2c >> 0x18;
        }
        *__ptr = local_2c;
        memset(__ptr + 1,0,0xa4);
        bVar1 = FUN_0041d6ac((char *)*piVar2,__ptr + 0x28);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          memset(__ptr + 0x28,0,6);
          if (DAT_00557704 == '\0') {
            uVar5 = atoi((char *)*piVar2);
          }
          else {
            uVar5 = atoi((char *)*piVar2);
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          __ptr[1] = uVar5;
        }
        uVar4 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)__ptr,0xa8);
        free(__ptr);
        return uVar4;
      }
      fwrite("Error allocating memory failed for wsec_buf",1,0x2b,stderr);
      return 0xffffffe5;
    }
  }
LAB_0042992c:
  fwrite("wsec test_type may be a number or name from the following set:",1,0x3e,stderr);
  local_28 = 0xffffffff;
  for (local_30 = 0; uVar5 = *(uint *)(&DAT_00555f2c + local_30 * 8), uVar5 != 0;
      local_30 = local_30 + 1) {
    if (uVar5 == local_28) {
      fprintf(stderr,", %s",(&PTR_s_mic_error_00555f30)[local_30 * 2]);
    }
    else {
      fprintf(stderr,"\n0x%04x %s",uVar5,(&PTR_s_mic_error_00555f30)[local_30 * 2]);
    }
    local_28 = uVar5;
  }
  fputc(10,stderr);
  return local_24;
}



int FUN_00429a60(int *param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  char *param4;
  uint uVar4;
  uint local_108;
  uint local_104;
  char *local_100;
  uint local_fc;
  uint local_f8;
  uint local_bc;
  uint local_b8;
  byte abStack_b4 [104];
  uint local_4c;
  uint local_48;
  char local_20;
  char local_1f;
  char local_1e;
  char local_1d;
  char local_1c;
  char local_1b;
  uint local_18 [3];
  
  local_18[0] = 0;
  iVar2 = FUN_004ba35c(param_1,"wsec",local_18);
  if (iVar2 < 0) {
    fwrite("Could not query wsec status.\n",1,0x1d,stderr);
  }
  local_f8 = 0xffffffff;
  local_fc = 0xffffffff;
  local_108 = 0;
  do {
    local_bc = local_108;
    if (DAT_00557704 != '\0') {
      local_bc = local_108 << 0x18 | (local_108 & 0xff00) << 8 | (local_108 & 0xff0000) >> 8 |
                 local_108 >> 0x18;
    }
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_bc,0xa4);
    if (((((local_20 == '\0' && local_1f == '\0') && local_1e == '\0') && local_1d == '\0') &&
        local_1c == '\0') && local_1b == '\0') {
      if (DAT_00557704 == '\0') {
        if (local_4c != 0) goto LAB_00429c60;
      }
      else if ((((local_4c & 0xff) != 0 || (local_4c & 0xff00) != 0) || (local_4c & 0xff0000) != 0)
               || local_4c >> 0x18 != 0) goto LAB_00429c60;
      bVar1 = true;
    }
    else {
LAB_00429c60:
      bVar1 = false;
    }
    if ((local_fc != 0xffffffff) && ((iVar2 < 0 || (!bVar1)))) {
      if (local_fc == local_f8) {
        printf("%3d: <empty>\n",local_fc);
      }
      else {
        printf("%3d - %3d: <empty>\n",local_fc,local_f8);
      }
      local_f8 = 0xffffffff;
      local_fc = 0xffffffff;
    }
    if (iVar2 < 0) {
      if (3 < local_108) {
        iVar2 = 0;
      }
      return iVar2;
    }
    if (local_108 < 4) {
      local_100 = "(default)";
LAB_00429d88:
      uVar3 = local_4c;
      uVar4 = local_bc;
      if (DAT_00557704 != '\0') {
        uVar3 = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                local_4c >> 0x18;
        uVar4 = local_bc << 0x18 | (local_bc & 0xff00) << 8 | (local_bc & 0xff0000) >> 8 |
                local_bc >> 0x18;
      }
      param4 = FUN_004beb9c(uVar3);
      printf("%3d: %-17s Key %d: %s ",local_108,local_100,uVar4,param4);
      if (local_18[0] != 0) {
        uVar4 = local_48;
        if (DAT_00557704 != '\0') {
          uVar4 = local_48 >> 0x18;
        }
        if ((uVar4 & 2) != 0) {
          putchar(0x2a);
        }
      }
      putchar(9);
      if (DAT_00557704 == '\0') {
        bVar1 = local_b8 == 0;
      }
      else {
        bVar1 = (((local_b8 & 0xff) == 0 && (local_b8 & 0xff00) == 0) && (local_b8 & 0xff0000) == 0)
                && local_b8 >> 0x18 == 0;
      }
      if (bVar1) {
        printf("No key present");
      }
      else {
        uVar4 = local_48;
        if (DAT_00557704 != '\0') {
          uVar4 = local_48 >> 0x18;
        }
        if ((uVar4 & 1) != 0) {
          printf("soft ");
        }
        uVar4 = local_b8;
        if (DAT_00557704 != '\0') {
          uVar4 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                  local_b8 >> 0x18;
        }
        printf("len %d, data 0x",uVar4);
        local_104 = 0;
        while( true ) {
          uVar4 = local_b8;
          if (DAT_00557704 != '\0') {
            uVar4 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                    local_b8 >> 0x18;
          }
          if (uVar4 <= local_104) break;
          printf("%02X",(uint)abStack_b4[local_104]);
          local_104 = local_104 + 1;
        }
        local_104 = 0;
        while( true ) {
          uVar4 = local_b8;
          if (DAT_00557704 != '\0') {
            uVar4 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                    local_b8 >> 0x18;
          }
          if ((uVar4 <= local_104) ||
             ((*(ushort *)(__ctype_b + (uint)abStack_b4[local_104] * 2) & 0x40) == 0)) break;
          local_104 = local_104 + 1;
        }
        uVar4 = local_b8;
        if (DAT_00557704 != '\0') {
          uVar4 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                  local_b8 >> 0x18;
        }
        if (uVar4 == local_104) {
          uVar4 = local_b8;
          if (DAT_00557704 != '\0') {
            uVar4 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                    local_b8 >> 0x18;
          }
          printf(" (%.*s)",uVar4,(char *)abStack_b4);
        }
      }
      putchar(10);
    }
    else {
      if (!bVar1) {
        local_100 = FUN_0041d780((int)&local_20);
        goto LAB_00429d88;
      }
      if (local_fc == 0xffffffff) {
        local_fc = local_108;
      }
      local_f8 = local_108;
    }
    local_108 = local_108 + 1;
  } while( true );
}



int FUN_0042a320(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint param1;
  uint local_14;
  uint local_10;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = -0x2c;
  }
  else {
    param1 = atoi(*(char **)(param_3 + 4));
    if ((int)param1 < 0) {
      fprintf(stderr,"Key index %d out of range. Should be positive.\n",param1);
      iVar1 = -2;
    }
    else {
      local_14 = param1;
      if (DAT_00557704 != '\0') {
        local_14 = param1 << 0x18 | (param1 & 0xff00) << 8 | (param1 & 0xff0000) >> 8 |
                   param1 >> 0x18;
      }
      iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_14,8);
      if (-1 < iVar1) {
        printf("Key %d TSC: 0x%04x:%08x\n",param1,local_10,local_14);
        iVar1 = 0;
      }
    }
  }
  return iVar1;
}



void FUN_0042a4ec(int *param_1,int param_2,uint param_3)

{
  int iVar1;
  
  iVar1 = FUN_004cf244(param_1);
  if (iVar1 == 1) {
    puts("\n20 in 40MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,3);
    puts("\n40MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,1);
  }
  else if (iVar1 == 0) {
    puts("\n20MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,0);
  }
  else if (iVar1 == 2) {
    puts("\n20 in 80MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,4);
    puts("\n40 in 80MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,5);
    puts("\n80MHz:");
    FUN_0042a9bc(param_1,param_2,param_3,2);
  }
  putchar(10);
  return;
}



int FUN_0042a670(int *param_1,int param_2,undefined4 param_3)

{
  int iVar1;
  char local_30;
  char acStack_28 [4];
  char acStack_24 [8];
  char acStack_1c [8];
  char acStack_14 [12];
  
  iVar1 = *(int *)(&DAT_004ec26c + param_2 * 0x1c);
  local_30 = -0x80;
  switch(*(undefined4 *)(&DAT_004ebe5c + iVar1 * 0x18)) {
  case 0:
    FUN_004cf2a0(param_1,param_3,*(int *)(&DAT_004ebe50 + iVar1 * 0x18),acStack_28);
    local_30 = acStack_28[param_2 - *(int *)(&DAT_004ebe60 + iVar1 * 0x18)];
    break;
  case 1:
    FUN_004cf364(param_1,param_3,*(int *)(&DAT_004ebe54 + iVar1 * 0x18),
                 *(int *)(&DAT_004ebe50 + iVar1 * 0x18),acStack_24);
    local_30 = acStack_24[param_2 - *(int *)(&DAT_004ebe60 + iVar1 * 0x18)];
    break;
  case 2:
    FUN_004cf42c(param_1,param_3,*(int *)(&DAT_004ebe58 + iVar1 * 0x18),
                 *(int *)(&DAT_004ebe54 + iVar1 * 0x18),*(uint *)(&DAT_004ebe50 + iVar1 * 0x18),
                 acStack_1c);
    local_30 = acStack_1c[param_2 - *(int *)(&DAT_004ebe60 + iVar1 * 0x18)];
    break;
  case 3:
  case 4:
    FUN_004cf4f8(param_1,param_3,*(int *)(&DAT_004ebe58 + iVar1 * 0x18),
                 *(int *)(&DAT_004ebe54 + iVar1 * 0x18),*(uint *)(&DAT_004ebe50 + iVar1 * 0x18),
                 acStack_14);
    local_30 = acStack_14[param_2 - *(int *)(&DAT_004ebe60 + iVar1 * 0x18)];
  }
  return (int)local_30;
}



void FUN_0042a9bc(int *param_1,int param_2,uint param_3,undefined4 param_4)

{
  bool bVar1;
  uint local_50;
  uint local_4c;
  uint local_48;
  uint local_44;
  int local_40;
  undefined1 *local_3c;
  undefined1 *local_38;
  char *local_34;
  int local_30;
  int local_2c;
  uint local_28;
  char acStack_20 [8];
  undefined1 auStack_18 [8];
  undefined1 auStack_10 [4];
  char acStack_c [4];
  
  local_44 = 4;
  local_40 = 0;
  local_34 = "";
  bVar1 = (param_3 & 4) != 0;
  if (bVar1) {
    local_44 = 6;
    local_40 = 6;
  }
  if (param_2 != 0) {
    FUN_004cf2a0(param_1,param_4,1,acStack_c);
    printf("CCK         ");
    for (local_4c = 0; local_4c < 4; local_4c = local_4c + 1) {
      if (acStack_c[local_4c] == -0x80) {
        printf("  -");
      }
      else {
        printf(" %2d",(int)acStack_c[local_4c]);
      }
    }
    if (bVar1) {
      FUN_004cf2a0(param_1,param_4,2,acStack_c);
      printf("\nCCK CDD 1x2 ");
      for (local_4c = 0; local_4c < 4; local_4c = local_4c + 1) {
        if (acStack_c[local_4c] == -0x80) {
          printf("  -");
        }
        else {
          printf(" %2d",(int)acStack_c[local_4c]);
        }
      }
      FUN_004cf2a0(param_1,param_4,3,acStack_c);
      printf("\nCCK CDD 1x3 ");
      for (local_4c = 0; local_4c < 4; local_4c = local_4c + 1) {
        if (acStack_c[local_4c] == -0x80) {
          printf("  -");
        }
        else {
          printf(" %2d",(int)acStack_c[local_4c]);
        }
      }
    }
  }
  FUN_004cf364(param_1,param_4,0,1,acStack_20);
  printf("\nOFDM        ");
  for (local_4c = 0; local_4c < 8; local_4c = local_4c + 1) {
    if (acStack_20[local_4c] == -0x80) {
      printf("  -");
    }
    else {
      printf(" %2d",(int)acStack_20[local_4c]);
    }
  }
  FUN_004cf364(param_1,param_4,2,2,acStack_20);
  printf("\nOFDM-CDD    ");
  for (local_4c = 0; local_4c < 8; local_4c = local_4c + 1) {
    if (acStack_20[local_4c] == -0x80) {
      printf("  -");
    }
    else {
      printf(" %2d",(int)acStack_20[local_4c]);
    }
  }
  putchar(10);
  for (local_50 = 0; local_50 < local_44; local_50 = local_50 + 1) {
    switch(local_50 + local_40) {
    case 0:
      local_34 = "MCS-SISO   ";
      local_30 = 1;
      local_2c = 0;
      local_28 = 1;
      local_3c = auStack_18;
      local_38 = (undefined1 *)0x0;
      break;
    case 1:
      local_34 = "MCS-CDD    ";
      local_30 = 1;
      local_2c = 2;
      local_28 = 2;
      local_3c = auStack_18;
      local_38 = (undefined1 *)0x0;
      break;
    case 2:
      local_34 = "MCS STBC   ";
      local_30 = 1;
      local_2c = 1;
      local_28 = 2;
      local_3c = auStack_18;
      local_38 = (undefined1 *)0x0;
      break;
    case 3:
      local_34 = "MCS 8~15   ";
      local_30 = 2;
      local_2c = 0;
      local_28 = 2;
      local_3c = auStack_18;
      local_38 = (undefined1 *)0x0;
      break;
    case 4:
    case 5:
      local_3c = (undefined1 *)0x0;
      local_38 = (undefined1 *)0x0;
      break;
    case 6:
      local_34 = "1 Nsts 1 Tx";
      local_30 = 1;
      local_2c = 0;
      local_28 = 1;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    case 7:
      local_34 = "1 Nsts 2 Tx";
      local_30 = 1;
      local_2c = 2;
      local_28 = 2;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    case 8:
      local_34 = "1 Nsts 3 Tx";
      local_30 = 1;
      local_2c = 2;
      local_28 = 3;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    case 9:
      local_34 = "2 Nsts 2 Tx";
      local_30 = 2;
      local_2c = 0;
      local_28 = 2;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    case 10:
      local_34 = "2 Nsts 3 Tx";
      local_30 = 2;
      local_2c = 0;
      local_28 = 3;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    case 0xb:
      local_34 = "3 Nsts 3 Tx";
      local_30 = 3;
      local_2c = 0;
      local_28 = 3;
      local_3c = auStack_18;
      local_38 = auStack_10;
      break;
    default:
      local_3c = (undefined1 *)0x0;
      local_38 = (undefined1 *)0x0;
    }
    if (local_3c != (undefined1 *)0x0) {
      FUN_004cf4f8(param_1,param_4,local_30,local_2c,local_28,auStack_18);
      printf("%s ",local_34);
      if (((param_3 & 0x20) == 0) || (local_38 == (undefined1 *)0x0)) {
        local_48 = 8;
      }
      else {
        local_48 = 10;
      }
      for (local_4c = 0; local_4c < local_48; local_4c = local_4c + 1) {
        if (local_3c[local_4c] == -0x80) {
          printf("  -");
        }
        else {
          printf(" %2d",(int)(char)local_3c[local_4c]);
        }
      }
      putchar(10);
    }
  }
  return;
}



int FUN_0042b1b0(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  undefined2 *__s;
  uint uVar5;
  char *pcVar6;
  char acStack_28 [20];
  int *local_14 [2];
  
  iVar3 = FUN_004cf27c();
  uVar4 = FUN_004ceff4(iVar3);
  local_14[0] = (int *)0x0;
  __s = (undefined2 *)malloc(uVar4 + 0x14);
  if (__s == (undefined2 *)0x0) {
    fwrite("Error allocating memory failed for curppr",1,0x29,stderr);
    iVar3 = -0x1b;
  }
  else {
    memset(__s,0,0x14);
    *(uint *)(__s + 6) = uVar4;
    iVar3 = FUN_004cf27c();
    iVar3 = FUN_004cf09c((undefined4 *)(__s + 8),iVar3,uVar4);
    if (iVar3 == 0) {
      if (uVar4 + 0x14 < 0x2001) {
        if (*(int *)(param_3 + 4) != 0) {
          fprintf(stderr,"Ignoring arguments for %s\n",(char *)*param_2);
        }
        *__s = 1;
        __s[1] = 0x14;
        iVar3 = FUN_004ba0cc(param_1,"curppr",__s,uVar4 + 0x14,PTR_DAT_00551644,0x2000);
        if (iVar3 < 0) {
          free(__s);
        }
        else {
          free(__s);
          puVar1 = PTR_DAT_00551644;
          if (DAT_00557704 == '\0') {
            uVar5 = *(uint *)(PTR_DAT_00551644 + 4);
          }
          else {
            uVar5 = *(uint *)(PTR_DAT_00551644 + 4);
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          *(uint *)(PTR_DAT_00551644 + 4) = uVar5;
          uVar2 = FUN_00402de8(*(ushort *)(puVar1 + 8));
          *(ushort *)(puVar1 + 8) = uVar2;
          uVar2 = FUN_00402de8(*(ushort *)(puVar1 + 10));
          *(ushort *)(puVar1 + 10) = uVar2;
          uVar2 = *(ushort *)(puVar1 + 8);
          uVar5 = *(uint *)(puVar1 + 4);
          pcVar6 = FUN_004c02bc(*(ushort *)(puVar1 + 8),acStack_28);
          printf("Current channel:\t %s\n",pcVar6);
          pcVar6 = FUN_004c02bc(*(ushort *)(puVar1 + 10),acStack_28);
          printf("BSS channel:\t\t %s\n",pcVar6);
          printf("Power/Rate Dump (in 1/4dB): Channel %d\n",uVar2 & 0xff);
          iVar3 = FUN_004d23d8(0,puVar1 + 0x10,uVar4,local_14);
          if (iVar3 == 0) {
            FUN_0042a4ec(local_14[0],(uint)((uVar2 & 0xc000) == 0),uVar5 & 0x3c);
            FUN_004cf208(0,local_14[0]);
          }
        }
      }
      else {
        free(__s);
        iVar3 = -1;
      }
    }
    else {
      free(__s);
    }
  }
  return iVar3;
}



// WARNING: Removing unreachable block (ram,0x0042bad4)

int FUN_0042b588(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  undefined *puVar3;
  ushort uVar4;
  int iVar5;
  uint uVar6;
  int *local_res8;
  int local_e0;
  int local_dc;
  ushort local_d8;
  char acStack_c8 [20];
  undefined2 local_b4;
  undefined2 local_b2;
  undefined4 local_b0;
  ushort local_ac;
  undefined4 auStack_a8 [3];
  int local_9c;
  char local_97;
  char local_96;
  char *local_14;
  int local_c;
  
  local_d8 = 0;
  bVar2 = false;
  bVar1 = false;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 != 0) {
    FUN_004cbd80(auStack_a8,"wl_get_chanspec_txpwr_max",0,0);
    while (iVar5 = FUN_004cbe18(auStack_a8,local_res8), iVar5 != -1) {
      if (iVar5 == 1) {
        return -0x2c;
      }
      local_res8 = local_res8 + local_9c;
      if (local_96 == 'b') {
        if (local_97 == '\0') {
          fprintf(stderr,"%s: could not parse [%s] as band\n","wl_get_chanspec_txpwr_max",local_14);
          return -2;
        }
        if ((local_c != 5) && (local_c != 2)) {
          fprintf(stderr,"%s: invalid band %d\n","wl_get_chanspec_txpwr_max",local_c);
          return -2;
        }
        if (local_c == 5) {
          local_d8 = local_d8 | 0xc000;
        }
        bVar2 = true;
      }
      if (local_96 == 'w') {
        if (local_97 == '\0') {
          fprintf(stderr,"%s: could not parse [%s] as bandwidth\n","wl_get_chanspec_txpwr_max",
                  local_14);
          return -2;
        }
        if (local_c == 0x14) {
          local_d8 = local_d8 | 0x1000;
        }
        else if (local_c == 0x28) {
          local_d8 = local_d8 | 0x1800;
        }
        else if (local_c == 0x50) {
          local_d8 = local_d8 | 0x2000;
        }
        else if (local_c == 0xa0) {
          local_d8 = local_d8 | 0x2800;
        }
        else {
          if (local_c != 0x1f90) {
            fprintf(stderr,"%s: invalid bandwidth %d\n","wl_get_chanspec_txpwr_max",local_c);
            return -2;
          }
          local_d8 = local_d8 | 0x3000;
        }
        bVar1 = true;
      }
    }
    if ((!bVar1) || (!bVar2)) {
      if (!bVar2) {
        fprintf(stderr,"%s: you need to set a band, \'-b <5|2>\'\n","wl_get_chanspec_txpwr_max");
      }
      if (!bVar1) {
        fprintf(stderr,"%s: you need to set a bandwidth, \'-w <20|40|80>\'\n",
                "wl_get_chanspec_txpwr_max");
      }
      return -0x2c;
    }
  }
  if ((local_d8 == 0) || (local_d8 = FUN_00402c2c(local_d8), local_d8 != 0xff)) {
    memset(&local_b4,0,0xc);
    local_b4 = 1;
    local_b2 = 0xc;
    local_b0 = 1;
    local_ac = local_d8;
    local_dc = FUN_004ba0cc(param_1,(char *)*param_2,&local_b4,0xc,PTR_DAT_00551644,0x2000);
    puVar3 = PTR_DAT_00551644;
    if (-1 < local_dc) {
      if (*(short *)PTR_DAT_00551644 == 1) {
        local_e0 = 0;
        while( true ) {
          if (DAT_00557704 == '\0') {
            uVar6 = *(uint *)(puVar3 + 4);
          }
          else {
            uVar6 = *(uint *)(puVar3 + 4);
            uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
          }
          if ((int)uVar6 <= local_e0) break;
          uVar4 = FUN_00402eb0((uint)*(ushort *)(puVar3 + (local_e0 + 2) * 4));
          FUN_004c02bc(uVar4,acStack_c8);
          printf("%s\t(0x%04x)\t%2d.%02d(dbm)\n",acStack_c8,(uint)uVar4,
                 (uint)((byte)puVar3[(local_e0 + 2) * 4 + 2] >> 2),
                 (int)(((byte)puVar3[(local_e0 + 2) * 4 + 2] & 3) * 100) >> 2);
          local_e0 = local_e0 + 1;
        }
        putchar(10);
      }
      else {
        fprintf(stderr,"Error: version [%d] mismatch Driver version:%d\n",1,
                (uint)*(ushort *)PTR_DAT_00551644);
      }
    }
  }
  else {
    local_dc = -0x2c;
  }
  return local_dc;
}



// WARNING: Removing unreachable block (ram,0x0042d010)
// WARNING: Removing unreachable block (ram,0x0042ccdc)
// WARNING: Removing unreachable block (ram,0x0042c3e0)
// WARNING: Removing unreachable block (ram,0x0042c444)
// WARNING: Removing unreachable block (ram,0x0042cf78)
// WARNING: Removing unreachable block (ram,0x0042d088)

int FUN_0042bba8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  char cVar3;
  ushort uVar4;
  short sVar5;
  int iVar6;
  size_t __size;
  uint *__s;
  char *pcVar7;
  char *param3;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int local_res8;
  int local_a8;
  int local_a4;
  byte local_a0;
  short local_9e;
  char acStack_70 [20];
  char acStack_5c [64];
  int local_1c;
  int *local_18;
  int *local_14;
  int *local_10 [2];
  
  local_a0 = 0;
  bVar2 = false;
  iVar6 = FUN_004cf27c();
  iVar6 = FUN_004ceff4(iVar6);
  __size = iVar6 * 3 + 0x43;
  local_a8 = FUN_004b9f94(param_1,0xa0,(char *)&local_1c,4);
  if (-1 < local_a8) {
    if (local_1c == 0) {
      fwrite("Error: clock not active, do wl up (if not done already) and force mpc 0 to active clock\n"
             ,1,0x58,stderr);
      local_a8 = -1;
    }
    else {
      __s = (uint *)malloc(__size);
      if (__s == (uint *)0x0) {
        fwrite("Allocating mem failed for curpower\n",1,0x23,stderr);
        local_a8 = -0x1b;
      }
      else {
        memset(__s,0,__size);
        *(int *)((int)__s + 0x3a) = iVar6;
        *(char *)(__s + 0xb) = '-';
        iVar6 = FUN_004cf27c();
        FUN_004cf09c((undefined4 *)((int)__s + 0x42),iVar6,*(uint *)((int)__s + 0x3a));
        pcVar7 = (char *)((int)__s + 0x42) + *(int *)((int)__s + 0x3a);
        iVar6 = FUN_004cf27c();
        FUN_004cf09c((undefined4 *)pcVar7,iVar6,*(uint *)((int)__s + 0x3a));
        iVar9 = *(int *)((int)__s + 0x3a);
        iVar6 = FUN_004cf27c();
        FUN_004cf09c((undefined4 *)(pcVar7 + iVar9),iVar6,*(uint *)((int)__s + 0x3a));
        local_res8 = param_3;
        if ((*(int *)(param_3 + 4) != 0) &&
           ((iVar6 = strcmp(*(char **)(param_3 + 4),"--verbose"), iVar6 == 0 ||
            (iVar6 = strcmp(*(char **)(param_3 + 4),"-v"), iVar6 == 0)))) {
          local_a0 = 1;
          local_res8 = param_3 + 4;
        }
        if ((*(int *)(local_res8 + 4) != 0) &&
           ((iVar6 = strcmp(*(char **)(local_res8 + 4),"--brief"), iVar6 == 0 ||
            (iVar6 = strcmp(*(char **)(local_res8 + 4),"-b"), iVar6 == 0)))) {
          bVar2 = true;
          local_res8 = local_res8 + 4;
        }
        if (*(int *)(local_res8 + 4) != 0) {
          fprintf(stderr,"Ignoring arguments for %s\n",(char *)*param_2);
        }
        local_a8 = FUN_004b9f94(param_1,param_2[2],(char *)__s,__size);
        if (local_a8 < 0) {
          fwrite("Error: Curpower failed. ",1,0x18,stderr);
          fwrite("Bring up interface and disable mpc if necessary (wl mpc 0)\n",1,0x3b,stderr);
          free(__s);
        }
        else {
          if ((char)__s[0xb] == '-') {
            local_18 = (int *)0x0;
            local_14 = (int *)0x0;
            local_10[0] = (int *)0x0;
            if (DAT_00557704 == '\0') {
              uVar10 = *__s;
            }
            else {
              uVar10 = *__s;
              uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                       uVar10 >> 0x18;
            }
            *__s = uVar10;
            uVar4 = FUN_00402de8((ushort)__s[1]);
            *(char *)(__s + 1) = (char)uVar4;
            *(char *)((int)__s + 5) = (char)(uVar4 >> 8);
            uVar4 = FUN_00402de8(*(ushort *)((int)__s + 6));
            *(char *)((int)__s + 6) = (char)uVar4;
            *(char *)((int)__s + 7) = (char)(uVar4 >> 8);
            uVar10 = __s[1];
            uVar11 = *__s;
            local_a8 = FUN_004d23d8(0,(char *)((int)__s + 0x42),*(uint *)((int)__s + 0x3a),&local_18
                                   );
            if (local_a8 == 0) {
              pcVar7 = (char *)((int)__s + *(int *)((int)__s + 0x3a) + 0x42);
              local_a8 = FUN_004d23d8(0,pcVar7,*(uint *)((int)__s + 0x3a),&local_14);
              if ((local_a8 == 0) &&
                 (local_a8 = FUN_004d23d8(0,pcVar7 + *(int *)((int)__s + 0x3a),
                                          *(uint *)((int)__s + 0x3a),local_10), local_a8 == 0)) {
                if (local_a0 != 0) {
                  printf("%-23s%s\n","Output Format Version:","5.1");
                }
                if ((*__s & 1) == 0) {
                  pcVar7 = "Off";
                }
                else {
                  pcVar7 = "On";
                }
                if ((*__s & 2) == 0) {
                  param3 = "SW";
                }
                else {
                  param3 = "HW";
                }
                printf("%-23s%s, %s\n","Power Control:",pcVar7,param3);
                pcVar7 = FUN_004c02bc((ushort)__s[1],acStack_70);
                printf("%-23s%s\n","Current Channel:",pcVar7);
                pcVar7 = FUN_004c02bc(*(ushort *)((int)__s + 6),acStack_70);
                printf("%-23s%s\n","BSS Channel:",pcVar7);
                printf("%-23s%d.%d dBm\n","BSS Local Max:",(uint)(byte)((byte)__s[2] >> 2),
                       (int)(((byte)__s[2] & 3) * 100) >> 2);
                printf("%-23s%d.%d dB\n","BSS Local Constraint:",
                       (uint)(*(byte *)((int)__s + 9) >> 2),
                       (int)((*(byte *)((int)__s + 9) & 3) * 100) >> 2);
                if (*(char *)((int)__s + 0x2b) == '\0') {
                  pcVar7 = "20MHz";
                }
                else if (*(char *)((int)__s + 0x2b) == '\x01') {
                  pcVar7 = "40MHz";
                }
                else {
                  pcVar7 = "80MHz";
                }
                printf("%-23s%s\n","Channel Width:",pcVar7);
                cVar3 = (char)*(undefined4 *)((int)__s + 0x36);
                iVar6 = (int)cVar3;
                if (iVar6 < 0) {
                  iVar6 = iVar6 + 3;
                }
                uVar8 = (uint)(char)(iVar6 >> 2);
                iVar6 = (cVar3 % '\x04') * 100;
                if (iVar6 < 0) {
                  iVar6 = iVar6 + 3;
                }
                if ((iVar6 >> 2 < 0) || ((int)uVar8 < 0)) {
                  bVar1 = true;
                }
                else {
                  bVar1 = false;
                }
                iVar9 = (uVar8 ^ (int)uVar8 >> 0x1f) - ((int)uVar8 >> 0x1f);
                if (bVar1) {
                  iVar9 = -iVar9;
                }
                printf("%-23s%d.%d dBm\n","User Target:",iVar9,
                       (iVar6 >> 2 ^ iVar6 >> 0x1f) - (iVar6 >> 0x1f));
                iVar6 = (int)*(char *)((int)__s + 10);
                if (iVar6 < 0) {
                  iVar6 = iVar6 + 3;
                }
                iVar9 = (*(char *)((int)__s + 10) % '\x04') * 100;
                if (iVar9 < 0) {
                  iVar9 = iVar9 + 3;
                }
                printf("%-23s%d.%d dB\n","SROM Antgain 2G:",(int)(char)(iVar6 >> 2),iVar9 >> 2);
                iVar6 = (int)*(char *)((int)__s + 0xb);
                if (iVar6 < 0) {
                  iVar6 = iVar6 + 3;
                }
                iVar9 = (*(char *)((int)__s + 0xb) % '\x04') * 100;
                if (iVar9 < 0) {
                  iVar9 = iVar9 + 3;
                }
                printf("%-23s%d.%d dB\n","SROM Antgain 5G:",(int)(char)(iVar6 >> 2),iVar9 >> 2);
                printf("%-23s","SAR:");
                if (*(char *)((int)__s + 0x2a) == '\x7f') {
                  puts("-");
                }
                else {
                  iVar6 = (int)*(char *)((int)__s + 0x2a);
                  if (iVar6 < 0) {
                    iVar6 = iVar6 + 3;
                  }
                  iVar9 = (*(char *)((int)__s + 0x2a) % '\x04') * 100;
                  if (iVar9 < 0) {
                    iVar9 = iVar9 + 3;
                  }
                  printf("%d.%d dB\n",(int)(char)(iVar6 >> 2),iVar9 >> 2);
                }
                printf("%-23s","Open loop:");
                if ((*__s & 0x40) == 0) {
                  puts("Off");
                }
                else {
                  puts("On");
                }
                printf("%-23s","Current rate:");
                FUN_00415e70(acStack_5c,*(uint *)((int)__s + 0x32));
                pcVar7 = FUN_004ccf7c(*(uint *)((int)__s + 0x32));
                printf("[%s] %s\n",pcVar7,acStack_5c);
                putchar(10);
                puts("Regulatory Limits:");
                if (bVar2) {
                  FUN_0042d85c(local_10[0],*(char *)((int)__s + 0x2b),*(uint *)((int)__s + 0x32));
                }
                else {
                  FUN_0042db1c(local_10[0],*(char *)((int)__s + 0x2b),local_a0,
                               (uVar10 & 0xc000) == 0xc000,*__s);
                }
                putchar(10);
                printf("%-23s%d\n","Core Index:",(uint)*(byte *)((int)__s + 0x2d));
                puts("Board Limits:");
                if (bVar2) {
                  FUN_0042d85c(local_18,*(char *)((int)__s + 0x2b),*(uint *)((int)__s + 0x32));
                }
                else {
                  FUN_0042db1c(local_18,*(char *)((int)__s + 0x2b),local_a0,
                               (uVar10 & 0xc000) == 0xc000,*__s);
                }
                putchar(10);
                puts("Power Targets:");
                if (bVar2) {
                  FUN_0042d85c(local_14,*(char *)((int)__s + 0x2b),*(uint *)((int)__s + 0x32));
                }
                else {
                  FUN_0042db1c(local_14,*(char *)((int)__s + 0x2b),local_a0,
                               (uVar10 & 0xc000) == 0xc000,*__s);
                }
                putchar(10);
                if ((uVar11 & 0x1c) == 0) {
                  printf("Last est. power:\t%2d.%02d dBm\n",(uint)(*(byte *)((int)__s + 0xd) >> 2),
                         (int)((*(byte *)((int)__s + 0xd) & 3) * 100) >> 2);
                }
                else {
                  printf("Maximum Power Target among all rates:\t");
                  for (local_a4 = 0; local_a4 < (int)(uint)(byte)__s[3]; local_a4 = local_a4 + 1) {
                    if (*(char *)((int)__s + local_a4 + 0x16) == -0x80) {
                      printf("-    ");
                    }
                    else {
                      sVar5 = (short)*(char *)((int)__s + local_a4 + 0x16);
                      iVar6 = (int)sVar5;
                      if (iVar6 < 0) {
                        iVar6 = iVar6 + 3;
                      }
                      uVar8 = (uint)(short)(iVar6 >> 2);
                      iVar6 = (sVar5 % 4) * 100;
                      if (iVar6 < 0) {
                        iVar6 = iVar6 + 3;
                      }
                      if ((iVar6 >> 2 < 0) || ((int)uVar8 < 0)) {
                        bVar2 = true;
                      }
                      else {
                        bVar2 = false;
                      }
                      iVar9 = (uVar8 ^ (int)uVar8 >> 0x1f) - ((int)uVar8 >> 0x1f);
                      if (bVar2) {
                        iVar9 = -iVar9;
                      }
                      printf("%2d.%02d  ",iVar9,(iVar6 >> 2 ^ iVar6 >> 0x1f) - (iVar6 >> 0x1f));
                    }
                  }
                  putchar(10);
                  printf("Last est. power                     :\t");
                  for (local_a4 = 0; local_a4 < (int)(uint)(byte)__s[3]; local_a4 = local_a4 + 1) {
                    printf("%2d.%02d  ",(uint)(*(byte *)((int)__s + local_a4 + 0xd) >> 2),
                           (int)((*(byte *)((int)__s + local_a4 + 0xd) & 3) * 100) >> 2);
                  }
                  putchar(10);
                  printf("Power Target for the current rate   :\t");
                  for (local_a4 = 0; local_a4 < (int)(uint)(byte)__s[3]; local_a4 = local_a4 + 1) {
                    if (*(char *)((int)__s + local_a4 + 0x2e) == -0x80) {
                      printf("-    ");
                    }
                    else {
                      local_9e = (short)*(char *)((int)__s + local_a4 + 0x16) -
                                 (short)*(char *)((int)__s + local_a4 + 0x2e);
                      if ((int)*(char *)((int)__s + local_a4 + 0x3e) < (int)local_9e) {
                        local_9e = (short)*(char *)((int)__s + local_a4 + 0x3e);
                      }
                      iVar6 = (int)local_9e;
                      if (iVar6 < 0) {
                        iVar6 = iVar6 + 3;
                      }
                      uVar8 = (uint)(short)(iVar6 >> 2);
                      iVar6 = (local_9e % 4) * 100;
                      if (iVar6 < 0) {
                        iVar6 = iVar6 + 3;
                      }
                      if ((iVar6 >> 2 < 0) || ((int)uVar8 < 0)) {
                        bVar2 = true;
                      }
                      else {
                        bVar2 = false;
                      }
                      iVar9 = (uVar8 ^ (int)uVar8 >> 0x1f) - ((int)uVar8 >> 0x1f);
                      if (bVar2) {
                        iVar9 = -iVar9;
                      }
                      printf("%2d.%02d  ",iVar9,(iVar6 >> 2 ^ iVar6 >> 0x1f) - (iVar6 >> 0x1f));
                    }
                  }
                  putchar(10);
                  printf("Last adjusted est. power            :\t");
                  for (local_a4 = 0; local_a4 < (int)(uint)(byte)__s[3]; local_a4 = local_a4 + 1) {
                    printf("%2d.%02d  ",(uint)(*(byte *)((int)__s + local_a4 + 0x11) >> 2),
                           (int)((*(byte *)((int)__s + local_a4 + 0x11) & 3) * 100) >> 2);
                  }
                  putchar(10);
                }
                if (((uVar11 & 0x1c) == 0) && ((uVar10 & 0xc000) == 0)) {
                  printf("Last CCK est. power:\t%2d.%02d dBm\n",
                         (uint)(*(byte *)((int)__s + 0x15) >> 2),
                         (int)((*(byte *)((int)__s + 0x15) & 3) * 100) >> 2);
                }
              }
            }
            if (local_18 != (int *)0x0) {
              FUN_004cf208(0,local_18);
            }
            if (local_14 != (int *)0x0) {
              FUN_004cf208(0,local_14);
            }
            if (local_10[0] != (int *)0x0) {
              FUN_004cf208(0,local_10[0]);
            }
          }
          else {
            printf("error: version mismatch - driver %d, wl executable was expecting %d\n",
                   (uint)(byte)__s[0xb],0x2d);
            local_a8 = -1;
          }
          free(__s);
        }
      }
    }
  }
  return local_a8;
}



int FUN_0042d154(int *param_1,undefined4 *param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_20;
  int local_18;
  ushort local_14;
  char acStack_12 [4];
  byte local_e;
  
  iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_18,0xb);
  if (iVar1 < 0) {
    fwrite("Error: txpwr_target failed. Make sure interface is up.\n",1,0x37,stderr);
  }
  else if (local_18 == 0) {
    printf("Maximum Tx Power Target (chanspec:0x%x):\t",(uint)local_14);
    for (local_20 = 0; local_20 < (int)(uint)local_e; local_20 = local_20 + 1) {
      iVar2 = (int)acStack_12[local_20];
      if (iVar2 < 0) {
        iVar2 = iVar2 + 3;
      }
      iVar3 = (acStack_12[local_20] % '\x04') * 100;
      if (iVar3 < 0) {
        iVar3 = iVar3 + 3;
      }
      printf("%2d.%02d  ",(int)(char)(iVar2 >> 2),iVar3 >> 2);
    }
    putchar(10);
  }
  else {
    fprintf(stderr,"Error: version [%d] mismatch Driver version:%d\n",0,local_18);
  }
  return iVar1;
}



void FUN_0042d30c(char *param_1,byte param_2,undefined4 param_3,undefined4 param_4,char param_5,
                 char param_6,char param_7)

{
  size_t sVar1;
  double in_f12_13;
  char local_res8;
  char cStackX_9;
  char cStackX_a;
  char cStackX_b;
  char local_resc;
  char cStackX_d;
  char local_50 [60];
  char local_14;
  char local_10;
  
  local_50[0x38] = param_5;
  local_14 = param_6;
  local_10 = param_7;
  builtin_strncpy(local_50,"-      ",8);
  builtin_strncpy(local_50 + 8,"-      ",8);
  builtin_strncpy(local_50 + 0x10,"-      ",8);
  builtin_strncpy(local_50 + 0x18,"-      ",8);
  builtin_strncpy(local_50 + 0x20,"-      ",8);
  builtin_strncpy(local_50 + 0x28,"-      ",8);
  builtin_strncpy(local_50 + 0x30,"-      ",8);
  local_res8 = (char)param_3;
  if (param_5 != local_res8) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 8,local_50,sVar1);
  }
  cStackX_a = (char)((uint)param_3 >> 0x10);
  if (local_50[0x38] != cStackX_a) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 0x10,local_50,sVar1);
  }
  cStackX_9 = (char)((uint)param_3 >> 8);
  if (local_50[0x38] != cStackX_9) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 0x18,local_50,sVar1);
  }
  cStackX_b = (char)((uint)param_3 >> 0x18);
  if (local_50[0x38] != cStackX_b) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 0x20,local_50,sVar1);
  }
  local_resc = (char)param_4;
  if (local_50[0x38] != local_resc) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 0x28,local_50,sVar1);
  }
  cStackX_d = (char)((uint)param_4 >> 8);
  if (local_50[0x38] != cStackX_d) {
    sprintf(local_50,"%2.2f",in_f12_13);
    sVar1 = strlen(local_50);
    strncpy(local_50 + 0x30,local_50,sVar1);
  }
  printf("%-23s%d     ",param_1,(uint)param_2);
  if (local_10 == '\0') {
    if (local_14 == '\x01') {
      printf("%s%s\n",local_50 + 0x10,local_50 + 0x18);
    }
    else if (local_14 == '\x02') {
      printf("%s%s%s\n",local_50 + 0x28,local_50 + 0x30,local_50 + 0x20);
    }
    else if (local_14 == '\0') {
      puts(local_50 + 8);
    }
  }
  else {
    printf("%s%s%s%s%s%s\n",local_50 + 8,local_50 + 0x10,local_50 + 0x18,local_50 + 0x28,
           local_50 + 0x30,local_50 + 0x20);
  }
  return;
}



void FUN_0042d85c(int *param_1,char param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 local_14;
  undefined4 local_10;
  
  memset(&local_14,0x80,6);
  iVar1 = FUN_004ccfec(param_3);
  if (iVar1 == -1) {
    puts("(NO_RATE)               -     -      -      -      -      -      -");
  }
  else {
    iVar2 = *(int *)(&DAT_004ec26c + iVar1 * 0x1c);
    if (param_2 == '\x01') {
      iVar3 = FUN_0042a670(param_1,iVar1,3);
      local_14._0_3_ = CONCAT12((char)iVar3,(undefined2)local_14);
      iVar3 = FUN_0042a670(param_1,iVar1,1);
      local_14._0_2_ = CONCAT11((char)iVar3,(undefined1)local_14);
    }
    else if (param_2 == '\x02') {
      iVar3 = FUN_0042a670(param_1,iVar1,2);
      local_14 = CONCAT13((char)iVar3,(undefined3)local_14);
      iVar3 = FUN_0042a670(param_1,iVar1,4);
      local_10 = CONCAT31(local_10._1_3_,(char)iVar3);
      iVar3 = FUN_0042a670(param_1,iVar1,5);
      local_10._0_2_ = CONCAT11((char)iVar3,(undefined1)local_10);
    }
    else if (param_2 == '\0') {
      iVar3 = FUN_0042a670(param_1,iVar1,0);
      local_14 = CONCAT31(local_14._1_3_,(char)iVar3);
    }
    FUN_0042d30c(&UNK_004ec254 + iVar1 * 0x1c,(byte)*(undefined4 *)(&DAT_004ebe50 + iVar2 * 0x18),
                 local_14,local_10,-0x80,param_2,'\x01');
  }
  return;
}



void FUN_0042da48(char param_1,char param_2)

{
  printf("Rate                  Chains ");
  if (param_2 == '\0') {
    if (param_1 == '\x01') {
      puts("20in40 40MHz");
    }
    else if (param_1 == '\x02') {
      puts("20in80 40in80 80MHz");
    }
    else if (param_1 == '\0') {
      puts("20MHz");
    }
  }
  else {
    puts("20MHz  20in40 40MHz  20in80 40in80 80MHz");
  }
  return;
}



void FUN_0042db1c(int *param_1,char param_2,byte param_3,char param_4,uint param_5)

{
  uint local_10;
  int local_c;
  
  local_c = 0;
  FUN_0042da48(param_2,param_3);
  for (local_10 = 0; local_10 < 0x2b; local_10 = local_10 + 1) {
    FUN_0042dda8(param_1,(uint)param_3,*(int *)(&DAT_004ebe5c + local_10 * 0x18),local_10,param_2,
                 &local_c,param_4,param_5);
    if (*(int *)(&DAT_004ebe5c + local_10 * 0x18) == 3) {
      local_10 = local_10 + 1;
    }
  }
  return;
}



void FUN_0042dc34(int *param_1,undefined4 param_2,int param_3,undefined4 param_4,void *param_5)

{
  int iVar1;
  
  iVar1 = param_3 * 0x18;
  switch(param_2) {
  case 0:
    FUN_004cf2a0(param_1,param_4,*(int *)(&DAT_004ebe50 + iVar1),param_5);
    break;
  case 1:
    FUN_004cf364(param_1,param_4,*(int *)(&DAT_004ebe54 + iVar1),*(int *)(&DAT_004ebe50 + iVar1),
                 param_5);
    break;
  case 2:
    FUN_004cf42c(param_1,param_4,*(int *)(&DAT_004ebe58 + iVar1),*(int *)(&DAT_004ebe54 + iVar1),
                 *(uint *)(&DAT_004ebe50 + iVar1),param_5);
    break;
  case 3:
  case 4:
    FUN_004cf4f8(param_1,param_4,*(int *)(&DAT_004ebe58 + iVar1),*(int *)(&DAT_004ebe54 + iVar1),
                 *(uint *)(&DAT_004ebe50 + iVar1),param_5);
  }
  return;
}



void FUN_0042dda8(int *param_1,int param_2,int param_3,int param_4,char param_5,int *param_6,
                 char param_7,uint param_8)

{
  bool bVar1;
  byte bVar2;
  void *pvVar3;
  int iVar4;
  undefined *puVar5;
  uint uVar6;
  char cVar7;
  uint local_50;
  size_t local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  uint local_3c;
  uint local_34;
  void *local_20 [4];
  char local_10;
  char local_c;
  
  local_10 = param_5;
  local_c = param_7;
  local_20[0] = (void *)0x0;
  local_20[1] = (void *)0x0;
  local_20[2] = (void *)0x0;
  bVar2 = (byte)*(undefined4 *)(&DAT_004ebe50 + param_4 * 0x18);
  bVar1 = false;
  local_34 = 0;
  if (param_1 == (int *)0x0) {
    fwrite("illegal ppr data!\n",1,0x12,stderr);
  }
  else {
    if (param_5 == '\x01') {
      local_50 = 2;
    }
    else if (param_5 == '\x02') {
      local_50 = 3;
    }
    else {
      if (param_5 != '\0') {
        fprintf(stderr,"Error: Unknown bandwidth %d\n",(int)param_5);
        return;
      }
      local_50 = 1;
    }
    if ((((param_8 & 0x20) == 0) && (param_3 == 3)) || ((param_3 == 4 && ((param_8 & 0x80) == 0))))
    {
      bVar1 = true;
    }
    switch(param_3) {
    case 0:
      local_4c = 4;
      break;
    case 1:
      local_4c = 8;
      break;
    case 2:
      local_4c = 8;
      break;
    case 3:
      local_4c = 10;
      break;
    case 4:
      local_4c = 10;
      local_34 = 8;
      break;
    default:
      fprintf(stderr,"Error: Unknown rate %d\n",param_3);
      return;
    }
    for (local_44 = 0; local_44 < local_50; local_44 = local_44 + 1) {
      pvVar3 = malloc(local_4c);
      local_20[local_44] = pvVar3;
      if (local_20[local_44] == (void *)0x0) {
        fwrite("Error allocating rates array\n",1,0x1d,stderr);
        for (local_40 = 0; local_40 < local_44; local_40 = local_40 + 1) {
          free(local_20[local_40]);
        }
        return;
      }
      memset(local_20[local_44],-0x80,local_4c);
    }
    if ((param_3 != 4) || (!bVar1)) {
      if (local_10 == '\x01') {
        FUN_0042dc34(param_1,param_3,param_4,1,local_20[0]);
        FUN_0042dc34(param_1,param_3,param_4,3,local_20[1]);
      }
      else if (local_10 == '\x02') {
        FUN_0042dc34(param_1,param_3,param_4,2,local_20[0]);
        FUN_0042dc34(param_1,param_3,param_4,5,local_20[1]);
        FUN_0042dc34(param_1,param_3,param_4,4,local_20[2]);
      }
      else if (local_10 == '\0') {
        FUN_0042dc34(param_1,param_3,param_4,0,local_20[0]);
      }
    }
    if ((param_3 == 0) && (local_c != '\0')) {
      iVar4 = FUN_004d0d30(param_1,-0x80);
      for (local_44 = 0; local_44 < local_50; local_44 = local_44 + 1) {
        for (local_40 = 0; local_40 < local_4c; local_40 = local_40 + 1) {
          if (*(char *)((int)local_20[local_44] + local_40) == iVar4) {
            *(undefined1 *)((int)local_20[local_44] + local_40) = 0x80;
          }
        }
      }
    }
    if (param_3 == 3) {
      local_48 = 2;
      local_4c = local_4c - 2;
      if (bVar1) {
        for (local_44 = 0; local_44 < local_50; local_44 = local_44 + 1) {
          memset((void *)((int)local_20[local_44] + local_4c),-0x80,2);
        }
      }
    }
    local_3c = (uint)(param_2 == 0);
    local_44 = 0;
    while (((local_44 < local_50 && (local_3c != 0)) && (!bVar1))) {
      uVar6 = FUN_0042e8c4((int)local_20[local_44],local_4c,
                           *(char *)((int)local_20[local_44] + local_34));
      local_3c = local_3c & uVar6;
      local_44 = local_44 + 1;
    }
    cVar7 = (char)param_2;
    if (local_3c == 0) {
      for (local_44 = local_34; local_44 < local_4c; local_44 = local_44 + 1) {
        FUN_0042e758(&UNK_004ec254 + ((*param_6 + local_44) - local_34) * 0x1c,bVar2,local_10,cVar7,
                     (int *)local_20,local_44);
      }
    }
    else {
      puVar5 = FUN_004ccf40(param_4);
      FUN_0042e758(puVar5,bVar2,local_10,cVar7,(int *)local_20,0);
    }
    if (param_3 == 3) {
      local_3c = (uint)(param_2 == 0);
      local_44 = 0;
      while (((local_44 < local_50 && (local_3c != 0)) && (!bVar1))) {
        uVar6 = FUN_0042e8c4((int)((int)local_20[local_44] + local_4c),local_48,
                             *(char *)((int)local_20[local_44] + local_4c));
        local_3c = local_3c & uVar6;
        local_44 = local_44 + 1;
      }
      if (local_3c == 0) {
        for (local_44 = local_4c; local_44 < local_4c + local_48; local_44 = local_44 + 1) {
          FUN_0042e758(&UNK_004ec254 + (*param_6 + local_44) * 0x1c,bVar2,local_10,cVar7,
                       (int *)local_20,local_44);
        }
      }
      else {
        puVar5 = FUN_004ccf40(param_4 + 1);
        FUN_0042e758(puVar5,bVar2,local_10,cVar7,(int *)local_20,local_4c);
      }
    }
    *param_6 = *param_6 + (local_4c - local_34);
    if (param_3 == 3) {
      *param_6 = *param_6 + local_48;
    }
    for (local_44 = 0; local_44 < local_50; local_44 = local_44 + 1) {
      free(local_20[local_44]);
    }
  }
  return;
}



void FUN_0042e758(undefined4 param_1,byte param_2,char param_3,char param_4,int *param_5,int param_6
                 )

{
  undefined4 uVar1;
  undefined4 local_10;
  undefined4 local_c;
  
  memset(&local_10,0x80,6);
  uVar1 = local_10;
  if (param_3 == '\x01') {
    local_10._3_1_ = SUB41(uVar1,3);
    local_10._0_3_ =
         CONCAT12(*(undefined1 *)(param_5[1] + param_6),
                  CONCAT11(*(undefined1 *)(*param_5 + param_6),(undefined1)local_10));
  }
  else if (param_3 == '\x02') {
    local_10 = CONCAT13(*(undefined1 *)(*param_5 + param_6),(undefined3)local_10);
    local_c = CONCAT31(CONCAT21(local_c._2_2_,*(undefined1 *)(param_5[1] + param_6)),
                       *(undefined1 *)(param_5[2] + param_6));
  }
  else if (param_3 == '\0') {
    local_10 = CONCAT31(local_10._1_3_,*(undefined1 *)(*param_5 + param_6));
  }
  FUN_0042d30c(param_1,param_2,local_10,local_c,-0x80,param_3,param_4);
  return;
}



undefined4 FUN_0042e8c4(int param_1,uint param_2,char param_3)

{
  uint local_10;
  
  local_10 = 0;
  while( true ) {
    if (param_2 <= local_10) {
      return 1;
    }
    if (param_3 != *(char *)(param_1 + local_10)) break;
    local_10 = local_10 + 1;
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x0042ebec)
// WARNING: Removing unreachable block (ram,0x0042eb90)
// WARNING: Removing unreachable block (ram,0x0042ec84)

int FUN_0042e94c(int *param_1)

{
  char *pcVar1;
  undefined *puVar2;
  int iVar3;
  uint local_14;
  uint local_10;
  uint local_c;
  
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x6e697874;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 's';
  pcVar1[1] = 't';
  pcVar1[2] = 'p';
  pcVar1[3] = 'w';
  puVar2[8] = 'r';
  puVar2[9] = '\0';
  iVar3 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
  puVar2 = PTR_DAT_00551644;
  if ((-1 < iVar3) && (iVar3 = FUN_004b9f94(param_1,0x8c,(char *)&local_14,0xc), -1 < iVar3)) {
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    if (local_10 == 2) {
      printf("Last B phy CCK est. power:\t%2d.%d dBm\n",(uint)((byte)*puVar2 >> 2),
             (int)(((byte)*puVar2 & 3) * 100) >> 2);
      printf("Last B phy OFDM est. power:\t%2d.%d dBm\n",(uint)((byte)puVar2[2] >> 2),
             (int)(((byte)puVar2[2] & 3) * 100) >> 2);
      putchar(10);
    }
    if ((local_10 == 1) || ((1 < local_14 && (local_c == 1)))) {
      printf("Last A phy est. power:\t\t%2d.%d dBm\n",(uint)((byte)puVar2[1] >> 2),
             (int)(((byte)puVar2[1] & 3) * 100) >> 2);
    }
  }
  return iVar3;
}



undefined4 FUN_0042ecc0(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  int iVar3;
  uint local_14;
  uint local_10;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    fwrite("Need to specify at least one parameter\n",1,0x27,stderr);
    uVar2 = 0xffffffd4;
  }
  else {
    iVar3 = strcasecmp((char *)*piVar1,"off");
    if (iVar3 == 0) {
      local_14 = 0;
    }
    else {
      local_14 = atoi((char *)*piVar1);
    }
    local_10 = 4;
    local_c = 0;
    if (*(int *)(param_3 + 8) != 0) {
      local_10 = FUN_0041584c(*(char **)(param_3 + 8));
    }
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    uVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_14,0xc);
  }
  return uVar2;
}



int FUN_0042ef0c(int *param_1,uint *param_2,uint *param_3)

{
  ushort uVar1;
  uint *puVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int local_38;
  uint *local_34;
  uint *local_30;
  uint *local_2c;
  uint local_28;
  uint local_24;
  
  local_38 = 0;
  local_30 = (uint *)0x0;
  puVar2 = (uint *)malloc(0x1fc00);
  local_34 = puVar2;
  if (puVar2 == (uint *)0x0) {
    fprintf(stderr,"Failed to allocate %d-byte buffer for scanresults\n",0x1fc00);
    local_38 = -0x1b;
  }
  else {
    iVar3 = FUN_004270c8(param_1,0x33,puVar2,0x1fc00);
    if (iVar3 == 0) {
      local_30 = puVar2;
      if (puVar2[1] == 0x6d) {
        local_24 = 0;
        local_2c = puVar2 + 3;
        for (local_28 = 0; uVar4 = local_24, local_28 < puVar2[2]; local_28 = local_28 + 1) {
          if (DAT_00557704 == '\0') {
            uVar4 = local_2c[1];
          }
          else {
            uVar4 = local_2c[1];
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          if (((uint)*(byte *)((int)local_2c + 0x12) == *param_2) &&
             (iVar3 = memcmp((void *)((int)local_2c + 0x13),param_2 + 1,*param_2), iVar3 == 0)) {
            FUN_004242c8(local_2c);
            puts("--------------------------------");
            memcpy((void *)((int)param_2 + (local_24 + 0x14) * 2 + 8),local_2c + 0x12,2);
            local_24 = local_24 + 1;
          }
          local_2c = (uint *)((int)local_2c + uVar4);
        }
        uVar5 = local_24 & 0xffff;
        local_34 = (uint *)((int)param_2 + (local_24 + 0x14) * 2 + 8);
        *param_3 = (int)local_34 - (int)param_2;
        *param_3 = *param_3 + local_24 * 6;
        if (*param_3 < 0xb1) {
          local_28 = 0;
          local_24 = 0;
          local_2c = puVar2 + 3;
          while ((local_28 < puVar2[2] && (local_24 < uVar5))) {
            if (DAT_00557704 == '\0') {
              uVar6 = local_2c[1];
            }
            else {
              uVar6 = local_2c[1];
              uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                      uVar6 >> 0x18;
            }
            if (((uint)*(byte *)((int)local_2c + 0x12) == *param_2) &&
               (iVar3 = memcmp((void *)((int)local_2c + 0x13),param_2 + 1,*param_2), iVar3 == 0)) {
              memcpy(local_34,local_2c + 2,6);
              local_34 = (uint *)((int)local_34 + 6);
              local_24 = local_24 + 1;
            }
            local_28 = local_28 + 1;
            local_2c = (uint *)((int)local_2c + uVar6);
          }
          if (local_24 == uVar5) {
            if (local_24 == 0) {
              puts("No matches found, issuing normal join.");
            }
            else {
              printf("Passing %d channel/bssid pairs.\n",local_24);
            }
            uVar1 = (ushort)uVar4;
            if (DAT_00557704 != '\0') {
              uVar1 = uVar1 << 8 | uVar1 >> 8;
            }
            *(ushort *)((int)param_2 + 0x2a) = uVar1;
          }
          else {
            fwrite("Mismatched channel and bssid counts!\n",1,0x25,stderr);
            local_38 = -1;
          }
        }
        else {
          fprintf(stderr,"Can\'t fit bssids for all %d APs found\n",local_24);
          local_38 = -1;
        }
      }
      else {
        fprintf(stderr,"scan parsing failed (expect version %d, got %d)\n",0x6d,puVar2[1]);
        local_38 = -1;
      }
    }
    else {
      fprintf(stderr,"failed to fetch scan results, err %d\n",iVar3);
      local_38 = iVar3;
    }
  }
  if (local_30 == (uint *)0x0) {
    free(local_34);
  }
  else {
    free(local_30);
  }
  return local_38;
}



int FUN_0042f4c8(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  bool bVar1;
  char *param3;
  uint *__s;
  size_t sVar2;
  int iVar3;
  int *piVar4;
  uint *__s_00;
  uint uVar5;
  int *local_res8;
  int local_110;
  uint local_10c;
  int local_104;
  uint local_c4;
  uint local_c0;
  uint local_bc;
  uint local_50;
  uint local_4c;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  char local_c [4];
  
  local_10c = 0;
  local_1c = 0;
  local_18 = 0;
  local_14 = 1;
  local_10 = 0;
  local_c[0] = '\0';
  bVar1 = false;
  param3 = (char *)*param_3;
  local_res8 = param_3 + 1;
  local_c4 = 0xb0;
  __s = (uint *)malloc(0xb0);
  if (__s == (uint *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for assoc params\n",local_c4);
    local_110 = -0x1b;
  }
  else {
    memset(__s,0,local_c4);
    __s[9] = 0xffffffff;
    *(undefined1 *)(__s + 10) = 0xff;
    *(undefined1 *)((int)__s + 0x29) = 0xff;
    if ((*local_res8 == 0) || (sVar2 = strlen((char *)*local_res8), 0x20 < sVar2)) {
      local_110 = -0x2c;
    }
    else {
      sVar2 = strlen((char *)*local_res8);
      *__s = sVar2;
      memcpy(__s + 1,(void *)*local_res8,*__s);
      local_c4 = 0x24;
      iVar3 = FUN_004ba35c(param_1,"wsec",&local_1c);
      if (iVar3 < 0) {
        local_1c = 0;
      }
      while (piVar4 = local_res8 + 1, *piVar4 != 0) {
        iVar3 = strcasecmp((char *)*piVar4,"wepkey");
        if (((iVar3 == 0) || (iVar3 = strcasecmp((char *)*piVar4,"wep"), iVar3 == 0)) ||
           (iVar3 = strcasecmp((char *)*piVar4,"key"), iVar3 == 0)) {
          memset(&local_c0,0,0xa4);
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            local_110 = -0x2c;
            goto LAB_00430554;
          }
          if (*(char *)(*local_res8 + 1) == ':') {
            local_10c = (int)*(char *)*local_res8 - 0x30;
            if (((int)local_10c < 0) || (3 < (int)local_10c)) {
              fprintf(stderr,"Invalid key index %d specified\n",local_10c);
              local_110 = -2;
              goto LAB_00430554;
            }
            *local_res8 = *local_res8 + 2;
          }
          local_c0 = local_10c;
          iVar3 = FUN_0042897c(local_res8,(int)&local_c0,'\0');
          if (iVar3 != 0) {
            local_110 = -2;
            goto LAB_00430554;
          }
          if (DAT_00557704 != '\0') {
            local_c0 = local_c0 << 0x18 | (local_c0 & 0xff00) << 8 | (local_c0 & 0xff0000) >> 8 |
                       local_c0 >> 0x18;
            local_bc = local_bc << 0x18 | (local_bc & 0xff00) << 8 | (local_bc & 0xff0000) >> 8 |
                       local_bc >> 0x18;
            local_50 = local_50 << 0x18 | (local_50 & 0xff00) << 8 | (local_50 & 0xff0000) >> 8 |
                       local_50 >> 0x18;
            local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                       local_4c >> 0x18;
          }
          local_110 = FUN_004ba050(param_1,0x2d,(char *)&local_c0,0xa4);
          if (local_110 < 0) goto LAB_00430554;
          local_1c = local_1c | 1;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar4,"imode");
          if (((iVar3 == 0) || (iVar3 = strcasecmp((char *)*piVar4,"infra"), iVar3 == 0)) ||
             (iVar3 = strcasecmp((char *)*piVar4,"mode"), iVar3 == 0)) {
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fprintf(stderr,
                      "%s %s: expected argument after \"infra\" keyword but command line ended.\n",
                      DAT_00557690,param3);
              local_110 = -0x2c;
              goto LAB_00430554;
            }
            iVar3 = strcasecmp((char *)*local_res8,"ibss");
            if (((iVar3 == 0) || (iVar3 = strcasecmp((char *)*local_res8,"adhoc"), iVar3 == 0)) ||
               (iVar3 = strcasecmp((char *)*local_res8,"ad-hoc"), iVar3 == 0)) {
              local_14 = 0;
            }
            else {
              iVar3 = strcasecmp((char *)*local_res8,"bss");
              if (((iVar3 != 0) && (iVar3 = strcasecmp((char *)*local_res8,"managed"), iVar3 != 0))
                 && (iVar3 = strncasecmp((char *)*local_res8,"infra",5), iVar3 != 0)) {
                fprintf(stderr,"%s %s: unrecongnized parameter \"%s\" after \"infra\" keyword\n",
                        DAT_00557690,param3,(char *)*local_res8);
                local_110 = -0x2c;
                goto LAB_00430554;
              }
              local_14 = 1;
            }
          }
          else {
            iVar3 = strcasecmp((char *)*piVar4,"amode");
            if ((iVar3 == 0) || (iVar3 = strncasecmp((char *)*piVar4,"auth",4), iVar3 == 0)) {
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                local_110 = -0x2c;
                goto LAB_00430554;
              }
              iVar3 = strcasecmp((char *)*local_res8,"open");
              if (iVar3 == 0) {
                local_18 = 0;
              }
              else {
                iVar3 = strcasecmp((char *)*local_res8,"shared");
                if (iVar3 == 0) {
                  local_18 = 1;
                }
                else {
                  iVar3 = strcasecmp((char *)*local_res8,"openshared");
                  if (iVar3 == 0) {
                    local_18 = 2;
                  }
                  else {
                    iVar3 = strcasecmp((char *)*local_res8,"cckm");
                    if (iVar3 == 0) {
                      local_10 = 8;
                    }
                    else {
                      iVar3 = strcasecmp((char *)*local_res8,"cckmwpa2");
                      if (iVar3 == 0) {
                        local_10 = 0x10;
                      }
                      else {
                        iVar3 = strcasecmp((char *)*local_res8,"wpanone");
                        if (iVar3 == 0) {
                          local_10 = 1;
                        }
                        else {
                          iVar3 = strcasecmp((char *)*local_res8,"wpa");
                          if (iVar3 == 0) {
                            local_10 = 2;
                          }
                          else {
                            iVar3 = strcasecmp((char *)*local_res8,"wpapsk");
                            if (iVar3 == 0) {
                              local_10 = 4;
                            }
                            else {
                              iVar3 = strcasecmp((char *)*local_res8,"wpa2");
                              if (iVar3 == 0) {
                                local_10 = 0x40;
                              }
                              else {
                                iVar3 = strcasecmp((char *)*local_res8,"wpa2psk");
                                if (iVar3 == 0) {
                                  local_10 = 0x80;
                                }
                                else {
                                  iVar3 = strcasecmp((char *)*local_res8,"ftpsk");
                                  if (iVar3 != 0) {
                                    local_110 = -0x2c;
                                    goto LAB_00430554;
                                  }
                                  local_10 = 0x4080;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              iVar3 = strcasecmp((char *)*piVar4,"-passive");
              if ((iVar3 != 0) && (iVar3 = strcasecmp((char *)*piVar4,"-p"), iVar3 != 0)) {
                local_110 = FUN_00421b24(piVar4,__s + 9,local_c);
                if (local_110 != 0) {
                  fprintf(stderr,"%s %s: unable to parse parameter \"%s\"\n",DAT_00557690,param3,
                          (char *)*piVar4);
                  goto LAB_00430554;
                }
                if (DAT_00557704 == '\0') {
                  uVar5 = __s[0xb];
                }
                else {
                  uVar5 = __s[0xb];
                  uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                }
                local_c4 = (uVar5 + 0x18) * 2;
                break;
              }
              bVar1 = true;
              local_res8 = piVar4;
            }
          }
        }
      }
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
      }
      local_110 = FUN_004ba050(param_1,0x14,(char *)&local_14,4);
      if (-1 < local_110) {
        if (DAT_00557704 != '\0') {
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
        }
        local_110 = FUN_004ba050(param_1,0x16,(char *)&local_18,4);
        if ((-1 < local_110) && (local_110 = FUN_004ba428(param_1,"wsec",local_1c), -1 < local_110))
        {
          if (DAT_00557704 != '\0') {
            local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                       local_10 >> 0x18;
          }
          local_110 = FUN_004ba050(param_1,0xa5,(char *)&local_10,4);
          if (-1 < local_110) {
            if (bVar1) {
              puts("Using passive assoc scan");
              sVar2 = (__s[0xb] + 0x22) * 2;
              __s_00 = (uint *)malloc(sVar2);
              if (__s_00 == (uint *)0x0) {
                fprintf(stderr,"Error allocating %d bytes for extjoin \n",sVar2);
                local_110 = -0x1b;
              }
              else {
                memset(__s_00,0,sVar2);
                memcpy(__s_00 + 1,__s + 1,0x20);
                if (DAT_00557704 == '\0') {
                  uVar5 = *__s;
                }
                else {
                  uVar5 = *__s;
                  uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                }
                *__s_00 = uVar5;
                memcpy(__s_00 + 0xe,__s + 9,6);
                __s_00[0x10] = __s[0xb];
                for (local_104 = 0; local_104 < (int)__s[0xb]; local_104 = local_104 + 1) {
                  *(undefined2 *)((int)__s_00 + (local_104 + 0x20) * 2 + 4) =
                       *(undefined2 *)((int)__s + (local_104 + 0x14) * 2 + 8);
                }
                *(undefined1 *)(__s_00 + 9) = 1;
                __s_00[10] = 0xffffffff;
                __s_00[0xb] = 0xffffffff;
                __s_00[0xc] = 0xffffffff;
                __s_00[0xd] = 0xffffffff;
                local_110 = FUN_00445444(param_1,"join",__s_00,sVar2);
                free(__s_00);
              }
            }
            else {
              if (DAT_00557704 == '\0') {
                uVar5 = *__s;
              }
              else {
                uVar5 = *__s;
                uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
              }
              *__s = uVar5;
              if ((local_c[0] == '\0') ||
                 (local_110 = FUN_0042ef0c(param_1,__s,&local_c4), -1 < local_110)) {
                if (DAT_00557704 == '\0') {
                  uVar5 = *__s;
                }
                else {
                  uVar5 = *__s;
                  uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                }
                *__s = uVar5;
                local_110 = FUN_004ba050(param_1,0x1a,(char *)__s,local_c4);
              }
            }
          }
        }
      }
    }
LAB_00430554:
    free(__s);
  }
  return local_110;
}



int FUN_0043057c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  char *__s;
  undefined3 extraout_var;
  int local_20;
  char acStack_1c [8];
  uint local_14;
  int local_10 [2];
  
  local_14 = 0;
  local_20 = FUN_004024e8((int *)(param_3 + 4),"bssid",&local_14,local_10);
  if (local_20 == 0) {
    piVar2 = (int *)(param_3 + 4) + local_10[0];
    if (*piVar2 == 0) {
      if (local_10[0] == 0) {
        local_20 = FUN_004b9f94(param_1,0x17,acStack_1c,6);
      }
      else {
        local_20 = FUN_0044588c(param_1,"bssid",local_14,acStack_1c,6);
      }
      if (-1 < local_20) {
        __s = FUN_0041d780((int)acStack_1c);
        puts(__s);
      }
    }
    else {
      bVar1 = FUN_0041d6ac((char *)*piVar2,acStack_1c);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        local_20 = -0x2c;
      }
      else if (local_10[0] == 0) {
        local_20 = FUN_004ba050(param_1,0x18,acStack_1c,6);
      }
      else {
        local_20 = FUN_00445980(param_1,"bssid",local_14,acStack_1c,6);
      }
    }
  }
  return local_20;
}



// WARNING: Type propagation algorithm not settling

int FUN_0043075c(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  size_t sVar3;
  int local_c8;
  byte abStack_bc [132];
  uint local_38 [12];
  
  local_38[0] = 0;
  local_38[1] = 0;
  local_38[2] = 0;
  local_38[3] = 0;
  local_38[4] = 0;
  local_38[5] = 0;
  local_38[6] = 0;
  local_38[7] = 0;
  local_38[8] = 0;
  local_38[9] = 0;
  local_c8 = FUN_004024e8((int *)(param_3 + 4),&DAT_004f6918,local_38 + 9,local_38 + 10);
  if (local_c8 == 0) {
    piVar1 = (int *)(param_3 + 4) + local_38[10];
    if (*piVar1 == 0) {
      if (local_38[10] == 0) {
        if (param_2[2] == 0x19) {
          local_c8 = FUN_004b9f94(param_1,0x19,(char *)local_38,0x24);
        }
        else {
          local_c8 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)local_38,0x24);
        }
      }
      else if (param_2[2] == 0x19) {
        local_c8 = FUN_0044588c(param_1,"ssid",local_38[9],(char *)local_38,0x24);
      }
      else {
        local_c8 = FUN_0044588c(param_1,(char *)*param_2,local_38[9],(char *)local_38,0x24);
      }
      if (-1 < local_c8) {
        if (DAT_00557704 != '\0') {
          local_38[0] = local_38[0] << 0x18 | (local_38[0] & 0xff00) << 8 |
                        (local_38[0] & 0xff0000) >> 8 | local_38[0] >> 0x18;
        }
        FUN_0041e0e8(abStack_bc,(int)(local_38 + 1),local_38[0]);
        if (param_2[2] == 0x19) {
          pcVar2 = "SSID";
        }
        else {
          pcVar2 = (char *)*param_2;
        }
        printf("Current %s: \"%s\"\n",pcVar2,(char *)abStack_bc);
      }
    }
    else {
      sVar3 = strlen((char *)*piVar1);
      if (sVar3 < 0x21) {
        local_38[0] = strlen((char *)*piVar1);
        memcpy(local_38 + 1,(void *)*piVar1,local_38[0]);
        FUN_0041e0e8(abStack_bc,(int)(local_38 + 1),local_38[0]);
        if (param_2[3] == 0x1a) {
          pcVar2 = "SSID";
        }
        else {
          pcVar2 = (char *)*param_2;
        }
        printf("Setting %s: \"%s\"\n",pcVar2,(char *)abStack_bc);
        if (DAT_00557704 != '\0') {
          local_38[0] = local_38[0] << 0x18 | (local_38[0] & 0xff00) << 8 |
                        (local_38[0] & 0xff0000) >> 8 | local_38[0] >> 0x18;
        }
        if (local_38[10] == 0) {
          if (param_2[3] == 0x1a) {
            local_c8 = FUN_004ba050(param_1,0x1a,(char *)local_38,0x24);
          }
          else {
            local_c8 = FUN_004ba2e4(param_1,(char *)*param_2,local_38,0x24);
          }
        }
        else if (param_2[3] == 0x1a) {
          local_c8 = FUN_00445980(param_1,"ssid",local_38[9],local_38,0x24);
        }
        else {
          local_c8 = FUN_00445980(param_1,(char *)*param_2,local_38[9],local_38,0x24);
        }
      }
      else {
        fprintf(stderr,"SSID arg \"%s\" must be 32 chars or less\n",(char *)*piVar1);
        local_c8 = -2;
      }
    }
  }
  return local_c8;
}



char * FUN_00430c54(char param_1)

{
  char *local_10;
  uint local_c;
  
  local_10 = "UNKNOWN";
  for (local_c = 0; local_c < 7; local_c = local_c + 1) {
    if (param_1 == (&DAT_00524854)[local_c * 0x21]) {
      local_10 = "Authentication_Request" + local_c * 0x21;
    }
  }
  return local_10;
}



undefined4 FUN_00430d04(uint *param_1)

{
  ushort uVar1;
  uint uVar2;
  undefined4 uVar3;
  uint *local_38;
  char *local_34;
  uint local_30;
  
  local_38 = (uint *)0x0;
  local_34 = FUN_00430c54(*(char *)((int)param_1 + 6));
  if (DAT_00557704 == '\0') {
    uVar2 = *param_1;
  }
  else {
    uVar2 = *param_1;
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  if (uVar2 == 1) {
    printf("Frame type: %s\n",local_34);
    if (DAT_00557704 == '\0') {
      uVar2 = param_1[2];
    }
    else {
      uVar2 = param_1[2];
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    printf("\tIgnored Count: %d\n",uVar2);
    if (DAT_00557704 == '\0') {
      uVar2 = param_1[3];
    }
    else {
      uVar2 = param_1[3];
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    printf("\tMalformed Count: %d\n",uVar2);
    if (DAT_00557704 == '\0') {
      local_30 = param_1[4];
    }
    else {
      uVar2 = param_1[4];
      local_30 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    if (local_30 != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = (uint)*(byte *)((int)param_1 + 7);
      }
      else {
        uVar2 = (uint)*(byte *)((int)param_1 + 7) << 0x18;
      }
      local_34 = (&PTR_s_Status_code_00556190)[uVar2];
      puts("\tSuccessful/Failed Count:");
      local_38 = param_1 + 5;
    }
    for (; local_30 != 0; local_30 = local_30 - 1) {
      if (DAT_00557704 == '\0') {
        uVar1 = (ushort)local_38[1];
      }
      else {
        uVar1 = (ushort)local_38[1] << 8 | (ushort)local_38[1] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *local_38;
      }
      else {
        uVar2 = *local_38;
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      printf("\t\t%s %d Count: %d\n",local_34,(uint)uVar1,uVar2);
      local_38 = local_38 + 2;
    }
    uVar3 = 0;
  }
  else {
    fprintf(stderr,
            "Sorry, your driver has smfs_version %d but this program supports only version %d.\n",
            uVar2,1);
    uVar3 = 0xffffffff;
  }
  return uVar3;
}



undefined4 FUN_00431118(int *param_1,int *param_2,int *param_3,undefined4 *param_4)

{
  char *__s1;
  int iVar1;
  int local_38;
  char *local_24 [4];
  char *local_14;
  char *local_10;
  char *local_c;
  
  local_24[0] = "auth";
  local_24[1] = "assoc";
  local_24[2] = "reassoc";
  local_24[3] = "disassoc_tx";
  local_14 = "disassoc_rx";
  local_10 = "deauth_tx";
  local_c = "deauth_rx";
  if (*param_1 != 0) {
    __s1 = (char *)*param_1;
    for (local_38 = 0; local_38 < 7; local_38 = local_38 + 1) {
      iVar1 = strcmp(__s1,local_24[local_38]);
      if (iVar1 == 0) {
        *param_2 = local_38;
        *param_3 = *param_3 + 1;
        return 0;
      }
    }
    iVar1 = strcmp(__s1,"clear");
    if (iVar1 == 0) {
      *param_4 = 1;
    }
  }
  return 0;
}



int FUN_00431290(int *param_1,undefined4 param_2,int param_3)

{
  int local_28;
  int local_24;
  uint local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  
  local_1c = 0;
  local_18 = 0;
  local_14 = 0;
  local_10 = 0;
  local_c = 0;
  local_28 = FUN_004024e8((int *)(param_3 + 4),"smfstats",&local_1c,&local_18);
  if ((local_28 == 0) &&
     (local_28 = FUN_00431118((int *)(param_3 + 4) + local_18,&local_10,&local_14,&local_c),
     local_28 == 0)) {
    if (local_c == 0) {
      if (local_18 == 0) {
        if (local_14 == 0) {
          for (local_24 = 0; local_24 < 7; local_24 = local_24 + 1) {
            local_10 = local_24;
            local_28 = FUN_004ba0cc(param_1,"smfstats",&local_10,4,PTR_DAT_00551644,0x100);
            if (local_28 == 0) {
              local_28 = FUN_00430d04((uint *)PTR_DAT_00551644);
            }
          }
        }
        else {
          local_28 = FUN_004ba0cc(param_1,"smfstats",&local_10,4,PTR_DAT_00551644,0x100);
          if (local_28 == 0) {
            local_28 = FUN_00430d04((uint *)PTR_DAT_00551644);
          }
        }
      }
      else if (local_14 == 0) {
        for (local_24 = 0; local_24 < 7; local_24 = local_24 + 1) {
          local_10 = local_24;
          local_28 = FUN_004457f4(param_1,"smfstats",local_1c,&local_10,4,PTR_DAT_00551644,0x100);
          if (local_28 == 0) {
            local_28 = FUN_00430d04((uint *)PTR_DAT_00551644);
          }
        }
      }
      else {
        local_28 = FUN_004457f4(param_1,"smfstats",local_1c,&local_10,4,PTR_DAT_00551644,0x100);
        if (local_28 == 0) {
          local_28 = FUN_00430d04((uint *)PTR_DAT_00551644);
        }
      }
    }
    else if (local_18 == 0) {
      local_28 = FUN_004ba428(param_1,"smfstats",0);
    }
    else {
      local_28 = FUN_00445ad8(param_1,"smfstats",local_1c,0);
    }
  }
  return local_28;
}



int FUN_00431618(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  uint *__ptr;
  int iVar2;
  size_t sVar3;
  uint uVar4;
  uint *local_1c0;
  int local_1bc;
  undefined4 local_18c [2];
  undefined4 local_184;
  size_t local_180;
  undefined1 auStack_17c [32];
  undefined1 local_15c;
  undefined1 auStack_15b [32];
  undefined1 local_13b;
  undefined1 auStack_13a [32];
  undefined1 local_11a;
  undefined1 auStack_119 [33];
  byte abStack_f8 [132];
  char acStack_74 [36];
  char acStack_50 [36];
  char acStack_2c [36];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    __ptr = (uint *)malloc(0x16e4);
    if (__ptr == (uint *)0x0) {
      fwrite("memory alloc failure\n",1,0x15,stderr);
      iVar2 = -0x1b;
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar4 = 0x16e4;
      }
      else {
        uVar4 = 0xe4160000;
      }
      *__ptr = uVar4;
      iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)__ptr,0x16e4);
      if (iVar2 < 0) {
        free(__ptr);
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar4 = *__ptr;
        }
        else {
          uVar4 = *__ptr;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        *__ptr = uVar4;
        if (DAT_00557704 == '\0') {
          uVar4 = __ptr[1];
        }
        else {
          uVar4 = __ptr[1];
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        __ptr[1] = uVar4;
        if (DAT_00557704 == '\0') {
          uVar4 = __ptr[2];
        }
        else {
          uVar4 = __ptr[2];
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        __ptr[2] = uVar4;
        printf("buflen %d version %d count %d\n",*__ptr,__ptr[1],__ptr[2]);
        local_1c0 = __ptr + 3;
        for (local_1bc = 0; local_1bc < (int)__ptr[2]; local_1bc = local_1bc + 1) {
          if (DAT_00557704 == '\0') {
            uVar4 = *local_1c0;
          }
          else {
            uVar4 = *local_1c0;
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          *local_1c0 = uVar4;
          FUN_0041e0e8(abStack_f8,(int)(local_1c0 + 1),*local_1c0);
          memcpy(acStack_2c,(char *)((int)local_1c0 + 0x25),(uint)(byte)local_1c0[9]);
          acStack_2c[(byte)local_1c0[9]] = '\0';
          memcpy(acStack_50,(char *)((int)local_1c0 + 0x46),(uint)*(byte *)((int)local_1c0 + 0x45));
          acStack_50[*(byte *)((int)local_1c0 + 0x45)] = '\0';
          memcpy(acStack_74,(char *)((int)local_1c0 + 0x67),(uint)*(byte *)((int)local_1c0 + 0x66));
          acStack_74[*(byte *)((int)local_1c0 + 0x66)] = '\0';
          printf(" % 2d: ssid \"%s\", user \"%s\", password \"%s\", domain \"%s\"\n",local_1bc,
                 (char *)abStack_f8,acStack_2c,acStack_50,acStack_74);
          local_1c0 = local_1c0 + 0x22;
        }
        free(__ptr);
        iVar2 = 0;
      }
    }
  }
  else {
    sVar3 = strlen((char *)*piVar1);
    if (sVar3 < 0x21) {
      memset(local_18c,0,0x94);
      if (DAT_00557704 == '\0') {
        local_18c[0] = 0x94;
        local_184 = 1;
        local_180 = sVar3;
      }
      else {
        local_18c[0] = 0x94000000;
        local_184 = 0x1000000;
        local_180 = sVar3 << 0x18 | (sVar3 & 0xff00) << 8 | (sVar3 & 0xff0000) >> 8 | sVar3 >> 0x18;
      }
      memcpy(auStack_17c,(void *)*piVar1,sVar3);
      piVar1 = (int *)(param_3 + 8);
      if (*piVar1 == 0) {
        iVar2 = -0x2c;
      }
      else {
        sVar3 = strlen((char *)*piVar1);
        if (sVar3 < 0x21) {
          local_15c = (undefined1)sVar3;
          memcpy(auStack_15b,(void *)*piVar1,sVar3);
          piVar1 = (int *)(param_3 + 0xc);
          if (*piVar1 == 0) {
            iVar2 = -0x2c;
          }
          else {
            sVar3 = strlen((char *)*piVar1);
            if (sVar3 < 0x21) {
              local_13b = (undefined1)sVar3;
              memcpy(auStack_13a,(void *)*piVar1,sVar3);
              piVar1 = (int *)(param_3 + 0x10);
              if (*piVar1 != 0) {
                sVar3 = strlen((char *)*piVar1);
                if (0x20 < sVar3) {
                  return -2;
                }
                local_11a = (undefined1)sVar3;
                memcpy(auStack_119,(void *)*piVar1,sVar3);
              }
              iVar2 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)local_18c,0x94);
            }
            else {
              iVar2 = -2;
            }
          }
        }
        else {
          iVar2 = -2;
        }
      }
    }
    else {
      iVar2 = -2;
    }
  }
  return iVar2;
}



int FUN_00431dfc(int *param_1,int param_2)

{
  int iVar1;
  uint local_10 [2];
  
  if (*(int *)(param_2 + 8) < 0) {
    iVar1 = -1;
  }
  else {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)local_10,4);
    if (-1 < iVar1) {
      if (DAT_00557704 != '\0') {
        local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                      (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
      }
      printf("CCK %d OFDM %d\n",local_10[0] & 0xff,(int)local_10[0] >> 8 & 0xff);
      iVar1 = 0;
    }
  }
  return iVar1;
}



uint FUN_00431f1c(char param_1)

{
  uint uVar1;
  uint local_10;
  int local_c;
  
  local_10 = 1;
  local_c = param_1 + -0x99;
  if (local_c < 0x28) {
    for (; local_c < 0; local_c = local_c + 0x28) {
      local_10 = local_10 * 10;
    }
    if (local_10 == 0) {
      trap(7);
    }
    uVar1 = ((uint)*(ushort *)(&DAT_005141c8 + local_c * 2) + (local_10 >> 1)) / local_10 & 0xffff;
  }
  else {
    uVar1 = 0xffff;
  }
  return uVar1;
}



int FUN_00431fe0(ushort param_1)

{
  char cVar1;
  int iVar2;
  byte local_18;
  uint local_10;
  
  local_10 = (uint)param_1;
  if (local_10 < 2) {
    iVar2 = -0x80;
  }
  else {
    cVar1 = -0x67;
    for (; local_10 < 0x195d; local_10 = local_10 * 10) {
      cVar1 = cVar1 + -0x28;
    }
    local_18 = 0;
    while ((local_18 < 0x27 &&
           ((uint)*(ushort *)(&DAT_005141c8 + (uint)local_18 * 2) +
            (int)((uint)*(ushort *)(&DAT_005141c8 + (local_18 + 1) * 2) -
                 (uint)*(ushort *)(&DAT_005141c8 + (uint)local_18 * 2)) / 2 <= local_10))) {
      local_18 = local_18 + 1;
    }
    iVar2 = (int)(char)(cVar1 + local_18);
  }
  return iVar2;
}



int FUN_00432138(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  uint uVar4;
  char cVar5;
  ushort uVar6;
  int iVar7;
  uint uVar8;
  int param2;
  char *pcVar9;
  int *piVar10;
  int *local_res8;
  uint local_40;
  int local_3c;
  char local_36;
  uint local_14 [2];
  
  local_40 = 0;
  bVar3 = false;
  bVar1 = false;
  if (*(int *)(param_3 + 4) == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      iVar7 = -1;
    }
    else {
      iVar7 = FUN_004ba35c(param_1,"qtxpower",local_14);
      uVar4 = local_14[0];
      if (-1 < iVar7) {
        local_14[0] = local_14[0] & 0x7fffffff;
        cVar5 = (char)local_14[0];
        iVar7 = (int)cVar5;
        if (iVar7 < 0) {
          iVar7 = iVar7 + 3;
        }
        uVar8 = (uint)(char)(iVar7 >> 2);
        iVar7 = (cVar5 % '\x04') * 100;
        if (iVar7 < 0) {
          iVar7 = iVar7 + 3;
        }
        if ((iVar7 >> 2 < 0) || ((int)uVar8 < 0)) {
          bVar1 = true;
        }
        else {
          bVar1 = false;
        }
        param2 = (uVar8 ^ (int)uVar8 >> 0x1f) - ((int)uVar8 >> 0x1f);
        if (bVar1) {
          param2 = -param2;
        }
        if (cVar5 < '\x04') {
          uVar8 = 0;
        }
        else {
          uVar8 = FUN_00431f1c(cVar5);
        }
        if ((int)uVar4 < 0) {
          pcVar9 = "On";
        }
        else {
          pcVar9 = "Off";
        }
        printf("TxPower is %d qdbm, %d.%d dbm, %d mW  Override is %s\n",(int)cVar5,param2,
               (iVar7 >> 2 ^ iVar7 >> 0x1f) - (iVar7 >> 0x1f),uVar8,pcVar9);
        iVar7 = 0;
      }
    }
  }
  else {
    bVar2 = false;
    local_3c = 3;
    local_36 = '\0';
    local_res8 = (int *)(param_3 + 4);
    while( true ) {
      pcVar9 = (char *)*local_res8;
      piVar10 = local_res8 + 1;
      if (pcVar9 == (char *)0x0) break;
      iVar7 = strcmp(pcVar9,"-o");
      if (iVar7 == 0) {
        bVar3 = true;
        local_res8 = piVar10;
      }
      else {
        iVar7 = strcmp(pcVar9,"-d");
        if (iVar7 == 0) {
          local_3c = 3;
          bVar2 = true;
          local_res8 = piVar10;
        }
        else {
          iVar7 = strcmp(pcVar9,"-q");
          if (iVar7 == 0) {
            local_3c = 2;
            bVar2 = true;
            local_res8 = piVar10;
          }
          else {
            iVar7 = strcmp(pcVar9,"-m");
            if (iVar7 == 0) {
              local_3c = 1;
              bVar2 = true;
              local_res8 = piVar10;
            }
            else {
              iVar7 = strcmp(pcVar9,"-b");
              if (iVar7 == 0) {
                pcVar9 = (char *)*piVar10;
                if (pcVar9 == (char *)0x0) {
                  return -0x2c;
                }
                iVar7 = strcmp(pcVar9,"a");
                if (((iVar7 == 0) || (iVar7 = strcmp(pcVar9,"5"), iVar7 == 0)) ||
                   (iVar7 = strcmp(pcVar9,"5g"), iVar7 == 0)) {
                  local_36 = '\x01';
                  local_res8 = local_res8 + 2;
                }
                else {
                  iVar7 = strcmp(pcVar9,"b");
                  if (((iVar7 != 0) && (iVar7 = strcmp(pcVar9,"2"), iVar7 != 0)) &&
                     (iVar7 = strcmp(pcVar9,"2g"), iVar7 != 0)) {
                    return -0x2c;
                  }
                  local_36 = '\x02';
                  local_res8 = local_res8 + 2;
                }
              }
              else {
                if (bVar1) {
                  return -0x2c;
                }
                local_14[0] = atoi(pcVar9);
                if (!bVar2) {
                  if (local_14[0] == 0xffffffff) {
                    local_14[0] = 0x7f;
                    local_3c = 2;
                  }
                  else if ((int)local_14[0] < 1) {
                    return -2;
                  }
                }
                if (((int)local_14[0] < 1) && (local_3c == 1)) {
                  return -2;
                }
                bVar1 = true;
                local_res8 = piVar10;
              }
            }
          }
        }
      }
    }
    if (local_3c == 2) {
      if (0x7f < (int)local_14[0]) {
        return -2;
      }
      if ((int)local_14[0] < -0x80) {
        local_14[0] = 0xffffff80;
      }
      local_40 = local_14[0] & 0xff;
    }
    else if (local_3c == 3) {
      if (0x1f < (int)local_14[0]) {
        return -2;
      }
      local_14[0] = local_14[0] << 2;
      if ((int)local_14[0] < -0x80) {
        local_14[0] = 0xffffff80;
      }
      local_40 = local_14[0] & 0xff;
    }
    else if (local_3c == 1) {
      if ((int)local_14[0] < 0xffff) {
        uVar6 = (ushort)local_14[0];
      }
      else {
        uVar6 = 0xffff;
      }
      local_40 = FUN_00431fe0(uVar6);
      local_40 = local_40 & 0xff;
    }
    if (bVar3) {
      local_40 = local_40 | 0x80000000;
    }
    if (local_36 == '\x02') {
      local_40 = local_40 | 0x40000000;
    }
    else if (local_36 == '\x01') {
      local_40 = local_40 | 0x20000000;
    }
    iVar7 = FUN_004ba428(param_1,"qtxpower",local_40);
  }
  return iVar7;
}



int FUN_004327e4(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  uint uVar2;
  char cVar3;
  ushort uVar4;
  int iVar5;
  uint uVar6;
  uint param3;
  char *param4;
  int *local_res8;
  uint local_28;
  uint local_1c;
  char *local_18 [2];
  
  local_18[0] = (char *)0x0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar5 = FUN_004ba35c(param_1,"qtxpower",&local_1c);
    uVar2 = local_1c;
    if (-1 < iVar5) {
      uVar1 = local_1c & 0x7fffffff;
      uVar6 = local_1c & 3;
      if (uVar1 < 0xff) {
        cVar3 = (char)uVar1;
      }
      else {
        cVar3 = -1;
      }
      local_1c = uVar1;
      param3 = FUN_00431f1c(cVar3);
      if ((int)uVar2 < 0) {
        param4 = "(Override ON)";
      }
      else {
        param4 = "";
      }
      printf("%d.%d dBm = %d mw.  %s\n",uVar1 >> 2,uVar6 * 100 >> 2,param3,param4);
      iVar5 = 0;
    }
  }
  else {
    iVar5 = strcmp((char *)*local_res8,"-u");
    if (iVar5 == 0) {
      local_28 = 0;
      local_res8 = (int *)(param_3 + 8);
    }
    else {
      local_28 = 0x80000000;
    }
    local_1c = strtol((char *)*local_res8,local_18,0);
    if (*local_18[0] == '\0') {
      if (local_1c < 0xffff) {
        uVar4 = (ushort)local_1c;
      }
      else {
        uVar4 = 0xffff;
      }
      local_1c = FUN_00431fe0(uVar4);
      local_1c = local_1c | local_28;
      iVar5 = FUN_004ba428(param_1,"qtxpower",local_1c);
    }
    else {
      iVar5 = -0x2c;
    }
  }
  return iVar5;
}



// WARNING: Removing unreachable block (ram,0x00432b00)

int FUN_00432a34(int *param_1,int param_2)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  byte local_68 [24];
  byte local_50;
  
  iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)local_68,0x5d);
  if (-1 < iVar2) {
    bVar1 = local_50;
    if (local_68[0] < local_50) {
      bVar1 = local_68[0];
    }
    uVar3 = FUN_00431f1c(bVar1);
    printf("%d mW (%d.%d dBm)\n",uVar3 & 0xffff,(uint)(bVar1 >> 2),(int)((bVar1 & 3) * 100) >> 2);
  }
  return iVar2;
}



int FUN_00432b3c(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  ulong uVar4;
  char *param1;
  ushort local_18;
  ushort local_16;
  ushort local_14;
  ushort local_12;
  char *local_10 [2];
  
  memset(&local_18,0,8);
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      iVar3 = -1;
    }
    else {
      iVar3 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_18,8);
      if (-1 < iVar3) {
        if (DAT_00557704 == '\0') {
          bVar1 = local_18 != 0;
        }
        else {
          bVar1 = (local_18 & 0xff) != 0 || local_18 >> 8 != 0;
        }
        if (bVar1) {
          param1 = "auto";
        }
        else {
          param1 = "";
        }
        if (DAT_00557704 != '\0') {
          local_16 = local_16 << 8 | local_16 >> 8;
        }
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 8 | local_14 >> 8;
        }
        if (DAT_00557704 != '\0') {
          local_12 = local_12 << 8 | local_12 >> 8;
        }
        printf("tx %s bb/radio/ctl1 %d/%d/%d\n",param1,(uint)local_16,(uint)local_14,(uint)local_12)
        ;
        iVar3 = 0;
      }
    }
  }
  else if (*(int *)(param_2 + 0xc) < 0) {
    iVar3 = -1;
  }
  else {
    iVar3 = strcasecmp((char *)*piVar2,"auto");
    if (iVar3 == 0) {
      if (DAT_00557704 == '\0') {
        local_18 = 1;
      }
      else {
        local_18 = 0x100;
      }
    }
    else {
      iVar3 = strcasecmp((char *)*piVar2,"manual");
      if (iVar3 == 0) {
        if (DAT_00557704 == '\0') {
          local_18 = 2;
        }
        else {
          local_18 = 0x200;
        }
      }
      else {
        local_18 = 0;
        uVar4 = strtoul((char *)*piVar2,local_10,0);
        local_16 = (ushort)uVar4;
        if (DAT_00557704 != '\0') {
          local_16 = local_16 << 8 | local_16 >> 8;
        }
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
        if (*(int *)(param_3 + 8) == 0) {
          return -0x2c;
        }
        uVar4 = strtoul(*(char **)(param_3 + 8),local_10,0);
        local_14 = (ushort)uVar4;
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 8 | local_14 >> 8;
        }
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
        if (*(int *)(param_3 + 0xc) == 0) {
          return -0x2c;
        }
        uVar4 = strtoul(*(char **)(param_3 + 0xc),local_10,0);
        local_12 = (ushort)uVar4;
        if (DAT_00557704 != '\0') {
          local_12 = local_12 << 8 | local_12 >> 8;
        }
        if (*local_10[0] != '\0') {
          return -0x2c;
        }
      }
    }
    iVar3 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_18,8);
  }
  return iVar3;
}



int FUN_00433138(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  int iVar3;
  uint uVar4;
  char *param2;
  undefined3 extraout_var;
  undefined4 uVar5;
  char *param1;
  int *local_res8;
  undefined *local_40;
  uint local_3c;
  
  puVar1 = PTR_DAT_00551644;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    if ((int)param_2[2] < 0) {
      iVar3 = -1;
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar5 = 0xff;
      }
      else {
        uVar5 = 0xff000000;
      }
      *(undefined4 *)PTR_DAT_00551644 = uVar5;
      iVar3 = FUN_004b9f94(param_1,param_2[2],puVar1,0x600);
      if (-1 < iVar3) {
        if (DAT_00557704 == '\0') {
          uVar4 = *(uint *)puVar1;
        }
        else {
          uVar4 = *(uint *)puVar1;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        *(uint *)puVar1 = uVar4;
        local_40 = puVar1 + 4;
        for (local_3c = 0; (local_3c < *(uint *)puVar1 && (local_3c < 0xff));
            local_3c = local_3c + 1) {
          param1 = (char *)*param_2;
          param2 = FUN_0041d780((int)local_40);
          printf("%s %s\n",param1,param2);
          local_40 = local_40 + 6;
        }
        iVar3 = 0;
      }
    }
  }
  else if ((int)param_2[3] < 0) {
    iVar3 = -1;
  }
  else {
    *(undefined4 *)PTR_DAT_00551644 = 0;
    iVar3 = strcasecmp((char *)*local_res8,"none");
    if ((iVar3 == 0) || (iVar3 = strcasecmp((char *)*local_res8,"clear"), iVar3 == 0)) {
      iVar3 = FUN_004ba050(param_1,param_2[3],puVar1,4);
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar5 = 0xff;
      }
      else {
        uVar5 = 0xff000000;
      }
      *(undefined4 *)puVar1 = uVar5;
      iVar3 = FUN_004b9f94(param_1,param_2[2],puVar1,0x600);
      if (-1 < iVar3) {
        if (DAT_00557704 == '\0') {
          uVar4 = *(uint *)puVar1;
        }
        else {
          uVar4 = *(uint *)puVar1;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        *(uint *)puVar1 = uVar4;
        local_40 = puVar1 + *(int *)puVar1 * 6 + 4;
        while ((*local_res8 != 0 && (*(uint *)puVar1 < 0xff))) {
          bVar2 = FUN_0041d6ac((char *)*local_res8,local_40);
          if (CONCAT31(extraout_var,bVar2) == 0) {
            printf("Problem parsing MAC address \"%s\".\n",(char *)*local_res8);
            return -0x2c;
          }
          *(int *)puVar1 = *(int *)puVar1 + 1;
          local_40 = local_40 + 6;
          local_res8 = local_res8 + 1;
        }
        iVar3 = *(int *)puVar1;
        if (DAT_00557704 == '\0') {
          uVar4 = *(uint *)puVar1;
        }
        else {
          uVar4 = *(uint *)puVar1;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        *(uint *)puVar1 = uVar4;
        iVar3 = FUN_004ba050(param_1,param_2[3],puVar1,iVar3 * 6 + 4);
      }
    }
  }
  return iVar3;
}



int FUN_004336cc(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  undefined *puVar1;
  int iVar2;
  char *param2;
  uint uVar3;
  char *param1;
  undefined *local_28;
  uint local_24;
  
  strcpy(PTR_DAT_00551644,(char *)*param_3);
  iVar2 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
  puVar1 = PTR_DAT_00551644;
  if (-1 < iVar2) {
    local_24 = 0;
    local_28 = PTR_DAT_00551644 + 4;
    while( true ) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)puVar1;
      }
      else {
        uVar3 = *(uint *)puVar1;
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      if (uVar3 <= local_24) break;
      param1 = (char *)*param_2;
      param2 = FUN_0041d780((int)local_28);
      printf("%s %s\n",param1,param2);
      local_24 = local_24 + 1;
      local_28 = local_28 + 6;
    }
    iVar2 = 0;
  }
  return iVar2;
}



int FUN_0043384c(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint local_18;
  uint local_14;
  char *pcStack_c;
  
  local_18 = 0;
  if (*(int *)(param_3 + 4) != 0) {
    local_18 = strtoul(*(char **)(param_3 + 4),&pcStack_c,0);
  }
  if (1000 < local_18) {
    printf("maximum allowed size is : %d\n",1000);
    local_18 = 1000;
  }
  memset(PTR_DAT_00551644,0,local_18 + 2);
  for (local_14 = 0; local_14 < local_18; local_14 = local_14 + 1) {
    PTR_DAT_00551644[local_14 + 2] = (char)local_14;
  }
  *(short *)PTR_DAT_00551644 = (short)local_18;
  iVar1 = FUN_004b9f94(param_1,0x143,PTR_DAT_00551644,local_18 + 2);
  if (-1 < iVar1) {
    if (*(ushort *)PTR_DAT_00551644 == local_18) {
      for (local_14 = 0; local_14 < *(ushort *)PTR_DAT_00551644; local_14 = local_14 + 1) {
        if (PTR_DAT_00551644[local_14 + 2] != (char)local_14) {
          puts("error read data is different then write data");
          return -1;
        }
      }
      puts("write buffer and read buffer are identical");
      iVar1 = 0;
    }
    else {
      puts("error read size is different then write size");
      iVar1 = -1;
    }
  }
  return iVar1;
}



void FUN_00433a7c(int *param_1)

{
  FUN_004ba050(param_1,0xa3,(char *)0x0,0);
  return;
}



int FUN_00433ac8(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int local_18;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    local_18 = FUN_004b9f94(param_1,0x8d,(char *)&local_c,4);
    if (-1 < local_18) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
      }
      if (local_c == 0) {
        puts("auto");
      }
      else if (local_c == 1) {
        puts("a");
      }
      else if (local_c == 2) {
        puts("b");
      }
      else {
        printf("unrecognized band value %d\n",local_c);
        local_18 = -1;
      }
    }
  }
  else {
    iVar2 = strcasecmp((char *)*piVar1,"auto");
    if (iVar2 == 0) {
      local_c = 0;
    }
    else {
      iVar2 = strcasecmp((char *)*piVar1,"a");
      if (iVar2 == 0) {
        local_c = 1;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar1,"b");
        if (iVar2 != 0) {
          printf("unsupported band: %s\n",(char *)*piVar1);
          return -0x17;
        }
        local_c = 2;
      }
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18;
    }
    local_18 = FUN_004ba050(param_1,0x8e,(char *)&local_c,4);
  }
  return local_18;
}



int FUN_00433d94(int *param_1)

{
  int iVar1;
  uint local_28;
  uint local_14 [3];
  
  iVar1 = FUN_004b9f94(param_1,0x8c,(char *)local_14,0xc);
  if (-1 < iVar1) {
    if (DAT_00557704 != '\0') {
      local_14[0] = local_14[0] << 0x18 | (local_14[0] & 0xff00) << 8 |
                    (local_14[0] & 0xff0000) >> 8 | local_14[0] >> 0x18;
    }
    if (DAT_00557704 != '\0') {
      local_14[1] = local_14[1] << 0x18 | (local_14[1] & 0xff00) << 8 |
                    (local_14[1] & 0xff0000) >> 8 | local_14[1] >> 0x18;
    }
    if (DAT_00557704 != '\0') {
      local_14[2] = local_14[2] << 0x18 | (local_14[2] & 0xff00) << 8 |
                    (local_14[2] & 0xff0000) >> 8 | local_14[2] >> 0x18;
    }
    if (2 < local_14[0]) {
      local_14[0] = 2;
    }
    for (local_28 = 1; local_28 <= local_14[0]; local_28 = local_28 + 1) {
      if (local_14[local_28] == 1) {
        printf("a ");
      }
      else if (local_14[local_28] == 2) {
        printf("b ");
      }
      else {
        printf("? ");
      }
    }
    putchar(10);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00434008(int *param_1)

{
  int iVar1;
  uchar *local_90;
  uchar local_88 [128];
  
  iVar1 = FUN_004b9f94(param_1,0xb4,(char *)local_88,0x80);
  if (-1 < iVar1) {
    for (local_90 = local_88; *local_90 != '\0'; local_90 = local_90 + 1) {
      printf("%c ",*local_90);
    }
    putchar(10);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_004340dc(int *param_1,int param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  FILE *__stream;
  size_t sVar3;
  int iVar4;
  int local_230;
  uint local_22c;
  int local_228;
  uint local_210;
  undefined1 auStack_20c [512];
  uint local_c;
  
  local_230 = 0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_230 = -0x2c;
  }
  else {
    __stream = fopen((char *)*piVar2,"rb");
    if (__stream == (FILE *)0x0) {
      fprintf(stderr,"%s: No such file or directory\n",(char *)*piVar2);
      local_230 = -2;
    }
    else {
      printf("Programming %s...",(char *)*piVar2);
      fflush(stdout);
      local_22c = 0;
      local_210 = 0;
      while ((sVar3 = fread(auStack_20c,1,0x200,__stream), sVar3 != 0 &&
             (local_230 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_210,sVar3 + 4)
             , -1 < local_230))) {
        local_22c = local_22c + sVar3;
        local_210 = local_22c;
        if (DAT_00557704 != '\0') {
          local_210 = local_22c * 0x1000000 | (local_22c & 0xff00) << 8 |
                      (local_22c & 0xff0000) >> 8 | local_22c >> 0x18;
        }
        putchar(0x2e);
        fflush(stdout);
      }
      iVar4 = ferror(__stream);
      if (iVar4 == 0) {
        local_c = 1;
        puts("\nCommitting image to flash...");
        while (local_c == 1) {
          local_228 = 10;
          while (local_230 = FUN_004b9f94(param_1,0xff,(char *)&local_c,4), local_230 < 0) {
            bVar1 = local_228 == 0;
            local_228 = local_228 + -1;
            if (bVar1) goto LAB_00434464;
          }
          if (DAT_00557704 != '\0') {
            local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                      local_c >> 0x18;
          }
        }
LAB_00434464:
        if (local_c == 0) {
          printf("\nDone\n\nSuccessfully downloaded %d bytes\n",local_210);
        }
        else {
          fprintf(stderr,"\n*** UPGRADE FAILED! *** (status %ld)\n",local_c);
        }
      }
      else {
        local_230 = ferror(__stream);
        printf("\nerror reading %s\n",(char *)*piVar2);
      }
      fclose(__stream);
    }
  }
  return local_230;
}



int FUN_004344dc(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  bool bVar2;
  char cVar3;
  ulong uVar4;
  int iVar5;
  size_t param1;
  uint __c;
  int local_4e0;
  uint local_4d8;
  byte *local_4d4;
  byte *local_4d0;
  char acStack_4b0 [4];
  undefined1 auStack_4ac [4];
  byte local_4a8 [384];
  uint local_328;
  uint local_324;
  byte *local_320;
  char *pcStack_31c;
  char local_318;
  char acStack_314 [776];
  
  bVar2 = true;
  local_320 = (byte *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar5 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_328 = strtoul(*(char **)(param_3 + 4),&pcStack_31c,0);
    }
    else {
      uVar4 = strtoul(*(char **)(param_3 + 4),&pcStack_31c,0);
      local_328 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    memcpy(acStack_4b0,&local_328,4);
    if (*(int *)(param_3 + 8) == 0) {
      local_324 = 1;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_324 = strtoul(*(char **)(param_3 + 8),&pcStack_31c,0);
      }
      else {
        uVar4 = strtoul(*(char **)(param_3 + 8),&pcStack_31c,0);
        local_324 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      if (0xc00 < local_324) {
        printf("bit size (%d) too long or negative!!\n",local_324);
        return -2;
      }
    }
    memcpy(auStack_4ac,&local_324,4);
    local_4e0 = 8;
    if (*(int *)(param_3 + 0xc) != 0) {
      local_4d4 = *(byte **)(param_3 + 0xc);
      bVar2 = false;
      if ((*local_4d4 == 0x30) && (iVar5 = toupper((int)(char)local_4d4[1]), iVar5 == 0x58)) {
        local_4d4 = local_4d4 + 2;
      }
      param1 = strlen((char *)local_4d4);
      if ((0x300 < param1) || (param1 << 2 < local_324)) {
        printf("data length (%d) too long or small!!\n",param1);
        return -0x2c;
      }
      for (local_4d8 = 1; local_4d8 <= param1; local_4d8 = local_4d8 + 1) {
        bVar1 = *local_4d4;
        __c = (uint)bVar1;
        local_4d4 = local_4d4 + 1;
        if ((*(ushort *)(__ctype_b + __c * 2) & 0x10) == 0) {
          fprintf(stderr,"invalid hex digit %c\n",bVar1);
          return -0x2c;
        }
        if ((*(ushort *)(__ctype_b + __c * 2) & 8) == 0) {
          if ((*(ushort *)(__ctype_b + __c * 2) & 2) == 0) {
            cVar3 = bVar1 - 0x37;
          }
          else {
            iVar5 = toupper(__c);
            cVar3 = (char)iVar5 + -0x37;
          }
        }
        else {
          cVar3 = bVar1 - 0x30;
        }
        acStack_314[param1 - local_4d8] = cVar3;
      }
      for (local_4d8 = 0; local_4d8 < param1; local_4d8 = local_4d8 + 2) {
        local_318 = acStack_314[local_4d8];
        if (local_4d8 + 1 < param1) {
          local_318 = acStack_314[local_4d8 + 1] * '\x10' + acStack_314[local_4d8];
        }
        acStack_4b0[local_4e0] = local_318;
        local_4e0 = local_4e0 + 1;
      }
      printf("OTP RAM Write:");
      for (local_4d8 = 0; local_4d8 < local_324; local_4d8 = local_4d8 + 8) {
        bVar1 = local_4a8[local_4d8 >> 3];
        if ((local_4d8 & 0x3f) == 0) {
          printf("\nbit %4d:",local_328 + local_4d8);
        }
        printf(" 0x%x",(uint)bVar1);
      }
      putchar(10);
    }
    if (bVar2) {
      iVar5 = FUN_00445198(param_1,(char *)*param_2,acStack_4b0,0x188,&local_320);
      if (iVar5 < 0) {
        puts("Error reading from OTP data");
      }
      else {
        local_4d0 = local_320;
        printf("OTP RAM Read:");
        for (local_4d8 = 0; local_4d8 < local_324; local_4d8 = local_4d8 + 8) {
          bVar1 = *local_4d0;
          local_4d0 = local_4d0 + 1;
          if ((local_4d8 & 0x3f) == 0) {
            printf("\nbit %4d:",local_328 + local_4d8);
          }
          printf(" 0x%02x",(uint)bVar1);
        }
        putchar(10);
        iVar5 = 0;
      }
    }
    else {
      iVar5 = FUN_00445444(param_1,(char *)*param_2,acStack_4b0,0x188);
    }
  }
  return iVar5;
}



int FUN_00434bcc(int *param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int local_3a0;
  int *local_39c;
  char *local_398;
  size_t local_394;
  FILE *local_390;
  int *local_38c;
  int local_388;
  int local_384;
  int aiStack_374 [219];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    return -0x2c;
  }
  local_390 = fopen((char *)*piVar1,"rb");
  if (local_390 == (FILE *)0x0) {
    fprintf(stderr,"%s: No such file or directory\n",(char *)*piVar1);
    return -2;
  }
  local_394 = fread(&local_388,1,0x37f,local_390);
  iVar2 = ferror(local_390);
  if (iVar2 == 0) {
    iVar2 = feof(local_390);
    if (iVar2 == 0) {
      printf("\nFile %s too large\n",(char *)*piVar1);
      local_3a0 = -1;
    }
    else {
      local_38c = &local_388;
      if (local_388 == 0x48534c46) {
        if (*(int *)(param_2 + 0xc) == 0x113) {
          printf("File %s looks like an nvserial file, use nvotpw\n",(char *)*piVar1);
          fflush(stdout);
          local_3a0 = -1;
          goto LAB_00434f3c;
        }
        local_394 = local_384 - 0x14;
        if ((int)local_394 < 1) {
          printf("Invalid length (%d)\n",local_394);
          local_3a0 = -1;
          goto LAB_00434f3c;
        }
        if ((local_394 & 1) != 0) {
          *(undefined1 *)((int)&local_39c + local_384) = 0;
          local_394 = local_384 - 0x13;
        }
        local_39c = aiStack_374;
        local_398 = "nvserial";
      }
      else {
        if (*(int *)(param_2 + 0xc) == 0x112) {
          printf("File %s is not an nvserial file\n",(char *)*piVar1);
          local_3a0 = -1;
          goto LAB_00434f3c;
        }
        if ((local_394 & 1) != 0) {
          printf("File %s has an odd length (%d)\n",(char *)*piVar1,local_394);
          local_3a0 = -1;
          goto LAB_00434f3c;
        }
        local_39c = &local_388;
        local_398 = "raw";
      }
      printf("Writing %d bytes from %s file %s to otp ...\n",local_394,local_398,(char *)*piVar1);
      fflush(stdout);
      local_3a0 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)local_39c,local_394);
      if (local_3a0 < 0) {
        printf("\nError %d writing %s to otp\n",local_3a0,(char *)*piVar1);
      }
    }
  }
  else {
    printf("\nerror %d reading %s\n",iVar2,(char *)*piVar1);
    local_3a0 = -1;
  }
LAB_00434f3c:
  fclose(local_390);
  return local_3a0;
}



int FUN_00434f64(int *param_1,int param_2)

{
  int iVar1;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  memset(&local_20,0,0x14);
  iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_20,0x14);
  if (-1 < iVar1) {
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
    }
    printf("Receive: good packet %d, bad packet %d, othercast good packet %d\n",local_20,local_1c,
           local_10);
    if (DAT_00557704 != '\0') {
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    printf("Transmit: good packet %d, bad packet %d\n",local_18,local_14);
  }
  return iVar1;
}



int FUN_004351fc(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  char *local_58;
  uint local_54;
  char acStack_50 [48];
  uint local_20;
  
  local_58 = (char *)0x0;
  memset(acStack_50,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
  if (iVar1 == 0) {
    uVar2 = local_20;
    if (DAT_00557704 != '\0') {
      uVar2 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
              local_20 >> 0x18;
    }
    if (*(int *)(param_3 + 4) == 0) {
      if (*(int *)(param_2 + 8) < 0) {
        iVar1 = -1;
      }
      else {
        iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_54,4);
        if (-1 < iVar1) {
          if (DAT_00557704 != '\0') {
            local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                       local_54 >> 0x18;
          }
          if (uVar2 == 0xb) {
            local_54 = local_54 & 0x7f;
            if (local_54 == 0) {
              puts("All interference mitigation is disabled. (mode 0)");
            }
            else {
              printf("\nMode = %d. Following ACI modes are enabled:\n",local_54);
              if ((local_54 & 1) != 0) {
                printf("\tbit-mask %d:  Reciever Desense based on glitch count\n",1);
              }
              if ((local_54 & 2) != 0) {
                printf("\tbit-mask %d:  Limit pktgain based on hwaci (high pwr aci)\n",2);
              }
              if ((local_54 & 4) != 0) {
                printf("\tbit-mask %d:  Limit pktgain based on w2/nb (high pwr aci)\n",4);
              }
              if ((local_54 & 8) != 0) {
                printf("\tbit-mask %d:  Preemption is enabled\n",8);
              }
              if ((local_54 & 0x10) != 0) {
                printf("\tbit-mask %d: HW ACI Detection + Mitigation\n",0x10);
              }
            }
            putchar(10);
          }
          else {
            switch(local_54 & 0x7f) {
            case 0:
              puts("All interference mitigation is disabled. (mode 0)");
              break;
            case 1:
              printf("Non-wireless LAN Interference mitigation is ");
              puts("enabled. (mode 1)");
              break;
            case 2:
              printf("Wireless LAN Interference mitigation ");
              puts("is enabled. (mode 2)");
              break;
            case 3:
              printf("Auto Wireless LAN Interference mitigation is ");
              if ((local_54 & 0x80) == 0) {
                puts("enabled and not active. (mode 3)");
              }
              else {
                puts("enabled and active. (mode 3)");
              }
              break;
            case 4:
              printf("Auto Wireless LAN Interference mitigation is enabled and ");
              if ((local_54 & 0x80) == 0) {
                printf("not active, ");
              }
              else {
                printf("active, ");
              }
              puts("and noise reduction is enabled. (mode 4)");
            }
          }
          iVar1 = 0;
        }
      }
    }
    else {
      local_54 = 0;
      local_54 = strtol(*(char **)(param_3 + 4),&local_58,0);
      if (*local_58 == '\0') {
        if (uVar2 == 0xb) {
          if (0x1f < (int)local_54) {
            return -1;
          }
        }
        else {
          switch(local_54) {
          case 0:
            local_54 = 0;
            break;
          case 1:
            local_54 = 1;
            break;
          case 2:
            local_54 = 2;
            break;
          case 3:
            local_54 = 3;
            break;
          case 4:
            local_54 = 4;
            break;
          default:
            return -2;
          }
        }
        if (DAT_00557704 != '\0') {
          local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                     local_54 >> 0x18;
        }
        iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_54,4);
      }
      else {
        iVar1 = -0x2c;
      }
    }
  }
  return iVar1;
}



int FUN_004357b8(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  char *local_58;
  uint local_54;
  char acStack_50 [48];
  uint local_20;
  
  memset(acStack_50,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
  if (iVar1 == 0) {
    uVar2 = local_20;
    if (DAT_00557704 != '\0') {
      uVar2 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
              local_20 >> 0x18;
    }
    if (*(int *)(param_3 + 4) == 0) {
      if (*(int *)(param_2 + 8) < 0) {
        iVar1 = -1;
      }
      else {
        iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_54,4);
        if (-1 < iVar1) {
          if (DAT_00557704 != '\0') {
            local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                       local_54 >> 0x18;
          }
          if (uVar2 == 0xb) {
            if (local_54 == 0xffffffff) {
              puts("Interference override disabled.");
            }
            else if (local_54 == 0) {
              puts("Interference override NONE, all mitigation disabled. (mode 0)");
            }
            else {
              printf("\nInterference override mode = %d. Following ACI modes are enabled:\n",
                     local_54);
              if ((local_54 & 1) != 0) {
                printf("\tbit-mask %d:  Reciever Desense based on glitch count\n",1);
              }
              if ((local_54 & 2) != 0) {
                printf("\tbit-mask %d:  Limit pktgain based on hwaci (high pwr aci)\n",2);
              }
              if ((local_54 & 4) != 0) {
                printf("\tbit-mask %d:  Limit pktgain based on w2/nb (high pwr aci)\n",4);
              }
              if ((local_54 & 8) != 0) {
                printf("\tbit-mask %d:  Preemption is enabled\n",8);
              }
              if ((local_54 & 0x10) != 0) {
                printf("\tbit-mask %d: HW ACI Detection + Mitigation\n",0x10);
              }
            }
            putchar(10);
          }
          else {
            switch(local_54) {
            case 0:
              puts("Interference override NONE, all mitigation disabled. (mode 0)");
              break;
            case 1:
              puts(
                  "Interference override enabled.  Non-wireless LAN Interference mitigation is enabled. (mode 1)"
                  );
              break;
            case 2:
              puts(
                  "Interference override enabled.   Wireless LAN Interference mitigation is enabled. (mode 2)"
                  );
              break;
            case 3:
              printf("Interference override enabled.  Interference mitigation is enabled and ");
              if ((local_54 & 0x80) == 0) {
                puts("not active. (mode 3)");
              }
              else {
                puts("active. (mode 3)");
              }
              break;
            case 4:
              printf("Interference override enabled.  Interference mitigation is enabled and ");
              if ((local_54 & 0x80) == 0) {
                printf("not active, ");
              }
              else {
                printf("active, ");
              }
              puts("and noise reduction is enabled. (mode 4)");
              break;
            case 0xffffffff:
              puts("Interference override disabled. ");
            }
          }
          iVar1 = 0;
        }
      }
    }
    else {
      local_54 = 0;
      local_54 = strtol(*(char **)(param_3 + 4),&local_58,0);
      if (*local_58 == '\0') {
        if (uVar2 == 0xb) {
          if (0x1f < (int)local_54) {
            return -1;
          }
        }
        else {
          switch(local_54) {
          case 0:
            local_54 = 0;
            break;
          case 1:
            local_54 = 1;
            break;
          case 2:
            local_54 = 2;
            break;
          case 3:
            local_54 = 3;
            break;
          case 4:
            local_54 = 4;
            break;
          case 0xffffffff:
            local_54 = 0xffffffff;
            break;
          default:
            return -2;
          }
        }
        if (DAT_00557704 != '\0') {
          local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                     local_54 >> 0x18;
        }
        iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_54,4);
      }
      else {
        iVar1 = -0x2c;
      }
    }
  }
  return iVar1;
}



undefined ** FUN_00435d94(char *param_1)

{
  int iVar1;
  undefined **local_10;
  
  local_10 = &PTR_s_AFGHANISTAN_00551648;
  while ((*local_10 != (undefined *)0x0 && (iVar1 = strcasecmp(param_1,*local_10), iVar1 != 0))) {
    local_10 = local_10 + 2;
  }
  if (*local_10 == (undefined *)0x0) {
    local_10 = (undefined **)0x0;
  }
  return local_10;
}



undefined ** FUN_00435e30(char *param_1)

{
  size_t sVar1;
  int iVar2;
  char *__s2;
  undefined **local_18;
  
  if (((*param_1 == '\0') || (sVar1 = strlen(param_1), 3 < sVar1)) ||
     (sVar1 = strlen(param_1), sVar1 < 2)) {
    local_18 = (undefined **)0x0;
  }
  else {
    for (local_18 = &PTR_s_AFGHANISTAN_00551648; *local_18 != (undefined *)0x0;
        local_18 = local_18 + 2) {
      __s2 = local_18[1];
      sVar1 = strlen(param_1);
      iVar2 = strncasecmp(param_1,__s2,sVar1);
      if (iVar2 == 0) break;
    }
    if (*local_18 == (undefined *)0x0) {
      local_18 = (undefined **)0x0;
    }
  }
  return local_18;
}



undefined4 FUN_00435f30(char *param_1,void *param_2,long *param_3)

{
  char *pcVar1;
  undefined4 uVar2;
  size_t local_18;
  long local_14;
  char *local_c;
  
  local_c = (char *)0x0;
  local_14 = -1;
  pcVar1 = strchr(param_1,0x2f);
  if ((pcVar1 != (char *)0x0) && (local_14 = strtol(pcVar1 + 1,&local_c,10), *local_c != '\0')) {
    fprintf(stderr,"Could not parse \"%s\" as a regulatory revision in the country string \"%s\"\n",
            pcVar1 + 1,param_1);
    return 0xffffffd4;
  }
  if (pcVar1 == (char *)0x0) {
    local_18 = strlen(param_1);
  }
  else {
    local_18 = (int)pcVar1 - (int)param_1;
  }
  if ((int)local_18 < 4) {
    memcpy(param_2,param_1,local_18);
    *(undefined1 *)((int)param_2 + local_18) = 0;
    *param_3 = local_14;
    uVar2 = 0;
  }
  else {
    fprintf(stderr,"Could not parse a 2-3 char country code in the country string \"%s\"\n",param_1)
    ;
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



int FUN_004360a4(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  undefined4 *puVar2;
  undefined **ppuVar3;
  int iVar4;
  int *piVar5;
  uint uVar6;
  char *param2;
  int local_58;
  int local_54;
  char *local_50;
  uint local_4c;
  undefined4 local_20;
  uint local_1c;
  undefined4 local_18;
  uint local_14;
  int local_10 [2];
  
  local_20 = 0;
  local_1c = 0;
  local_18 = 0;
  local_14 = 1;
  puVar2 = (undefined4 *)(param_3 + 4);
  for (local_58 = 0; puVar2[local_58] != 0; local_58 = local_58 + 1) {
  }
  if (local_58 < 3) {
    *PTR_DAT_00551644 = 0;
    if (local_58 == 0) {
      local_50 = "<unknown>";
      local_54 = FUN_004ba1f8(param_1,"country",(char *)&local_20,0xc);
      if (local_54 == 0) {
        ppuVar3 = FUN_00435e30((char *)&local_20);
        if (ppuVar3 != (undefined **)0x0) {
          local_50 = *ppuVar3;
        }
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
        }
        printf("%s (%s/%d) %s\n",(char *)&local_20,(char *)&local_18,local_1c,local_50);
        local_54 = 0;
      }
      else {
        FUN_004ba35c(param_1,"bcmerror",&local_14);
        if ((local_14 == 0xffffffe9) &&
           (local_54 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x100), -1 < local_54)) {
          if (*PTR_DAT_00551644 == '\0') {
            puts("No country set");
            local_54 = 0;
          }
          else {
            ppuVar3 = FUN_00435e30(PTR_DAT_00551644);
            if (ppuVar3 != (undefined **)0x0) {
              local_50 = *ppuVar3;
            }
            printf("%s () %s\n",PTR_DAT_00551644,local_50);
            local_54 = 0;
          }
        }
      }
    }
    else {
      iVar4 = strcasecmp((char *)*puVar2,"list");
      puVar1 = PTR_DAT_00551644;
      if (iVar4 == 0) {
        *(undefined4 *)PTR_DAT_00551644 = 0x2000;
        *(undefined4 *)(puVar1 + 0xc) = 0;
        piVar5 = (int *)(param_3 + 8);
        if (*piVar5 == 0) {
          *(undefined4 *)(puVar1 + 4) = 0;
        }
        else {
          *(undefined4 *)(puVar1 + 4) = 1;
          iVar4 = strcasecmp((char *)*piVar5,"a");
          if (iVar4 == 0) {
            *(undefined4 *)(puVar1 + 8) = 1;
          }
          else {
            iVar4 = strcasecmp((char *)*piVar5,"b");
            if ((iVar4 != 0) && (iVar4 = strcasecmp((char *)*piVar5,"g"), iVar4 != 0)) {
              printf("unsupported band: %s\n",(char *)*piVar5);
              return -0x17;
            }
            *(undefined4 *)(puVar1 + 8) = 2;
          }
        }
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)puVar1;
        }
        else {
          uVar6 = *(uint *)puVar1;
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        }
        *(uint *)puVar1 = uVar6;
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)(puVar1 + 4);
        }
        else {
          uVar6 = *(uint *)(puVar1 + 4);
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        }
        *(uint *)(puVar1 + 4) = uVar6;
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)(puVar1 + 8);
        }
        else {
          uVar6 = *(uint *)(puVar1 + 8);
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        }
        *(uint *)(puVar1 + 8) = uVar6;
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)(puVar1 + 0xc);
        }
        else {
          uVar6 = *(uint *)(puVar1 + 0xc);
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        }
        *(uint *)(puVar1 + 0xc) = uVar6;
        local_54 = FUN_004b9f94(param_1,0x105,PTR_DAT_00551644,0x2000);
        if (-1 < local_54) {
          puts("Supported countries: country code and long name");
          local_4c = 0;
          while( true ) {
            if (DAT_00557704 == '\0') {
              uVar6 = *(uint *)(puVar1 + 0xc);
            }
            else {
              uVar6 = *(uint *)(puVar1 + 0xc);
              uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                      uVar6 >> 0x18;
            }
            if (uVar6 <= local_4c) break;
            ppuVar3 = FUN_00435e30(puVar1 + local_4c * 4 + 0x10);
            if (ppuVar3 == (undefined **)0x0) {
              param2 = "";
            }
            else {
              param2 = *ppuVar3;
            }
            printf("%s\t%s\n",puVar1 + local_4c * 4 + 0x10,param2);
            local_4c = local_4c + 1;
          }
          local_54 = 0;
        }
      }
      else {
        memset(&local_20,0,0xc);
        local_1c = 0xffffffff;
        if (local_58 == 1) {
          ppuVar3 = FUN_00435d94((char *)*puVar2);
          if (ppuVar3 == (undefined **)0x0) {
            local_54 = FUN_00435f30((char *)*puVar2,&local_20,(long *)&local_1c);
          }
          else {
            local_20 = *(undefined4 *)ppuVar3[1];
            local_54 = 0;
          }
          if (local_54 != 0) {
            fprintf(stderr,
                    "Argument \"%s\" could not be parsed as a country name, country code, or country code and regulatory revision.\n"
                    ,(char *)*puVar2);
            return -0x2c;
          }
          if (local_1c != 0xffffffff) {
            local_18 = local_20;
          }
        }
        else {
          iVar4 = FUN_00435f30((char *)*puVar2,&local_18,(long *)&local_1c);
          if (iVar4 != 0) {
            fprintf(stderr,
                    "Argument 1 \"%s\" could not be parsed as a country code, or country code and regulatory revision.\n"
                    ,(char *)*puVar2);
            return -0x2c;
          }
          ppuVar3 = FUN_00435d94(*(char **)(param_3 + 8));
          if (ppuVar3 == (undefined **)0x0) {
            local_54 = FUN_00435f30(*(char **)(param_3 + 8),&local_20,local_10);
            if (local_10[0] != -1) {
              fprintf(stderr,
                      "Argument \"%s\" had a revision. Arg 2 must be a country name or country code without a revision\n"
                      ,*(char **)(param_3 + 8));
              return -0x2c;
            }
          }
          else {
            local_20 = *(undefined4 *)ppuVar3[1];
            local_54 = 0;
          }
          if (local_54 != 0) {
            fprintf(stderr,
                    "Argument 2 \"%s\" could not be parsed as a country name or country code\n",
                    *(char **)(param_3 + 8));
            return -0x2c;
          }
        }
        if ((local_1c == 0xffffffff) && ((char)local_18 == '\0')) {
          local_54 = FUN_004ba2e4(param_1,"country",&local_20,4);
        }
        else {
          if (DAT_00557704 != '\0') {
            local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                       local_1c >> 0x18;
          }
          local_54 = FUN_004ba2e4(param_1,"country",&local_20,0xc);
        }
        if (local_54 == 0) {
          local_54 = 0;
        }
        else {
          FUN_004ba35c(param_1,"bcmerror",&local_14);
          if (local_14 == 0xffffffe9) {
            if ((local_1c == 0xffffffff) && ((char)local_18 == '\0')) {
              local_54 = FUN_004ba050(param_1,0x54,(char *)&local_20,4);
            }
            else {
              fwrite("Driver does not support full country spec interface, only a country name or code may be sepcified\n"
                     ,1,0x62,stderr);
            }
          }
        }
      }
    }
  }
  else {
    fprintf(stderr,"Too many arguments (%d) for command %s\n",local_58,(char *)*param_2);
    local_54 = -0x2c;
  }
  return local_54;
}



int FUN_00436bbc(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  void *__s;
  long lVar4;
  undefined4 *local_res8;
  int local_38;
  int local_34;
  byte *local_1c;
  char *local_18 [3];
  
  local_res8 = (undefined4 *)(param_3 + 4);
  for (local_38 = 0; local_res8[local_38] != 0; local_38 = local_38 + 1) {
  }
  if (local_38 == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_1c);
    if (-1 < iVar2) {
      printf("ie tag:0x%x ie len:0x%x ie data:",(uint)*local_1c,(uint)local_1c[1]);
      for (local_34 = 0; local_34 < (int)(uint)local_1c[1]; local_34 = local_34 + 1) {
        printf("0x%x ",(uint)local_1c[local_34 + 2]);
      }
      putchar(10);
    }
  }
  else {
    local_18[0] = (char *)0x0;
    uVar3 = strtol(*(char **)(param_3 + 8),(char **)0x0,0);
    bVar1 = (uVar3 & 1) != 0;
    if (bVar1) {
      fprintf(stderr,"country ie len is odd(%d), padding by 1 octet\n",(int)(char)uVar3);
    }
    __s = malloc(bVar1 + local_38);
    if (__s == (void *)0x0) {
      fprintf(stderr,"Error allocating %d bytes country ie\n",local_38);
      iVar2 = -0x1b;
    }
    else {
      memset(__s,0,bVar1 + local_38);
      for (local_34 = 0; local_34 < local_38; local_34 = local_34 + 1) {
        lVar4 = strtol((char *)*local_res8,local_18,0);
        *(char *)((int)__s + local_34) = (char)lVar4;
        if (*local_18[0] != '\0') {
          free(__s);
          return -0x2c;
        }
        local_res8 = local_res8 + 1;
      }
      if (bVar1) {
        *(char *)((int)__s + 1) = *(char *)((int)__s + 1) + '\x01';
        *(undefined1 *)((int)__s + (char)uVar3 + 2) = 0;
      }
      iVar2 = FUN_00445444(param_1,(char *)*param_2,__s,bVar1 + local_38);
      free(__s);
    }
  }
  return iVar2;
}



int FUN_00436f1c(int *param_1,undefined4 *param_2)

{
  ushort uVar1;
  int iVar2;
  undefined **ppuVar3;
  char *param4;
  int local_50;
  ushort *local_2c;
  char *local_28 [4];
  char *local_18;
  char *local_14;
  char *local_10;
  
  local_28[0] = "2G";
  local_28[1] = "5G";
  local_28[2] = "accode";
  local_28[3] = "hdcode";
  local_18 = "11dassoccode";
  local_14 = "11dscancode";
  local_10 = "defccode";
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_2c);
  if (-1 < iVar2) {
    if (DAT_00557704 == '\0') {
      uVar1 = *local_2c;
    }
    else {
      uVar1 = *local_2c << 8 | *local_2c >> 8;
    }
    if (uVar1 == 1) {
      if (DAT_00557704 == '\0') {
        uVar1 = local_2c[1];
      }
      else {
        uVar1 = local_2c[1] << 8 | local_2c[1] >> 8;
      }
      if (uVar1 < 0xb) {
        local_50 = 0;
        while( true ) {
          if (DAT_00557704 == '\0') {
            uVar1 = local_2c[1];
          }
          else {
            uVar1 = local_2c[1] << 8 | local_2c[1] >> 8;
          }
          if ((int)(uint)uVar1 <= local_50) break;
          ppuVar3 = FUN_00435e30((char *)(local_2c + local_50 * 4 + 4));
          if (ppuVar3 == (undefined **)0x0) {
            param4 = "";
          }
          else {
            param4 = *ppuVar3;
          }
          printf("%s\t%s:%s\t%s\n",local_28[(byte)local_2c[local_50 * 4 + 3]],
                 local_28[*(byte *)((int)local_2c + local_50 * 8 + 7) + 2],
                 (char *)(local_2c + local_50 * 4 + 4),param4);
          local_50 = local_50 + 1;
        }
        iVar2 = 0;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar1 = local_2c[1];
        }
        else {
          uVar1 = local_2c[1] << 8 | local_2c[1] >> 8;
        }
        printf("\tBigger than expected country codes. Expected:%d; got %d\n",10,(uint)uVar1);
        iVar2 = -1;
      }
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar1 = *local_2c;
      }
      else {
        uVar1 = *local_2c << 8 | *local_2c >> 8;
      }
      printf("\tIncorrect version of ccode_info IOVAR expected %d; got %d\n",1,(uint)uVar1);
      iVar2 = -1;
    }
  }
  return iVar2;
}



int FUN_004372f8(int *param_1,int param_2,int param_3)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  char *pcVar4;
  int *local_res8;
  uint *local_108;
  ushort *local_104;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  ushort local_3c;
  ushort local_3a;
  ushort local_38;
  ushort local_36;
  ushort local_34;
  ushort local_32;
  ushort local_30;
  ushort local_2e;
  ushort local_2c;
  ushort local_2a;
  ushort local_28;
  ushort local_26;
  ushort local_24;
  ushort local_22;
  ushort local_20;
  ushort local_1e;
  ushort local_1c;
  ushort local_1a;
  ushort local_18;
  ushort local_16;
  char *local_14 [2];
  
  memset(&local_4c,0,0x38);
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_4c,0x38);
    if (iVar1 < 0) {
      puts("Cannot get ACI args");
      if (DAT_00557704 != '\0') {
        local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                   local_4c >> 0x18;
      }
      printf("aci_args.enter_aci_thresh = %d\n",local_4c);
      return iVar1;
    }
    if (DAT_00557704 != '\0') {
      local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                 local_4c >> 0x18;
      local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                 local_48 >> 0x18;
      local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                 local_44 >> 0x18;
      local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                 local_40 >> 0x18;
      local_3c = local_3c << 8 | local_3c >> 8;
      local_3a = local_3a << 8 | local_3a >> 8;
      local_38 = local_38 << 8 | local_38 >> 8;
      local_36 = local_36 << 8 | local_36 >> 8;
      local_34 = local_34 << 8 | local_34 >> 8;
      local_32 = local_32 << 8 | local_32 >> 8;
      local_30 = local_30 << 8 | local_30 >> 8;
      local_2e = local_2e << 8 | local_2e >> 8;
      local_2c = local_2c << 8 | local_2c >> 8;
      local_2a = local_2a << 8 | local_2a >> 8;
      local_28 = local_28 << 8 | local_28 >> 8;
      local_26 = local_26 << 8 | local_26 >> 8;
      local_24 = local_24 << 8 | local_24 >> 8;
      local_22 = local_22 << 8 | local_22 >> 8;
      local_20 = local_20 << 8 | local_20 >> 8;
      local_1e = local_1e << 8 | local_1e >> 8;
      local_1c = local_1c << 8 | local_1c >> 8;
      local_1a = local_1a << 8 | local_1a >> 8;
      local_18 = local_18 << 8 | local_18 >> 8;
    }
    printf("Glitch count to enter ACI scan mode: %d\n",local_4c);
    printf("Glitch count to exit ACI mode: %d\n",local_48);
    printf("Usecs to spin between rssi samples : %d\n",local_44);
    printf("Interval (in seconds) for ACI scanning in presence of high glitch count: %d\n\n",
           local_40);
    printf("(NPHY) Glitch count to enter ACI scan mode: %d\n",local_4c);
    printf("(NPHY) ADC power to enter ACI Mitigation mode: %d\n",(uint)local_3c);
    printf("(NPHY) ADC power to exit ACI Mitigation mode: %d\n",(uint)local_3a);
    printf("(NPHY) Number of tries per channel to compute power: %d\n",(uint)local_38);
    printf("(NPHY) Number of samples to use to compute power on a channel: %d\n",(uint)local_36);
    printf("(NPHY) # Undetects to wait before coming out of ACI Mitigation mode: %d\n",
           (uint)local_34);
    printf("(NPHY) bphy energy threshold for low aci pwr: %d\n",(uint)local_32);
    printf("(NPHY) bphy energy threshold for medium aci pwr: %d\n",(uint)local_30);
    printf("(NPHY) bphy energy threshold for high aci pwr: %d\n",(uint)local_2e);
    printf("(NPHY) nphy_noise_noassoc_glitch_th_up: %d\n",(uint)local_2c);
    printf("(NPHY) nphy_noise_noassoc_glitch_th_dn: %d\n",(uint)local_2a);
    printf("(NPHY) nphy_noise_assoc_glitch_th_up: %d\n",(uint)local_28);
    printf("(NPHY) nphy_noise_assoc_glitch_th_dn: %d\n",(uint)local_26);
    printf("(NPHY) nphy_noise_assoc_aci_glitch_th_up: %d\n",(uint)local_24);
    printf("(NPHY) nphy_noise_assoc_aci_glitch_th_dn: %d\n",(uint)local_22);
    printf("(NPHY) nphy_noise_assoc_enter_th: %d\n",(uint)local_20);
    printf("(NPHY) nphy_noise_noassoc_enter_th: %d\n",(uint)local_1e);
    printf("(NPHY) nphy_noise_assoc_rx_glitch_badplcp_enter_th: %d\n",(uint)local_1c);
    printf("(NPHY) nphy_noise_noassoc_crsidx_incr: %d\n",(uint)local_1a);
    printf("(NPHY) nphy_noise_assoc_crsidx_incr: %d\n",(uint)local_18);
    printf("(NPHY) nphy_noise_crsidx_decr: %d\n",(uint)local_16);
  }
  else {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_4c,0x38);
    if (iVar1 < 0) {
      puts("Cannot get ACI args for setting");
      return iVar1;
    }
    if (DAT_00557704 != '\0') {
      local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                 local_4c >> 0x18;
      local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                 local_48 >> 0x18;
      local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                 local_44 >> 0x18;
      local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                 local_40 >> 0x18;
      local_3c = local_3c << 8 | local_3c >> 8;
      local_3a = local_3a << 8 | local_3a >> 8;
      local_38 = local_38 << 8 | local_38 >> 8;
      local_36 = local_36 << 8 | local_36 >> 8;
      local_34 = local_34 << 8 | local_34 >> 8;
      local_32 = local_32 << 8 | local_32 >> 8;
      local_30 = local_30 << 8 | local_30 >> 8;
      local_2e = local_2e << 8 | local_2e >> 8;
      local_2c = local_2c << 8 | local_2c >> 8;
      local_2a = local_2a << 8 | local_2a >> 8;
      local_28 = local_28 << 8 | local_28 >> 8;
      local_26 = local_26 << 8 | local_26 >> 8;
      local_24 = local_24 << 8 | local_24 >> 8;
      local_22 = local_22 << 8 | local_22 >> 8;
      local_1e = local_1e << 8 | local_1e >> 8;
      local_20 = local_20 << 8 | local_20 >> 8;
      local_1c = local_1c << 8 | local_1c >> 8;
      local_1a = local_1a << 8 | local_1a >> 8;
      local_18 = local_18 << 8 | local_18 >> 8;
    }
    for (; *local_res8 != 0; local_res8 = local_res8 + 2) {
      local_108 = (uint *)0x0;
      local_104 = (ushort *)0x0;
      iVar1 = strncmp((char *)*local_res8,"enter",2);
      if (iVar1 == 0) {
        local_108 = &local_4c;
      }
      iVar1 = strncmp((char *)*local_res8,"exit",2);
      if (iVar1 == 0) {
        local_108 = &local_48;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"spin",sVar2);
      if (iVar1 == 0) {
        local_108 = &local_44;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"glitch",sVar2);
      if (iVar1 == 0) {
        local_108 = &local_40;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"adcpwr_enter",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_3c;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"adcpwr_exit",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_3a;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"repeat",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_38;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"samples",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_36;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"undetect_sz",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_34;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"loaci",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_32;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"mdaci",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_30;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"hiaci",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_2e;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_noassoc_glitch_th_up",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_2c;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_noassoc_glitch_th_dn",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_2a;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_glitch_th_up",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_28;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_glitch_th_dn",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_26;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_aci_glitch_th_up",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_24;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_aci_glitch_th_dn",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_22;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_noassoc_enter_th",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_1e;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_enter_th",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_20;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_rx_glitch_badplcp_enter_th",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_1c;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_assoc_crsidx_incr",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_18;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_noassoc_crsidx_incr",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_1a;
      }
      pcVar4 = (char *)*local_res8;
      sVar2 = strlen((char *)*local_res8);
      iVar1 = strncmp(pcVar4,"nphy_noise_crsidx_decr",sVar2);
      if (iVar1 == 0) {
        local_104 = &local_16;
      }
      if ((local_108 == (uint *)0x0) && (local_104 == (ushort *)0x0)) {
        puts("Bad parameter specification");
        return -2;
      }
      if (local_res8[1] == 0) {
        puts("Need to specify a value");
        return -0x2c;
      }
      uVar3 = strtol((char *)local_res8[1],local_14,0);
      if (*local_14[0] != '\0') {
        return -0x2c;
      }
      if ((int)uVar3 < 0) {
        printf("Invalid value for %s\n",(char *)*local_res8);
        return -2;
      }
      if (local_108 != (uint *)0x0) {
        *local_108 = uVar3;
      }
      if (local_104 != (ushort *)0x0) {
        *local_104 = (ushort)uVar3;
      }
    }
    if (DAT_00557704 != '\0') {
      local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                 local_4c >> 0x18;
      local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                 local_48 >> 0x18;
      local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                 local_44 >> 0x18;
      local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                 local_40 >> 0x18;
      local_3c = local_3c << 8 | local_3c >> 8;
      local_3a = local_3a << 8 | local_3a >> 8;
      local_38 = local_38 << 8 | local_38 >> 8;
      local_36 = local_36 << 8 | local_36 >> 8;
      local_34 = local_34 << 8 | local_34 >> 8;
      local_32 = local_32 << 8 | local_32 >> 8;
      local_30 = local_30 << 8 | local_30 >> 8;
      local_2e = local_2e << 8 | local_2e >> 8;
      local_2c = local_2c << 8 | local_2c >> 8;
      local_2a = local_2a << 8 | local_2a >> 8;
      local_28 = local_28 << 8 | local_28 >> 8;
      local_26 = local_26 << 8 | local_26 >> 8;
      local_24 = local_24 << 8 | local_24 >> 8;
      local_22 = local_22 << 8 | local_22 >> 8;
      local_20 = local_20 << 8 | local_20 >> 8;
      local_1e = local_1e << 8 | local_1e >> 8;
      local_1c = local_1c << 8 | local_1c >> 8;
      local_1a = local_1a << 8 | local_1a >> 8;
      local_18 = local_18 << 8 | local_18 >> 8;
    }
    iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_4c,0x38);
    if (iVar1 < 0) {
      puts("Cannot set ACI args");
      return iVar1;
    }
  }
  return 0;
}



uint FUN_00439558(int *param_1,void *param_2,char *param_3,FILE *param_4)

{
  uint local_20;
  ushort local_1c;
  ushort local_1a;
  
  local_20 = FUN_004ba0cc(param_1,"sample_collect",param_2,0x30,param_3,0x2800);
  if (local_20 == 0) {
    for (local_20 = 0; local_20 < *(ushort *)((int)param_2 + 0x24); local_20 = local_20 + 1) {
      local_1c = (ushort)*(undefined4 *)(param_3 + local_20 * 4) & 0x3fff;
      local_1a = (ushort)((uint)*(undefined4 *)(param_3 + local_20 * 4) >> 0x10) & 0x3fff;
      if (0x1fff < local_1c) {
        local_1c = local_1c + 0xc000;
      }
      if (0x1fff < local_1a) {
        local_1a = local_1a + 0xc000;
      }
      fprintf(param_4,"%d %d\n",(int)(short)local_1c,(int)(short)local_1a);
    }
  }
  return local_20;
}



size_t FUN_00439728(int *param_1,void *param_2,short *param_3,FILE *param_4)

{
  ushort uVar1;
  short *local_res8;
  size_t local_18;
  
  local_18 = FUN_004ba0cc(param_1,"sample_collect",param_2,0x30,(char *)param_3,0x2800);
  local_res8 = param_3;
  if (local_18 == 0) {
    for (; *local_res8 != 0; local_res8 = (short *)((int)local_res8 + (uint)uVar1)) {
      uVar1 = *local_res8 + 2;
      local_18 = fwrite(local_res8,1,(uint)uVar1,param_4);
      if (uVar1 != local_18) {
        fprintf(stderr,"Error writing %d bytes to file, rc %d!\n",(uint)uVar1,local_18);
        return 0xffffffff;
      }
      fprintf(stderr,"Wrote %d bytes\n",(uint)uVar1);
    }
  }
  return local_18;
}



int FUN_0043989c(int *param_1,void *param_2,char *param_3,FILE *param_4)

{
  int iVar1;
  uint local_18;
  
  iVar1 = FUN_004ba0cc(param_1,"sample_collect",param_2,0x30,param_3,0x2800);
  if (iVar1 == 0) {
    for (local_18 = 0; local_18 < *(ushort *)((int)param_2 + 0x24); local_18 = local_18 + 1) {
      fprintf(param_4,"0x%x\n",*(uint *)(param_3 + local_18 * 4));
    }
  }
  return iVar1;
}



int FUN_00439990(int *param_1,void *param_2,undefined2 param_3,char *param_4,FILE *param_5)

{
  ushort uVar1;
  uint param2;
  size_t sVar2;
  int iVar3;
  uint local_58;
  int local_54;
  undefined2 local_18;
  undefined2 local_16;
  undefined2 local_14;
  undefined2 local_12;
  uint local_10;
  
  local_54 = FUN_004ba0cc(param_1,"sample_collect",param_2,0x30,param_4,0x2800);
  if (local_54 == 0) {
    if (*(ushort *)(param_4 + 4) == 1) {
      uVar1 = *(ushort *)(param_4 + 6);
      param2 = *(uint *)(param_4 + 0xc);
      if (param2 == 0xacdc2009) {
        sVar2 = fwrite(param_4 + 0xc,1,(uint)uVar1,param_5);
        if (uVar1 != sVar2) {
          fprintf(stderr,"Failed write file-header to file %d\n",sVar2);
        }
        memset(&local_18,0,0xc);
        local_16 = 0xc;
        local_58 = 0;
        local_18 = param_3;
        do {
          local_14 = 2;
          local_12 = 0x2800;
          local_10 = local_58 & 0xff;
          iVar3 = FUN_004ba0cc(param_1,"sample_data",&local_18,0xc,param_4,0x2800);
          if (iVar3 != 0) {
            fwrite("Error reading back sample collected data\n",1,0x29,stderr);
            return -1;
          }
          uVar1 = *(ushort *)(param_4 + 6);
          local_58 = *(uint *)(param_4 + 8);
          if (*(ushort *)(param_4 + 4) != 2) {
            fprintf(stderr,"Expect SampleData type %d, receive type %d\n",2,
                    (uint)*(ushort *)(param_4 + 4));
            return -1;
          }
          if (uVar1 == 0) {
            fwrite("Done retrieving sample data\n",1,0x1c,stderr);
            return -1;
          }
          sVar2 = fwrite(param_4 + 0xc,1,(uint)uVar1,param_5);
          if (uVar1 != sVar2) {
            fprintf(stderr,"Error writing %d bytes to file, rc %d!\n",(uint)uVar1,sVar2);
            return -1;
          }
          printf("Wrote %d bytes\n",sVar2);
          local_54 = 0;
        } while ((local_58 & 0x100) != 0);
      }
      else {
        fprintf(stderr,"Header sync word mismatch (0x%08x)\n",param2);
        local_54 = -1;
      }
    }
    else {
      fprintf(stderr,"Expect SampleData Header type %d, receive type %d\n",1,
              (uint)*(ushort *)(param_4 + 4));
      local_54 = -1;
    }
  }
  return local_54;
}



size_t FUN_00439eac(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  FILE *param0;
  uint uVar2;
  int iVar3;
  int *piVar4;
  char *pcVar5;
  int *local_res8;
  size_t local_b0;
  short *local_ac;
  char *local_a8;
  FILE *local_a4;
  int local_a0;
  undefined1 local_88 [4];
  int local_84;
  undefined2 local_80;
  undefined2 local_7e;
  undefined1 local_7c;
  undefined2 local_7a;
  undefined2 local_78;
  int local_74;
  int local_70;
  undefined1 local_6c;
  undefined1 local_6b;
  undefined1 local_6a;
  undefined1 local_69;
  undefined1 local_68;
  undefined1 local_67;
  undefined1 local_66;
  undefined1 local_65;
  ushort local_64;
  int local_60;
  int local_5c;
  char acStack_58 [48];
  uint local_28;
  uint local_24;
  
  local_ac = (short *)0x0;
  local_a8 = "sample_collect.dat";
  local_a4 = (FILE *)0x0;
  local_a0 = 1;
  memset(acStack_58,0,0x44);
  local_b0 = FUN_004b9f94(param_1,0x62,acStack_58,0x44);
  if (-1 < (int)local_b0) {
    uVar2 = local_24;
    uVar1 = local_28;
    if (DAT_00557704 != '\0') {
      uVar2 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
              local_24 >> 0x18;
      uVar1 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
              local_28 >> 0x18;
    }
    local_88[0] = 0x3c;
    local_84 = -1;
    local_60 = -1;
    local_7c = 0;
    local_78 = 1;
    local_70 = 10;
    local_74 = 10;
    local_6c = 0;
    local_6b = 0;
    local_6a = 0;
    local_7a = 1000;
    local_69 = 0;
    local_68 = 0;
    local_67 = 0;
    local_66 = 2;
    local_65 = 6;
    if (uVar1 == 0xc) {
      local_66 = 1;
      local_65 = 2;
    }
    local_64 = 0x800;
    local_80 = 2;
    local_7e = 0x30;
    local_b0 = 0xffffffff;
    for (local_res8 = (int *)(param_3 + 4); *local_res8 != 0; local_res8 = local_res8 + 2) {
      pcVar5 = (char *)*local_res8;
      if (local_res8[1] == 0) {
        local_b0 = 0xffffffd4;
        goto LAB_0043aa34;
      }
      iVar3 = strcmp(pcVar5,"-f");
      if (iVar3 == 0) {
        local_a8 = (char *)local_res8[1];
      }
      else {
        iVar3 = strcmp(pcVar5,"-u");
        if (iVar3 == 0) {
          iVar3 = atoi((char *)local_res8[1]);
          local_88[0] = (undefined1)iVar3;
        }
        else {
          iVar3 = strcmp(pcVar5,"-c");
          if (iVar3 == 0) {
            local_84 = atoi((char *)local_res8[1]);
          }
          else {
            iVar3 = strcmp(pcVar5,"-t");
            if (iVar3 == 0) {
              iVar3 = strcmp((char *)local_res8[1],"crs");
              if (iVar3 == 0) {
                local_7c = 1;
              }
              else {
                iVar3 = strcmp((char *)local_res8[1],"crs_deassert");
                if (iVar3 == 0) {
                  local_7c = 2;
                }
                else {
                  iVar3 = strcmp((char *)local_res8[1],"good_fcs");
                  if (iVar3 == 0) {
                    local_7c = 4;
                  }
                  else {
                    iVar3 = strcmp((char *)local_res8[1],"bad_fcs");
                    if (iVar3 == 0) {
                      local_7c = 8;
                    }
                    else {
                      iVar3 = strcmp((char *)local_res8[1],"bad_plcp");
                      if (iVar3 == 0) {
                        local_7c = 0x10;
                      }
                      else {
                        iVar3 = strcmp((char *)local_res8[1],"crs_glitch");
                        if (iVar3 == 0) {
                          local_7c = 0x20;
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              iVar3 = strcmp(pcVar5,"-m");
              if (iVar3 == 0) {
                iVar3 = strcmp((char *)local_res8[1],"gpio");
                if (iVar3 == 0) {
                  if (uVar1 == 7) {
                    local_78 = 4;
                  }
                  else {
                    local_78 = 0xff;
                  }
                }
                else {
                  iVar3 = atoi((char *)local_res8[1]);
                  local_78 = (undefined2)iVar3;
                }
              }
              else {
                iVar3 = strcmp(pcVar5,"-k");
                if (iVar3 == 0) {
                  local_5c = atoi((char *)local_res8[1]);
                }
                else {
                  iVar3 = strcmp(pcVar5,"-s");
                  if (iVar3 == 0) {
                    local_60 = atoi((char *)local_res8[1]);
                  }
                  else {
                    iVar3 = strcmp(pcVar5,"-b");
                    if (iVar3 == 0) {
                      local_74 = atoi((char *)local_res8[1]);
                    }
                    else {
                      iVar3 = strcmp(pcVar5,"-a");
                      if (iVar3 == 0) {
                        local_70 = atoi((char *)local_res8[1]);
                      }
                      else {
                        iVar3 = strcmp(pcVar5,"-g");
                        if (iVar3 == 0) {
                          iVar3 = atoi((char *)local_res8[1]);
                          local_6c = (undefined1)iVar3;
                        }
                        else {
                          iVar3 = strcmp(pcVar5,"-d");
                          if (iVar3 == 0) {
                            iVar3 = atoi((char *)local_res8[1]);
                            local_6b = (undefined1)iVar3;
                          }
                          else {
                            iVar3 = strcmp(pcVar5,"-e");
                            if (iVar3 == 0) {
                              iVar3 = atoi((char *)local_res8[1]);
                              local_6a = (undefined1)iVar3;
                            }
                            else {
                              iVar3 = strcmp(pcVar5,"-i");
                              if (iVar3 == 0) {
                                iVar3 = atoi((char *)local_res8[1]);
                                local_7a = (undefined2)iVar3;
                              }
                              else {
                                iVar3 = strcmp(pcVar5,"--agc");
                                if (iVar3 == 0) {
                                  iVar3 = atoi((char *)local_res8[1]);
                                  local_69 = (undefined1)iVar3;
                                }
                                else {
                                  iVar3 = strcmp(pcVar5,"--filter");
                                  if (iVar3 == 0) {
                                    iVar3 = atoi((char *)local_res8[1]);
                                    local_68 = (undefined1)iVar3;
                                  }
                                  else {
                                    iVar3 = strcmp(pcVar5,"-v");
                                    if (iVar3 == 0) {
                                      local_a0 = atoi((char *)local_res8[1]);
                                    }
                                    else {
                                      iVar3 = strcmp(pcVar5,"-s");
                                      if (iVar3 == 0) {
                                        iVar3 = atoi((char *)local_res8[1]);
                                        local_67 = (undefined1)iVar3;
                                      }
                                      else {
                                        iVar3 = strcmp(pcVar5,"-x");
                                        if (iVar3 == 0) {
                                          iVar3 = atoi((char *)local_res8[1]);
                                          local_66 = (undefined1)iVar3;
                                        }
                                        else {
                                          iVar3 = strcmp(pcVar5,"-y");
                                          if (iVar3 == 0) {
                                            iVar3 = atoi((char *)local_res8[1]);
                                            local_65 = (undefined1)iVar3;
                                          }
                                          else {
                                            iVar3 = strcmp(pcVar5,"-n");
                                            if (iVar3 != 0) {
                                              local_b0 = 0xffffffd4;
                                              goto LAB_0043aa34;
                                            }
                                            iVar3 = atoi((char *)local_res8[1]);
                                            local_64 = (ushort)iVar3;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    local_ac = (short *)malloc(0x2800);
    if (local_ac == (short *)0x0) {
      fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x2800);
      local_b0 = 0xffffffe5;
    }
    else {
      memset(local_ac,0,0x2800);
      local_a4 = fopen(local_a8,"wb");
      param0 = stderr;
      if (local_a4 == (FILE *)0x0) {
        piVar4 = __errno_location();
        pcVar5 = strerror(*piVar4);
        fprintf(param0,"Problem creating file %s: %s\n",local_a8,pcVar5);
        local_b0 = 0xfffffffe;
      }
      else if ((uVar1 == 7) || (uVar1 == 0xb)) {
        local_b0 = FUN_00439990(param_1,local_88,(short)local_a0,(char *)local_ac,local_a4);
      }
      else if (uVar1 == 0xc) {
        if (local_64 < 0x2801) {
          local_b0 = FUN_0043989c(param_1,local_88,(char *)local_ac,local_a4);
        }
        else {
          fprintf(stderr,"Max number of samples supported = %d\n",0x2800);
          local_b0 = 0xffffffff;
        }
      }
      else if (uVar1 == 4) {
        if (uVar2 < 7) {
          local_b0 = FUN_00439728(param_1,local_88,local_ac,local_a4);
        }
        else {
          local_b0 = FUN_00439990(param_1,local_88,(short)local_a0,(char *)local_ac,local_a4);
        }
      }
      else if (uVar1 == 10) {
        if (local_64 < 0xa01) {
          local_b0 = FUN_00439558(param_1,local_88,(char *)local_ac,local_a4);
        }
        else {
          fprintf(stderr,"Max number of samples supported = %d\n",0xa00);
          local_b0 = 0xffffffff;
        }
      }
LAB_0043aa34:
      if (local_ac != (short *)0x0) {
        free(local_ac);
      }
      if (local_a4 != (FILE *)0x0) {
        fclose(local_a4);
      }
    }
  }
  return local_b0;
}



void FUN_0043aa84(int param_1)

{
  char *pcVar1;
  
  puts("Test Init Summary");
  puts("----------------------------------------------------------");
  printf("Toatl Number of test req %d\n\n",(uint)*(ushort *)(param_1 + 0x58));
  printf("Sync timeout %d synch fail action: %d \n",(uint)*(byte *)(param_1 + 0x5b),
         (int)*(char *)(param_1 + 0x5c));
  printf("Sync Mac address : \t");
  pcVar1 = FUN_0041d780(param_1 + 0x5d);
  puts(pcVar1);
  printf("Tx Mac address : \t");
  pcVar1 = FUN_0041d780(param_1 + 99);
  puts(pcVar1);
  printf("Rx Mac address : \t");
  pcVar1 = FUN_0041d780(param_1 + 0x69);
  puts(pcVar1);
  printf("Test in Loop mode : %d \n",(int)*(char *)(param_1 + 0x70));
  puts("\n\n");
  return;
}



void FUN_0043abd4(ushort param_1)

{
  if ((param_1 & 0x100) == 0) {
    if ((param_1 & 0x80) == 0) {
      if (param_1 == 0xb) {
        printf("5.5 ");
      }
      else {
        printf("%d ",(param_1 & 0x7f) / 2);
      }
    }
    else {
      putchar(0x6d);
      printf("%d ",param_1 & 0x7f);
    }
  }
  else {
    putchar(0x76);
    printf("%d ",param_1 & 0x7f);
  }
  return;
}



void FUN_0043acd4(char *param_1,short param_2)

{
  char *pcVar1;
  byte local_10;
  
  printf("Test cnt %d  \n",(int)param_2);
  puts("-----------------------------------------------------------");
  if (*param_1 == '\0') {
    pcVar1 = "TX";
  }
  else {
    pcVar1 = "RX";
  }
  printf("Curr Test : %s\n",pcVar1);
  printf("Wait for sync enabled %d \n",(uint)(byte)param_1[0x50]);
  printf("Channel : %d",(uint)(byte)param_1[1]);
  if (param_1[2] == '\x01') {
    pcVar1 = "20";
  }
  else if (param_1[2] == '\x02') {
    pcVar1 = "40";
  }
  else {
    pcVar1 = "20 in 40";
  }
  printf("\t Bandwidth : %s ",pcVar1);
  printf("\t Control Band : %c \n",param_1[3]);
  printf("Rates : ");
  for (local_10 = 0; local_10 < (byte)param_1[6]; local_10 = local_10 + 1) {
    FUN_0043abd4(*(ushort *)(param_1 + (uint)local_10 * 2 + 8));
  }
  printf("\nStf mode :  %d \n",(uint)(byte)param_1[4]);
  printf("Txant: %d   rxant: %d \n",(uint)(byte)param_1[0x4a],(uint)(byte)param_1[0x4b]);
  printf("Pkt eng Options :  ifs %d  len: %d num: %d \n",(uint)*(ushort *)(param_1 + 0x44),
         (uint)*(ushort *)(param_1 + 0x48),(uint)*(ushort *)(param_1 + 0x46));
  printf("Tx power sweep options :\nPower control %d \nstart pwr: %d  delta: %d end pwr : %d \n",
         (int)param_1[0x4c],(int)param_1[0x4d],(int)param_1[0x4e],(int)param_1[0x4f]);
  return;
}



undefined4 FUN_0043af48(undefined1 param_1,byte *param_2)

{
  undefined4 local_10;
  
  local_10 = 0;
  switch(param_1) {
  case 0:
  case 4:
    if (((char)*param_2 < -1) || ('\x01' < (char)*param_2)) {
      local_10 = 0xffffffff;
    }
    break;
  case 1:
    if ((*param_2 != 0x6c) && (*param_2 != 0x75)) {
      local_10 = 0xffffffff;
    }
    break;
  case 2:
  case 3:
    if (3 < *param_2) {
      local_10 = 0xffffffff;
    }
  }
  return local_10;
}



undefined4 FUN_0043b074(char *param_1,int param_2)

{
  long lVar1;
  undefined4 local_10;
  char *local_c;
  
  local_c = (char *)0x0;
  local_10 = 0;
  lVar1 = strtol(param_1,&local_c,10);
  *(char *)(param_2 + 0x4d) = (char)lVar1;
  if (*local_c == ':') {
    local_c = local_c + 1;
    lVar1 = strtol(local_c,&local_c,10);
    *(char *)(param_2 + 0x4e) = (char)lVar1;
    if (*local_c == ':') {
      local_c = local_c + 1;
      lVar1 = strtol(local_c,&local_c,10);
      *(char *)(param_2 + 0x4f) = (char)lVar1;
      if (((*local_c != '\0') && (*local_c != '\n')) && (*local_c != ' ')) {
        local_10 = 0xffffffff;
      }
    }
    else {
      local_10 = 0xffffffff;
    }
  }
  else {
    local_10 = 0xffffffff;
  }
  return local_10;
}



undefined4 FUN_0043b1d4(int param_1,char *param_2,undefined2 param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  long lVar2;
  undefined4 local_10;
  char *local_c;
  
  local_10 = 0;
  local_c = (char *)0x0;
  switch(param_3) {
  default:
    break;
  case 1:
    lVar2 = strtol(param_2,&local_c,10);
    *(char *)(param_1 + 0x20d3) = (char)lVar2;
    if (*local_c != '\0') {
      local_10 = 0xffffffff;
    }
    break;
  case 2:
    lVar2 = strtol(param_2,&local_c,10);
    *(char *)(param_1 + 0x20d4) = (char)lVar2;
    if (*local_c == '\0') {
      local_10 = FUN_0043af48(0,(byte *)(param_1 + 0x20d4));
    }
    else {
      local_10 = 0xffffffff;
    }
    break;
  case 3:
    bVar1 = FUN_0041d6ac(param_2,(void *)(param_1 + 0x20d5));
    if (CONCAT31(extraout_var,bVar1) == 0) {
      local_10 = 0xffffffff;
    }
    break;
  case 4:
    bVar1 = FUN_0041d6ac(param_2,(void *)(param_1 + 0x20db));
    if (CONCAT31(extraout_var_00,bVar1) == 0) {
      local_10 = 0xffffffff;
    }
    break;
  case 5:
    bVar1 = FUN_0041d6ac(param_2,(void *)(param_1 + 0x20e1));
    if (CONCAT31(extraout_var_01,bVar1) == 0) {
      local_10 = 0xffffffff;
    }
    break;
  case 6:
    lVar2 = strtol(param_2,&local_c,10);
    *(char *)(param_1 + 0x20e7) = (char)lVar2;
    if (((*local_c != '\0') && (*local_c != '\n')) && (*local_c != ' ')) {
      local_10 = 0xffffffff;
    }
  }
  return local_10;
}



undefined4 FUN_0043b42c(char *param_1,byte *param_2,ushort param_3,char *param_4)

{
  size_t sVar1;
  int iVar2;
  long lVar3;
  undefined4 local_18;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  local_18 = 0;
  if ((*param_1 == '\x01') && (param_3 - 0xb < 2)) {
    local_18 = 0;
  }
  else {
    switch(param_3) {
    case 0:
      iVar2 = strncmp((char *)param_2,"ota_tx",6);
      if (iVar2 == 0) {
        *param_1 = '\0';
      }
      else {
        iVar2 = strncmp((char *)param_2,"ota_rx",6);
        if (iVar2 == 0) {
          *param_1 = '\x01';
        }
        else {
          local_18 = 0xffffffff;
        }
      }
      break;
    case 1:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[1] = (char)lVar3;
      if (*local_10[0] != '\0') {
        local_18 = 0xffffffff;
      }
      break;
    case 2:
      iVar2 = strncmp((char *)param_2,"20/40",5);
      if (iVar2 == 0) {
        param_1[2] = '\x01';
      }
      else {
        iVar2 = strncmp((char *)param_2,"20",2);
        if (iVar2 == 0) {
          param_1[2] = '\x01';
        }
        else {
          iVar2 = strncmp((char *)param_2,"40",2);
          if (iVar2 == 0) {
            param_1[2] = '\x02';
          }
          else {
            iVar2 = strncmp((char *)param_2,"80",2);
            if (iVar2 == 0) {
              param_1[2] = '\x03';
            }
            else {
              local_18 = 0xffffffff;
            }
          }
        }
      }
      break;
    case 3:
      param_1[3] = *param_2;
      local_18 = FUN_0043af48(1,param_2);
      break;
    case 4:
      sVar1 = strlen((char *)param_2);
      if ((ushort)sVar1 < 0x65) {
        strncpy(param_4,(char *)param_2,sVar1 & 0xffff);
      }
      else {
        local_18 = 0xffffffff;
      }
      break;
    case 5:
      iVar2 = strncmp((char *)param_2,"siso",4);
      if (iVar2 == 0) {
        param_1[4] = '\0';
      }
      else {
        iVar2 = strncmp((char *)param_2,"cdd",3);
        if (iVar2 == 0) {
          param_1[4] = '\x01';
        }
        else {
          iVar2 = strncmp((char *)param_2,"stbc",4);
          if (iVar2 == 0) {
            param_1[4] = '\x02';
          }
          else {
            iVar2 = strncmp((char *)param_2,"sdm",3);
            if (iVar2 == 0) {
              param_1[4] = '\x03';
            }
            else {
              local_18 = 0xffffffff;
            }
          }
        }
      }
      break;
    case 6:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[0x4a] = (char)lVar3;
      if (*local_10[0] == '\0') {
        local_18 = FUN_0043af48(2,(byte *)(param_1 + 0x4a));
      }
      else {
        local_18 = 0xffffffff;
      }
      break;
    case 7:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[0x4b] = (char)lVar3;
      if (*local_10[0] == '\0') {
        local_18 = FUN_0043af48(3,(byte *)(param_1 + 0x4b));
      }
      else {
        local_18 = 0xffffffff;
      }
      break;
    case 8:
      lVar3 = strtol((char *)param_2,local_10,10);
      *(short *)(param_1 + 0x44) = (short)lVar3;
      if (*local_10[0] != '\0') {
        local_18 = 0xffffffff;
      }
      break;
    case 9:
      lVar3 = strtol((char *)param_2,local_10,10);
      *(short *)(param_1 + 0x48) = (short)lVar3;
      if (*local_10[0] != '\0') {
        local_18 = 0xffffffff;
      }
      break;
    case 10:
      lVar3 = strtol((char *)param_2,local_10,10);
      *(short *)(param_1 + 0x46) = (short)lVar3;
      if (((*local_10[0] != '\0') && (*local_10[0] != '\n')) && (*local_10[0] != ' ')) {
        local_18 = 0xffffffff;
      }
      break;
    case 0xb:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[0x4c] = (char)lVar3;
      if (*local_10[0] == '\0') {
        local_18 = FUN_0043af48(4,(byte *)(param_1 + 0x4c));
      }
      else {
        local_18 = 0xffffffff;
      }
      break;
    case 0xc:
      local_18 = FUN_0043b074((char *)param_2,(int)param_1);
      break;
    case 0xd:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[0x51] = (char)lVar3;
      if (*local_10[0] != '\0') {
        local_18 = 0xffffffff;
      }
      break;
    case 0xe:
      lVar3 = strtol((char *)param_2,local_10,10);
      param_1[0x52] = (char)lVar3;
      if (*local_10[0] != '\0') {
        local_18 = 0xffffffff;
      }
    }
  }
  return local_18;
}



undefined4 FUN_0043baec(char *param_1,char *param_2)

{
  size_t sVar1;
  int iVar2;
  uint uVar3;
  byte local_28;
  char *local_24;
  ushort local_20;
  undefined4 local_1c;
  char local_14 [12];
  
  local_28 = 0;
  local_14[0] = '\0';
  local_14[1] = '\0';
  local_14[2] = '\0';
  local_14[3] = '\0';
  local_14[4] = 0;
  local_1c = 0;
  local_24 = strtok(param_2,",");
  do {
    if (local_24 == (char *)0x0) {
LAB_0043bd24:
      param_1[6] = local_28;
      return local_1c;
    }
    strncpy(local_14," ",4);
    if (*param_1 == '\x01') {
      (param_1 + (uint)local_28 * 2 + 8)[0] = '\0';
      (param_1 + (uint)local_28 * 2 + 8)[1] = '\0';
      local_28 = 1;
      goto LAB_0043bd24;
    }
    if (0x1d < local_28) {
      local_1c = 0xffffffff;
      goto LAB_0043bd24;
    }
    sVar1 = strlen(local_24);
    if (5 < (ushort)sVar1) {
      local_1c = 0xffffffff;
      goto LAB_0043bd24;
    }
    strncpy(local_14,local_24,sVar1 & 0xffff);
    iVar2 = strncmp(local_14,"5.5",3);
    if (iVar2 == 0) {
      local_20 = 0xb;
    }
    else if (local_14[0] == 'm') {
      local_14[0] = 0x20;
      iVar2 = atoi(local_14);
      local_20 = (ushort)iVar2 | 0x80;
    }
    else if (local_14[0] == 'v') {
      local_14[0] = 0x20;
      iVar2 = atoi(local_14);
      local_20 = (ushort)iVar2 | 0x100;
    }
    else {
      uVar3 = atoi(local_14);
      local_20 = (ushort)((uVar3 & 0xffff) << 1);
    }
    *(ushort *)(param_1 + (uint)local_28 * 2 + 8) = local_20;
    local_24 = strtok((char *)0x0,",");
    local_28 = local_28 + 1;
  } while( true );
}



int FUN_0043bd4c(char *param_1,int param_2,ushort *param_3,undefined1 *param_4)

{
  int iVar1;
  byte *local_78;
  ushort local_74;
  int local_70;
  char local_6c [100];
  
  local_6c[0] = '\0';
  local_6c[1] = '\0';
  memset(local_6c + 2,0,0x62);
  local_70 = 0;
  local_78 = (byte *)strtok(param_1," ");
  *(undefined1 *)(param_2 + (uint)*param_3 * 0x54 + 0x4c) = 0xff;
  *(undefined1 *)(param_2 + (uint)*param_3 * 0x54 + 0x4d) = 0xff;
  *(undefined1 *)(param_2 + (uint)*param_3 * 0x54 + 0x4e) = 0xff;
  *(undefined1 *)(param_2 + (uint)*param_3 * 0x54 + 0x4f) = 0xff;
  iVar1 = strncmp((char *)local_78,"test_setup",10);
  if (iVar1 == 0) {
    local_74 = 0;
    while ((local_78 != (byte *)0x0 &&
           (local_70 = FUN_0043b1d4(param_2,(char *)local_78,local_74), local_70 == 0))) {
      local_78 = (byte *)strtok((char *)0x0," ");
      local_74 = local_74 + 1;
    }
  }
  else {
    iVar1 = strncmp((char *)local_78,"ota_tx",6);
    if ((iVar1 == 0) || (iVar1 = strncmp((char *)local_78,"ota_rx",6), iVar1 == 0)) {
      local_74 = 0;
      while (local_78 != (byte *)0x0) {
        iVar1 = FUN_0043b42c((char *)(param_2 + (uint)*param_3 * 0x54),local_78,local_74,local_6c);
        if (iVar1 != 0) {
          return iVar1;
        }
        local_78 = (byte *)strtok((char *)0x0," ");
        local_74 = local_74 + 1;
      }
      local_70 = FUN_0043baec((char *)(param_2 + (uint)*param_3 * 0x54),local_6c);
      if (local_70 == 0) {
        *(undefined1 *)(param_2 + (uint)*param_3 * 0x54 + 0x50) = *param_4;
        *param_4 = 0;
        *param_3 = *param_3 + 1;
      }
    }
    else {
      iVar1 = strncmp((char *)local_78,"ota_sync",8);
      if (iVar1 == 0) {
        *param_4 = 1;
        local_70 = 0;
      }
    }
  }
  return local_70;
}



int FUN_0043c108(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  void *__ptr;
  size_t sVar2;
  char *__src;
  int *local_res8;
  int local_f8;
  byte local_f4;
  undefined4 *local_f0;
  char local_e0 [200];
  ushort local_18;
  undefined1 local_16 [10];
  
  local_e0[0] = '\0';
  local_e0[1] = '\0';
  memset(local_e0 + 2,0,0xc6);
  local_18 = 0;
  local_16[0] = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    local_f8 = -1;
  }
  else {
    iVar1 = strncmp((char *)*local_res8,"start",5);
    if (iVar1 == 0) {
      local_f8 = FUN_0048334c(param_1);
    }
    else {
      iVar1 = strncmp((char *)*local_res8,"stop",4);
      if (iVar1 == 0) {
        __ptr = malloc(0x20e8);
        if (__ptr == (void *)0x0) {
          fprintf(stderr,"Failed to allocate  %d bytes of memory \n",0x20e8);
          local_f8 = -0x1b;
        }
        else {
          if (DAT_0055769c == '\0') {
            puts("calling ota_stream stop when it\'s already out of batching mode");
            local_f8 = -1;
          }
          else {
            DAT_0055769c = '\0';
            local_f0 = DAT_00557694;
            if (DAT_00557694 == (undefined4 *)0x0) {
              puts("no command batched");
              local_f8 = 0;
            }
            else {
              local_18 = 0;
              while ((local_f8 = 0, local_f0 != (undefined4 *)0x0 && (local_18 != 100))) {
                iVar1 = FUN_0043bd4c((char *)local_f0[3],(int)__ptr,&local_18,local_16);
                if (iVar1 != 0) {
                  puts("Error Parsing the test command ");
                  local_f8 = -2;
                  goto LAB_0043c40c;
                }
                local_f0 = (undefined4 *)*local_f0;
              }
              *(ushort *)((int)__ptr + 0x20d0) = local_18;
              for (local_f4 = 0; local_f4 < 8; local_f4 = local_f4 + 1) {
                local_f8 = FUN_00445444(param_1,"ota_loadtest",
                                        (void *)((int)__ptr + (uint)local_f4 * 0x4b0),0x4b0);
                if (local_f8 < 0) {
                  fprintf(stderr,"host to dongle download failed to pass  %dbytes in stage %d \n",
                          0x4b0,(uint)local_f4);
                }
              }
            }
          }
LAB_0043c40c:
          FUN_004b9c5c();
          free(__ptr);
        }
      }
      else {
        for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
          __src = (char *)*local_res8;
          sVar2 = strlen((char *)*local_res8);
          strncat(local_e0,__src,sVar2);
          sVar2 = strlen(local_e0);
          local_e0[sVar2] = ' ';
          local_e0[sVar2 + 1] = '\0';
        }
        sVar2 = strlen(local_e0);
        local_f8 = FUN_004b9d04(0x107,local_e0,sVar2);
      }
    }
  }
  return local_f8;
}



int FUN_0043c4f8(int *param_1,undefined4 *param_2,int param_3)

{
  FILE *param0;
  void *__ptr;
  FILE *__stream;
  int *piVar1;
  char *param3;
  int iVar2;
  int local_1c0;
  char *local_1bc;
  byte local_1b8;
  char local_1a4 [200];
  char local_dc [200];
  ushort local_14;
  char local_12 [6];
  
  local_1c0 = -1;
  local_1bc = "ota_test.txt";
  local_1a4[0] = '\0';
  local_1a4[1] = '\0';
  memset(local_1a4 + 2,0,0xc6);
  local_dc[0] = '\0';
  local_dc[1] = '\0';
  memset(local_dc + 2,0,0xc6);
  local_14 = 0;
  local_12[0] = '\0';
  if (*(int *)(param_3 + 4) != 0) {
    local_1bc = *(char **)(param_3 + 4);
  }
  __ptr = malloc(0x20e8);
  if (__ptr == (void *)0x0) {
    fprintf(stderr,"Failed to allocate  %d bytes of memory \n",0x20e8);
    local_1c0 = -0x1b;
  }
  else {
    __stream = fopen(local_1bc,"r");
    param0 = stderr;
    if (__stream == (FILE *)0x0) {
      piVar1 = __errno_location();
      param3 = strerror(*piVar1);
      fprintf(param0,"Problem creating file %s: %s\n",local_1bc,param3);
      free(__ptr);
      local_1c0 = -2;
    }
    else {
      local_14 = 0;
      do {
        fgets(local_1a4,199,__stream);
        iVar2 = feof(__stream);
        if ((iVar2 != 0) || (local_14 == 100)) {
          if (local_12[0] == '\0') {
            *(ushort *)((int)__ptr + 0x20d0) = local_14;
            local_1b8 = 0;
            goto LAB_0043c820;
          }
          local_1c0 = -1;
          puts("Flow File Error : \nFile can not end with ota_sync");
          goto LAB_0043c834;
        }
        strncpy(local_dc,local_1a4,199);
        local_1c0 = FUN_0043bd4c(local_dc,(int)__ptr,&local_14,local_12);
      } while (local_1c0 == 0);
      printf("Flow File Error: \nError Parsing string : %s \n",local_1a4);
      local_1c0 = -2;
LAB_0043c834:
      if (__stream != (FILE *)0x0) {
        fclose(__stream);
      }
      free(__ptr);
    }
  }
  return local_1c0;
LAB_0043c820:
  if (7 < local_1b8) goto LAB_0043c834;
  local_1c0 = FUN_00445444(param_1,(char *)*param_2,(void *)((int)__ptr + (uint)local_1b8 * 0x4b0),
                           0x4b0);
  if (local_1c0 < 0) {
    fprintf(stderr,"host to dongle download failed to pass  %dbytes in stage %d \n",0x4b0,
            (uint)local_1b8);
    goto LAB_0043c834;
  }
  local_1b8 = local_1b8 + 1;
  goto LAB_0043c820;
}



void FUN_0043c878(undefined1 param_1)

{
  switch(param_1) {
  case 0:
    puts("Test successfully finished");
    break;
  case 1:
    puts("Phy cal Failure ");
    break;
  case 2:
    puts("Sync Packet failure ");
    break;
  case 3:
    puts("File download Failure ");
    break;
  case 4:
    puts("No test found in the flow file ");
    break;
  case 5:
    puts("WL Not UP ");
    break;
  case 6:
    puts("Erroneous scheduling of test. Not intended ");
    break;
  default:
    puts("Unknown test state ");
  }
  return;
}



int FUN_0043c990(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  undefined *puVar2;
  int iVar3;
  ushort local_c [2];
  
  puVar2 = PTR_DAT_00551644;
  local_c[0] = 0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,PTR_DAT_00551644,0x2000);
    if (-1 < iVar3) {
      local_c[0] = *(ushort *)puVar2;
      bVar1 = puVar2[0x6f];
      if (bVar1 == 1) {
        local_c[0] = local_c[0] + 1;
        iVar3 = FUN_004ba0cc(param_1,(char *)*param_2,local_c,2,PTR_DAT_00551644,0x2000);
        if (puVar2[0x71] == '\x01') {
          puts("Waiting for sync ");
        }
        else {
          FUN_0043acd4(puVar2 + 4,local_c[0]);
        }
      }
      else {
        if (bVar1 < 2) {
          if (bVar1 == 0) {
            puts("Init state ");
            return iVar3;
          }
        }
        else {
          if (bVar1 == 2) {
            puts("Test completed ");
            return iVar3;
          }
          if (bVar1 == 3) {
            FUN_0043c878(puVar2[2]);
            return iVar3;
          }
        }
        puts("Invalid test Phase ");
      }
    }
  }
  else {
    iVar3 = atoi(*(char **)(param_3 + 4));
    local_c[0] = (ushort)iVar3;
    if (((short)local_c[0] < 1) || (100 < local_c[0])) {
      puts("Error, Out of range ");
      iVar3 = -0x1d;
    }
    else {
      iVar3 = FUN_004ba0cc(param_1,(char *)*param_2,local_c,2,PTR_DAT_00551644,0x2000);
      if (-1 < iVar3) {
        if ((int)(uint)*(ushort *)(puVar2 + 0x58) < (int)(short)local_c[0]) {
          printf("Error : Number of test seq downloaded %d  \n",(uint)*(ushort *)(puVar2 + 0x58));
          iVar3 = -0x1d;
        }
        else {
          FUN_0043aa84((int)puVar2);
          FUN_0043acd4(puVar2 + 4,local_c[0]);
        }
      }
    }
  }
  return iVar3;
}



void FUN_0043ccc4(int *param_1,undefined4 *param_2)

{
  FUN_004ba428(param_1,(char *)*param_2,1);
  return;
}



undefined4 FUN_0043cd14(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  undefined4 local_18;
  byte local_c;
  undefined1 local_b;
  
  local_18 = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    local_18 = 0xffffffd4;
  }
  else {
    iVar1 = atoi(*(char **)(param_3 + 4));
    local_c = (byte)iVar1;
    if (*(char **)(param_3 + 8) != (char *)0x0) {
      uVar2 = atoi(*(char **)(param_3 + 8));
      local_b = (undefined1)uVar2;
      printf("%d %d\n",(uint)local_c,uVar2 & 0xff);
      local_18 = FUN_00445444(param_1,"ampdu_activate_test",&local_c,2);
    }
  }
  return local_18;
}



int FUN_0043ce1c(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  byte local_14;
  undefined1 local_13;
  int local_10 [2];
  
  local_10[0] = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar1 = -0x2c;
  }
  else {
    uVar2 = atoi(*(char **)(param_3 + 4));
    local_14 = (byte)uVar2;
    if (local_14 < 8) {
      if (*(char **)(param_3 + 8) == (char *)0x0) {
        iVar1 = FUN_0044527c(param_1,"ampdu_tid",&local_14,2,local_10);
        iVar1 = -(iVar1 >> 0x1f);
        if (iVar1 == 0) {
          printf("AMPDU for tid %d: %d\n",uVar2 & 0xff,(uint)*(byte *)(local_10[0] + 1));
        }
      }
      else {
        iVar1 = atoi(*(char **)(param_3 + 8));
        local_13 = (undefined1)iVar1;
        iVar1 = FUN_00445444(param_1,"ampdu_tid",&local_14,2);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_0043cf9c(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  char *pcVar1;
  byte bVar2;
  int iVar3;
  char *param2;
  undefined4 *local_res8;
  uint local_30;
  undefined1 auStack_18 [2];
  byte local_16 [2];
  undefined2 local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (param_3[1] == 0) {
    iVar3 = FUN_0044527c(param_1,(char *)*param_2,auStack_18,6,local_10);
    pcVar1 = local_10[0];
    iVar3 = -(iVar3 >> 0x1f);
    if (iVar3 == 0) {
      if (*local_10[0] == -1) {
        param2 = "AUTO";
      }
      else if (*local_10[0] == '\x01') {
        param2 = "ON";
      }
      else {
        param2 = "OFF";
      }
      printf("%s_override: %s\n",(char *)*param_2,param2);
      for (local_30 = 0; (int)local_30 < 8; local_30 = local_30 + 1) {
        printf("tid:%d status:%d\n",local_30,
               (uint)(((int)(uint)*(ushort *)(pcVar1 + 4) >> (local_30 & 0x1f) & 1U) != 0));
      }
    }
  }
  else {
    memset(auStack_18,0,6);
    local_res8 = param_3;
    if (param_3[2] == 0) {
      iVar3 = atoi((char *)param_3[1]);
      if ((char)iVar3 == '\0') {
        local_14 = 0;
      }
      else {
        local_14 = 0xff;
      }
      local_16[0] = 0xff;
      local_16[1] = 0;
    }
    else {
      while ((char *)local_res8[1] != (char *)0x0) {
        iVar3 = atoi((char *)local_res8[1]);
        bVar2 = (byte)iVar3;
        if (7 < bVar2) {
          return -0x2c;
        }
        local_res8 = local_res8 + 2;
        if ((char *)*local_res8 == (char *)0x0) {
          return -0x2c;
        }
        iVar3 = atoi((char *)*local_res8);
        local_16[bVar2 >> 3] = local_16[bVar2 >> 3] | (byte)(1 << (bVar2 & 7));
        if ((char)iVar3 != '\0') {
          *(byte *)((int)&local_14 + (uint)(bVar2 >> 3)) =
               *(byte *)((int)&local_14 + (uint)(bVar2 >> 3)) | (byte)(1 << (bVar2 & 7));
        }
      }
    }
    iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_18,6);
  }
  return iVar3;
}



int FUN_0043d30c(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  byte local_14;
  undefined1 local_13;
  int local_10 [2];
  
  local_10[0] = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar1 = -0x2c;
  }
  else {
    uVar2 = atoi(*(char **)(param_3 + 4));
    local_14 = (byte)uVar2;
    if (local_14 < 8) {
      if (*(char **)(param_3 + 8) == (char *)0x0) {
        iVar1 = FUN_00445198(param_1,"ampdu_retry_limit_tid",&local_14,2,local_10);
        if (-1 < iVar1) {
          printf("AMPDU retry limit for tid %d: %d\n",uVar2 & 0xff,(uint)*(byte *)(local_10[0] + 1))
          ;
        }
      }
      else {
        iVar1 = atoi(*(char **)(param_3 + 8));
        local_13 = (undefined1)iVar1;
        iVar1 = FUN_00445444(param_1,"ampdu_retry_limit_tid",&local_14,2);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_0043d484(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  byte local_14;
  undefined1 local_13;
  int local_10 [2];
  
  local_10[0] = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar1 = -0x2c;
  }
  else {
    uVar2 = atoi(*(char **)(param_3 + 4));
    local_14 = (byte)uVar2;
    if (local_14 < 8) {
      if (*(char **)(param_3 + 8) == (char *)0x0) {
        iVar1 = FUN_00445198(param_1,"ampdu_rr_retry_limit_tid",&local_14,2,local_10);
        if (-1 < iVar1) {
          printf("AMPDU regular rate retry limit for tid %d: %d\n",uVar2 & 0xff,
                 (uint)*(byte *)(local_10[0] + 1));
        }
      }
      else {
        iVar1 = atoi(*(char **)(param_3 + 8));
        local_13 = (undefined1)iVar1;
        iVar1 = FUN_00445444(param_1,"ampdu_rr_retry_limit_tid",&local_14,2);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



undefined4 FUN_0043d5fc(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 uVar2;
  int iVar3;
  int *piVar4;
  undefined3 extraout_var;
  undefined1 auStack_14 [6];
  byte local_e;
  
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    uVar2 = 0xffffffd4;
  }
  else {
    iVar3 = atoi(*(char **)(param_3 + 4));
    local_e = (byte)iVar3;
    if (local_e < 8) {
      piVar4 = (int *)(param_3 + 8);
      if (*piVar4 == 0) {
        puts("error: missing address");
        uVar2 = 0xffffffd4;
      }
      else {
        bVar1 = FUN_0041d6ac((char *)*piVar4,auStack_14);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          printf("error: could not parse MAC address %s\n",(char *)*piVar4);
          uVar2 = 0xffffffd4;
        }
        else {
          uVar2 = FUN_00445444(param_1,"ampdu_send_addba",auStack_14,8);
        }
      }
    }
    else {
      uVar2 = 0xffffffd4;
    }
  }
  return uVar2;
}



undefined4 FUN_0043d740(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 uVar2;
  int iVar3;
  int *piVar4;
  undefined3 extraout_var;
  undefined1 auStack_14 [6];
  byte local_e;
  undefined1 local_d;
  
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    uVar2 = 0xffffffd4;
  }
  else {
    iVar3 = atoi(*(char **)(param_3 + 4));
    local_e = (byte)iVar3;
    if (local_e < 8) {
      piVar4 = (int *)(param_3 + 8);
      if (*piVar4 == 0) {
        puts("error: missing address");
        uVar2 = 0xffffffd4;
      }
      else {
        bVar1 = FUN_0041d6ac((char *)*piVar4,auStack_14);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          printf("error: could not parse MAC address %s\n",(char *)*piVar4);
          uVar2 = 0xffffffd4;
        }
        else {
          if (*(int *)(param_3 + 0xc) == 0) {
            local_d = 1;
          }
          else {
            iVar3 = atoi(*(char **)(param_3 + 0xc));
            local_d = (undefined1)iVar3;
          }
          uVar2 = FUN_00445444(param_1,"ampdu_send_delba",auStack_14,8);
        }
      }
    }
    else {
      uVar2 = 0xffffffd4;
    }
  }
  return uVar2;
}



undefined4 FUN_0043d8cc(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  undefined3 extraout_var;
  undefined1 auStack_14 [6];
  undefined1 local_e;
  undefined4 local_c;
  
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    uVar3 = 0xffffffd4;
  }
  else {
    local_c = 0;
    iVar4 = strcmp("add",(char *)*piVar2);
    if (iVar4 == 0) {
      local_e = 1;
    }
    else {
      iVar4 = strcmp("remove",(char *)*piVar2);
      if (iVar4 != 0) {
        puts("error: invalid mode string");
        return 0xffffffd4;
      }
      local_e = 2;
    }
    piVar2 = (int *)(param_3 + 8);
    if (*piVar2 == 0) {
      puts("error: missing mode value");
      uVar3 = 0xffffffd4;
    }
    else {
      bVar1 = FUN_0041d6ac((char *)*piVar2,auStack_14);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        printf("error: could not parse MAC address %s\n",(char *)*piVar2);
        uVar3 = 0xffffffd4;
      }
      else {
        uVar3 = FUN_00445444(param_1,"dpt_deny",auStack_14,0xc);
      }
    }
  }
  return uVar3;
}



undefined4 FUN_0043da5c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  undefined3 extraout_var;
  undefined1 auStack_14 [6];
  undefined1 local_e;
  undefined4 local_c;
  
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    uVar3 = 0xffffffd4;
  }
  else {
    local_c = 0;
    iVar4 = strcmp("create",(char *)*piVar2);
    if (iVar4 == 0) {
      local_e = 1;
    }
    else {
      iVar4 = strcmp("modify",(char *)*piVar2);
      if (iVar4 == 0) {
        local_e = 2;
      }
      else {
        iVar4 = strcmp("delete",(char *)*piVar2);
        if (iVar4 != 0) {
          puts("error: invalid mode string");
          return 0xffffffd4;
        }
        local_e = 3;
      }
    }
    piVar2 = (int *)(param_3 + 8);
    if (*piVar2 == 0) {
      puts("error: missing ea");
      uVar3 = 0xffffffd4;
    }
    else {
      bVar1 = FUN_0041d6ac((char *)*piVar2,auStack_14);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        printf("error: could not parse MAC address %s\n",(char *)*piVar2);
        uVar3 = 0xffffffd4;
      }
      else {
        uVar3 = FUN_00445444(param_1,"dpt_endpoint",auStack_14,0xc);
      }
    }
  }
  return uVar3;
}



int FUN_0043dc20(char *param_1,int param_2)

{
  int iVar1;
  size_t sVar2;
  ulong uVar3;
  char *local_res0;
  int local_18;
  char acStack_14 [2];
  undefined1 local_12;
  
  iVar1 = strncmp(param_1,"0x",2);
  if ((iVar1 == 0) || (iVar1 = strncmp(param_1,"0X",2), iVar1 == 0)) {
    local_res0 = param_1 + 2;
    sVar2 = strlen(local_res0);
    if ((sVar2 & 1) == 0) {
      local_18 = 0;
      for (; *local_res0 != '\0'; local_res0 = local_res0 + 2) {
        strncpy(acStack_14,local_res0,2);
        local_12 = 0;
        uVar3 = strtoul(acStack_14,(char **)0x0,0x10);
        *(char *)(param_2 + local_18) = (char)uVar3;
        local_18 = local_18 + 1;
      }
    }
    else {
      puts("Data invalid format. Needs to be of even length");
      local_18 = -1;
    }
  }
  else {
    puts("Data invalid format. Needs to start with 0x");
    local_18 = -1;
  }
  return local_18;
}



undefined4 FUN_0043dd74(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  int iVar3;
  undefined4 uVar4;
  int *piVar5;
  undefined3 extraout_var;
  undefined1 auStack_18 [6];
  char local_12;
  ushort local_10;
  
  iVar3 = strcmp((char *)*param_2,"tdls_endpoint");
  if (iVar3 == 0) {
    piVar5 = (int *)(param_3 + 4);
    if (*piVar5 == 0) {
      uVar4 = 0xffffffd4;
    }
    else {
      memset(auStack_18,0,0x10);
      iVar3 = strcmp("create",(char *)*piVar5);
      if (iVar3 == 0) {
        local_12 = '\x01';
      }
      else {
        iVar3 = strcmp("modify",(char *)*piVar5);
        if (iVar3 == 0) {
          local_12 = '\x02';
        }
        else {
          iVar3 = strcmp("delete",(char *)*piVar5);
          if (iVar3 == 0) {
            local_12 = '\x03';
          }
          else {
            iVar3 = strcmp("PM",(char *)*piVar5);
            if (iVar3 == 0) {
              local_12 = '\x04';
            }
            else {
              iVar3 = strcmp("wake",(char *)*piVar5);
              if (iVar3 == 0) {
                local_12 = '\x05';
              }
              else {
                iVar3 = strcmp("disc",(char *)*piVar5);
                if (iVar3 == 0) {
                  local_12 = '\x06';
                }
                else {
                  iVar3 = strcmp("cw",(char *)*piVar5);
                  if (iVar3 == 0) {
                    local_12 = '\a';
                  }
                  else {
                    iVar3 = strcmp("wfd_disc",(char *)*piVar5);
                    if (iVar3 != 0) {
                      puts("error: invalid mode string");
                      return 0xffffffd4;
                    }
                    local_12 = '\b';
                  }
                }
              }
            }
          }
        }
      }
      piVar5 = (int *)(param_3 + 8);
      if (*piVar5 == 0) {
        puts("error: missing ea");
        uVar4 = 0xffffffd4;
      }
      else {
        bVar1 = FUN_0041d6ac((char *)*piVar5,auStack_18);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          printf("error: could not parse MAC address %s\n",(char *)*piVar5);
          uVar4 = 0xffffffd4;
        }
        else {
          if (local_12 == '\a') {
            piVar5 = (int *)(param_3 + 0xc);
            if (*piVar5 == 0) {
              puts("error: missing target channel number");
              return 0xffffffd4;
            }
            iVar3 = atoi((char *)*piVar5);
            if (iVar3 != 0) {
              uVar2 = FUN_004c0638((char *)*piVar5);
              if (uVar2 == 0) {
                printf("error: bad chanspec \"%s\".\n",(char *)*piVar5);
                return 0xffffffd4;
              }
              local_10 = FUN_00402c2c(uVar2);
              if (local_10 == 0xff) {
                return 0xffffffd4;
              }
            }
          }
          uVar4 = FUN_00445444(param_1,(char *)*param_2,auStack_18,0x10);
        }
      }
    }
  }
  else {
    puts("error: invalid command name.");
    uVar4 = 0xffffffd4;
  }
  return uVar4;
}



int FUN_0043e17c(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *__s;
  bool bVar1;
  ushort uVar2;
  int iVar3;
  int *piVar4;
  undefined3 extraout_var;
  int iVar5;
  byte *pbVar6;
  size_t sVar7;
  undefined3 extraout_var_00;
  ulong uVar8;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  char *local_440;
  char local_43c;
  char local_43b;
  ushort local_43a;
  ushort local_438;
  ushort local_436;
  ushort local_434;
  undefined1 auStack_41c [6];
  undefined1 local_416;
  short local_414;
  undefined1 auStack_412 [10];
  byte local_408;
  undefined1 local_407;
  undefined1 local_406;
  undefined4 local_400;
  undefined2 local_3fc;
  undefined4 local_3f6;
  char local_210 [508];
  undefined4 local_14;
  undefined2 local_10;
  undefined4 local_c;
  
  __s = PTR_DAT_00551644;
  iVar3 = strcmp((char *)*param_2,"tdls_wfd_ie");
  if (iVar3 == 0) {
    piVar4 = (int *)(param_3 + 4);
    if (*piVar4 == 0) {
      iVar3 = -0x2c;
    }
    else {
      iVar3 = strcmp((char *)*piVar4,"clr");
      if (iVar3 == 0) {
        memset(auStack_41c,0,0x20a);
        if (*(int *)(param_3 + 8) == 0) {
          iVar3 = -0x2c;
        }
        else {
          iVar3 = strcmp("own",*(char **)(param_3 + 8));
          if (iVar3 == 0) {
            local_416 = 0;
            iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_41c,0x20a);
          }
          else {
            puts("error: invalid mode string");
            iVar3 = -0x2c;
          }
        }
      }
      else {
        iVar3 = strcmp((char *)*piVar4,"get");
        if (iVar3 == 0) {
          memset(__s,0,0x20a);
          piVar4 = (int *)(param_3 + 8);
          if (*piVar4 == 0) {
            iVar3 = -0x2c;
          }
          else {
            iVar3 = strcmp("own",(char *)*piVar4);
            if (iVar3 == 0) {
              __s[6] = 0;
            }
            else {
              bVar1 = FUN_0041d6ac((char *)*piVar4,__s);
              if (CONCAT31(extraout_var,bVar1) == 0) {
                puts("error: invalid mode string");
                return -0x2c;
              }
              __s[6] = 1;
            }
            iVar3 = FUN_004ba0cc(param_1,(char *)*param_2,__s,0x20a,PTR_DAT_00551644,0x2000);
            if ((-1 < iVar3) && (*(short *)(__s + 8) != 0)) {
              piVar4 = (int *)(param_3 + 0xc);
              if (*piVar4 == 0) {
                FUN_0041e248((int)(__s + 10),(uint)*(ushort *)(__s + 8));
              }
              else {
                iVar5 = strcmp("ip",(char *)*piVar4);
                if (iVar5 == 0) {
                  local_43c = '\b';
                  local_436 = 5;
                }
                else {
                  iVar5 = strcmp("port",(char *)*piVar4);
                  if (iVar5 != 0) {
                    puts("error: unknown element");
                    return -0x2c;
                  }
                  local_43c = '\0';
                  local_436 = 6;
                }
                uVar2 = *(ushort *)(__s + 8);
                local_43a = 0;
                local_434 = 0;
                while ((6 < (int)((uint)uVar2 - (uint)local_43a) &&
                       (pbVar6 = FUN_004be3d8(__s + 10 + local_43a,(uint)uVar2 - (uint)local_43a,
                                              0xdd), pbVar6 != (byte *)0x0))) {
                  if ((4 < pbVar6[1]) &&
                     ((iVar5 = memcmp(pbVar6 + 2,&DAT_00512b4c,3), iVar5 == 0 && (pbVar6[5] == 10)))
                     ) {
                    memcpy(local_210 + local_434,pbVar6 + 6,pbVar6[1] - 4);
                    local_434 = (pbVar6[1] + local_434) - 4;
                  }
                  local_43a = ((short)pbVar6 - (short)(__s + 10)) + (ushort)pbVar6[1] + 2;
                }
                local_440 = local_210;
                for (local_438 = local_434; 3 < local_438; local_438 = (local_438 - uVar2) - 3) {
                  uVar2 = (ushort)(byte)local_440[1] * 0x100 + (ushort)(byte)local_440[2];
                  if (((local_43c == *local_440) && (uVar2 == local_436)) &&
                     ((int)(uint)uVar2 <= (int)(local_438 - 3))) {
                    if (local_43c == '\0') {
                      printf("%u\n",(uint)(byte)local_440[5] * 0x100 + (uint)(byte)local_440[6]);
                      return iVar3;
                    }
                    if (local_43c != '\b') {
                      return iVar3;
                    }
                    printf("%u.%u.%u.%u\n",(uint)(byte)local_440[4],(uint)(byte)local_440[5],
                           (uint)(byte)local_440[6],(uint)(byte)local_440[7]);
                    return iVar3;
                  }
                  if ((uint)local_438 <= uVar2 + 3) {
                    return iVar3;
                  }
                  local_440 = local_440 + uVar2 + 3;
                }
              }
            }
          }
        }
        else {
          iVar3 = strcmp((char *)*piVar4,"set");
          if (iVar3 == 0) {
            memset(auStack_41c,0,0x20a);
            if (*(int *)(param_3 + 8) == 0) {
              iVar3 = -0x2c;
            }
            else {
              iVar3 = strcmp("own",*(char **)(param_3 + 8));
              if (iVar3 == 0) {
                local_416 = 0;
                piVar4 = (int *)(param_3 + 0xc);
                if (*piVar4 == 0) {
                  puts("error: missing IE string");
                  iVar3 = -0x2c;
                }
                else {
                  sVar7 = strlen((char *)*piVar4);
                  if (sVar7 - 2 < 0x401) {
                    iVar3 = FUN_0043dc20((char *)*piVar4,(int)auStack_412);
                    if (iVar3 < 1) {
                      printf("error: could not parse IE string address %s\n",(char *)*piVar4);
                      iVar3 = -0x2c;
                    }
                    else {
                      local_414 = (short)iVar3;
                      if (*(int *)(param_3 + 0x10) != 0) {
                        if (local_414 != 0x20) {
                          puts(
                              "if one or several set fields are used, the following the IE string must be\nexactly 32 bytes and must have the following order:\n\t6-byte header (0xDD1E506F9A0A)\n\t9-byte subelement 0 (WFD device information)\n\t9-byte subelement 1 (BSSID)\n\t8-byte subelement 8 (IP address)"
                              );
                          return -0x2c;
                        }
                        bVar1 = FUN_0041d840(*(char **)(param_3 + 0x10),(int)&local_c);
                        if (CONCAT31(extraout_var_00,bVar1) == 0) {
                          return -0x2c;
                        }
                        local_3f6 = local_c;
                        if (*(int *)(param_3 + 0x14) != 0) {
                          uVar8 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
                          local_407 = (undefined1)(uVar8 >> 8);
                          local_406 = (undefined1)uVar8;
                          if (*(int *)(param_3 + 0x18) != 0) {
                            uVar8 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
                            if ((uVar8 & 1) == 0) {
                              local_408 = local_408 & 0xfe;
                            }
                            else {
                              local_408 = local_408 | 1;
                            }
                            if (*(int *)(param_3 + 0x1c) != 0) {
                              bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x1c),&local_14);
                              if (CONCAT31(extraout_var_01,bVar1) == 0) {
                                return -0x2c;
                              }
                              local_400 = local_14;
                              local_3fc = local_10;
                            }
                          }
                        }
                      }
                      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_41c,0x20a);
                    }
                  }
                  else {
                    printf("error: IE string too long; max is %u bytes\n",0x200);
                    iVar3 = -2;
                  }
                }
              }
              else {
                puts("error: invalid mode string");
                iVar3 = -0x2c;
              }
            }
          }
          else {
            iVar3 = strcmp((char *)*piVar4,"clr2");
            if (iVar3 == 0) {
              memset(auStack_41c,0,0x20a);
              if (*(int *)(param_3 + 8) == 0) {
                iVar3 = -0x2c;
              }
              else {
                iVar3 = strcmp("own",*(char **)(param_3 + 8));
                if (iVar3 == 0) {
                  local_416 = 2;
                  iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_41c,0x20a);
                }
                else {
                  puts("error: invalid mode string");
                  iVar3 = -0x2c;
                }
              }
            }
            else {
              iVar3 = strcmp((char *)*piVar4,"get2");
              if (iVar3 == 0) {
                memset(__s,0,0x20a);
                piVar4 = (int *)(param_3 + 8);
                if (*piVar4 == 0) {
                  iVar3 = -0x2c;
                }
                else {
                  iVar3 = strcmp("own",(char *)*piVar4);
                  if (iVar3 == 0) {
                    __s[6] = 2;
                  }
                  else {
                    bVar1 = FUN_0041d6ac((char *)*piVar4,__s);
                    if (CONCAT31(extraout_var_02,bVar1) == 0) {
                      puts("error: invalid mode string");
                      return -0x2c;
                    }
                    __s[6] = 3;
                  }
                  iVar3 = FUN_004ba0cc(param_1,(char *)*param_2,__s,0x20a,PTR_DAT_00551644,0x2000);
                  if ((-1 < iVar3) && (*(short *)(__s + 8) != 0)) {
                    piVar4 = (int *)(param_3 + 0xc);
                    if (*piVar4 == 0) {
                      FUN_0041e248((int)(__s + 10),(uint)*(ushort *)(__s + 8));
                    }
                    else {
                      iVar5 = strcmp("alt_mac",(char *)*piVar4);
                      if (iVar5 == 0) {
                        local_43c = '\n';
                      }
                      else {
                        iVar5 = strcmp("port",(char *)*piVar4);
                        if (iVar5 == 0) {
                          local_43c = '\0';
                          local_43b = '\x01';
                        }
                        else {
                          iVar5 = strcmp("PC_bit",(char *)*piVar4);
                          if (iVar5 != 0) {
                            puts("error: unknown element");
                            return -0x2c;
                          }
                          local_43c = '\0';
                          local_43b = '\0';
                        }
                      }
                      uVar2 = *(ushort *)(__s + 8);
                      local_43a = 0;
                      local_434 = 0;
                      while ((6 < (int)((uint)uVar2 - (uint)local_43a) &&
                             (pbVar6 = FUN_004be3d8(__s + 10 + local_43a,
                                                    (uint)uVar2 - (uint)local_43a,0xdd),
                             pbVar6 != (byte *)0x0))) {
                        if ((4 < pbVar6[1]) &&
                           ((iVar5 = memcmp(pbVar6 + 2,&DAT_00512b4c,3), iVar5 == 0 &&
                            (pbVar6[5] == 10)))) {
                          memcpy(local_210 + local_434,pbVar6 + 6,pbVar6[1] - 4);
                          local_434 = (pbVar6[1] + local_434) - 4;
                        }
                        local_43a = ((short)pbVar6 - (short)(__s + 10)) + (ushort)pbVar6[1] + 2;
                      }
                      local_440 = local_210;
                      for (local_438 = local_434; 3 < local_438; local_438 = (local_438 - uVar2) - 3
                          ) {
                        uVar2 = (ushort)(byte)local_440[1] * 0x100 + (ushort)(byte)local_440[2];
                        if (((local_43c == *local_440) && (uVar2 == 6)) &&
                           (5 < (int)(local_438 - 3))) {
                          if (local_43c == '\0') {
                            if (local_43b != '\0') {
                              printf("%u\n",(uint)(byte)local_440[5] * 0x100 +
                                            (uint)(byte)local_440[6]);
                              return iVar3;
                            }
                            printf("%u\n",(uint)((byte)local_440[4] >> 7));
                            return iVar3;
                          }
                          if (local_43c != '\n') {
                            return iVar3;
                          }
                          printf("%02X:%02X:%02X:%02X:%02X:%02X\n",(uint)(byte)local_440[3],
                                 (uint)(byte)local_440[4],(uint)(byte)local_440[5],
                                 (uint)(byte)local_440[6],(uint)(byte)local_440[7],
                                 (uint)(byte)local_440[8]);
                          return iVar3;
                        }
                        if ((uint)local_438 <= uVar2 + 3) {
                          return iVar3;
                        }
                        local_440 = local_440 + uVar2 + 3;
                      }
                    }
                  }
                }
              }
              else {
                iVar3 = strcmp((char *)*piVar4,"set2");
                if (iVar3 == 0) {
                  memset(auStack_41c,0,0x20a);
                  if (*(int *)(param_3 + 8) == 0) {
                    iVar3 = -0x2c;
                  }
                  else {
                    iVar3 = strcmp("own",*(char **)(param_3 + 8));
                    if (iVar3 == 0) {
                      local_416 = 2;
                      piVar4 = (int *)(param_3 + 0xc);
                      if (*piVar4 == 0) {
                        puts("error: missing IE string");
                        iVar3 = -0x2c;
                      }
                      else {
                        sVar7 = strlen((char *)*piVar4);
                        if (sVar7 - 2 < 0x401) {
                          iVar3 = FUN_0043dc20((char *)*piVar4,(int)auStack_412);
                          if (iVar3 < 1) {
                            printf("error: could not parse IE string address %s\n",(char *)*piVar4);
                            iVar3 = -0x2c;
                          }
                          else {
                            local_414 = (short)iVar3;
                            if (*(int *)(param_3 + 0x10) != 0) {
                              if (local_414 != 0x18) {
                                puts(
                                    "if one or several set2 fields are used, the following the IE string must be\nexactly 24 bytes and must have the following order:\n\t6-byte header (0xDD16506F9A0A)\n\t9-byte subelement 0  (WFD device information)\n\t9-byte subelement 10 (alternate MAC address)"
                                    );
                                return -0x2c;
                              }
                              bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x10),&local_14);
                              if (CONCAT31(extraout_var_03,bVar1) == 0) {
                                return -0x2c;
                              }
                              local_400 = local_14;
                              local_3fc = local_10;
                              if (*(int *)(param_3 + 0x14) != 0) {
                                uVar8 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
                                local_407 = (undefined1)(uVar8 >> 8);
                                local_406 = (undefined1)uVar8;
                                if (*(int *)(param_3 + 0x18) != 0) {
                                  uVar8 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
                                  if ((uVar8 & 1) == 0) {
                                    local_408 = local_408 & 0xfe;
                                  }
                                  else {
                                    local_408 = local_408 | 1;
                                  }
                                }
                              }
                            }
                            iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_41c,0x20a);
                          }
                        }
                        else {
                          printf("error: IE string too long; max is %u bytes\n",0x200);
                          iVar3 = -0x2c;
                        }
                      }
                    }
                    else {
                      puts("error: invalid mode string");
                      iVar3 = -0x2c;
                    }
                  }
                }
                else {
                  puts("error: unknown operation");
                  iVar3 = -0x2c;
                }
              }
            }
          }
        }
      }
    }
  }
  else {
    puts("error: invalid command name.");
    iVar3 = -0x2c;
  }
  return iVar3;
}



int FUN_0043f54c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  int iVar3;
  uint *__ptr;
  undefined3 extraout_var;
  size_t sVar4;
  uint uVar5;
  undefined3 extraout_var_00;
  int local_30;
  uint local_14;
  undefined1 local_10;
  undefined1 local_f;
  
  if ((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    iVar3 = -0x2c;
  }
  else {
    for (local_30 = 0; *(int *)(param_3 + local_30 * 4) != 0; local_30 = local_30 + 1) {
    }
    __ptr = (uint *)malloc(0x724);
    if (__ptr == (uint *)0x0) {
      puts("wl_actframe: unable to allocate frame ");
      iVar3 = -0x1b;
    }
    else {
      *__ptr = 0;
      __ptr[1] = 0xffffffff;
      __ptr[6] = (uint)(__ptr + 4);
      bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),&local_14);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        free(__ptr);
        puts(" ERROR: no valid ether addr provided");
        iVar3 = -0x2c;
      }
      else {
        __ptr[4] = local_14;
        *(undefined1 *)(__ptr + 5) = local_10;
        *(undefined1 *)((int)__ptr + 0x15) = local_f;
        __ptr[2] = local_14;
        *(undefined1 *)(__ptr + 3) = local_10;
        *(undefined1 *)((int)__ptr + 0xd) = local_f;
        if (*(int *)(param_3 + 8) != 0) {
          if (DAT_00557704 == '\0') {
            sVar4 = strlen(*(char **)(param_3 + 8));
            uVar2 = (ushort)((sVar4 & 0xffff) / 2);
          }
          else {
            sVar4 = strlen(*(char **)(param_3 + 8));
            uVar2 = (ushort)((ushort)sVar4 << 8 | (ushort)sVar4 >> 8) / 2;
          }
          *(ushort *)((int)__ptr + 0x16) = uVar2;
        }
        if ((3 < local_30) && (*(int *)(param_3 + 0xc) != 0)) {
          if (DAT_00557704 == '\0') {
            uVar5 = atoi(*(char **)(param_3 + 0xc));
          }
          else {
            uVar5 = atoi(*(char **)(param_3 + 0xc));
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          *__ptr = uVar5;
        }
        if ((4 < local_30) && (*(int *)(param_3 + 0x10) != 0)) {
          if (DAT_00557704 == '\0') {
            uVar5 = atoi(*(char **)(param_3 + 0x10));
          }
          else {
            uVar5 = atoi(*(char **)(param_3 + 0x10));
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          __ptr[1] = uVar5;
        }
        if ((5 < local_30) && (*(int *)(param_3 + 0x14) != 0)) {
          bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x14),&local_14);
          if (CONCAT31(extraout_var_00,bVar1) == 0) {
            free(__ptr);
            puts(" ERROR: no valid ether addr provided");
            return -0x2c;
          }
          __ptr[2] = local_14;
          *(undefined1 *)(__ptr + 3) = local_10;
          *(undefined1 *)((int)__ptr + 0xd) = local_f;
        }
        iVar3 = FUN_00459628(*(char **)(param_3 + 8),(undefined1 *)(__ptr + 7),
                             (uint)*(ushort *)((int)__ptr + 0x16));
        if (iVar3 == 0) {
          iVar3 = FUN_00445444(param_1,"actframe",__ptr,0x724);
          free(__ptr);
        }
        else {
          free(__ptr);
          fwrite("Error parsing data arg\n",1,0x17,stderr);
        }
      }
    }
  }
  return iVar3;
}



undefined4 FUN_0043fa5c(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  size_t __n;
  ushort local_4c;
  undefined2 local_4a;
  undefined1 auStack_48 [64];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    __n = strlen((char *)*piVar1);
    if ((__n < 8) || (0x40 < __n)) {
      fprintf(stderr,"passphrase must be between %d and %d characters long\n",8,0x40);
      uVar2 = 0xfffffffe;
    }
    else {
      local_4c = (ushort)__n;
      if (DAT_00557704 == '\0') {
        local_4a = 1;
      }
      else {
        local_4c = local_4c << 8 | local_4c >> 8;
        local_4a = 0x100;
      }
      memcpy(auStack_48,(void *)*piVar1,__n);
      uVar2 = FUN_00445444(param_1,"dpt_pmk",&local_4c,0x44);
    }
  }
  return uVar2;
}



int FUN_0043fc10(int *param_1,undefined4 param_2,int param_3)

{
  char *__s;
  size_t sVar1;
  int iVar2;
  byte local_40;
  undefined1 auStack_3f [51];
  int local_c;
  
  local_c = 0;
  __s = *(char **)(param_3 + 4);
  if (__s == (char *)0x0) {
    iVar2 = FUN_00445198(param_1,"dpt_fname",&local_40,0x31,&local_c);
    iVar2 = -(iVar2 >> 0x1f);
    if (iVar2 == 0) {
      puts((char *)(local_c + 1));
    }
  }
  else {
    sVar1 = strlen(__s);
    local_40 = (byte)sVar1;
    if (local_40 < 0x2f) {
      memcpy(auStack_3f,__s,sVar1 & 0xff);
      auStack_3f[local_40] = 0;
      iVar2 = FUN_00445444(param_1,"dpt_fname",&local_40,0x31);
    }
    else {
      fwrite("Name must be less than 32 characters\n",1,0x25,stderr);
      iVar2 = -2;
    }
  }
  return iVar2;
}



int FUN_0043fd8c(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint local_18;
  
  if (*(int *)(param_3 + 4) == 0) {
    strcpy(PTR_DAT_00551644,(char *)*param_2);
    iVar2 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar2) {
      puts("List of DPT connections:");
      for (local_18 = 0; local_18 < *(uint *)puVar1; local_18 = local_18 + 1) {
        printf("%s: status 0x%x rx %d tx %d rssi %d\n",puVar1 + local_18 * 0x100 + 10,
               (uint)(byte)puVar1[local_18 * 0x100 + 8],*(int *)(puVar1 + local_18 * 0x100 + 0x7c),
               *(int *)(puVar1 + local_18 * 0x100 + 0x74),*(int *)(puVar1 + local_18 * 0x100 + 0x3c)
              );
      }
    }
  }
  else {
    iVar2 = -0x2c;
  }
  return iVar2;
}



undefined4 FUN_0043ff24(int *param_1,undefined4 *param_2,int param_3)

{
  undefined1 *puVar1;
  size_t sVar2;
  int iVar3;
  char *__nptr;
  long lVar4;
  undefined4 uVar5;
  uint uVar6;
  int *local_res8;
  undefined1 auStack_130 [272];
  byte local_20;
  undefined1 *local_1c;
  undefined1 *local_18;
  char *local_14;
  
  local_1c = auStack_130;
  if (*(int *)(param_3 + 4) == 0) {
    return 0xffffffd4;
  }
  local_14 = *(char **)(param_3 + 4);
  local_res8 = (int *)(param_3 + 8);
  local_18 = local_1c;
  sVar2 = strlen(local_14);
  if (sVar2 == 0x11) {
    sVar2 = strlen(local_14);
    iVar3 = strncmp(local_14,"Read_Link_Quality",sVar2);
    puVar1 = local_18;
    if (iVar3 != 0) goto LAB_00440024;
    *local_18 = 3;
    puVar1[1] = 0x14;
LAB_00440d68:
    for (local_20 = 0; (*local_res8 != 0 && (local_20 != 0xff)); local_20 = local_20 + 1) {
      uVar6 = (uint)local_20;
      __nptr = (char *)*local_res8;
      local_res8 = local_res8 + 1;
      lVar4 = strtol(__nptr,(char **)0x0,0);
      local_18[uVar6 + 3] = (char)lVar4;
    }
    local_18[2] = local_20;
    uVar5 = FUN_00445444(param_1,(char *)*param_2,local_18,local_20 + 3);
  }
  else {
LAB_00440024:
    sVar2 = strlen(local_14);
    if (sVar2 == 0x13) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Local_AMP_Info",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 9;
        puVar1[1] = 0x14;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x14) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Local_AMP_ASSOC",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 10;
        puVar1[1] = 0x14;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x16) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Write_Remote_AMP_ASSOC",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0xb;
        puVar1[1] = 0x14;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x14) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Create_Physical_Link",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x35;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1c) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Accept_Physical_Link_Request",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x36;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x18) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Disconnect_Physical_Link",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x37;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x13) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Create_Logical_Link",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x38;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x13) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Accept_Logical_Link",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x39;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x17) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Disconnect_Logical_Link",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x3a;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x13) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Logical_Link_Cancel",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x3b;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x10) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Short_Range_Mode",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x6b;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1e) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Connection_Accept_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x15;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1f) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Write_Connection_Accept_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x16;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1d) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Link_Supervision_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x36;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1e) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Write_Link_Supervision_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x37;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 5) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Reset",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 3;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0xe) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Enhanced_Flush",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x5f;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1e) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Best_Effort_Flush_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x69;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1f) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Write_Best_Effort_Flush_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x6a;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x20) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Logical_Link_Accept_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x61;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x21) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Write_Logical_Link_Accept_Timeout",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x62;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x10) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Buffer_Size",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 5;
        puVar1[1] = 0x10;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x14) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Data_Block_Size",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 10;
        puVar1[1] = 0x10;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x15) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Set_Event_Mask_Page_2",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 99;
        puVar1[1] = 0xc;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x10) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Flow_Spec_Modify",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 0x3c;
        puVar1[1] = 4;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x17) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Local_Version_Info",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 1;
        puVar1[1] = 0x10;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1d) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Local_Supported_Commands",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 2;
        puVar1[1] = 0x10;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1b) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Read_Failed_Contact_Counter",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 1;
        puVar1[1] = 0x14;
        goto LAB_00440d68;
      }
    }
    sVar2 = strlen(local_14);
    if (sVar2 == 0x1c) {
      sVar2 = strlen(local_14);
      iVar3 = strncmp(local_14,"Reset_Failed_Contact_Counter",sVar2);
      puVar1 = local_18;
      if (iVar3 == 0) {
        *local_18 = 2;
        puVar1[1] = 0x14;
        goto LAB_00440d68;
      }
    }
    printf("unsupported HCI command: %s\n",local_14);
    uVar5 = 0xffffffe9;
  }
  return uVar5;
}



undefined4 FUN_00440e34(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  undefined4 uVar2;
  ushort *__ptr;
  uint uVar3;
  char *__nptr;
  long lVar4;
  int *local_res8;
  ushort local_20;
  
  if (*(int *)(param_3 + 4) == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    __ptr = (ushort *)malloc(0x804);
    if (__ptr == (ushort *)0x0) {
      uVar2 = 0xffffffe5;
    }
    else {
      *(undefined1 *)__ptr = 0;
      *(undefined1 *)((int)__ptr + 1) = 0x30;
      uVar1 = *__ptr;
      local_res8 = (int *)(param_3 + 8);
      uVar3 = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
      uVar3 = (uint)uVar1 | uVar3 & 0xffff;
      *(char *)__ptr = (char)uVar3;
      *(char *)((int)__ptr + 1) = (char)(uVar3 >> 8);
      for (local_20 = 0; (*local_res8 != 0 && (local_20 < 0x800)); local_20 = local_20 + 1) {
        __nptr = (char *)*local_res8;
        local_res8 = local_res8 + 1;
        lVar4 = strtol(__nptr,(char **)0x0,0);
        *(char *)((int)__ptr + local_20 + 4) = (char)lVar4;
      }
      *(char *)(__ptr + 1) = (char)local_20;
      *(char *)((int)__ptr + 3) = (char)(local_20 >> 8);
      uVar2 = FUN_00445444(param_1,(char *)*param_2,__ptr,local_20 + 4);
      free(__ptr);
    }
  }
  return uVar2;
}



int FUN_00441044(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  int local_28;
  byte local_24;
  byte *local_10 [2];
  
  local_10[0] = PTR_DAT_00551644;
  if (param_3[1] == 0) {
    iVar2 = FUN_0044527c(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    pbVar1 = local_10[0];
    if (iVar2 == 0) {
      local_24 = *local_10[0];
      for (local_28 = 0; local_28 < 0x40; local_28 = local_28 + 1) {
        uVar3 = local_24 & 0x3f;
        switch(pbVar1[uVar3 + 1]) {
        case 1:
          printf("%2d: HCI Reset\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 2:
          printf("%2d: HCI Read Local AMPInfo\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 3:
          printf("%2d: HCI Read Local AMPASSOC\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 4:
          printf("%2d: HCI Write Remote AMPASSOC\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 5:
          printf("%2d: HCI Create Physical Link\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 6:
          printf("%2d: HCI Accept Physical Link Request\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 7:
          printf("%2d: HCI Disconnect Physical Link\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 8:
          printf("%2d: HCI Create Logical Link\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 9:
          printf("%2d: HCI Accept Logical Link\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 10:
          printf("%2d: HCI Disconnect Logical Link\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 0xb:
          printf("%2d: HCI Logical Link Cancel\n",(uint)pbVar1[uVar3 + 1]);
          break;
        case 0xc:
          printf("%2d: HCI Amp State Change\n",(uint)pbVar1[uVar3 + 1]);
        }
        local_24 = local_24 - 1;
      }
      iVar2 = 0;
    }
  }
  else {
    iVar2 = FUN_004ba428(param_1,(char *)*param_3,0);
  }
  return iVar2;
}



int FUN_004413cc(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  int *local_res8;
  int local_100;
  int local_f0;
  int local_ec;
  int local_e8;
  int local_e4;
  ushort local_e0;
  ushort local_de;
  ushort local_dc;
  ushort local_da;
  int local_d8;
  int local_d4;
  int local_d0;
  int local_cc;
  int local_c8;
  int local_c4;
  int local_c0;
  ushort local_bc;
  ushort local_ba;
  ushort local_b8;
  int local_b4;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  ushort local_a0;
  int local_9c;
  int local_98;
  int local_94;
  int local_90;
  int local_8c;
  ushort local_88;
  char *local_84;
  long local_80 [30];
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_f0,0x6c);
    if (-1 < iVar1) {
      if (local_b4 == 2) {
        printf("version %d npulses %d ncontig %d min_pw %d max_pw %d thresh0 0x%x thresh1 0x%x\n",2,
               local_f0,local_ec,local_e8,local_e4,(uint)local_e0,(uint)local_de);
        printf("blank 0x%x fmdemodcfg 0x%x npulses_lp %d min_pw_lp %d max_pw_lp %d\n",(uint)local_dc
               ,(uint)local_da,local_d8,local_d4,local_d0);
        printf("min_fm_lp %d max_span_lp %d min_deltat %d max_deltat %d\n",local_cc,local_c8,
               local_c4,local_c0);
        printf("autocorr 0x%x st_level_time 0x%x  t2_min %d fra_pulse_err %d\n",(uint)local_bc,
               (uint)local_ba,(uint)local_b8,local_b0);
        printf("npulses_fra %d npulses_stg2 %d npulses_stg3 %d percal_mask 0x%x quant %d\n",local_ac
               ,local_a8,local_a4,(uint)local_a0,local_9c);
        printf("min_burst_intv_lp %d max_burst_intv_lp %d nskip_rst_lp %d max_pw_tol %d feature_mask 0x%x\n"
               ,local_98,local_94,local_90,local_8c,(uint)local_88);
        printf("%d %d %d %d %d 0x%x 0x%x",local_b4,local_f0,local_ec,local_e8,local_e4,
               (uint)local_e0,(uint)local_de);
        printf(" 0x%x 0x%x %d %d %d",(uint)local_dc,(uint)local_da,local_d8,local_d4,local_d0);
        printf(" %d %d %d %d",local_cc,local_c8,local_c4,local_c0);
        printf(" 0x%x 0x%x %d %d",(uint)local_bc,(uint)local_ba,(uint)local_b8,local_b0);
        printf(" %d %d %d 0x%x %d",local_ac,local_a8,local_a4,(uint)local_a0,local_9c);
        printf(" %d %d %d %d 0x%x\n",local_98,local_94,local_90,local_8c,(uint)local_88);
      }
      else {
        printf("\tIncorrect version of RADAR_ARGS struct: expected %d; got %d\n",2,local_b4);
        iVar1 = -1;
      }
    }
  }
  else {
    local_84 = (char *)0x0;
    for (local_100 = 0; local_100 < 0x1e; local_100 = local_100 + 1) {
      if (*local_res8 == 0) {
        return -0x2c;
      }
      lVar2 = strtol((char *)*local_res8,&local_84,0);
      local_80[local_100] = lVar2;
      if (*local_84 != '\0') {
        return -0x2c;
      }
      local_res8 = local_res8 + 1;
    }
    local_e0 = (ushort)local_80[5];
    local_de = (ushort)local_80[6];
    local_dc = (ushort)local_80[7];
    local_da = (ushort)local_80[8];
    local_bc = (ushort)local_80[0x10];
    local_ba = (ushort)local_80[0x11];
    local_b8 = (ushort)local_80[0x12];
    local_a0 = (ushort)local_80[0x17];
    local_88 = (ushort)local_80[0x1d];
    iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_f0,0x6c);
  }
  return iVar1;
}



undefined4 FUN_00441b14(int *param_1,undefined4 *param_2,int param_3)

{
  long lVar1;
  undefined4 uVar2;
  int *local_res8;
  int local_50;
  undefined4 local_40 [7];
  char *local_24;
  undefined2 local_20 [12];
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    uVar2 = 0xffffffff;
  }
  else {
    for (local_50 = 0; local_50 < 0xc; local_50 = local_50 + 1) {
      if (*local_res8 == 0) {
        return 0xffffffd4;
      }
      lVar1 = strtol((char *)*local_res8,&local_24,0);
      local_20[local_50] = (short)lVar1;
      if (*local_24 != '\0') {
        return 0xffffffd4;
      }
      local_res8 = local_res8 + 1;
    }
    local_40[0] = 2;
    uVar2 = FUN_00445444(param_1,(char *)*param_2,local_40,0x1c);
  }
  return uVar2;
}



int FUN_00441d7c(int *param_1,undefined4 *param_2)

{
  ushort uVar1;
  int iVar2;
  uint uVar3;
  char *param1;
  char acStack_40 [20];
  char *local_2c [4];
  char *local_1c;
  char *local_18;
  char *local_14;
  uint *local_10 [2];
  
  local_2c[0] = "IDLE";
  local_2c[1] = "PRE-ISM Channel Availability Check(CAC)";
  local_2c[2] = "In-Service Monitoring(ISM)";
  local_2c[3] = "Channel Switching Announcement(CSA)";
  local_1c = "POST-ISM Channel Availability Check";
  local_18 = "PRE-ISM Ouf Of Channels(OOC)";
  local_14 = "POST-ISM Out Of Channels(OOC)";
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
  if (-1 < iVar2) {
    if (DAT_00557704 == '\0') {
      uVar3 = *local_10[0];
    }
    else {
      uVar3 = *local_10[0];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *local_10[0] = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = local_10[0][1];
    }
    else {
      uVar3 = local_10[0][1];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    local_10[0][1] = uVar3;
    uVar1 = FUN_00402de8((ushort)local_10[0][2]);
    *(ushort *)(local_10[0] + 2) = uVar1;
    if (*local_10[0] < 7) {
      printf("state %s time elapsed %dms radar channel cleared by dfs ",local_2c[*local_10[0]],
             local_10[0][1]);
      if ((short)local_10[0][2] == 0) {
        puts("none");
      }
      else {
        param1 = FUN_004c02bc((ushort)local_10[0][2],acStack_40);
        printf("channel %s (0x%04X)\n",param1,(uint)(ushort)local_10[0][2]);
      }
    }
    else {
      printf("Unknown dfs state %d.\n",*local_10[0]);
      iVar2 = -1;
    }
  }
  return iVar2;
}



int FUN_0044202c(int *param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  char *param1;
  uint local_14 [3];
  
  iVar2 = FUN_004b9f94(param_1,0xf6,(char *)local_14,8);
  if (iVar2 < 0) {
    puts("Unable to get remote endpoint\'s hwaddr");
  }
  else {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)local_14,8);
    if (iVar2 < 0) {
      puts("Unable to get local endpoint\'s WPA role");
    }
    else {
      if (DAT_00557704 == '\0') {
        bVar1 = local_14[0] != 0;
      }
      else {
        bVar1 = (((local_14[0] & 0xff) != 0 || (local_14[0] & 0xff00) != 0) ||
                (local_14[0] & 0xff0000) != 0) || local_14[0] >> 0x18 != 0;
      }
      if (bVar1) {
        param1 = "supplicant";
      }
      else {
        param1 = "authenticator";
      }
      printf("Local endpoing\'s WPA role: %s\n",param1);
      iVar2 = 0;
    }
  }
  return iVar2;
}



int FUN_004421b0(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  int iVar3;
  uint uVar4;
  undefined1 auStack_118 [4];
  undefined1 auStack_114 [252];
  uint local_18;
  uint *local_14;
  char *apcStack_10 [2];
  
  bVar1 = true;
  local_14 = (uint *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_18 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
      local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    memcpy(auStack_118,&local_18,4);
    if (*(int *)(param_3 + 8) != 0) {
      bVar1 = false;
      if (DAT_00557704 == '\0') {
        local_18 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
        local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      memcpy(auStack_114,&local_18,4);
    }
    if (bVar1) {
      iVar3 = FUN_00445198(param_1,(char *)*param_2,auStack_118,0x100,&local_14);
      if (-1 < iVar3) {
        if (DAT_00557704 == '\0') {
          uVar4 = *local_14;
        }
        else {
          uVar4 = *local_14;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        printf("0x%x\n",uVar4);
      }
    }
    else {
      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_118,0x100);
    }
  }
  return iVar3;
}



int FUN_004424c8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  int iVar3;
  uint uVar4;
  undefined1 auStack_118 [4];
  undefined1 auStack_114 [252];
  uint local_18;
  uint *local_14;
  char *apcStack_10 [2];
  
  bVar1 = true;
  local_14 = (uint *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_18 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
      local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    memcpy(auStack_118,&local_18,4);
    if (*(int *)(param_3 + 8) != 0) {
      bVar1 = false;
      if (DAT_00557704 == '\0') {
        local_18 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
        local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      memcpy(auStack_114,&local_18,4);
    }
    if (bVar1) {
      iVar3 = FUN_00445198(param_1,(char *)*param_2,auStack_118,0x100,&local_14);
      if (-1 < iVar3) {
        if (DAT_00557704 == '\0') {
          uVar4 = *local_14;
        }
        else {
          uVar4 = *local_14;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        printf("0x%x\n",uVar4);
      }
    }
    else {
      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_118,0x100);
    }
  }
  return iVar3;
}



int FUN_004427e0(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  ulong uVar3;
  uint uVar4;
  int local_12c;
  uint local_128;
  uint local_124;
  undefined1 auStack_114 [256];
  uint local_14;
  uint *local_10;
  char *pcStack_c;
  
  local_10 = (uint *)0x0;
  local_12c = 0;
  if ((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) {
    puts("Wrong syntax => dev offset [val]");
    iVar2 = -0x2c;
  }
  else {
    bVar1 = *(int *)(param_3 + 0xc) == 0;
    if (bVar1) {
      local_124 = 2;
    }
    else {
      local_124 = 3;
    }
    for (local_128 = 1; local_128 <= local_124; local_128 = local_128 + 1) {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul(*(char **)(param_3 + local_128 * 4),&pcStack_c,0);
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + local_128 * 4),&pcStack_c,0);
        local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      memcpy(auStack_114 + local_12c,&local_14,4);
      local_12c = local_12c + 4;
    }
    if (bVar1) {
      iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_114,0x100,&local_10);
      if (-1 < iVar2) {
        if (DAT_00557704 == '\0') {
          uVar4 = *local_10;
        }
        else {
          uVar4 = *local_10;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        printf("0x%x\n",uVar4);
      }
    }
    else {
      iVar2 = FUN_00445444(param_1,(char *)*param_2,auStack_114,0x100);
    }
  }
  return iVar2;
}



int FUN_00442aac(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  ulong uVar3;
  uint uVar4;
  int local_12c;
  uint local_128;
  uint local_124;
  undefined1 auStack_114 [256];
  uint local_14;
  uint *local_10;
  char *pcStack_c;
  
  bVar1 = true;
  local_10 = (uint *)0x0;
  local_12c = 0;
  if (*(int *)(param_3 + 4) == 0) {
    puts("Wrong syntax => cmd addr [mask val]");
    iVar2 = -0x2c;
  }
  else {
    if (*(int *)(param_3 + 8) == 0) {
      local_124 = 1;
    }
    else {
      if (*(int *)(param_3 + 0xc) == 0) {
        puts("Wrong syntax => cmd addr [mask val]");
        return -0x2c;
      }
      bVar1 = false;
      local_124 = 3;
    }
    for (local_128 = 1; local_128 <= local_124; local_128 = local_128 + 1) {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul(*(char **)(param_3 + local_128 * 4),&pcStack_c,0);
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + local_128 * 4),&pcStack_c,0);
        local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      memcpy(auStack_114 + local_12c,&local_14,4);
      local_12c = local_12c + 4;
    }
    if (bVar1) {
      iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_114,0x100,&local_10);
      if (-1 < iVar2) {
        if (DAT_00557704 == '\0') {
          uVar4 = *local_10;
        }
        else {
          uVar4 = *local_10;
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        printf("0x%x\n",uVar4);
      }
    }
    else {
      iVar2 = FUN_00445444(param_1,(char *)*param_2,auStack_114,0x100);
    }
  }
  return iVar2;
}



undefined4 FUN_00442d94(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 uVar1;
  ulong uVar2;
  int local_128;
  uint local_124;
  uint local_120;
  undefined1 auStack_114 [256];
  uint local_14;
  char *apcStack_10 [2];
  
  local_128 = 0;
  if (*(int *)(param_3 + 4) == 0) {
    puts("Wrong syntax => coma [reset-time] [delay]");
    uVar1 = 0xffffffd4;
  }
  else {
    if (*(int *)(param_3 + 8) == 0) {
      local_120 = 1;
    }
    else if (*(int *)(param_3 + 0xc) == 0) {
      local_120 = 2;
    }
    else {
      local_120 = 3;
    }
    for (local_124 = 1; local_124 <= local_120; local_124 = local_124 + 1) {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul(*(char **)(param_3 + local_124 * 4),apcStack_10,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + local_124 * 4),apcStack_10,0);
        local_14 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      memcpy(auStack_114 + local_128,&local_14,4);
      local_128 = local_128 + 4;
    }
    uVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_114,0x100);
  }
  return uVar1;
}



int FUN_00442f8c(int *param_1,undefined4 *param_2)

{
  int iVar1;
  undefined2 local_a;
  
  iVar1 = FUN_004ba35c(param_1,(char *)*param_2,(uint *)&stack0xfffffff6);
  if (-1 < iVar1) {
    printf("TPC: APs link margin:%d\t STAs link margin:%d\n",(int)(char)((ushort)local_a >> 8),
           (int)(char)local_a);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00443038(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  ulong uVar3;
  ulong uVar4;
  char *local_10;
  uint local_c;
  
  local_c = 0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba35c(param_1,(char *)*param_2,&local_c);
    if (iVar2 == 0) {
      printf("TxPwr:%d Link Margin:%d\n",local_c >> 8 & 0xff,local_c & 0xff);
    }
  }
  else if (*(int *)(param_3 + 8) == 0) {
    iVar2 = -0x2c;
  }
  else {
    uVar3 = strtoul((char *)*piVar1,&local_10,0);
    if (*local_10 == '\0') {
      uVar4 = strtoul(*(char **)(param_3 + 8),&local_10,0);
      if (*local_10 == '\0') {
        local_c = (int)(char)uVar3 << 8 | (int)(char)uVar4;
        iVar2 = FUN_004ba428(param_1,(char *)*param_2,local_c);
      }
      else {
        fprintf(stderr,"%s: %s: error parsing \"%s\" as an integer\n",DAT_00557690,(char *)*param_2,
                *(char **)(param_3 + 8));
        iVar2 = -0x2c;
      }
    }
    else {
      fprintf(stderr,"%s: %s: error parsing \"%s\" as an integer\n",DAT_00557690,(char *)*param_2,
              (char *)*piVar1);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int FUN_00443278(int *param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  char *param1;
  char local_108 [19];
  byte local_f5;
  
  builtin_strncpy(local_108,"wds_wpa_role",0xd);
  iVar1 = FUN_004b9f94(param_1,0xf6,local_108 + 0xd,6);
  if (iVar1 < 0) {
    puts("Unable to get remote endpoint\'s hwaddr");
  }
  else if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),local_108,0x14);
    if (iVar1 < 0) {
      puts("Unable to get local endpoint\'s WPA role");
    }
    else {
      if (local_108[0] == '\0') {
        param1 = "authenticator";
      }
      else {
        param1 = "supplicant";
      }
      printf("Local endpoint\'s WPA role: %s\n",param1);
    }
  }
  else {
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_f5 = (byte)iVar2;
    if ((local_f5 < 2) || (local_f5 == 0xff)) {
      iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),local_108,0x14);
      if (iVar1 < 0) {
        puts("Unable to set local endpoint\'s WPA role");
      }
    }
    else {
      printf("Invalid WPA role %s. %u:authenticator, %u:supplicant, %u:auto\n",
             *(char **)(param_3 + 4),0,1,0xff);
    }
  }
  return iVar1;
}



undefined4 FUN_004434e4(int *param_1,int param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  int *piVar3;
  undefined4 uVar4;
  int iVar5;
  undefined3 extraout_var;
  uint local_14;
  undefined4 local_10;
  undefined1 local_c;
  undefined1 local_b;
  
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    puts("error: missing arguments");
    uVar4 = 0xffffffd4;
  }
  else {
    iVar5 = strcasecmp((char *)*piVar3,"tpc");
    if (iVar5 == 0) {
      local_14 = 1;
    }
    else {
      iVar5 = strcasecmp((char *)*piVar3,"basic");
      if (iVar5 == 0) {
        local_14 = 2;
      }
      else {
        iVar5 = strcasecmp((char *)*piVar3,"cca");
        if (iVar5 == 0) {
          local_14 = 3;
        }
        else {
          iVar5 = strcasecmp((char *)*piVar3,"rpi");
          if (iVar5 != 0) {
            printf("error: unknown measurement type %s\n",(char *)*piVar3);
            return 0xffffffd4;
          }
          local_14 = 4;
        }
      }
    }
    piVar3 = (int *)(param_3 + 8);
    if (*piVar3 == 0) {
      puts("error: missing target address");
      uVar4 = 0xffffffd4;
    }
    else {
      bVar2 = FUN_0041d6ac((char *)*piVar3,&local_10);
      if (CONCAT31(extraout_var,bVar2) == 0) {
        printf("error: could not parse MAC address %s\n",(char *)*piVar3);
        uVar4 = 0xffffffd4;
      }
      else {
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
        }
        memcpy(PTR_DAT_00551644,&local_14,4);
        puVar1 = PTR_DAT_00551644;
        *(undefined4 *)(PTR_DAT_00551644 + 4) = local_10;
        puVar1[8] = local_c;
        puVar1[9] = local_b;
        uVar4 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),PTR_DAT_00551644,10);
      }
    }
  }
  return uVar4;
}



undefined4 FUN_0044379c(int *param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  char acStack_14 [2];
  undefined1 local_12;
  undefined1 local_11;
  ushort local_10;
  ushort local_e;
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("error: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else {
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_12 = (undefined1)iVar2;
    if (*(int *)(param_3 + 8) == 0) {
      puts("error: missing arguments");
      uVar1 = 0xffffffd4;
    }
    else {
      iVar2 = atoi(*(char **)(param_3 + 8));
      local_10 = (ushort)iVar2;
      if (*(int *)(param_3 + 0xc) == 0) {
        puts("error: missing arguments");
        uVar1 = 0xffffffd4;
      }
      else {
        iVar2 = atoi(*(char **)(param_3 + 0xc));
        local_e = (ushort)iVar2;
        local_11 = 0;
        if (DAT_00557704 != '\0') {
          local_10 = local_10 << 8 | local_10 >> 8;
          local_e = local_e << 8 | local_e >> 8;
        }
        uVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),acStack_14,8);
      }
    }
  }
  return uVar1;
}



undefined4 FUN_00443994(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  int *piVar3;
  undefined1 local_14;
  undefined1 local_13;
  ushort local_12;
  undefined1 local_10;
  undefined1 local_f;
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("error: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else {
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_14 = iVar2 != 0;
    if (*(int *)(param_3 + 8) == 0) {
      puts("error: missing count");
      uVar1 = 0xffffffd4;
    }
    else {
      iVar2 = atoi(*(char **)(param_3 + 8));
      local_13 = (undefined1)iVar2;
      piVar3 = (int *)(param_3 + 0xc);
      if (*piVar3 == 0) {
        puts("error: missing channel");
        uVar1 = 0xffffffd4;
      }
      else {
        local_10 = 0;
        local_12 = FUN_004c0638((char *)*piVar3);
        if (local_12 == 0) {
          printf("Error: bad parameters \"%s\"\n",(char *)*piVar3);
          uVar1 = 0xfffffffe;
        }
        else {
          local_12 = FUN_00402c2c(local_12);
          if (local_12 == 0xff) {
            uVar1 = 0xffffffd4;
          }
          else {
            piVar3 = (int *)(param_3 + 0x10);
            if (*piVar3 == 0) {
              local_f = 0;
            }
            else {
              iVar2 = strcmp((char *)*piVar3,"u");
              if (iVar2 != 0) {
                printf("error: invalid frame type: %s\n",(char *)*piVar3);
                return 0xffffffd4;
              }
              local_f = 1;
            }
            uVar1 = FUN_00445444(param_1,(char *)*param_2,&local_14,6);
          }
        }
      }
    }
  }
  return uVar1;
}



int FUN_00443bd4(int *param_1,undefined4 param_2,int *param_3)

{
  bool bVar1;
  int iVar2;
  char *pcVar3;
  undefined3 extraout_var;
  uint uStack_14;
  undefined1 auStack_10 [8];
  
  if (*param_3 == 0) {
    puts("set: missing arguments");
    iVar2 = -0x2c;
  }
  else {
    pcVar3 = (char *)*param_3;
    if (param_3[1] == 0) {
      iVar2 = FUN_004ba35c(param_1,pcVar3,&uStack_14);
      if (iVar2 == 0) {
        pcVar3 = FUN_0041e064((byte *)&uStack_14);
        puts(pcVar3);
        iVar2 = 0;
      }
    }
    else {
      bVar1 = FUN_0041d840((char *)param_3[1],(int)auStack_10);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        iVar2 = -0x2c;
      }
      else {
        iVar2 = FUN_00445444(param_1,pcVar3,auStack_10,4);
      }
    }
  }
  return iVar2;
}



undefined4 FUN_00443d2c(int *param_1,undefined4 param_2,int *param_3)

{
  undefined4 uVar1;
  char *param2;
  long lVar2;
  char *pcVar3;
  int *piVar4;
  uint param1;
  size_t sVar5;
  void *__src;
  char *pcStack_a0;
  char *local_9c;
  uint local_98;
  undefined1 auStack_94 [136];
  
  memset(&local_98,0,0x84);
  if (*param_3 == 0) {
    puts("set: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else {
    param2 = (char *)*param_3;
    if (param_3[1] == 0) {
      puts("set: missing arguments");
      uVar1 = 0xffffffd4;
    }
    else {
      lVar2 = strtol((char *)param_3[1],&pcStack_a0,0);
      if (lVar2 == 0) {
        pcVar3 = "get";
      }
      else {
        pcVar3 = "set";
      }
      printf("%s %s \n",pcVar3,param2);
      if (lVar2 < 2) {
        if (param_3[2] == 0) {
          puts("set: missing arguments");
          uVar1 = 0xffffffd4;
        }
        else {
          piVar4 = param_3 + 3;
          param1 = strtol((char *)param_3[2],&pcStack_a0,0);
          local_98 = param1;
          printf("var = %08x\n",param1);
          if ((param1 == 0) || (1 < (param1 & 0xffff))) {
            puts("set: arguments error");
            uVar1 = 0xffffffd4;
          }
          else {
            if (lVar2 != 0) {
              if (*piVar4 == 0) {
                puts("set: missing arguments");
                return 0xffffffd4;
              }
              sVar5 = strlen((char *)*piVar4);
              if (0x7f < sVar5) {
                puts("set: parameter too long");
                return 0xffffffd4;
              }
              __src = (void *)*piVar4;
              sVar5 = strlen((char *)*piVar4);
              memcpy(auStack_94,__src,sVar5);
              pcVar3 = (char *)*piVar4;
              sVar5 = strlen((char *)*piVar4);
              printf("argv  = %s, %d\n",pcVar3,sVar5);
            }
            if (lVar2 == 0) {
              uVar1 = FUN_0044527c(param_1,param2,&local_98,0x84,&local_9c);
              printf("reply = %s\n",local_9c);
            }
            else {
              uVar1 = FUN_00445444(param_1,param2,&local_98,0x84);
            }
          }
        }
      }
      else {
        puts("set: wrong arguments");
        uVar1 = 0xffffffd4;
      }
    }
  }
  return uVar1;
}



undefined4 FUN_00444098(int *param_1,undefined4 param_2,int *param_3)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  int *piVar4;
  char *param1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined4 uVar5;
  int local_24;
  void *local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  
  memset(&local_1c,0,0x14);
  if (*param_3 == 0) {
    puts("set: missing arguments");
    return 0xffffffd4;
  }
  pcVar3 = (char *)*param_3;
  piVar4 = param_3 + 1;
  bVar1 = *piVar4 != 0;
  if (bVar1) {
    param1 = "set";
  }
  else {
    param1 = "get";
  }
  printf("%s %s \n",param1,pcVar3);
  if (bVar1) {
    if (*piVar4 == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)*piVar4,(int)&local_24);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_1c = local_24;
    if (param_3[2] == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)param_3[2],(int)&local_24);
    if (CONCAT31(extraout_var_00,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_18 = local_24;
    if (param_3[3] == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)param_3[3],(int)&local_24);
    if (CONCAT31(extraout_var_01,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_14 = local_24;
    if (param_3[4] == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)param_3[4],(int)&local_24);
    if (CONCAT31(extraout_var_02,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_10 = local_24;
    if (param_3[5] != 0) {
      local_24 = atoi((char *)param_3[5]);
      local_c = local_24;
    }
  }
  if (bVar1) {
    uVar5 = FUN_00445444(param_1,pcVar3,&local_1c,0x14);
  }
  else {
    uVar5 = FUN_0044527c(param_1,pcVar3,(void *)0x0,0,&local_20);
    memcpy(&local_1c,local_20,0x14);
    puts("get dhcpd_para");
    pcVar3 = FUN_0041e064((byte *)&local_1c);
    printf("host_pa.dhcpd_ip_addr \t= %s\n",pcVar3);
    pcVar3 = FUN_0041e064((byte *)&local_18);
    printf("host_pa.dhcpd_ip_mask \t= %s\n",pcVar3);
    pcVar3 = FUN_0041e064((byte *)&local_14);
    printf("host_pa.dhcpd_ip_start \t= %s\n",pcVar3);
    pcVar3 = FUN_0041e064((byte *)&local_10);
    printf("host_pa.dhcpd_ip_end \t= %s\n",pcVar3);
    printf("host_pa.dhcpd_lease_time= %d\n",local_c);
  }
  return uVar5;
}



undefined4 FUN_004444c4(int *param_1,undefined4 param_2,int *param_3)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  int *piVar4;
  char *param1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined4 uVar5;
  int local_1c;
  void *local_18;
  int local_14;
  int local_10;
  int local_c;
  
  memset(&local_14,0,0xc);
  if (*param_3 == 0) {
    puts("set: missing arguments");
    return 0xffffffd4;
  }
  pcVar3 = (char *)*param_3;
  piVar4 = param_3 + 1;
  bVar1 = *piVar4 != 0;
  if (bVar1) {
    param1 = "set";
  }
  else {
    param1 = "get";
  }
  printf("%s %s \n",param1,pcVar3);
  if (bVar1) {
    if (*piVar4 == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)*piVar4,(int)&local_1c);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_14 = local_1c;
    if (param_3[2] == 0) {
      puts("miss para");
      return 0xffffffd4;
    }
    bVar2 = FUN_0041d840((char *)param_3[2],(int)&local_1c);
    if (CONCAT31(extraout_var_00,bVar2) == 0) {
      return 0xffffffd4;
    }
    local_10 = local_1c;
    if (param_3[3] != 0) {
      local_1c = atoi((char *)param_3[3]);
      local_c = local_1c;
    }
  }
  if (bVar1) {
    uVar5 = FUN_00445444(param_1,pcVar3,&local_14,0xc);
  }
  else {
    uVar5 = FUN_0044527c(param_1,pcVar3,(void *)0x0,0,&local_18);
    memcpy(&local_14,local_18,0xc);
    pcVar3 = FUN_0041e064((byte *)&local_14);
    printf("host_pa.dhcpc_ip_addr \t= %s\n",pcVar3);
    pcVar3 = FUN_0041e064((byte *)&local_10);
    printf("host_pa.dhcpc_ip_serv \t= %s\n",pcVar3);
    printf("host_pa.dhcpc_lease_time= %d\n",local_c);
  }
  return uVar5;
}



undefined4 FUN_004447b0(int *param_1,undefined4 param_2,int *param_3)

{
  undefined4 uVar1;
  char *pcVar2;
  int iVar3;
  char *param1;
  void *local_24;
  byte abStack_20 [4];
  byte abStack_1c [4];
  byte abStack_18 [4];
  byte abStack_14 [4];
  byte abStack_10 [4];
  int local_c;
  
  memset(abStack_20,0,0x18);
  if (*param_3 == 0) {
    puts("set: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else {
    pcVar2 = (char *)*param_3;
    iVar3 = param_3[1];
    if (iVar3 != 0) {
      param1 = "set";
    }
    else {
      param1 = "get";
    }
    printf("%s %s \n",param1,pcVar2);
    if (iVar3 != 0) {
      puts("Not supported");
      uVar1 = 0xffffffd4;
    }
    else {
      uVar1 = FUN_0044527c(param_1,pcVar2,(void *)0x0,0,&local_24);
      memcpy(abStack_20,local_24,0x18);
      pcVar2 = FUN_0041e064(abStack_20);
      printf("host_pa.dhcpc_ip_addr \t= %s\n",pcVar2);
      pcVar2 = FUN_0041e064(abStack_1c);
      printf("host_pa.dhcpc_ip_serv \t= %s\n",pcVar2);
      pcVar2 = FUN_0041e064(abStack_18);
      printf("host_pa.dhcpc_ip_mask \t= %s\n",pcVar2);
      pcVar2 = FUN_0041e064(abStack_14);
      printf("host_pa.dhcpc_gateway \t= %s\n",pcVar2);
      pcVar2 = FUN_0041e064(abStack_10);
      printf("host_pa.dhcpc_dnsserv \t= %s\n",pcVar2);
      printf("host_pa.dhcpc_lease_time= %d\n",local_c);
    }
  }
  return uVar1;
}



undefined4 FUN_004449f0(int *param_1,undefined4 param_2,int *param_3)

{
  undefined4 uVar1;
  char *param2;
  int *piVar2;
  ulong uVar3;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (*param_3 == 0) {
    puts("set: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else {
    param2 = (char *)*param_3;
    piVar2 = param_3 + 1;
    if (*piVar2 == 0) {
      printf("set: missing value argument for set of \"%s\"\n",param2);
      uVar1 = 0xffffffd4;
    }
    else {
      uVar3 = strtoul((char *)*piVar2,local_10,0);
      if (*local_10[0] == '\0') {
        uVar1 = FUN_004ba428(param_1,param2,uVar3);
      }
      else {
        printf("set: error parsing value \"%s\" as an integer for set of \"%s\"\n",(char *)*piVar2,
               param2);
        uVar1 = 0xffffffd4;
      }
    }
  }
  return uVar1;
}



undefined4 FUN_00444b10(int *param_1,undefined4 param_2,int *param_3)

{
  undefined4 uVar1;
  int iVar2;
  char *local_10;
  
  if (*param_3 == 0) {
    puts("get: missing arguments");
    uVar1 = 0xffffffd4;
  }
  else if (param_3[1] == 0) {
    strcpy(PTR_DAT_00551644,(char *)*param_3);
    for (local_10 = PTR_DAT_00551644; *local_10 != '\0'; local_10 = local_10 + 1) {
      iVar2 = tolower((int)*local_10);
      *local_10 = (char)iVar2;
    }
    uVar1 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
  }
  else {
    printf("get: error, extra arg \"%s\"\n",(char *)param_3[1]);
    uVar1 = 0xffffffd4;
  }
  return uVar1;
}



int FUN_00444c48(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_00444b10(param_1,param_2,param_3);
  if (iVar1 == 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = *(uint *)PTR_DAT_00551644;
    }
    else {
      uVar2 = *(uint *)PTR_DAT_00551644;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    printf("0x%08x\n",uVar2);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00444d34(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  uint local_10 [2];
  
  if (*param_3 == 0) {
    puts("get: missing arguments");
    iVar1 = -0x2c;
  }
  else {
    iVar1 = FUN_004ba35c(param_1,(char *)*param_3,local_10);
    if (iVar1 == 0) {
      if ((int)local_10[0] < 10) {
        printf("%d\n",local_10[0]);
      }
      else {
        printf("%d (0x%x)\n",local_10[0],local_10[0]);
      }
      iVar1 = 0;
    }
  }
  return iVar1;
}



int FUN_00444e34(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  
  iVar1 = FUN_00444b10(param_1,param_2,param_3);
  if (iVar1 == 0) {
    puts(PTR_DAT_00551644);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00444eb0(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  char *param2;
  int *piVar2;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (*param_3 == 0) {
    puts("set: missing arguments");
    iVar1 = -0x2c;
  }
  else {
    param2 = (char *)*param_3;
    piVar2 = param_3 + 1;
    if (*piVar2 == 0) {
      local_14 = 0;
    }
    else {
      local_14 = strtol((char *)*piVar2,local_10,0);
      if (*local_10[0] != '\0') {
        printf("set: error parsing value \"%s\" as an integer for set of \"%s\"\n",(char *)*piVar2,
               param2);
        return -0x2c;
      }
    }
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar1 = FUN_004ba0cc(param_1,param2,&local_14,4,PTR_DAT_00551644,0x2000);
    if (iVar1 == 0) {
      puts(PTR_DAT_00551644);
      iVar1 = 0;
    }
  }
  return iVar1;
}



void FUN_0044506c(int *param_1)

{
  int iVar1;
  char acStack_88 [128];
  
  iVar1 = FUN_004ba1f8(param_1,"bcmerrorstr",acStack_88,0x80);
  if (iVar1 == 0) {
    fprintf(stderr,"%s: %s\n",DAT_00557690,acStack_88);
  }
  else {
    fprintf(stderr,"%s: \nError getting the last error\n",DAT_00557690);
  }
  return;
}



void FUN_00445120(int *param_1,undefined4 param_2,int *param_3)

{
  if (param_3[1] == 0) {
    FUN_00444d34(param_1,param_2,param_3);
  }
  else {
    FUN_004449f0(param_1,param_2,param_3);
  }
  return;
}



void FUN_00445198(int *param_1,char *param_2,void *param_3,size_t param_4,undefined4 *param_5)

{
  size_t sVar1;
  
  memset(PTR_DAT_00551644,0,0x2000);
  strcpy(PTR_DAT_00551644,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00551644 + sVar1 + 1,param_3,param_4);
  }
  *param_5 = PTR_DAT_00551644;
  FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
  return;
}



void FUN_0044527c(int *param_1,char *param_2,void *param_3,size_t param_4,undefined4 *param_5)

{
  size_t sVar1;
  
  memset(PTR_DAT_00551644,0,0x100);
  strcpy(PTR_DAT_00551644,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00551644 + sVar1 + 1,param_3,param_4);
  }
  *param_5 = PTR_DAT_00551644;
  FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x100);
  return;
}



void FUN_00445360(int *param_1,char *param_2,void *param_3,size_t param_4,undefined4 *param_5)

{
  size_t sVar1;
  
  memset(PTR_DAT_00551644,0,0x600);
  strcpy(PTR_DAT_00551644,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00551644 + sVar1 + 1,param_3,param_4);
  }
  *param_5 = PTR_DAT_00551644;
  FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x600);
  return;
}



void FUN_00445444(int *param_1,char *param_2,void *param_3,size_t param_4)

{
  size_t sVar1;
  
  memset(PTR_DAT_00551644,0,0x2000);
  strcpy(PTR_DAT_00551644,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00551644 + sVar1 + 1,param_3,param_4);
  }
  FUN_004ba050(param_1,0x107,PTR_DAT_00551644,sVar1 + 1 + param_4);
  return;
}



undefined4 FUN_00445528(int *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  
  if ((int)param_2[3] < 0) {
    uVar1 = 0xffffffff;
  }
  else {
    uVar1 = FUN_00445444(param_1,(char *)*param_2,(void *)0x0,0);
  }
  return uVar1;
}



uint FUN_00445598(char *param_1,uint param_2,void *param_3,size_t param_4,void *param_5,uint param_6
                 ,undefined4 *param_7)

{
  size_t __n;
  size_t sVar1;
  uint uVar2;
  void *__dest;
  uint local_res4;
  void *local_res8;
  size_t local_resc;
  
  local_res4 = param_2;
  local_res8 = param_3;
  local_resc = param_4;
  __n = strlen("bsscfg:");
  sVar1 = strlen(param_1);
  sVar1 = sVar1 + 1;
  uVar2 = __n + sVar1 + local_resc + 4;
  if (((int)param_6 < 0) || (param_6 < uVar2)) {
    *param_7 = 0xfffffff2;
    uVar2 = 0;
  }
  else {
    memcpy(param_5,"bsscfg:",__n);
    memcpy((void *)((int)param_5 + __n),param_1,sVar1);
    __dest = (void *)((int)((int)param_5 + __n) + sVar1);
    if (DAT_00557704 != '\0') {
      local_res4 = local_res4 << 0x18 | (local_res4 & 0xff00) << 8 | (local_res4 & 0xff0000) >> 8 |
                   local_res4 >> 0x18;
    }
    memcpy(__dest,&local_res4,4);
    if (local_resc != 0) {
      memcpy((void *)((int)__dest + 4),local_res8,local_resc);
    }
    *param_7 = 0;
  }
  return uVar2;
}



int FUN_00445758(int *param_1,char *param_2,uint param_3,void *param_4,size_t param_5,char *param_6,
                uint param_7)

{
  uint uVar1;
  int local_c;
  
  uVar1 = FUN_00445598(param_2,param_3,param_4,param_5,param_6,param_7,&local_c);
  if (local_c == 0) {
    local_c = FUN_004ba050(param_1,0x107,param_6,uVar1);
  }
  return local_c;
}



int FUN_004457f4(int *param_1,char *param_2,uint param_3,void *param_4,size_t param_5,char *param_6,
                uint param_7)

{
  int local_10 [2];
  
  FUN_00445598(param_2,param_3,param_4,param_5,param_6,param_7,local_10);
  if (local_10[0] == 0) {
    local_10[0] = FUN_004b9f94(param_1,0x106,param_6,param_7);
  }
  return local_10[0];
}



int FUN_0044588c(int *param_1,char *param_2,uint param_3,char *param_4,size_t param_5)

{
  int local_110;
  char acStack_10c [260];
  
  if ((int)param_5 < 0x101) {
    memset(acStack_10c,0,0x100);
    local_110 = FUN_004457f4(param_1,param_2,param_3,(void *)0x0,0,acStack_10c,0x100);
    if (local_110 == 0) {
      memcpy(param_4,acStack_10c,param_5);
    }
  }
  else {
    local_110 = FUN_004457f4(param_1,param_2,param_3,(void *)0x0,0,param_4,param_5);
  }
  return local_110;
}



void FUN_00445980(int *param_1,char *param_2,uint param_3,void *param_4,size_t param_5)

{
  char acStack_108 [256];
  
  memset(acStack_108,0,0x100);
  FUN_00445758(param_1,param_2,param_3,param_4,param_5,acStack_108,0x100);
  return;
}



int FUN_00445a00(int *param_1,char *param_2,uint param_3,uint *param_4)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_0044588c(param_1,param_2,param_3,(char *)param_4,4);
  if (iVar1 == 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = *param_4;
    }
    else {
      uVar2 = *param_4;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    *param_4 = uVar2;
  }
  return iVar1;
}



void FUN_00445ad8(int *param_1,char *param_2,uint param_3,uint param_4)

{
  uint local_resc;
  
  if (DAT_00557704 != '\0') {
    param_4 = param_4 << 0x18 | (param_4 & 0xff00) << 8 | (param_4 & 0xff0000) >> 8 |
              param_4 >> 0x18;
  }
  local_resc = param_4;
  FUN_00445980(param_1,param_2,param_3,&local_resc,4);
  return;
}



int FUN_00445b94(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  int local_28;
  char *local_14;
  ulong local_10;
  ulong local_c;
  
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    puts("Missing argument");
    iVar4 = -2;
  }
  else {
    local_10 = strtoul((char *)*piVar3,&local_14,0);
    if (*local_14 == '\0') {
      piVar3 = (int *)(param_3 + 8);
      if (*piVar3 == 0) {
        puts("Missing argument");
        iVar4 = -2;
      }
      else {
        local_c = strtoul((char *)*piVar3,&local_14,0);
        if (*local_14 == '\0') {
          if ((local_c == 0) || (0x1000 < local_c)) {
            printf("invalid input!");
            iVar4 = -2;
          }
          else {
            uVar5 = local_c >> 2;
            memset(PTR_DAT_00551644,0,0x1000);
            puVar2 = PTR_DAT_00551644;
            *(undefined4 *)PTR_DAT_00551644 = 0x725f7462;
            pcVar1 = puVar2 + 4;
            pcVar1[0] = 'e';
            pcVar1[1] = 'g';
            pcVar1[2] = 's';
            pcVar1[3] = '_';
            pcVar1 = puVar2 + 8;
            pcVar1[0] = 'r';
            pcVar1[1] = 'e';
            pcVar1[2] = 'a';
            pcVar1[3] = 'd';
            puVar2[0xc] = '\0';
            memcpy(PTR_DAT_00551644 + 0xd,&local_10,8);
            iVar4 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x1000);
            puVar2 = PTR_DAT_00551644;
            if (iVar4 < 0) {
              puts("could not get the memory");
            }
            else {
              for (local_28 = 0; local_28 < (int)uVar5; local_28 = local_28 + 1) {
                printf("%x \n",*(uint *)(puVar2 + local_28 * 4));
              }
            }
          }
        }
        else {
          fprintf(stderr,"Bad arg: %s\n",(char *)*piVar3);
          iVar4 = -0x2c;
        }
      }
    }
    else {
      fprintf(stderr,"Bad arg: %s\n",(char *)*piVar3);
      iVar4 = -0x2c;
    }
  }
  return iVar4;
}



int FUN_00445e90(int *param_1,undefined4 param_2,int param_3)

{
  int local_18;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = FUN_00445198(param_1,"nvram_dump",(void *)0x0,0,local_10);
    if (local_18 < 0) {
      local_18 = FUN_004b9f94(param_1,0x10a,PTR_DAT_00551644,0x2000);
      if (local_18 < 0) {
        return local_18;
      }
      local_10[0] = PTR_DAT_00551644;
    }
    fputs(local_10[0],stdout);
  }
  else {
    printf("nvdump error: extra arg \"%s\"\n",*(char **)(param_3 + 4));
    local_18 = -0x2c;
  }
  return local_18;
}



int FUN_00445fb0(int *param_1,undefined4 param_2,int param_3)

{
  char *__s;
  size_t sVar1;
  int local_18;
  undefined4 uStack_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("nvget: missing arguments");
    local_18 = -0x2c;
  }
  else {
    __s = *(char **)(param_3 + 4);
    if (*(int *)(param_3 + 8) == 0) {
      sVar1 = strlen(__s);
      local_18 = FUN_00445198(param_1,"nvram_get",__s,sVar1 + 1,&uStack_c);
      if (local_18 < 0) {
        strcpy(PTR_DAT_00551644,__s);
        local_18 = FUN_004b9f94(param_1,0x108,PTR_DAT_00551644,0x2000);
        if (local_18 < 0) {
          return local_18;
        }
      }
      puts(PTR_DAT_00551644);
    }
    else {
      printf("nvget error: extra arg \"%s\"\n",*(char **)(param_3 + 8));
      local_18 = -0x2c;
    }
  }
  return local_18;
}



undefined4 FUN_00446124(int *param_1,undefined4 param_2,int *param_3)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uVar3;
  char *__s;
  char *pcVar4;
  size_t sVar5;
  int *local_res8;
  
  iVar2 = strcmp("nvset",(char *)*param_3);
  local_res8 = param_3;
  if (iVar2 == 0) {
    local_res8 = param_3 + 1;
  }
  if (*local_res8 == 0) {
    puts("nvset: missing arguments");
    uVar3 = 0xffffffd4;
  }
  else {
    __s = (char *)*local_res8;
    local_res8 = local_res8 + 1;
    if (*local_res8 == 0) {
      pcVar4 = strchr(__s,0x3d);
      if (pcVar4 == (char *)0x0) {
        fprintf(stderr,
                "nvset error: no \'=\' in \"%s\", format is name=value (no spaces around \'=\')\n",
                (char *)*local_res8);
        uVar3 = 0xffffffd4;
      }
      else {
        strcpy(PTR_DAT_00551644,__s);
        puVar1 = PTR_DAT_00551644;
        sVar5 = strlen(PTR_DAT_00551644);
        uVar3 = FUN_004ba050(param_1,0x109,puVar1,sVar5 + 1);
      }
    }
    else {
      fprintf(stderr,
              "nvset error: extra arg \"%s\"; format is name=value (no spaces around \'=\')\n",
              (char *)*local_res8);
      uVar3 = 0xffffffd4;
    }
  }
  return uVar3;
}



int FUN_004462b4(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  bool bVar2;
  ushort uVar3;
  size_t sVar4;
  undefined *puVar5;
  int iVar6;
  uint uVar7;
  uint local_38;
  uint local_34;
  uint local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    local_38 = 0;
    local_34 = 0xe0;
    bVar2 = true;
  }
  else {
    local_38 = atoi(*(char **)(param_3 + 4));
    if ((int)local_38 < 1) {
      printf(" Usage: %s [channel | All ]\n",(char *)*param_2);
      return -0x2c;
    }
    bVar2 = false;
    local_34 = local_38;
  }
  while( true ) {
    puVar5 = PTR_DAT_00551644;
    if ((int)local_34 < (int)local_38) {
      return 0;
    }
    if (local_38 < 0xf) {
      uVar3 = 0;
    }
    else {
      uVar3 = 0xc000;
    }
    local_10[0] = (uint)(ushort)((ushort)local_38 | 0x1000 | uVar3);
    *(undefined4 *)PTR_DAT_00551644 = 0x5f726570;
    pcVar1 = puVar5 + 4;
    pcVar1[0] = 'c';
    pcVar1[1] = 'h';
    pcVar1[2] = 'a';
    pcVar1[3] = 'n';
    pcVar1 = puVar5 + 8;
    pcVar1[0] = '_';
    pcVar1[1] = 'i';
    pcVar1[2] = 'n';
    pcVar1[3] = 'f';
    puVar5[0xc] = 'o';
    puVar5[0xd] = '\0';
    sVar4 = strlen(PTR_DAT_00551644);
    puVar5 = PTR_DAT_00551644 + sVar4 + 1;
    local_10[0] = FUN_00402d10((ushort)local_10[0]);
    memcpy(puVar5,local_10,4);
    iVar6 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
    if (iVar6 < 0) break;
    if (DAT_00557704 == '\0') {
      uVar7 = *(uint *)PTR_DAT_00551644;
    }
    else {
      uVar7 = *(uint *)PTR_DAT_00551644 << 0x18 | *(uint *)PTR_DAT_00551644 >> 0x18;
    }
    if ((uVar7 & 1) == 0) {
      if (!bVar2) {
        puts("Invalid Channel");
      }
    }
    else if ((uVar7 & 2) == 0) {
      if (!bVar2) {
        puts("Not supported in current locale");
      }
    }
    else {
      printf("Channel %d\t",local_38);
      if ((uVar7 & 4) == 0) {
        printf("B Band");
      }
      else {
        printf("A Band");
      }
      if ((uVar7 & 8) != 0) {
        printf(", RADAR Sensitive");
      }
      if ((uVar7 & 0x40) != 0) {
        printf(", Restricted");
      }
      if ((uVar7 & 0x20) != 0) {
        printf(", Passive");
      }
      if ((uVar7 & 0x10) != 0) {
        printf(", Temporarily Out of Service for %d minutes",uVar7 >> 0x18);
      }
      putchar(10);
    }
    local_38 = local_38 + 1;
  }
  return iVar6;
}



int FUN_004466b8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtol((char *)*piVar1,local_10,0);
    }
    else {
      uVar3 = strtol((char *)*piVar1,local_10,0);
      local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    if (*local_10[0] == '\0') {
      iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,&local_14,4,PTR_DAT_00551644,0x2000);
      if (iVar2 == 0) {
        if (DAT_00557704 == '\0') {
          local_14 = *(uint *)PTR_DAT_00551644;
        }
        else {
          uVar3 = *(uint *)PTR_DAT_00551644;
          local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        FUN_00402444(local_14);
      }
    }
    else {
      printf("set: error parsing value \"%s\" as an integer\n",(char *)*piVar1);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_004468c0(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtol((char *)*piVar1,local_10,0);
    }
    else {
      uVar3 = strtol((char *)*piVar1,local_10,0);
      local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    if (*local_10[0] == '\0') {
      iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,&local_14,4,PTR_DAT_00551644,0x2000);
      if (iVar2 == 0) {
        if (DAT_00557704 == '\0') {
          local_14 = *(uint *)PTR_DAT_00551644;
        }
        else {
          uVar3 = *(uint *)PTR_DAT_00551644;
          local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        FUN_00402444(local_14);
      }
    }
    else {
      printf("set: error parsing value \"%s\" as an integer\n",(char *)*piVar1);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_00446ac8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = -1;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtol((char *)*piVar1,local_10,0);
    }
    else {
      uVar3 = strtol((char *)*piVar1,local_10,0);
      local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    if (*local_10[0] == '\0') {
      iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,&local_14,4,PTR_DAT_00551644,0x2000);
      if (iVar2 == 0) {
        if (DAT_00557704 == '\0') {
          local_14 = *(uint *)PTR_DAT_00551644;
        }
        else {
          uVar3 = *(uint *)PTR_DAT_00551644;
          local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        FUN_00402444(local_14);
      }
    }
    else {
      printf("set: error parsing value \"%s\" as an integer\n",(char *)*piVar1);
      iVar2 = -1;
    }
  }
  return iVar2;
}



int FUN_00446cd0(int *param_1,int param_2,undefined4 *param_3)

{
  undefined *puVar1;
  bool bVar2;
  ushort uVar3;
  int *piVar4;
  undefined3 extraout_var;
  int iVar5;
  size_t sVar6;
  undefined4 *puVar7;
  uint uVar8;
  char *param16;
  uint uVar9;
  char *pcVar10;
  char *param15;
  char *pcVar11;
  char *param14;
  char *pcVar12;
  char *pcVar13;
  char *pcVar14;
  char *pcVar15;
  char *pcVar16;
  char *pcVar17;
  char *pcVar18;
  char *pcVar19;
  char *pcVar20;
  undefined **param4;
  undefined4 local_408;
  undefined1 local_404;
  undefined1 local_403;
  undefined4 local_400;
  uint local_3fc;
  uint local_3f8;
  undefined4 local_3f4;
  undefined4 local_3f0;
  uint local_3ec;
  undefined4 local_3e8;
  uint local_3e4;
  uint local_3e0;
  undefined4 local_3dc;
  undefined4 local_3d8;
  uint local_3d4;
  uint local_3d0;
  undefined4 local_3cc;
  undefined4 local_3c8;
  uint local_3c4;
  undefined4 local_3c0;
  uint local_3bc;
  uint local_3b8;
  uint local_3b4;
  undefined4 local_3b0;
  uint local_3ac;
  uint local_3a8;
  undefined4 local_3a4;
  uint local_3a0;
  uint local_39c;
  undefined4 local_398;
  uint local_394;
  uint local_390;
  undefined4 local_38c;
  uint local_388;
  uint local_384;
  uint local_380;
  undefined4 local_37c;
  uint local_378;
  uint local_374;
  undefined4 local_370;
  uint local_36c;
  uint local_368;
  undefined4 local_364;
  undefined4 local_360;
  uint local_35c;
  undefined4 local_358;
  uint local_354;
  uint local_350;
  undefined4 local_34c;
  undefined4 local_348;
  uint local_344;
  undefined4 local_340;
  uint local_33c;
  uint local_338;
  undefined4 local_334;
  undefined4 local_330;
  uint local_32c;
  undefined4 local_328;
  uint local_324;
  undefined4 local_320;
  uint local_31c;
  uint local_318;
  undefined4 local_314;
  uint local_310;
  uint local_30c;
  undefined4 local_308;
  uint local_304;
  uint local_300;
  undefined4 local_2fc;
  uint local_2f8;
  uint local_2f4;
  undefined4 local_2f0;
  uint local_2ec;
  uint local_2e8;
  undefined4 local_2e4;
  uint local_2e0;
  uint local_2dc;
  uint local_2d8;
  undefined4 local_2d4;
  uint local_2d0;
  uint local_2cc;
  undefined4 local_2c8;
  uint local_2c4;
  uint local_2c0;
  undefined4 local_2bc;
  undefined4 local_2b8;
  uint local_2b4;
  undefined4 local_2b0;
  uint local_2ac;
  uint local_2a8;
  undefined4 local_2a4;
  undefined4 local_2a0;
  uint local_29c;
  undefined4 local_298;
  uint local_294;
  uint local_290;
  undefined4 local_28c;
  undefined4 local_288;
  uint local_284;
  undefined4 local_280;
  uint local_27c;
  undefined4 local_278;
  uint local_274;
  uint local_270;
  undefined4 local_26c;
  uint local_268;
  uint local_264;
  undefined4 local_260;
  uint local_25c;
  uint local_258;
  undefined4 local_254;
  uint local_250;
  uint local_24c;
  undefined4 local_248;
  uint local_244;
  uint local_240;
  undefined4 local_23c;
  uint local_238;
  uint local_234;
  uint local_230;
  undefined4 local_22c;
  uint local_228;
  uint local_224;
  undefined4 local_220;
  uint local_21c;
  uint local_218;
  undefined4 local_214;
  undefined4 local_210;
  uint local_20c;
  undefined4 local_208;
  uint local_204;
  uint local_200;
  undefined4 local_1fc;
  undefined4 local_1f8;
  uint local_1f4;
  undefined4 local_1f0;
  uint local_1ec;
  uint local_1e8;
  undefined4 local_1e4;
  undefined4 local_1e0;
  uint local_1dc;
  undefined4 local_1d8;
  uint local_1d4;
  undefined4 local_1d0;
  uint local_1cc;
  uint local_1c8;
  undefined4 local_1c4;
  uint local_1c0;
  uint local_1bc;
  undefined4 local_1b8;
  uint local_1b4;
  uint local_1b0;
  undefined4 local_1ac;
  uint local_1a8;
  uint local_1a4;
  undefined4 local_1a0;
  uint local_19c;
  uint local_198;
  undefined4 local_194;
  uint local_190;
  uint local_18c;
  uint local_188;
  undefined4 local_184;
  uint local_180;
  uint local_17c;
  undefined4 local_178;
  uint local_174;
  uint local_170;
  undefined4 local_16c;
  undefined4 local_168;
  uint local_164;
  undefined4 local_160;
  uint local_15c;
  uint local_158;
  undefined4 local_154;
  undefined4 local_150;
  uint local_14c;
  undefined4 local_148;
  uint local_144;
  uint local_140;
  undefined4 local_13c;
  undefined4 local_138;
  uint local_134;
  undefined4 local_130;
  uint local_12c;
  undefined4 local_128;
  uint local_124;
  uint local_120;
  undefined4 local_11c;
  uint local_118;
  uint local_114;
  undefined4 local_110;
  uint local_10c;
  uint local_108;
  undefined4 local_104;
  uint local_100;
  uint local_fc;
  undefined4 local_f8;
  uint local_f4;
  uint local_f0;
  undefined4 local_ec;
  uint local_e8;
  uint local_e4;
  uint local_e0;
  undefined4 local_dc;
  uint local_d8;
  uint local_d4;
  undefined4 local_d0;
  uint local_cc;
  uint local_c8;
  undefined4 local_c4;
  undefined4 local_c0;
  uint local_bc;
  undefined4 local_b8;
  uint local_b4;
  uint local_b0;
  undefined4 local_ac;
  undefined4 local_a8;
  uint local_a4;
  undefined4 local_a0;
  uint local_9c;
  uint local_98;
  undefined4 local_94;
  undefined4 local_90;
  uint local_8c;
  undefined4 local_88;
  uint local_84;
  undefined4 local_80;
  uint local_7c;
  uint local_78;
  undefined4 local_74;
  uint local_70;
  uint local_6c;
  undefined4 local_68;
  uint local_64;
  uint local_60;
  undefined4 local_5c;
  uint local_58;
  uint local_54;
  undefined4 local_50;
  uint local_4c;
  uint local_48;
  undefined4 local_44;
  uint local_40;
  uint local_3c;
  uint local_38;
  undefined4 local_34;
  uint local_30;
  uint local_2c;
  
  strcpy(PTR_DAT_00551644,(char *)*param_3);
  piVar4 = param_3 + 1;
  if ((*piVar4 == 0) ||
     (bVar2 = FUN_0041d6ac((char *)*piVar4,&local_408), CONCAT31(extraout_var,bVar2) == 0)) {
    puts(" ERROR: no valid ether addr provided");
    iVar5 = -0x2c;
  }
  else {
    sVar6 = strlen(PTR_DAT_00551644);
    puVar7 = (undefined4 *)(PTR_DAT_00551644 + sVar6 + 1);
    *puVar7 = local_408;
    *(undefined1 *)(puVar7 + 1) = local_404;
    *(undefined1 *)((int)puVar7 + 5) = local_403;
    iVar5 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x600);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar3 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      *(ushort *)PTR_DAT_00551644 = uVar3;
      if (*(ushort *)puVar1 < 5) {
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 2);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 2) << 8 | *(ushort *)(puVar1 + 2) >> 8;
        }
        *(ushort *)(puVar1 + 2) = uVar3;
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 4);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 4) << 8 | *(ushort *)(puVar1 + 4) >> 8;
        }
        *(ushort *)(puVar1 + 4) = uVar3;
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 0x98);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 0x98) << 8 | *(ushort *)(puVar1 + 0x98) >> 8;
        }
        *(ushort *)(puVar1 + 0x98) = uVar3;
        if (DAT_00557704 == '\0') {
          uVar8 = *(uint *)(puVar1 + 8);
        }
        else {
          uVar8 = *(uint *)(puVar1 + 8);
          uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
        }
        *(uint *)(puVar1 + 8) = uVar8;
        if (DAT_00557704 == '\0') {
          uVar8 = *(uint *)(puVar1 + 0xc);
        }
        else {
          uVar8 = *(uint *)(puVar1 + 0xc);
          uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
        }
        *(uint *)(puVar1 + 0xc) = uVar8;
        if (DAT_00557704 == '\0') {
          uVar8 = *(uint *)(puVar1 + 0x18);
        }
        else {
          uVar8 = *(uint *)(puVar1 + 0x18);
          uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
        }
        *(uint *)(puVar1 + 0x18) = uVar8;
        if (DAT_00557704 == '\0') {
          uVar8 = *(uint *)(puVar1 + 0x2c);
        }
        else {
          uVar8 = *(uint *)(puVar1 + 0x2c);
          uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
        }
        *(uint *)(puVar1 + 0x2c) = uVar8;
        if (DAT_00557704 == '\0') {
          uVar8 = *(uint *)(puVar1 + 0x30);
        }
        else {
          uVar8 = *(uint *)(puVar1 + 0x30);
          uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
        }
        *(uint *)(puVar1 + 0x30) = uVar8;
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 0x9a);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 0x9a) << 8 | *(ushort *)(puVar1 + 0x9a) >> 8;
        }
        *(ushort *)(puVar1 + 0x9a) = uVar3;
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 0x9c);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 0x9c) << 8 | *(ushort *)(puVar1 + 0x9c) >> 8;
        }
        *(ushort *)(puVar1 + 0x9c) = uVar3;
        printf("[VER %d] STA %s:\n",(uint)*(ushort *)puVar1,(char *)*piVar4);
        printf("\t aid:%d ",*(ushort *)(puVar1 + 0x98) & 0xffff3fff);
        printf("\n\t rateset ");
        FUN_004226f4((int)(puVar1 + 0x1c),*(uint *)(puVar1 + 0x18));
        printf("\n\t idle %d seconds\n",*(int *)(puVar1 + 0xc));
        printf("\t in network %d seconds\n",*(int *)(puVar1 + 0x2c));
        if ((*(uint *)(puVar1 + 8) & 8) == 0) {
          pcVar11 = "";
        }
        else {
          pcVar11 = " AUTHENTICATED";
        }
        if ((*(uint *)(puVar1 + 8) & 0x10) == 0) {
          pcVar12 = "";
        }
        else {
          pcVar12 = " ASSOCIATED";
        }
        if ((*(uint *)(puVar1 + 8) & 0x20) == 0) {
          pcVar10 = "";
        }
        else {
          pcVar10 = " AUTHORIZED";
        }
        printf("\t state:%s%s%s\n",pcVar11,pcVar12,pcVar10);
        if ((*(uint *)(puVar1 + 8) & 1) == 0) {
          pcVar11 = "";
        }
        else {
          pcVar11 = " BRCM";
        }
        if ((*(uint *)(puVar1 + 8) & 2) == 0) {
          pcVar12 = "";
        }
        else {
          pcVar12 = " WME";
        }
        if ((*(uint *)(puVar1 + 8) & 0x100) == 0) {
          param4 = (undefined **)&DAT_004e4a88;
        }
        else {
          param4 = &PTR_s_txpid2ga3_0051774c;
        }
        if ((*(uint *)(puVar1 + 8) & 4) == 0) {
          pcVar10 = "";
        }
        else {
          pcVar10 = " No-ERP";
        }
        if ((*(uint *)(puVar1 + 8) & 0x200) == 0) {
          pcVar20 = "";
        }
        else {
          pcVar20 = " APSD_BE";
        }
        if ((*(uint *)(puVar1 + 8) & 0x400) == 0) {
          pcVar19 = "";
        }
        else {
          pcVar19 = " APSD_BK";
        }
        if ((*(uint *)(puVar1 + 8) & 0x800) == 0) {
          pcVar18 = "";
        }
        else {
          pcVar18 = " APSD_VI";
        }
        if ((*(uint *)(puVar1 + 8) & 0x1000) == 0) {
          pcVar17 = "";
        }
        else {
          pcVar17 = " APSD_VO";
        }
        if ((*(uint *)(puVar1 + 8) & 0x2000) == 0) {
          pcVar16 = "";
        }
        else {
          pcVar16 = " N_CAP";
        }
        if ((*(uint *)(puVar1 + 8) & 0x100000) == 0) {
          pcVar15 = "";
        }
        else {
          pcVar15 = " VHT_CAP";
        }
        if ((*(uint *)(puVar1 + 8) & 0x8000) == 0) {
          pcVar14 = "";
        }
        else {
          pcVar14 = " AMPDU";
        }
        if ((*(uint *)(puVar1 + 8) & 0x10000) == 0) {
          pcVar13 = "";
        }
        else {
          pcVar13 = " AMSDU";
        }
        if ((*(uint *)(puVar1 + 8) & 0x20000) == 0) {
          param14 = "";
        }
        else {
          param14 = " MIMO-PS";
        }
        if ((*(uint *)(puVar1 + 8) & 0x40000) == 0) {
          param15 = "";
        }
        else {
          param15 = " MIMO-PS-RTS";
        }
        if ((*(uint *)(puVar1 + 8) & 0x80000) == 0) {
          param16 = "";
        }
        else {
          param16 = " RIFS";
        }
        printf("\t flags 0x%x:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",*(uint *)(puVar1 + 8),pcVar11,
               pcVar12,(char *)param4,pcVar10,pcVar20,pcVar19,pcVar18,pcVar17,pcVar16,pcVar15,
               pcVar14,pcVar13,param14,param15,param16);
        if ((*(ushort *)(puVar1 + 0x9a) & 1) == 0) {
          pcVar11 = "";
        }
        else {
          pcVar11 = " LDPC";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 2) == 0) {
          pcVar12 = " ";
        }
        else {
          pcVar12 = " 40MHz";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x10) == 0) {
          pcVar10 = "";
        }
        else {
          pcVar10 = " GF";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x20) == 0) {
          pcVar20 = "";
        }
        else {
          pcVar20 = " SGI20";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x40) == 0) {
          pcVar19 = "";
        }
        else {
          pcVar19 = " SGI40";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x80) == 0) {
          pcVar18 = "";
        }
        else {
          pcVar18 = " STBC-Tx";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x300) == 0) {
          pcVar17 = "";
        }
        else {
          pcVar17 = " STBC-Rx";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x400) == 0) {
          pcVar16 = "";
        }
        else {
          pcVar16 = " D-BlockAck";
        }
        if ((*(ushort *)(puVar1 + 0x9a) & 0x4000) == 0) {
          pcVar15 = "";
        }
        else {
          pcVar15 = " 40-Intl";
        }
        printf("\t HT caps 0x%x:%s%s%s%s%s%s%s%s%s\n",(uint)*(ushort *)(puVar1 + 0x9a),pcVar11,
               pcVar12,pcVar10,pcVar20,pcVar19,pcVar18,pcVar17,pcVar16,pcVar15);
        if ((*(uint *)(puVar1 + 8) & 0x100000) != 0) {
          if ((*(ushort *)(puVar1 + 0x9c) & 1) == 0) {
            pcVar11 = "";
          }
          else {
            pcVar11 = " LDPC";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 2) == 0) {
            pcVar12 = "";
          }
          else {
            pcVar12 = " SGI80";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 4) == 0) {
            pcVar10 = "";
          }
          else {
            pcVar10 = " SGI160";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 8) == 0) {
            pcVar20 = "";
          }
          else {
            pcVar20 = " STBC-Tx";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x10) == 0) {
            pcVar19 = "";
          }
          else {
            pcVar19 = " STBC-Rx";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x20) == 0) {
            pcVar18 = "";
          }
          else {
            pcVar18 = " SU-BFR";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x40) == 0) {
            pcVar17 = "";
          }
          else {
            pcVar17 = " SU-BFE";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x80) == 0) {
            pcVar16 = "";
          }
          else {
            pcVar16 = " MU-BFR";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x100) == 0) {
            pcVar15 = "";
          }
          else {
            pcVar15 = " MU-BFE";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x200) == 0) {
            pcVar14 = "";
          }
          else {
            pcVar14 = " TXOPPS";
          }
          if ((*(ushort *)(puVar1 + 0x9c) & 0x400) == 0) {
            pcVar13 = "";
          }
          else {
            pcVar13 = " VHT-HTC";
          }
          printf("\t VHT caps 0x%x:%s%s%s%s%s%s%s%s%s%s%s\n",(uint)*(ushort *)(puVar1 + 0x9c),
                 pcVar11,pcVar12,pcVar10,pcVar20,pcVar19,pcVar18,pcVar17,pcVar16,pcVar15,pcVar14,
                 pcVar13);
        }
        if (*(ushort *)(puVar1 + 2) < 200) {
          iVar5 = 0;
        }
        else {
          if ((*(uint *)(puVar1 + 8) & 0x4000) != 0) {
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x54);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x54);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx total pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_380 = *(uint *)(puVar1 + 100);
              uVar8 = *(uint *)(puVar1 + 0x60);
              local_3fc = uVar8 << 0x18;
              local_400 = 0;
              local_3f8 = uVar8 & 0xff00;
              local_3f4 = 0;
              local_3ec = local_3f8 << 8;
              local_3f0 = 0;
              local_3e8 = 0;
              local_3e4 = local_3fc | local_3ec;
              local_3e0 = uVar8 & 0xff0000;
              local_3dc = 0;
              local_3d8 = 0;
              local_3d4 = local_3e4 | local_3e0 >> 8;
              local_3d0 = uVar8 & 0xff000000;
              local_3cc = 0;
              local_3c8 = 0;
              local_3c4 = local_3d4 | uVar8 >> 0x18;
              local_3c0 = 0;
              local_3bc = local_380 & 0xff;
              local_3b8 = local_3bc << 0x18;
              local_3b0 = 0;
              local_3ac = local_380 & 0xff00;
              local_3a8 = local_3ac << 8;
              local_3a4 = 0;
              local_3a0 = local_3b8 | local_3a8;
              local_398 = 0;
              local_394 = local_380 & 0xff0000;
              local_390 = local_394 >> 8;
              local_38c = 0;
              local_388 = local_3a0 | local_390;
              local_380 = local_380 >> 0x18;
              local_37c = 0;
              local_378 = local_388 | local_380;
              local_3b4 = local_3c4;
              local_39c = local_3c4;
              local_384 = local_3c4;
              local_374 = local_3c4;
            }
            printf("\t tx total bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x34);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x34);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx ucast pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_2d8 = *(uint *)(puVar1 + 0x74);
              local_32c = *(uint *)(puVar1 + 0x70);
              local_36c = local_32c << 0x18;
              local_370 = 0;
              local_368 = local_32c & 0xff00;
              local_364 = 0;
              local_35c = local_368 << 8;
              local_360 = 0;
              local_358 = 0;
              local_354 = local_36c | local_35c;
              local_350 = local_32c & 0xff0000;
              local_34c = 0;
              local_344 = local_350 >> 8;
              local_348 = 0;
              local_33c = local_354 | local_344;
              local_338 = local_32c & 0xff000000;
              local_334 = 0;
              local_32c = local_32c >> 0x18;
              local_330 = 0;
              local_324 = local_33c | local_32c;
              local_320 = 0;
              local_31c = local_2d8 & 0xff;
              local_318 = local_31c << 0x18;
              local_314 = 0;
              local_308 = 0;
              local_304 = local_2d8 & 0xff00;
              local_300 = local_304 << 8;
              local_2fc = 0;
              local_2f8 = local_318 | local_300;
              local_2f0 = 0;
              local_2ec = local_2d8 & 0xff0000;
              local_2e8 = local_2ec >> 8;
              local_2e4 = 0;
              local_2e0 = local_2f8 | local_2e8;
              local_2d8 = local_2d8 >> 0x18;
              local_2d4 = 0;
              local_2d0 = local_2e0 | local_2d8;
              local_340 = local_348;
              local_328 = local_330;
              local_310 = local_318;
              local_30c = local_324;
              local_2f4 = local_324;
              local_2dc = local_324;
              local_2cc = local_324;
            }
            printf("\t tx ucast bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x5c);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x5c);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx mcast/bcast pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_230 = *(uint *)(puVar1 + 0x7c);
              local_284 = *(uint *)(puVar1 + 0x78);
              local_2c4 = local_284 << 0x18;
              local_2c8 = 0;
              local_2c0 = local_284 & 0xff00;
              local_2bc = 0;
              local_2b4 = local_2c0 << 8;
              local_2b8 = 0;
              local_2b0 = 0;
              local_2ac = local_2c4 | local_2b4;
              local_2a8 = local_284 & 0xff0000;
              local_2a4 = 0;
              local_29c = local_2a8 >> 8;
              local_2a0 = 0;
              local_294 = local_2ac | local_29c;
              local_290 = local_284 & 0xff000000;
              local_28c = 0;
              local_284 = local_284 >> 0x18;
              local_288 = 0;
              local_27c = local_294 | local_284;
              local_278 = 0;
              local_274 = local_230 & 0xff;
              local_270 = local_274 << 0x18;
              local_26c = 0;
              local_260 = 0;
              local_25c = local_230 & 0xff00;
              local_258 = local_25c << 8;
              local_254 = 0;
              local_250 = local_270 | local_258;
              local_248 = 0;
              local_244 = local_230 & 0xff0000;
              local_240 = local_244 >> 8;
              local_23c = 0;
              local_238 = local_250 | local_240;
              local_230 = local_230 >> 0x18;
              local_22c = 0;
              local_228 = local_238 | local_230;
              local_298 = local_2a0;
              local_280 = local_288;
              local_268 = local_270;
              local_264 = local_27c;
              local_24c = local_27c;
              local_234 = local_27c;
              local_224 = local_27c;
            }
            printf("\t tx mcast/bcast bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x38);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x38);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx failures: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x58);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x58);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx data pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_188 = *(uint *)(puVar1 + 0x6c);
              local_1dc = *(uint *)(puVar1 + 0x68);
              local_21c = local_1dc << 0x18;
              local_220 = 0;
              local_218 = local_1dc & 0xff00;
              local_214 = 0;
              local_20c = local_218 << 8;
              local_210 = 0;
              local_208 = 0;
              local_204 = local_21c | local_20c;
              local_200 = local_1dc & 0xff0000;
              local_1fc = 0;
              local_1f4 = local_200 >> 8;
              local_1f8 = 0;
              local_1ec = local_204 | local_1f4;
              local_1e8 = local_1dc & 0xff000000;
              local_1e4 = 0;
              local_1dc = local_1dc >> 0x18;
              local_1e0 = 0;
              local_1d4 = local_1ec | local_1dc;
              local_1d0 = 0;
              local_1cc = local_188 & 0xff;
              local_1c8 = local_1cc << 0x18;
              local_1c4 = 0;
              local_1b8 = 0;
              local_1b4 = local_188 & 0xff00;
              local_1b0 = local_1b4 << 8;
              local_1ac = 0;
              local_1a8 = local_1c8 | local_1b0;
              local_1a0 = 0;
              local_19c = local_188 & 0xff0000;
              local_198 = local_19c >> 8;
              local_194 = 0;
              local_190 = local_1a8 | local_198;
              local_188 = local_188 >> 0x18;
              local_184 = 0;
              local_180 = local_190 | local_188;
              local_1f0 = local_1f8;
              local_1d8 = local_1e0;
              local_1c0 = local_1c8;
              local_1bc = local_1d4;
              local_1a4 = local_1d4;
              local_18c = local_1d4;
              local_17c = local_1d4;
            }
            printf("\t rx data bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x3c);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x3c);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx ucast pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_e0 = *(uint *)(puVar1 + 0x84);
              local_134 = *(uint *)(puVar1 + 0x80);
              local_174 = local_134 << 0x18;
              local_178 = 0;
              local_170 = local_134 & 0xff00;
              local_16c = 0;
              local_164 = local_170 << 8;
              local_168 = 0;
              local_160 = 0;
              local_15c = local_174 | local_164;
              local_158 = local_134 & 0xff0000;
              local_154 = 0;
              local_14c = local_158 >> 8;
              local_150 = 0;
              local_144 = local_15c | local_14c;
              local_140 = local_134 & 0xff000000;
              local_13c = 0;
              local_134 = local_134 >> 0x18;
              local_138 = 0;
              local_12c = local_144 | local_134;
              local_128 = 0;
              local_124 = local_e0 & 0xff;
              local_120 = local_124 << 0x18;
              local_11c = 0;
              local_110 = 0;
              local_10c = local_e0 & 0xff00;
              local_108 = local_10c << 8;
              local_104 = 0;
              local_100 = local_120 | local_108;
              local_f8 = 0;
              local_f4 = local_e0 & 0xff0000;
              local_f0 = local_f4 >> 8;
              local_ec = 0;
              local_e8 = local_100 | local_f0;
              local_e0 = local_e0 >> 0x18;
              local_dc = 0;
              local_d8 = local_e8 | local_e0;
              local_148 = local_150;
              local_130 = local_138;
              local_118 = local_120;
              local_114 = local_12c;
              local_fc = local_12c;
              local_e4 = local_12c;
              local_d4 = local_12c;
            }
            printf("\t rx ucast bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x40);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x40);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx mcast/bcast pkts: %d\n",uVar8);
            if (DAT_00557704 != '\0') {
              local_38 = *(uint *)(puVar1 + 0x8c);
              local_8c = *(uint *)(puVar1 + 0x88);
              local_cc = local_8c << 0x18;
              local_d0 = 0;
              local_c8 = local_8c & 0xff00;
              local_c4 = 0;
              local_bc = local_c8 << 8;
              local_c0 = 0;
              local_b8 = 0;
              local_b4 = local_cc | local_bc;
              local_b0 = local_8c & 0xff0000;
              local_ac = 0;
              local_a4 = local_b0 >> 8;
              local_a8 = 0;
              local_9c = local_b4 | local_a4;
              local_98 = local_8c & 0xff000000;
              local_94 = 0;
              local_8c = local_8c >> 0x18;
              local_90 = 0;
              local_84 = local_9c | local_8c;
              local_80 = 0;
              local_7c = local_38 & 0xff;
              local_78 = local_7c << 0x18;
              local_74 = 0;
              local_68 = 0;
              local_64 = local_38 & 0xff00;
              local_60 = local_64 << 8;
              local_5c = 0;
              local_58 = local_78 | local_60;
              local_50 = 0;
              local_4c = local_38 & 0xff0000;
              local_48 = local_4c >> 8;
              local_44 = 0;
              local_40 = local_58 | local_48;
              local_38 = local_38 >> 0x18;
              local_34 = 0;
              local_30 = local_40 | local_38;
              local_a0 = local_a8;
              local_88 = local_90;
              local_70 = local_78;
              local_6c = local_84;
              local_54 = local_84;
              local_3c = local_84;
              local_2c = local_84;
            }
            printf("\t rx mcast/bcast bytes: %llu\n",CONCAT44(pcVar20,pcVar10));
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x44);
              uVar9 = *(uint *)(puVar1 + 0xc4);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x44);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
              uVar9 = *(uint *)(puVar1 + 0xc4);
              uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 |
                      uVar9 >> 0x18;
            }
            printf("\t rate of last tx pkt: %d kbps - %d kbps\n",uVar8,uVar9);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x48);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x48);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rate of last rx pkt: %d kbps\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x4c);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x4c);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx decrypt succeeds: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0x50);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0x50);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx decrypt failures: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xac);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xac);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx total pkts sent: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xb0);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xb0);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx pkts retries: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xa4);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xa4);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx pkts retry exhausted: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xb4);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xb4);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx FW total pkts sent: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xb8);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xb8);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx FW pkts retries: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xbc);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xbc);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t tx FW pkts retry exhausted: %d\n",uVar8);
            if (DAT_00557704 == '\0') {
              uVar8 = *(uint *)(puVar1 + 0xc0);
            }
            else {
              uVar8 = *(uint *)(puVar1 + 0xc0);
              uVar8 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                      uVar8 >> 0x18;
            }
            printf("\t rx total pkts retried: %d\n",uVar8);
          }
          iVar5 = 0;
        }
      }
      else {
        printf(" ERROR: unknown driver station info version %d\n",(uint)*(ushort *)puVar1);
        iVar5 = -1;
      }
    }
  }
  return iVar5;
}



int FUN_00449530(int *param_1)

{
  int iVar1;
  char *param1;
  char acStack_58 [8];
  uint local_50;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  memset(&local_50,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,(char *)&local_50,0x44);
  if (-1 < iVar1) {
    if (DAT_00557704 != '\0') {
      local_50 = local_50 << 0x18 | (local_50 & 0xff00) << 8 | (local_50 & 0xff0000) >> 8 |
                 local_50 >> 0x18;
    }
    printf("vendorid 0x%x\n",local_50);
    if (DAT_00557704 != '\0') {
      local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                 local_4c >> 0x18;
    }
    printf("deviceid 0x%x\n",local_4c);
    if (DAT_00557704 != '\0') {
      local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                 local_48 >> 0x18;
    }
    printf("radiorev 0x%x\n",local_48);
    if (DAT_00557704 != '\0') {
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
    }
    printf("chipnum 0x%x\n",local_24);
    if (DAT_00557704 != '\0') {
      local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                 local_44 >> 0x18;
    }
    printf("chiprev 0x%x\n",local_44);
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    printf("chippackage 0x%x\n",local_14);
    if (DAT_00557704 != '\0') {
      local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                 local_40 >> 0x18;
    }
    printf("corerev 0x%x\n",local_40);
    if (DAT_00557704 != '\0') {
      local_3c = local_3c << 0x18 | (local_3c & 0xff00) << 8 | (local_3c & 0xff0000) >> 8 |
                 local_3c >> 0x18;
    }
    printf("boardid 0x%x\n",local_3c);
    if (DAT_00557704 != '\0') {
      local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                 local_38 >> 0x18;
    }
    printf("boardvendor 0x%x\n",local_38);
    if (DAT_00557704 != '\0') {
      local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                 local_34 >> 0x18;
    }
    param1 = FUN_004bed04(local_34,acStack_58);
    printf("boardrev %s\n",param1);
    if (DAT_00557704 != '\0') {
      local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                 local_30 >> 0x18;
    }
    printf("driverrev 0x%x\n",local_30);
    if (DAT_00557704 != '\0') {
      local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                 local_2c >> 0x18;
    }
    printf("ucoderev 0x%x\n",local_2c);
    if (DAT_00557704 != '\0') {
      local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                 local_28 >> 0x18;
    }
    printf("bus 0x%x\n",local_28);
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
    }
    printf("phytype 0x%x\n",local_20);
    if (DAT_00557704 != '\0') {
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
    }
    printf("phyrev 0x%x\n",local_1c);
    if (DAT_00557704 != '\0') {
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
    }
    printf("anarev 0x%x\n",local_18);
    if (DAT_00557704 != '\0') {
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
    }
    printf("nvramrev %d\n",local_10);
    iVar1 = 0;
  }
  return iVar1;
}



undefined4 FUN_00449d3c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined *puVar2;
  int iVar3;
  int *local_res8;
  size_t local_138;
  undefined4 local_134;
  undefined1 local_130;
  undefined4 auStack_e4 [3];
  int local_d8;
  char local_d4;
  char local_d3;
  char local_d2;
  char *local_50;
  uint local_48;
  uint local_44;
  uint local_40;
  undefined1 local_20;
  undefined1 local_1f;
  ushort local_1e;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  bVar1 = false;
  memset(PTR_DAT_00551644,0,0x2000);
  memset(&local_44,0,0x10);
  memset(&local_20,0,0x14);
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x725f6d72;
  puVar2[4] = 0x65;
  puVar2[5] = 0x71;
  puVar2[6] = 0;
  local_138 = strlen(PTR_DAT_00551644);
  puVar2 = PTR_DAT_00551644 + local_138 + 1;
  local_138 = local_138 + 0x11;
  local_res8 = (int *)(param_3 + 4);
  FUN_004cbd80(auStack_e4,"wl_rm_request",0x517ca8,0);
  while( true ) {
    iVar3 = FUN_004cbe18(auStack_e4,local_res8);
    if (iVar3 == -1) {
      if (bVar1) {
        local_1e = FUN_00402c2c(local_1e);
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
          local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                     local_10 >> 0x18;
        }
        memcpy(PTR_DAT_00551644 + local_138,&local_20,0x14);
        local_138 = local_138 + 0x14;
        local_40 = local_40 + 1;
      }
      if (local_40 == 0) {
        fprintf(stderr,"%s: no measurement requests specified\n","wl_rm_request");
        local_134 = 0xffffffd4;
      }
      else {
        if (DAT_00557704 != '\0') {
          local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                     local_44 >> 0x18;
          local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                     local_40 >> 0x18;
        }
        memcpy(puVar2,&local_44,0x10);
        local_134 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_138);
      }
      return local_134;
    }
    if (iVar3 == 1) break;
    local_res8 = local_res8 + local_d8;
    if (local_d2 == 't') {
      if (local_d3 == '\0') {
        fprintf(stderr,"%s: could not parse \"%s\" as an int for the token\n","wl_rm_request",
                local_50);
        return 0xfffffffe;
      }
      if (bVar1) {
        local_1c = local_48;
      }
      else {
        local_44 = local_48;
      }
    }
    if (local_d2 == 'c') {
      if (local_d3 == '\0') {
        fprintf(stderr,"%s: could not parse \"%s\" as an int for channel\n","wl_rm_request",local_50
               );
        return 0xfffffffe;
      }
      if ((int)local_48 < 0xf) {
        local_1e = 0;
      }
      else {
        local_1e = 0xc000;
      }
      local_1e = (ushort)local_48 | 0x1000 | local_1e;
    }
    if (local_d2 == 'd') {
      if (local_d3 == '\0') {
        fprintf(stderr,"%s: could not parse \"%s\" as an int for duration\n","wl_rm_request",
                local_50);
        return 0xfffffffe;
      }
      local_10 = local_48;
    }
    if (local_d2 == 'p') {
      local_1f = 1;
    }
    if (local_d4 != '\0') {
      iVar3 = strcmp(local_50,"basic");
      if (iVar3 == 0) {
        local_130 = 1;
      }
      else {
        iVar3 = strcmp(local_50,"cca");
        if (iVar3 == 0) {
          local_130 = 2;
        }
        else {
          iVar3 = strcmp(local_50,"rpi");
          if (iVar3 != 0) {
            fprintf(stderr,"%s: could not parse \"%s\" as a measurement type\n","wl_rm_request",
                    local_50);
            return 0xfffffffe;
          }
          local_130 = 3;
        }
      }
      if (bVar1) {
        local_1e = FUN_00402c2c(local_1e);
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
          local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                     local_10 >> 0x18;
        }
        memcpy(PTR_DAT_00551644 + local_138,&local_20,0x14);
        local_138 = local_138 + 0x14;
        local_40 = local_40 + 1;
        local_1e = FUN_00402de8(local_1e);
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
          local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                     local_10 >> 0x18;
        }
        local_1c = local_1c + 1;
        local_1f = 0;
      }
      bVar1 = true;
      local_20 = local_130;
    }
  }
  return 0xffffffd4;
}



// WARNING: Removing unreachable block (ram,0x0044aca4)

int FUN_0044a7dc(int *param_1)

{
  char cVar1;
  undefined *puVar2;
  int iVar3;
  uint uVar4;
  undefined4 *__src;
  char *param2;
  char *local_108;
  char *local_104;
  undefined *local_100;
  int local_fc;
  int local_f8;
  char local_f4;
  char local_bc;
  byte local_bb;
  ushort local_ba;
  uint local_b8;
  uint local_b4;
  uint local_b0;
  uint local_ac;
  uint local_a8;
  char local_a0 [128];
  uint local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x725f6d72;
  puVar2[4] = 0x65;
  puVar2[5] = 0x70;
  puVar2[6] = 0;
  iVar3 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
  local_100 = PTR_DAT_00551644;
  if (iVar3 < 0) {
    return iVar3;
  }
  if (DAT_00557704 == '\0') {
    uVar4 = *(uint *)PTR_DAT_00551644;
  }
  else {
    uVar4 = *(uint *)PTR_DAT_00551644;
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  *(uint *)PTR_DAT_00551644 = uVar4;
  if (DAT_00557704 == '\0') {
    uVar4 = *(uint *)(local_100 + 4);
  }
  else {
    uVar4 = *(uint *)(local_100 + 4);
    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
  }
  *(uint *)(local_100 + 4) = uVar4;
  printf("Measurement Report: token %d, length %d\n",*(int *)local_100,*(int *)(local_100 + 4));
  local_f8 = *(int *)(local_100 + 4);
  local_100 = local_100 + 8;
  while( true ) {
    if (local_f8 < 1) {
      return iVar3;
    }
    if (local_f8 < 0x18) break;
    memcpy(&local_bc,local_100,0x18);
    local_ba = FUN_00402de8(local_ba);
    if (DAT_00557704 != '\0') {
      local_b8 = local_b8 << 0x18 | (local_b8 & 0xff00) << 8 | (local_b8 & 0xff0000) >> 8 |
                 local_b8 >> 0x18;
      local_b4 = local_b4 << 0x18 | (local_b4 & 0xff00) << 8 | (local_b4 & 0xff0000) >> 8 |
                 local_b4 >> 0x18;
      local_b0 = local_b0 << 0x18 | (local_b0 & 0xff00) << 8 | (local_b0 & 0xff0000) >> 8 |
                 local_b0 >> 0x18;
      local_ac = local_ac << 0x18 | (local_ac & 0xff00) << 8 | (local_ac & 0xff0000) >> 8 |
                 local_ac >> 0x18;
      local_a8 = local_a8 << 0x18 | (local_a8 & 0xff00) << 8 | (local_a8 & 0xff0000) >> 8 |
                 local_a8 >> 0x18;
    }
    __src = (undefined4 *)(local_100 + 0x18);
    local_f8 = local_f8 + -0x18;
    if (local_bc == '\x01') {
      local_104 = "Basic";
    }
    else if (local_bc == '\x02') {
      local_104 = "CCA";
    }
    else if (local_bc == '\x03') {
      local_104 = "RPI";
    }
    else {
      local_104 = (char *)0x0;
    }
    if (local_104 == (char *)0x0) {
      printf("\nReport   : %d <unknown>\n",(int)local_bc);
    }
    else {
      printf("\nReport   : %s\n",local_104);
    }
    local_108 = local_a0;
    if ((local_bb & 1) != 0) {
      builtin_strncpy(local_a0,"Parallel",9);
      local_108 = local_a0 + 8;
    }
    if ((local_bb & 2) != 0) {
      if (local_108 != local_a0) {
        builtin_strncpy(local_108," | ",4);
        local_108 = local_108 + 3;
      }
      builtin_strncpy(local_108,"Late",5);
      local_108 = local_108 + 4;
    }
    if ((local_bb & 4) != 0) {
      if (local_108 != local_a0) {
        builtin_strncpy(local_108," | ",4);
        local_108 = local_108 + 3;
      }
      builtin_strncpy(local_108,"Incapable",10);
      local_108 = local_108 + 9;
    }
    if ((local_bb & 8) != 0) {
      if (local_108 != local_a0) {
        builtin_strncpy(local_108," | ",4);
        local_108 = local_108 + 3;
      }
      builtin_strncpy(local_108,"Refused",8);
      local_108 = local_108 + 7;
    }
    if (local_108 == local_a0) {
      printf("flags    : 0x%02x\n",(int)(char)local_bb);
    }
    else {
      printf("flags    : 0x%02x (%s)\n",(int)(char)local_bb,local_a0);
    }
    printf("token    : %4d\n",local_b8);
    if ((local_bb & 0xe) == 0) {
      if ((local_ba & 0xc000) == 0xc000) {
        param2 = "(a)";
      }
      else {
        param2 = "(b)";
      }
      printf("channel  : %4d %s\n",(uint)(local_ba & 0xff),param2);
      printf("start tsf: 0x%x:%08x\n",local_b4,local_b0);
      printf("duration : %4d TU\n",local_ac);
      if (local_f8 < (int)local_a8) {
        printf("Error: partial report element, %d report bytes remain, element claims %d\n",local_f8
               ,local_a8);
        return iVar3;
      }
      if (local_bc == '\x01') {
        if (3 < local_a8) {
          memcpy(&local_20,__src,4);
          if (DAT_00557704 != '\0') {
            local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                       local_20 >> 0x18;
          }
          printf("Basic bits: 0x%08x\n",local_20);
        }
      }
      else if (local_bc == '\x02') {
        if (3 < local_a8) {
          memcpy(&local_20,__src,4);
          if (DAT_00557704 != '\0') {
            local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                       local_20 >> 0x18;
          }
          printf("Carrier Fraction: %d / 255\n",local_20);
        }
      }
      else if ((local_bc == '\x03') && (0xf < local_a8)) {
        local_f4 = -0x80;
        local_1c = *__src;
        local_18 = *(undefined4 *)(local_100 + 0x1c);
        local_14 = *(undefined4 *)(local_100 + 0x20);
        local_10 = *(undefined4 *)(local_100 + 0x24);
        for (local_fc = 0; local_fc < 8; local_fc = local_fc + 1) {
          cVar1 = *(char *)((int)&local_14 + local_fc);
          if (local_fc == 0) {
            printf("       Power <= %3d: ",(int)cVar1);
          }
          else if (local_fc < 7) {
            printf(" %3d < Power <= %3d: ",(int)local_f4,(int)cVar1);
          }
          else {
            printf(" %3d < Power       : ",(int)local_f4);
          }
          printf("%3d\n",(uint)*(byte *)((int)&local_1c + local_fc));
          local_f4 = cVar1;
        }
      }
    }
    local_f8 = local_f8 - local_a8;
    local_100 = (undefined *)((int)__src + local_a8);
  }
  return iVar3;
}



int FUN_0044b2e4(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  ulong uVar4;
  uint uVar5;
  undefined *puVar6;
  char *local_30;
  int local_2c;
  size_t local_28;
  byte *local_24;
  uint local_18;
  undefined2 local_14;
  undefined1 local_12;
  
  puVar6 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x6e696f6a;
  pcVar1 = puVar6 + 4;
  pcVar1[0] = '_';
  pcVar1[1] = 'p';
  pcVar1[2] = 'r';
  pcVar1[3] = 'e';
  puVar6[8] = 'f';
  puVar6[9] = '\0';
  if (*(int *)(param_3 + 4) == 0) {
    local_2c = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
    puVar6 = PTR_DAT_00551644;
    if (local_2c == 0) {
      if (DAT_00557704 == '\0') {
        uVar5 = *(uint *)PTR_DAT_00551644;
      }
      else {
        uVar5 = *(uint *)PTR_DAT_00551644;
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      local_24 = PTR_DAT_00551644 + 4;
      for (local_28 = 0; (int)local_28 < (int)uVar5; local_28 = local_28 + 1) {
        printf("%02x",(uint)local_24[local_28]);
      }
      putchar(10);
      local_18 = uVar5;
      if (((int)uVar5 < 2) || ((int)uVar5 < (int)((byte)puVar6[5] + 2))) {
        local_24 = (byte *)0x0;
      }
      for (; local_24 != (byte *)0x0;
          local_24 = (byte *)FUN_004be2ec((int)local_24,(int *)&local_18)) {
        FUN_0044b620(local_24);
      }
    }
  }
  else {
    local_28 = strlen(PTR_DAT_00551644);
    local_30 = *(char **)(param_3 + 4);
    sVar2 = strlen(local_30);
    iVar3 = (sVar2 >> 1) + local_28;
    while ((local_28 = local_28 + 1, (int)local_28 < iVar3 + 1 && ((int)local_28 < 0x2000))) {
      local_12 = 0;
      local_14 = *(undefined2 *)local_30;
      local_30 = local_30 + 2;
      puVar6 = PTR_DAT_00551644 + local_28;
      uVar4 = strtoul((char *)&local_14,(char **)0x0,0x10);
      *puVar6 = (char)uVar4;
    }
    local_2c = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_28);
  }
  return local_2c;
}



void FUN_0044b620(byte *param_1)

{
  byte bVar1;
  int iVar2;
  uint local_20;
  byte *local_1c;
  int local_18;
  
  bVar1 = *param_1;
  if (bVar1 == 2) {
    printf("Pref WPA: ");
    if (param_1[1] < 2) {
      printf("len = %d <WPA pref data truncated>\n",(uint)param_1[1]);
      return;
    }
    bVar1 = param_1[3];
    printf("%d ACP Specs\n",(uint)bVar1);
    local_1c = param_1 + 4;
    local_20 = 0;
    for (local_18 = param_1[1] - 2; ((int)local_20 < (int)(uint)bVar1 && (0xb < local_18));
        local_18 = local_18 + -0xc) {
      putchar(9);
      FUN_0044bc78(local_1c);
      putchar(0x2c);
      printf("U:");
      FUN_0044be1c(local_1c + 4);
      putchar(0x2c);
      printf("M:");
      iVar2 = memcmp(local_1c + 8,&DAT_00518084,4);
      if (iVar2 == 0) {
        printf("Any");
      }
      else {
        FUN_0044be1c(local_1c + 8);
      }
      putchar(10);
      local_1c = local_1c + 0xc;
      local_20 = local_20 + 1;
    }
    if (bVar1 != local_20) {
      printf("\t<expected %d more specs, %d bytes>\n",bVar1 - local_20,(bVar1 - local_20) * 4);
    }
    if (local_18 < 1) {
      return;
    }
    printf("\t<%d extra bytes>\n",local_18);
    return;
  }
  if (bVar1 < 3) {
    if (bVar1 == 1) {
      puts("Pref RSSI");
      if (param_1[1] < 3) {
        return;
      }
      printf("\t<%d extra bytes in pref data>\n",(uint)param_1[1]);
      return;
    }
  }
  else {
    if (bVar1 == 3) {
      printf("Pref BAND: ");
      if (param_1[1] < 2) {
        printf("len = %d <band pref data truncated>\n",(uint)param_1[1]);
        return;
      }
      bVar1 = param_1[3];
      if (bVar1 == 0) {
        printf("0x%x AUTO (no preference)\n",0);
      }
      else if (bVar1 == 1) {
        printf("0x%x 5 GHz\n",1);
      }
      else if (bVar1 == 2) {
        printf("0x%x 2.4 GHz\n",2);
      }
      else if (bVar1 == 0xff) {
        printf("0x%x Use ASSOC_PREFER value\n",0xff);
      }
      else {
        printf("0x%x\n",(uint)bVar1);
      }
      if (param_1[1] < 3) {
        return;
      }
      printf("\t<%d extra bytes in pref data>\n",param_1[1] - 1);
      return;
    }
    if (bVar1 == 4) {
      printf("RSSI Delta for Pref BAND: ");
      if (param_1[1] < 2) {
        printf("len = %d <rssi delta pref data truncated>\n",(uint)param_1[1]);
        return;
      }
      bVar1 = param_1[3];
      if (bVar1 == 0) {
        printf("0x%x AUTO (no preference)\n",0);
      }
      else if (bVar1 == 1) {
        printf("0x%x 5 GHz\n",1);
      }
      else if (bVar1 == 2) {
        printf("0x%x 2.4 GHz\n",2);
      }
      else {
        printf("0x%x\n",(uint)bVar1);
      }
      printf("RSSI boost %ddb\n",(uint)param_1[2]);
      return;
    }
  }
  printf("Pref 0x%x: len = %d\n",(uint)*param_1,(uint)param_1[1]);
  for (local_20 = 0; (int)local_20 < (int)(uint)param_1[1]; local_20 = local_20 + 1) {
    printf("%02x",(uint)param_1[local_20 + 2]);
  }
  putchar(10);
  return;
}



void FUN_0044bc78(byte *param_1)

{
  byte bVar1;
  int iVar2;
  char *local_10;
  
  bVar1 = param_1[3];
  iVar2 = memcmp(param_1,&DAT_00512508,3);
  if (iVar2 == 0) {
    local_10 = "WPA";
  }
  else {
    iVar2 = memcmp(param_1,&DAT_00512504,3);
    if (iVar2 == 0) {
      local_10 = "WPA2";
    }
    else {
      local_10 = (char *)0x0;
    }
  }
  if (local_10 == (char *)0x0) {
    printf("0x%02x%02x%02x/0x%02x",(uint)*param_1,(uint)param_1[1],(uint)param_1[2],(uint)param_1[3]
          );
  }
  else if (bVar1 == 0) {
    printf("%s-NONE",local_10);
  }
  else if (bVar1 == 1) {
    printf("%s",local_10);
  }
  else if (bVar1 == 1) {
    printf("%s-PSK",local_10);
  }
  else {
    printf("%s/0x%x",local_10,(uint)bVar1);
  }
  return;
}



void FUN_0044be1c(byte *param_1)

{
  byte bVar1;
  int iVar2;
  char *local_10;
  
  bVar1 = param_1[3];
  iVar2 = memcmp(param_1,&DAT_00512508,3);
  if (iVar2 == 0) {
    local_10 = "WPA";
  }
  else {
    iVar2 = memcmp(param_1,&DAT_00512504,3);
    if (iVar2 == 0) {
      local_10 = "WPA2";
    }
    else {
      local_10 = (char *)0x0;
    }
  }
  if (local_10 == (char *)0x0) {
    printf("0x%02x%02x%02x/0x%02x",(uint)*param_1,(uint)param_1[1],(uint)param_1[2],(uint)param_1[3]
          );
  }
  else if (bVar1 == 0) {
    printf("%s/NONE",local_10);
  }
  else if (bVar1 == 1) {
    printf("%s/WEP40",local_10);
  }
  else if (bVar1 == 2) {
    printf("%s/TKIP",local_10);
  }
  else if (bVar1 == 4) {
    printf("%s/AES",local_10);
  }
  else if (bVar1 == 5) {
    printf("%s/WEP104",local_10);
  }
  else {
    printf("%s/0x%x",local_10,(uint)bVar1);
  }
  return;
}



int FUN_0044c018(int *param_1,int param_2,int param_3)

{
  int iVar1;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_c,4);
    if (iVar1 == 0) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
      }
      if (local_c == 1) {
        puts("a");
      }
      else if (local_c == 0) {
        puts("auto");
      }
      else if (local_c == 2) {
        puts("b/g");
      }
    }
  }
  else {
    iVar1 = strcmp(*(char **)(param_3 + 4),"auto");
    if ((iVar1 == 0) || (iVar1 = strcmp(*(char **)(param_3 + 4),"0"), iVar1 == 0)) {
      local_c = 0;
    }
    else {
      iVar1 = strcmp(*(char **)(param_3 + 4),"a");
      if ((iVar1 == 0) || (iVar1 = strcmp(*(char **)(param_3 + 4),"1"), iVar1 == 0)) {
        local_c = 1;
      }
      else {
        iVar1 = strcmp(*(char **)(param_3 + 4),"b");
        if (((iVar1 != 0) && (iVar1 = strcmp(*(char **)(param_3 + 4),"g"), iVar1 != 0)) &&
           (iVar1 = strcmp(*(char **)(param_3 + 4),"2"), iVar1 != 0)) {
          return -0x2c;
        }
        local_c = 2;
      }
    }
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18;
    }
    iVar1 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)&local_c,4);
  }
  return iVar1;
}



int FUN_0044c34c(int *param_1,undefined4 param_2,int param_3)

{
  undefined1 uVar1;
  undefined *puVar2;
  int iVar3;
  char *pcVar4;
  ulong uVar5;
  size_t sVar6;
  undefined4 *puVar7;
  undefined4 *local_res8;
  int local_60;
  int local_58;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
  pcVar4 = puVar2 + 4;
  pcVar4[0] = 't';
  pcVar4[1] = 'x';
  pcVar4[2] = '_';
  pcVar4[3] = 'p';
  pcVar4 = puVar2 + 8;
  pcVar4[0] = 'a';
  pcVar4[1] = 'r';
  pcVar4[2] = 'a';
  pcVar4[3] = 'm';
  puVar2[0xc] = 's';
  puVar2[0xd] = '\0';
  iVar3 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
  if (-1 < iVar3) {
    memcpy(&local_40,PTR_DAT_00551644,0x18);
    pcVar4 = *(char **)(param_3 + 4);
    local_res8 = (undefined4 *)(param_3 + 8);
    if (pcVar4 == (char *)0x0) {
      puts("WME TX params: ");
      for (local_60 = 0; local_60 < 4; local_60 = local_60 + 1) {
        printf("%s: short %d. sfb %d. long %d. lfb %d. max %d\n",&UNK_005181a8 + local_60 * 6,
               (uint)*(byte *)((int)&local_40 + local_60 * 6),
               (uint)*(byte *)((int)&local_40 + local_60 * 6 + 1),
               (uint)*(byte *)((int)&local_40 + local_60 * 6 + 2),
               (uint)*(byte *)((int)&local_40 + local_60 * 6 + 3),
               (uint)*(ushort *)((int)&local_3c + local_60 * 6));
      }
    }
    else {
      iVar3 = strcmp(pcVar4,"be");
      if (iVar3 == 0) {
        local_60 = 0;
      }
      else {
        iVar3 = strcmp(pcVar4,"bk");
        if (iVar3 == 0) {
          local_60 = 1;
        }
        else {
          iVar3 = strcmp(pcVar4,"vi");
          if (iVar3 == 0) {
            local_60 = 2;
          }
          else {
            iVar3 = strcmp(pcVar4,"vo");
            if (iVar3 != 0) {
              printf("Unknown access class: %s\n",pcVar4);
              return -0x2c;
            }
            local_60 = 3;
          }
        }
      }
      local_28 = local_40;
      local_24 = local_3c;
      local_20 = local_38;
      local_1c = local_34;
      local_18 = local_30;
      local_14 = local_2c;
      do {
        puVar2 = PTR_DAT_00551644;
        pcVar4 = (char *)*local_res8;
        puVar7 = local_res8 + 1;
        if (pcVar4 == (char *)0x0) {
          *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
          pcVar4 = puVar2 + 4;
          pcVar4[0] = 't';
          pcVar4[1] = 'x';
          pcVar4[2] = '_';
          pcVar4[3] = 'p';
          pcVar4 = puVar2 + 8;
          pcVar4[0] = 'a';
          pcVar4[1] = 'r';
          pcVar4[2] = 'a';
          pcVar4[3] = 'm';
          puVar2[0xc] = 's';
          puVar2[0xd] = '\0';
          puVar2 = PTR_DAT_00551644;
          sVar6 = strlen(PTR_DAT_00551644);
          memcpy(puVar2 + sVar6 + 1,&local_28,0x18);
          iVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,0x2000);
          return iVar3;
        }
        local_res8 = local_res8 + 2;
        if ((char *)*puVar7 == (char *)0x0) {
          printf("Need value following %s\n",pcVar4);
          return -0x2c;
        }
        local_58 = 0xf;
        uVar5 = strtoul((char *)*puVar7,(char **)0x0,0);
        iVar3 = strcmp(pcVar4,"short");
        uVar1 = (undefined1)uVar5;
        if (iVar3 == 0) {
          *(undefined1 *)((int)&local_28 + local_60 * 6) = uVar1;
        }
        else {
          iVar3 = strcmp(pcVar4,"sfb");
          if (iVar3 == 0) {
            *(undefined1 *)((int)&local_28 + local_60 * 6 + 1) = uVar1;
          }
          else {
            iVar3 = strcmp(pcVar4,"long");
            if (iVar3 == 0) {
              *(undefined1 *)((int)&local_28 + local_60 * 6 + 2) = uVar1;
            }
            else {
              iVar3 = strcmp(pcVar4,"lfb");
              if (iVar3 == 0) {
                *(undefined1 *)((int)&local_28 + local_60 * 6 + 3) = uVar1;
              }
              else {
                iVar3 = strcmp(pcVar4,"max_rate");
                if (((iVar3 != 0) && (iVar3 = strcmp(pcVar4,"max"), iVar3 != 0)) &&
                   (iVar3 = strcmp(pcVar4,"rate"), iVar3 != 0)) {
                  printf("Unknown parameter: %s\n",pcVar4);
                  return -0x2c;
                }
                local_58 = 0xff;
                *(ushort *)((int)&local_24 + local_60 * 6) = (ushort)uVar5 & 0xff;
              }
            }
          }
        }
      } while ((int)uVar5 <= local_58);
      printf("Value for %s must be < %d\n",pcVar4,local_58 + 1);
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



int FUN_0044c9e0(int *param_1,undefined4 param_2,int param_3)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  char *pcVar4;
  int iVar5;
  byte *pbVar6;
  uint param4;
  uint param5;
  uint param6;
  char *__nptr;
  int iVar7;
  long lVar8;
  undefined4 *local_res8;
  char *local_60;
  int local_5c;
  int local_58;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  
  pcVar4 = *(char **)(param_3 + 4);
  if (pcVar4 == (char *)0x0) {
    local_5c = -0x2c;
  }
  else {
    iVar5 = strcmp(pcVar4,"ap");
    if (iVar5 == 0) {
      local_60 = "wme_ac_ap";
    }
    else {
      iVar5 = strcmp(pcVar4,"sta");
      if (iVar5 != 0) {
        return -0x2c;
      }
      local_60 = "wme_ac_sta";
    }
    local_5c = FUN_004ba1f8(param_1,local_60,(char *)&local_2c,0x10);
    if (-1 < local_5c) {
      pcVar4 = *(char **)(param_3 + 8);
      local_res8 = (undefined4 *)(param_3 + 0xc);
      if (pcVar4 == (char *)0x0) {
        puts("AC Parameters");
        for (local_58 = 0; local_58 < 4; local_58 = local_58 + 1) {
          iVar5 = local_58 * 4;
          pbVar6 = (byte *)(&local_2c + local_58);
          if (DAT_00557704 == '\0') {
            uVar3 = *(ushort *)((int)&local_2c + iVar5 + 2);
          }
          else {
            uVar3 = *(ushort *)((int)&local_2c + iVar5 + 2);
            uVar3 = uVar3 << 8 | uVar3 >> 8;
          }
          *(char *)((int)&local_2c + iVar5 + 2) = (char)uVar3;
          *(char *)((int)&local_2c + iVar5 + 3) = (char)(uVar3 >> 8);
          if ((int)(*pbVar6 & 0x60) >> 5 != local_58) {
            puts("Warning: AC params out of order");
          }
          bVar1 = *pbVar6;
          bVar2 = *pbVar6;
          param4 = *(byte *)((int)&local_2c + iVar5 + 1) & 0xf;
          param5 = (uint)(*(byte *)((int)&local_2c + iVar5 + 1) >> 4);
          param6 = (uint)*(ushort *)((int)&local_2c + iVar5 + 2);
          printf("%s: raw: ACI 0x%x ECW 0x%x TXOP 0x%x\n",&UNK_005181a8 + local_58 * 6,(uint)*pbVar6
                 ,(uint)*(byte *)((int)&local_2c + iVar5 + 1),
                 (uint)*(ushort *)((int)&local_2c + iVar5 + 2));
          printf("       dec: aci %d acm %d aifsn %d ecwmin %d ecwmax %d txop 0x%x\n",local_58,
                 (uint)((bVar1 & 0x10) != 0),bVar2 & 0xf,param4,param5,param6);
          printf("       eff: CWmin %d CWmax %d TXop %dusec\n",(1 << param4) + -1,(1 << param5) + -1
                 ,param6 << 5);
        }
        local_5c = 0;
      }
      else {
        iVar5 = strcmp(pcVar4,"be");
        if (iVar5 == 0) {
          local_58 = 0;
        }
        else {
          iVar5 = strcmp(pcVar4,"bk");
          if (iVar5 == 0) {
            local_58 = 1;
          }
          else {
            iVar5 = strcmp(pcVar4,"vi");
            if (iVar5 == 0) {
              local_58 = 2;
            }
            else {
              iVar5 = strcmp(pcVar4,"vo");
              if (iVar5 != 0) {
                return -0x2c;
              }
              local_58 = 3;
            }
          }
        }
        local_1c = local_2c;
        local_18 = local_28;
        local_14 = local_24;
        local_10 = local_20;
        iVar5 = local_58 * 4;
        pbVar6 = (byte *)(&local_1c + local_58);
        while( true ) {
          pcVar4 = (char *)*local_res8;
          if (pcVar4 == (char *)0x0) break;
          __nptr = (char *)local_res8[1];
          local_res8 = local_res8 + 2;
          if (__nptr == (char *)0x0) {
            return -0x2c;
          }
          iVar7 = strcmp(pcVar4,"acm");
          if (iVar7 == 0) {
            iVar7 = strcasecmp(__nptr,"on");
            if ((iVar7 == 0) || (iVar7 = strcasecmp(__nptr,"1"), iVar7 == 0)) {
              *pbVar6 = *pbVar6 | 0x10;
            }
            else {
              iVar7 = strcasecmp(__nptr,"off");
              if ((iVar7 != 0) && (iVar7 = strcasecmp(__nptr,"0"), iVar7 != 0)) {
                fwrite("acm value must be 1|0\n",1,0x16,stderr);
                return -0x2c;
              }
              *pbVar6 = *pbVar6 & 0xef;
            }
          }
          else {
            iVar7 = strcmp(pcVar4,"aifsn");
            if (iVar7 == 0) {
              lVar8 = strtol(__nptr,(char **)0x0,0);
              if ((lVar8 < 1) || (0xf < lVar8)) {
                fprintf(stderr,"aifsn %d out of range (%d-%d)\n",lVar8,1,0xf);
                return -0x2c;
              }
              *pbVar6 = *pbVar6 & 0xf0 | (byte)lVar8 & 0xf;
            }
            else {
              iVar7 = strcmp(pcVar4,"ecwmax");
              if (iVar7 == 0) {
                lVar8 = strtol(__nptr,(char **)0x0,0);
                if ((lVar8 < 0) || (0xf < lVar8)) {
                  fprintf(stderr,"ecwmax %d out of range (%d-%d)\n",lVar8,0,0xf);
                  return -0x2c;
                }
                *(byte *)((int)&local_1c + iVar5 + 1) =
                     (byte)(lVar8 << 4) | *(byte *)((int)&local_1c + iVar5 + 1) & 0xf;
              }
              else {
                iVar7 = strcmp(pcVar4,"ecwmin");
                if (iVar7 == 0) {
                  lVar8 = strtol(__nptr,(char **)0x0,0);
                  if ((lVar8 < 0) || (0xf < lVar8)) {
                    fprintf(stderr,"ecwmin %d out of range (%d-%d)\n",lVar8,0,0xf);
                    return -0x2c;
                  }
                  *(byte *)((int)&local_1c + iVar5 + 1) =
                       *(byte *)((int)&local_1c + iVar5 + 1) & 0xf0 | (byte)lVar8 & 0xf;
                }
                else {
                  iVar7 = strcmp(pcVar4,"txop");
                  if (iVar7 != 0) {
                    fprintf(stderr,"unexpected param %s\n",pcVar4);
                    return -0x2c;
                  }
                  lVar8 = strtol(__nptr,(char **)0x0,0);
                  if ((lVar8 < 0) || (0xffff < lVar8)) {
                    fprintf(stderr,"txop %d out of range (%d-%d)\n",lVar8,0,0xffff);
                    return -0x2c;
                  }
                  uVar3 = (ushort)lVar8;
                  if (DAT_00557704 != '\0') {
                    uVar3 = uVar3 << 8 | uVar3 >> 8;
                  }
                  *(char *)((int)&local_1c + iVar5 + 2) = (char)uVar3;
                  *(char *)((int)&local_1c + iVar5 + 3) = (char)(uVar3 >> 8);
                }
              }
            }
          }
        }
        local_5c = FUN_004ba2e4(param_1,local_60,pbVar6,4);
      }
    }
  }
  return local_5c;
}



int FUN_0044d3ac(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  size_t sVar9;
  int local_1c;
  uint local_18 [3];
  
  iVar3 = FUN_004b9f94(param_1,0x75,(char *)&local_1c,4);
  if (-1 < iVar3) {
    if (local_1c == 0) {
      memset(PTR_DAT_00551644,0,0x2000);
      puVar2 = PTR_DAT_00551644;
      *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
      pcVar1 = puVar2 + 4;
      pcVar1[0] = 'q';
      pcVar1[1] = 'o';
      pcVar1[2] = 's';
      pcVar1[3] = 'i';
      pcVar1 = puVar2 + 8;
      pcVar1[0] = 'n';
      pcVar1[1] = 'f';
      pcVar1[2] = 'o';
      pcVar1[3] = '\0';
      if (*(char **)(param_3 + 4) == (char *)0x0) {
        iVar3 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
        if (-1 < iVar3) {
          memcpy(local_18,PTR_DAT_00551644,4);
          if (DAT_00557704 != '\0') {
            local_18[0] = local_18[0] << 0x18 | (local_18[0] & 0xff00) << 8 |
                          (local_18[0] & 0xff0000) >> 8 | local_18[0] >> 0x18;
          }
          printf("Max SP Length = %d, APSD: BE=%d BK=%d VI=%d VO=%d\n",
                 ((int)(local_18[0] & 0x60) >> 5) << 1,(int)(local_18[0] & 8) >> 3,
                 (int)(local_18[0] & 4) >> 2,(int)(local_18[0] & 2) >> 1,local_18[0] & 1);
        }
      }
      else {
        uVar4 = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
        if (*(char **)(param_3 + 8) == (char *)0x0) {
          iVar3 = -0x2c;
        }
        else {
          uVar5 = strtol(*(char **)(param_3 + 8),(char **)0x0,0);
          if (*(char **)(param_3 + 0xc) == (char *)0x0) {
            iVar3 = -0x2c;
          }
          else {
            uVar6 = strtol(*(char **)(param_3 + 0xc),(char **)0x0,0);
            if (*(char **)(param_3 + 0x10) == (char *)0x0) {
              iVar3 = -0x2c;
            }
            else {
              uVar7 = strtol(*(char **)(param_3 + 0x10),(char **)0x0,0);
              if (*(char **)(param_3 + 0x14) == (char *)0x0) {
                iVar3 = -0x2c;
              }
              else {
                uVar8 = strtol(*(char **)(param_3 + 0x14),(char **)0x0,0);
                puVar2 = PTR_DAT_00551644;
                if (((uVar5 | uVar6 | uVar7 | uVar8) & 0xfffffffe) == 0 && (uVar4 & 0xfffffff9) == 0
                   ) {
                  local_18[0] = uVar8 & 1 |
                                (uVar7 & 1) << 1 |
                                (uVar6 & 1) << 2 | (uVar5 & 1) << 3 | ((int)uVar4 / 2 & 3U) << 5;
                  if (DAT_00557704 != '\0') {
                    local_18[0] = local_18[0] << 0x18;
                  }
                  sVar9 = strlen(PTR_DAT_00551644);
                  memcpy(puVar2 + sVar9 + 1,local_18,4);
                  iVar3 = FUN_004ba050(param_1,param_2[3],PTR_DAT_00551644,0x2000);
                }
                else {
                  printf("%s: Invalid parameter\n",(char *)*param_2);
                  iVar3 = -2;
                }
              }
            }
          }
        }
      }
    }
    else {
      printf("%s: STA only\n",(char *)*param_2);
      iVar3 = -1;
    }
  }
  return iVar3;
}



int FUN_0044d90c(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  size_t sVar7;
  uint local_14 [2];
  
  memset(PTR_DAT_00551644,0,0x2000);
  puVar1 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
  puVar1[4] = 100;
  puVar1[5] = 0x70;
  puVar1[6] = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar2 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
    if (-1 < iVar2) {
      memcpy(local_14,PTR_DAT_00551644,4);
      if (DAT_00557704 != '\0') {
        local_14[0] = local_14[0] << 0x18 | (local_14[0] & 0xff00) << 8 |
                      (local_14[0] & 0xff0000) >> 8 | local_14[0] >> 0x18;
      }
      printf("Discard oldest first: BE=%d BK=%d VI=%d VO=%d\n",local_14[0] & 1,
             (int)local_14[0] >> 1 & 1,(int)local_14[0] >> 2 & 1,(int)local_14[0] >> 3 & 1);
    }
  }
  else {
    uVar3 = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
    if (*(char **)(param_3 + 8) == (char *)0x0) {
      iVar2 = -0x2c;
    }
    else {
      uVar4 = strtol(*(char **)(param_3 + 8),(char **)0x0,0);
      if (*(char **)(param_3 + 0xc) == (char *)0x0) {
        iVar2 = -0x2c;
      }
      else {
        uVar5 = strtol(*(char **)(param_3 + 0xc),(char **)0x0,0);
        if (*(char **)(param_3 + 0x10) == (char *)0x0) {
          iVar2 = -0x2c;
        }
        else {
          uVar6 = strtol(*(char **)(param_3 + 0x10),(char **)0x0,0);
          puVar1 = PTR_DAT_00551644;
          if (((uVar3 | uVar4 | uVar5 | uVar6) & 0xfffffffe) == 0) {
            local_14[0] = uVar4 << 1 | uVar3 | uVar5 << 2 | uVar6 << 3;
            if (DAT_00557704 != '\0') {
              local_14[0] = local_14[0] << 0x18 | (local_14[0] & 0xff00) << 8 |
                            (local_14[0] & 0xff0000) >> 8 | local_14[0] >> 0x18;
            }
            sVar7 = strlen(PTR_DAT_00551644);
            memcpy(puVar1 + sVar7 + 1,local_14,4);
            iVar2 = FUN_004ba050(param_1,param_2[3],PTR_DAT_00551644,0x2000);
          }
          else {
            printf("%s: Invalid parameter\n",(char *)*param_2);
            iVar2 = -2;
          }
        }
      }
    }
  }
  return iVar2;
}



int FUN_0044dd2c(int *param_1,undefined4 param_2,int param_3)

{
  char *__s1;
  int iVar1;
  char *__nptr;
  uint uVar2;
  byte local_3c;
  uint local_14;
  uint local_10;
  uint *local_c;
  
  local_c = (uint *)0x0;
  __s1 = *(char **)(param_3 + 4);
  if (__s1 == (char *)0x0) {
    iVar1 = -0x2c;
  }
  else {
    iVar1 = strcmp(__s1,"be");
    if (iVar1 == 0) {
      local_3c = 0;
    }
    else {
      iVar1 = strcmp(__s1,"bk");
      if (iVar1 == 0) {
        local_3c = 1;
      }
      else {
        iVar1 = strcmp(__s1,"vi");
        if (iVar1 == 0) {
          local_3c = 2;
        }
        else {
          iVar1 = strcmp(__s1,"vo");
          if (iVar1 != 0) {
            fprintf(stderr,"unexpected param %s\n",__s1);
            return -0x2c;
          }
          local_3c = 3;
        }
      }
    }
    __nptr = *(char **)(param_3 + 8);
    if (__nptr == (char *)0x0) {
      if (DAT_00557704 == '\0') {
        local_14 = (uint)local_3c;
      }
      else {
        local_14 = (uint)local_3c << 0x18;
      }
      iVar1 = FUN_00445198(param_1,"lifetime",&local_14,8,&local_c);
      if (-1 < iVar1) {
        if (DAT_00557704 == '\0') {
          uVar2 = *local_c;
        }
        else {
          uVar2 = *local_c;
          uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
        }
        *local_c = uVar2;
        if (DAT_00557704 == '\0') {
          uVar2 = local_c[1];
        }
        else {
          uVar2 = local_c[1];
          uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
        }
        local_c[1] = uVar2;
        printf("Lifetime for access class \'%s\' is %dms\n",__s1,local_c[1]);
      }
    }
    else {
      if (DAT_00557704 == '\0') {
        local_14 = (uint)local_3c;
        local_10 = strtol(__nptr,(char **)0x0,0);
      }
      else {
        local_14 = (uint)local_3c << 0x18;
        uVar2 = strtol(__nptr,(char **)0x0,0);
        local_10 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = FUN_00445444(param_1,"lifetime",&local_14,8);
    }
  }
  return iVar1;
}



void FUN_0044e148(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  FUN_0044e7e0(param_1,"add",0x7f,param_3);
  return;
}



void FUN_0044e198(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  FUN_0044e7e0(param_1,"del",0x7f,param_3);
  return;
}



int FUN_0044e1e8(char *param_1,uint param_2,int param_3,undefined4 *param_4,size_t *param_5)

{
  FILE *param0;
  int param2;
  size_t sVar1;
  int iVar2;
  int iVar3;
  char *local_38;
  int local_34;
  uint local_1c;
  undefined4 local_18 [3];
  
  if (((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) ||
     (*(int *)(param_3 + 0xc) == 0)) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    local_34 = -0x2c;
  }
  else {
    local_1c = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
    if ((~param_2 & local_1c) == 0) {
      param2 = atoi(*(char **)(param_3 + 8));
      if (param2 < 0x100) {
        if (param2 < 3) {
          fprintf(stderr,"IE length is %d, should be >= %d\n",param2,3);
          local_34 = -2;
        }
        else {
          sVar1 = strlen(*(char **)(param_3 + 0xc));
          param0 = stderr;
          if (sVar1 == 8) {
            iVar2 = param2 + -3;
            if (0 < iVar2) {
              if (*(int *)(param_3 + 0x10) == 0) {
                fprintf(stderr,"Data bytes should be specified for IE of length %d\n",param2);
                return -0x2c;
              }
              sVar1 = strlen(*(char **)(param_3 + 0x10));
              if ((int)sVar1 < iVar2 * 2) {
                fwrite("Please specify all the data bytes for this IE\n",1,0x2e,stderr);
                return -0x2c;
              }
            }
            if ((iVar2 == 0) && (*(int *)(param_3 + 0x10) != 0)) {
              fprintf(stderr,"Ignoring data bytes for IE of length %d",param2);
            }
            local_38 = (char *)malloc(param2 + 0xeU);
            if (local_38 == (char *)0x0) {
              fwrite("memory alloc failure\n",1,0x15,stderr);
              local_34 = -0x1b;
            }
            else {
              strncpy(local_38,param_1,3);
              local_38[3] = '\0';
              if (DAT_00557704 == '\0') {
                local_18[0] = 1;
              }
              else {
                local_18[0] = 0x1000000;
              }
              memcpy(local_38 + 4,local_18,4);
              if (DAT_00557704 != '\0') {
                local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8
                           | local_1c >> 0x18;
              }
              memcpy(local_38 + 8,&local_1c,4);
              local_38[0xc] = -0x23;
              local_38[0xd] = (char)param2;
              iVar3 = FUN_00459510(*(char **)(param_3 + 0xc),local_38 + 0xe);
              if (iVar3 == 0) {
                local_34 = 0;
                if ((iVar2 < 1) ||
                   (local_34 = FUN_00459628(*(char **)(param_3 + 0x10),local_38 + 0x11,iVar2),
                   local_34 == 0)) {
                  if (param_4 != (undefined4 *)0x0) {
                    *param_4 = local_38;
                    local_38 = (char *)0x0;
                  }
                  if (param_5 != (size_t *)0x0) {
                    *param_5 = param2 + 0xeU;
                  }
                  if (local_38 != (char *)0x0) {
                    free(local_38);
                  }
                }
                else {
                  free(local_38);
                  fwrite("Error parsing data arg\n",1,0x17,stderr);
                  local_34 = -2;
                }
              }
              else {
                free(local_38);
                fwrite("Error parsing OUI arg\n",1,0x16,stderr);
                local_34 = -2;
              }
            }
          }
          else {
            sVar1 = strlen(*(char **)(param_3 + 0xc));
            fprintf(param0,"Invalid OUI length %d\n",sVar1);
            local_34 = -2;
          }
        }
      }
      else {
        fprintf(stderr,"IE length is %d, should be <= %d\n",param2,0xff);
        local_34 = -2;
      }
    }
    else {
      fprintf(stderr,"Invalid packet flag 0x%x (%d)\n",local_1c,local_1c);
      local_34 = -2;
    }
  }
  return local_34;
}



int FUN_0044e7e0(int *param_1,char *param_2,uint param_3,undefined4 *param_4)

{
  undefined4 *local_resc;
  int local_20;
  void *local_18;
  size_t local_14;
  uint local_10;
  int local_c;
  
  local_10 = 0;
  local_c = 0;
  local_20 = FUN_004024e8(param_4 + 1,*param_4,&local_10,&local_c);
  if (local_20 == 0) {
    if (local_c == 0) {
      local_10 = 0xffffffff;
      local_resc = param_4;
    }
    else {
      local_resc = param_4 + local_c;
    }
    local_20 = FUN_0044e1e8(param_2,param_3,(int)local_resc,&local_18,&local_14);
    if (local_20 == 0) {
      if (local_10 == 0xffffffff) {
        local_20 = FUN_00445444(param_1,"ie",local_18,local_14);
      }
      else {
        local_20 = FUN_00445758(param_1,"ie",local_10,local_18,local_14,PTR_DAT_00551644,0x2000);
      }
      free(local_18);
    }
  }
  return local_20;
}



int FUN_0044e970(int *param_1,undefined4 *param_2)

{
  int param2;
  void *local_14;
  undefined4 local_10;
  undefined1 local_c;
  
  local_10 = 0xffffffff;
  local_c = 0xdd;
  param2 = FUN_00445198(param_1,(char *)*param_2,&local_10,5,&local_14);
  if (param2 == 0) {
    FUN_0044eaa4(local_14);
  }
  else {
    fprintf(stderr,"Error %d getting IOVar\n",param2);
  }
  return param2;
}



int FUN_0044ea2c(int *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = *param_2;
  *param_2 = &DAT_00509148;
  iVar2 = FUN_0044e970(param_1,param_2);
  *param_2 = uVar1;
  return iVar2;
}



void FUN_0044eaa4(void *param_1)

{
  byte bVar1;
  int iVar2;
  void *local_38;
  byte *local_34;
  int local_30;
  int local_2c;
  int local_28;
  uint local_10;
  uint local_c;
  
  memcpy(&local_10,param_1,4);
  if (DAT_00557704 != '\0') {
    local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
               local_10 >> 0x18;
  }
  printf("Total IEs %d\n",local_10);
  local_38 = (void *)((int)param_1 + 4);
  for (local_30 = 0; local_30 < (int)local_10; local_30 = local_30 + 1) {
    memcpy(&local_c,local_38,4);
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    putchar(10);
    printf("IE index = %d\n",local_30);
    puts("-----------------");
    printf("Pkt Flg = 0x%x\n",local_c);
    printf("Length  = %d\n",(uint)*(byte *)((int)local_38 + 5));
    printf("OUI     = %02x:%02x:%02x\n",(uint)*(byte *)((int)local_38 + 6),
           (uint)*(byte *)((int)local_38 + 7),(uint)*(byte *)((int)local_38 + 8));
    puts("Data:");
    local_34 = (byte *)((int)local_38 + 9);
    iVar2 = *(byte *)((int)local_38 + 5) - 3;
    local_2c = 0;
    while (local_2c < iVar2) {
      local_28 = 0;
      for (; (local_28 < 0x10 && (local_2c < iVar2)); local_2c = local_2c + 1) {
        bVar1 = *local_34;
        local_34 = local_34 + 1;
        printf("%02x ",(uint)bVar1);
        local_28 = local_28 + 1;
      }
      putchar(10);
    }
    local_38 = (void *)((int)local_38 + *(byte *)((int)local_38 + 5) + 6);
  }
  return;
}



int FUN_0044edb4(int *param_1,undefined4 *param_2)

{
  int iVar1;
  ushort local_10 [2];
  void *local_c;
  
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar1 == 0) {
    memcpy(local_10,local_c,2);
    printf("%d\n",(uint)local_10[0]);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_0044ee68(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int local_110;
  char acStack_10c [260];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_0044527c(param_1,(char *)*param_2,(void *)0x0,0,&local_110);
    if (iVar1 == 0) {
      sprintf(acStack_10c,"wlc_ver %d.%d\nepi_ver %d.%d.%d.%d\n",(uint)*(ushort *)(local_110 + 0xc),
              (uint)*(ushort *)(local_110 + 0xe),(uint)*(ushort *)(local_110 + 4),
              (uint)*(ushort *)(local_110 + 6),(uint)*(ushort *)(local_110 + 8),
              (uint)*(ushort *)(local_110 + 10));
      fputs(acStack_10c,stdout);
      iVar1 = 0;
    }
  }
  else {
    fprintf(stderr,"\"%s\" wlc_ver iovar doesn\'t take any arguments\n",*(char **)(param_3 + 4));
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_0044efc8(int *param_1,undefined4 *param_2)

{
  ushort uVar1;
  undefined *param0;
  undefined2 uVar2;
  int iVar3;
  void *__dest;
  ushort *__dest_00;
  uint uVar4;
  char *pcVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  undefined1 *__ptr;
  uint uVar16;
  uint uVar17;
  uint local_2d8;
  char *local_2d4;
  ushort *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar3 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar3 == 0) {
    uVar1 = *local_c;
    if (uVar1 < 0xb) {
      if (uVar1 == 6) {
        puts("\tUse version 6 counters struct");
      }
      else if (uVar1 != 10) {
        printf("\tIncorrect version of counters struct: expected %d; got %d\n",10,(uint)uVar1);
        puts("\tDisplayed values may be incorrect");
      }
      __dest = malloc(0x2ec);
      if (__dest == (void *)0x0) {
        printf("\tCan not allocate %d bytes for counters six struct\n",0x2ec);
        iVar3 = -0x1b;
      }
      else {
        memcpy(__dest,local_c,0x2ec);
        __dest_00 = (ushort *)malloc(0x350);
        if (__dest_00 == (ushort *)0x0) {
          free(__dest);
          printf("\tCan not allocate %d bytes for counters struct\n",0x350);
          iVar3 = -0x1b;
        }
        else {
          memcpy(__dest_00,local_c,0x350);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 2);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 2);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(param0,"%s %u ","txframe",uVar4);
          pcVar5 = param0 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 4);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 4);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txbyte",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 6);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txretrans",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 8);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 8);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txerror",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x20);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x20);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxframe",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x22);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x22);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxbyte",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x24);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x24);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxerror",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xc);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xc);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txprshort",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x5e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x5e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txdmawar",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x10);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x10);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txnobuf",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x12);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x12);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txnoassoc",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x16);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x16);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txchit",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x18);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x18);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","txcmiss",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x5a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x5a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","reset",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xe);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xe);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txserr",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x1c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x1c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txphyerr",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x1e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x1e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txphycrs",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xd8);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xd8);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txfail",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x5c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x5c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","tbtt",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar7 = *(uint *)(__dest_00 + 0xd4);
            uVar4 = *(uint *)(__dest_00 + 0xd6);
            uVar16 = *(uint *)(__dest_00 + 0xda);
            uVar17 = *(uint *)(__dest_00 + 0xdc);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xd4);
            uVar7 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar4 = *(uint *)(__dest_00 + 0xd6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar16 = *(uint *)(__dest_00 + 0xda);
            uVar16 = uVar16 << 0x18 | (uVar16 & 0xff00) << 8 | (uVar16 & 0xff0000) >> 8 |
                     uVar16 >> 0x18;
            uVar17 = *(uint *)(__dest_00 + 0xdc);
            uVar17 = uVar17 << 0x18 | (uVar17 & 0xff00) << 8 | (uVar17 & 0xff0000) >> 8 |
                     uVar17 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"d11_txfrag %u d11_txmulti %u d11_txretry %u d11_txretrie %u\n",
                          uVar7,uVar4,uVar16,uVar17);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar7 = *(uint *)(__dest_00 + 0xe0);
            uVar4 = *(uint *)(__dest_00 + 0xe2);
            uVar16 = *(uint *)(__dest_00 + 0xe4);
            uVar17 = *(uint *)(__dest_00 + 0xec);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xe0);
            uVar7 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar4 = *(uint *)(__dest_00 + 0xe2);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar16 = *(uint *)(__dest_00 + 0xe4);
            uVar16 = uVar16 << 0x18 | (uVar16 & 0xff00) << 8 | (uVar16 & 0xff0000) >> 8 |
                     uVar16 >> 0x18;
            uVar17 = *(uint *)(__dest_00 + 0xec);
            uVar17 = uVar17 << 0x18 | (uVar17 & 0xff00) << 8 | (uVar17 & 0xff0000) >> 8 |
                     uVar17 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"d11_txrts %u d11_txnocts %u d11_txnoack %u d11_txfrmsnt %u\n",
                          uVar7,uVar4,uVar16,uVar17);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xea);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xea);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcrc",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x28);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x28);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxnobuf",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x2a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x2a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxnondata",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x2c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x2c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxbadds",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x2e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x2e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxbadcm",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xde);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xde);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxdup",uVar4);
          local_2d4 = pcVar5 + iVar3 + iVar6;
          if ((*__dest_00 == 7) && (0x2eb < __dest_00[1])) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x1a6);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x1a6);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","rxrtry",uVar4);
            local_2d4 = local_2d4 + iVar3;
          }
          if ((9 < *__dest_00) && (0x34b < __dest_00[1])) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x1a6);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x1a6);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","rxrtry",uVar4);
            local_2d4 = local_2d4 + iVar3;
          }
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x30);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x30);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(local_2d4,"%s %u ","rxfragerr",uVar4);
          pcVar5 = local_2d4 + iVar3;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x32);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x32);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5,"%s %u ","rxrunt",uVar4);
          pcVar5 = pcVar5 + iVar6;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x34);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x34);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar8 = sprintf(pcVar5,"%s %u ","rxgiant",uVar4);
          pcVar5 = pcVar5 + iVar8;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x36);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x36);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar9 = sprintf(pcVar5,"%s %u ","rxnoscb",uVar4);
          pcVar5 = pcVar5 + iVar9;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x38);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x38);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar10 = sprintf(pcVar5,"%s %u ","rxbadproto",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x3a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x3a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar11 = sprintf(pcVar5 + iVar10,"%s %u ","rxbadsrcmac",uVar4);
          pcVar5 = pcVar5 + iVar10 + iVar11;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xe6);
            uVar7 = *(uint *)(__dest_00 + 0xe8);
            uVar16 = *(uint *)(__dest_00 + 0xee);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xe6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar7 = *(uint *)(__dest_00 + 0xe8);
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
            uVar16 = *(uint *)(__dest_00 + 0xee);
            uVar16 = uVar16 << 0x18 | (uVar16 & 0xff00) << 8 | (uVar16 & 0xff0000) >> 8 |
                     uVar16 >> 0x18;
          }
          iVar12 = sprintf(pcVar5,"d11_rxfrag %u d11_rxmulti %u d11_rxundec %u\n",uVar4,uVar7,uVar16
                          );
          pcVar5 = pcVar5 + iVar12;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x26);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x26);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar13 = sprintf(pcVar5,"%s %u ","rxctl",uVar4);
          pcVar5 = pcVar5 + iVar13;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x3c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x3c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar14 = sprintf(pcVar5,"%s %u ","rxbadda",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x3e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x3e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar15 = sprintf(pcVar5 + iVar14,"%s %u ","rxfilter",uVar4);
          builtin_strncpy(local_2d4 +
                          iVar15 + iVar14 + iVar13 + iVar12 + iVar11 + iVar10 + iVar9 + iVar8 +
                          iVar6 + iVar3 + 2,"\nrxuflo: ",10);
          local_2d4 = pcVar5 + iVar14 + iVar15 + 9;
          for (local_2d8 = 0; local_2d8 < 6; local_2d8 = local_2d8 + 1) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + (local_2d8 + 0x20) * 2 + 2);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + (local_2d8 + 0x20) * 2 + 2);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%u ",uVar4);
            local_2d4 = local_2d4 + iVar3;
          }
          *local_2d4 = '\n';
          local_2d4[1] = '\0';
          pcVar5 = local_2d4 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x62);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x62);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txallfrm",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 100);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 100);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5,"%s %u ","txrtsfrm",uVar4);
          pcVar5 = pcVar5 + iVar6;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x66);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x66);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar8 = sprintf(pcVar5,"%s %u ","txctsfrm",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x68);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x68);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar9 = sprintf(pcVar5 + iVar8,"%s %u ","txackfrm",uVar4);
          pcVar5 = pcVar5 + iVar8 + iVar9;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x6a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x6a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar10 = sprintf(pcVar5,"%s %u ","txdnlfrm",uVar4);
          pcVar5 = pcVar5 + iVar10;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x6c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x6c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar11 = sprintf(pcVar5,"%s %u ","txbcnfrm",uVar4);
          pcVar5 = pcVar5 + iVar11;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x7e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x7e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar12 = sprintf(pcVar5,"%s %u ","txtplunfl",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x1c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x1c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar13 = sprintf(pcVar5 + iVar12,"%s %u ","txphyerr",uVar4);
          builtin_strncpy(local_2d4 +
                          iVar13 + iVar12 + iVar11 + iVar10 + iVar9 + iVar8 + iVar6 + iVar3 + 2,
                          "\ntxfunfl: ",0xb);
          local_2d4 = pcVar5 + iVar12 + iVar13 + 10;
          for (local_2d8 = 0; local_2d8 < 6; local_2d8 = local_2d8 + 1) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + (local_2d8 + 0x36) * 2 + 2);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + (local_2d8 + 0x36) * 2 + 2);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%u ",uVar4);
            local_2d4 = local_2d4 + iVar3;
          }
          *local_2d4 = '\n';
          local_2d4[1] = '\0';
          local_2d4[1] = '\n';
          local_2d4[2] = '\0';
          local_2d4 = local_2d4 + 2;
          if ((*__dest_00 == 6) && (*__dest_00 != 10)) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1e0);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1e0);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","tkipmicfaill",uVar4);
            local_2d4 = local_2d4 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x208);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x208);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","tkipicverr",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1e4);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1e4);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","tkipcntrmsr",uVar4);
            pcVar5 = local_2d4 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1e8);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1e8);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","tkipreplay",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1ec);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1ec);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","ccmpfmterr",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1f0);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1f0);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","ccmpreplay",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 500);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 500);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","ccmpundec",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1f8);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1f8);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","fourwayfail",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1fc);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1fc);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","wepundec",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x200);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x200);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","wepicverr",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x204);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x204);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","decsuccess",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x1dc);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x1dc);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxundec",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xf0);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xf0);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","tkipmicfaill",uVar4);
            local_2d4 = local_2d4 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x104);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x104);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","tkipicverr",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xf2);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xf2);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","tkipcntrmsr",uVar4);
            pcVar5 = local_2d4 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xf4);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xf4);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","tkipreplay",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xf6);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xf6);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","ccmpfmterr",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xf8);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xf8);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","ccmpreplay",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xfa);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xfa);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","ccmpundec",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xfc);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xfc);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","fourwayfail",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xfe);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xfe);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","wepundec",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x100);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x100);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","wepicverr",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x102);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x102);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","decsuccess",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0xee);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0xee);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxundec",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
          }
          local_2d4 = pcVar5 + 1;
          *local_2d4 = '\n';
          pcVar5[2] = '\0';
          pcVar5 = pcVar5 + 2;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x82);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x82);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxfrmtoolong",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x84);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x84);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxfrmtooshrt",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x86);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x86);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxinvmachdr",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x88);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x88);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxbadfcs",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x8a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x8a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxbadplcp",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x8c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x8c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcrsglitch",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x8e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x8e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxstrt",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x90);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x90);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxdfrmucastmbss",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x92);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x92);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxmfrmucastmbss",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x94);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x94);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcfrmucast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x96);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x96);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxrtsucast",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x98);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x98);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxctsucast",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x9a);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x9a);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxackucast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x9c);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x9c);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxdfrmocast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x9e);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x9e);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxmfrmocast",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xa0);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xa0);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxcfrmocast",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xa2);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xa2);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxrtsocast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xa4);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xa4);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxctsocast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xa6);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xa6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxdfrmmcast",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xa8);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xa8);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxmfrmmcast",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xaa);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xaa);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcfrmmcast",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xac);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xac);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxbeaconmbss",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xae);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xae);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxdfrmucastobss",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xb0);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xb0);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxbeaconobss",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xb2);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xb2);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxrsptmout",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xb4);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xb4);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","bcntxcancl",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xb6);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xb6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxf0ovfl",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xb8);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xb8);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxf1ovfl",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xba);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xba);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxf2ovfl",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xbc);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xbc);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txsfovfl",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xbe);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xbe);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","pmqovfl",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xc0);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xc0);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcgprqfrm",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xc2);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xc2);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxcgprsqovfl",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xc4);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xc4);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txcgprsfail",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xc6);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xc6);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","txcgprssuc",uVar4);
          pcVar5 = pcVar5 + iVar3 + iVar6;
          *pcVar5 = '\n';
          pcVar5[1] = '\0';
          pcVar5 = pcVar5 + 1;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 200);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 200);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","prs_timeout",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xca);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xca);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","rxnack",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xcc);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xcc);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","frmscons",uVar4);
          pcVar5 = pcVar5 + iVar3;
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0xce);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0xce);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar3 = sprintf(pcVar5,"%s %u ","txnack",uVar4);
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(__dest_00 + 0x80);
          }
          else {
            uVar4 = *(uint *)(__dest_00 + 0x80);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
          }
          iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","txphyerror",uVar4);
          local_2d4 = pcVar5 + iVar3 + iVar6;
          *local_2d4 = '\n';
          local_2d4[1] = '\0';
          local_2d4 = local_2d4 + 1;
          if ((*__dest_00 == 6) && (*__dest_00 != 10)) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x244);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x244);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","txchanrej",uVar4);
            local_2d4 = local_2d4 + iVar3;
            *local_2d4 = '\n';
            local_2d4[1] = '\0';
            local_2d4 = local_2d4 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x270);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x270);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","rx1mbps",uVar4);
            local_2d4 = local_2d4 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x274);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x274);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","rx2mbps",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x278);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x278);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","rx5mbps5",uVar4);
            pcVar5 = local_2d4 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x27c);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x27c);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx6mbps",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x280);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x280);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx9mbps",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x284);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x284);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx11mbps",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x288);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x288);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx12mbps",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x28c);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x28c);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx18mbps",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x290);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x290);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx24mbps",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x294);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x294);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx36mbps",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x298);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x298);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rx48mbps",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x29c);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x29c);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx54mbps",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2c4);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2c4);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","pktengrxducast",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2c8);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2c8);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","pktengrxdmcast",uVar4);
            pcVar5 = pcVar5 + iVar3 + iVar6;
            *pcVar5 = '\n';
            pcVar5[1] = '\0';
            pcVar5 = pcVar5 + 1;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2d8);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2d8);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","txmpdu_sgi",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2dc);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2dc);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","rxmpdu_sgi",uVar4);
            pcVar5 = pcVar5 + iVar3;
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2e0);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2e0);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(pcVar5,"%s %u ","txmpdu_stbc",uVar4);
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)((int)__dest + 0x2e4);
            }
            else {
              uVar4 = *(uint *)((int)__dest + 0x2e4);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rxmpdu_stbc",uVar4);
            local_2d4 = pcVar5 + iVar3 + iVar6;
            *local_2d4 = '\n';
            local_2d4[1] = '\0';
            local_2d4 = local_2d4 + 1;
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar4 = *(uint *)(__dest_00 + 0x108);
            }
            else {
              uVar4 = *(uint *)(__dest_00 + 0x108);
              uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18;
            }
            iVar3 = sprintf(local_2d4,"%s %u ","txchanrej",uVar4);
            local_2d4 = local_2d4 + iVar3;
            *local_2d4 = '\n';
            local_2d4[1] = '\0';
            local_2d4 = local_2d4 + 1;
            if (3 < *__dest_00) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x11c);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x11c);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","rx1mbps",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x11e);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x11e);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","rx2mbps",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x120);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x120);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","rx5mbps5",uVar4);
              pcVar5 = local_2d4 + iVar3 + iVar6;
              *pcVar5 = '\n';
              pcVar5[1] = '\0';
              pcVar5 = pcVar5 + 1;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x122);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x122);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx6mbps",uVar4);
              pcVar5 = pcVar5 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x124);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x124);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx9mbps",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x126);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x126);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx11mbps",uVar4);
              pcVar5 = pcVar5 + iVar3 + iVar6;
              *pcVar5 = '\n';
              pcVar5[1] = '\0';
              pcVar5 = pcVar5 + 1;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x128);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x128);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx12mbps",uVar4);
              pcVar5 = pcVar5 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x12a);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x12a);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx18mbps",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 300);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 300);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx24mbps",uVar4);
              pcVar5 = pcVar5 + iVar3 + iVar6;
              *pcVar5 = '\n';
              pcVar5[1] = '\0';
              pcVar5 = pcVar5 + 1;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x12e);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x12e);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx36mbps",uVar4);
              pcVar5 = pcVar5 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x130);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x130);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(pcVar5,"%s %u ","rx48mbps",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x132);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x132);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(pcVar5 + iVar3,"%s %u ","rx54mbps",uVar4);
              local_2d4 = pcVar5 + iVar3 + iVar6;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
            if (4 < *__dest_00) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x146);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x146);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","pktengrxducast",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x148);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x148);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","pktengrxdmcast",uVar4);
              local_2d4 = local_2d4 + iVar3 + iVar6;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
            if (5 < *__dest_00) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x152);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x152);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","txmpdu_sgi",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x154);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x154);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","rxmpdu_sgi",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x156);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x156);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","txmpdu_stbc",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x158);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x158);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","rxmpdu_stbc",uVar4);
              local_2d4 = local_2d4 + iVar3 + iVar6;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
            if (7 < *__dest_00) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x176);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x176);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","reinit",uVar4);
              local_2d4 = local_2d4 + iVar3;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
              if (0x307 < __dest_00[1]) {
                if (DAT_00557704 == '\0') {
                  uVar4 = *(uint *)(__dest_00 + 0x184);
                }
                else {
                  uVar4 = *(uint *)(__dest_00 + 0x184);
                  uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                          uVar4 >> 0x18;
                }
                iVar3 = sprintf(local_2d4,"%s %u ","cso_normal",uVar4);
                if (DAT_00557704 == '\0') {
                  uVar4 = *(uint *)(__dest_00 + 0x182);
                }
                else {
                  uVar4 = *(uint *)(__dest_00 + 0x182);
                  uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                          uVar4 >> 0x18;
                }
                iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","cso_passthrough",uVar4);
                local_2d4 = local_2d4 + iVar3 + iVar6;
                *local_2d4 = '\n';
                local_2d4[1] = '\0';
                local_2d4 = local_2d4 + 1;
              }
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x186);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x186);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","chained",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x188);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x188);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","chainedsz1",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x18a);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x18a);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","unchained",uVar4);
              local_2d4 = local_2d4 + iVar3;
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x18c);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x18c);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","maxchainsz",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x18e);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x18e);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","currchainsz",uVar4);
              local_2d4 = local_2d4 + iVar3 + iVar6;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
            if (8 < *__dest_00) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x192);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x192);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar3 = sprintf(local_2d4,"%s %u ","pciereset",uVar4);
              if (DAT_00557704 == '\0') {
                uVar4 = *(uint *)(__dest_00 + 0x194);
              }
              else {
                uVar4 = *(uint *)(__dest_00 + 0x194);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              iVar6 = sprintf(local_2d4 + iVar3,"%s %u ","cfgrestore",uVar4);
              local_2d4 = local_2d4 + iVar3 + iVar6;
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
            if (9 < *__dest_00) {
              builtin_strncpy(local_2d4,"reinitreason counts:  ",0x17);
              local_2d4 = local_2d4 + 0x16;
              for (local_2d8 = 0; local_2d8 < 8; local_2d8 = local_2d8 + 1) {
                iVar3 = sprintf(local_2d4,"%2d(%d)  ",local_2d8,
                                *(int *)(__dest_00 + (local_2d8 + 0xca) * 2 + 2));
                local_2d4 = local_2d4 + iVar3;
              }
              *local_2d4 = '\n';
              local_2d4[1] = '\0';
              local_2d4 = local_2d4 + 1;
            }
          }
          *local_2d4 = '\n';
          local_2d4[1] = '\0';
          fputs(PTR_DAT_00551644,stdout);
          if (__dest_00 != (ushort *)0x0) {
            free(__dest_00);
          }
          if (__dest != (void *)0x0) {
            free(__dest);
          }
          __ptr = (undefined1 *)calloc(1,0x109);
          if (__ptr == (undefined1 *)0x0) {
            iVar3 = -0x1b;
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar2 = 1;
            }
            else {
              uVar2 = 0x100;
            }
            *__ptr = (char)uVar2;
            __ptr[1] = (char)((ushort)uVar2 >> 8);
            __ptr[2] = 0xf;
            __ptr[3] = 0;
            __ptr[4] = 0;
            __ptr[5] = 1;
            FUN_004b3288(param_1,__ptr,0x109);
            free(__ptr);
            iVar3 = 0;
          }
        }
      }
    }
    else {
      printf("\tIncorrect version of counters struct: expected %d; got %d\n",10,(uint)uVar1);
      iVar3 = -1;
    }
  }
  return iVar3;
}



int FUN_0045597c(int *param_1,undefined4 *param_2)

{
  undefined *param0;
  ushort uVar1;
  int iVar2;
  void *__dest;
  uint uVar3;
  char *pcVar4;
  int iVar5;
  uint param2;
  uint uVar6;
  uint uVar7;
  char *local_70;
  void *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar2 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar2 == 0) {
    __dest = malloc(0xb0);
    if (__dest == (void *)0x0) {
      printf("\tCan not allocate %d bytes for counters struct\n",0xb0);
      iVar2 = -0x1b;
    }
    else {
      memcpy(__dest,local_c,0xb0);
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 8);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 8);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(param0,"%s %u ","txframe",uVar3);
      pcVar4 = param0 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x10);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x10);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","txbyte",uVar3);
      pcVar4 = pcVar4 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x18);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x18);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","txerror",uVar3);
      pcVar4 = pcVar4 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x60);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x60);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","rxframe",uVar3);
      pcVar4 = pcVar4 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x68);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x68);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","rxbyte",uVar3);
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x70);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x70);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rxerror",uVar3);
      pcVar4 = pcVar4 + iVar2 + iVar5;
      *pcVar4 = '\n';
      pcVar4[1] = '\0';
      pcVar4 = pcVar4 + 1;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x20);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x20);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","txnobuf",uVar3);
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x30);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x30);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","txfail",uVar3);
      pcVar4 = pcVar4 + iVar2 + iVar5;
      *pcVar4 = '\n';
      pcVar4[1] = '\0';
      pcVar4 = pcVar4 + 1;
      if (DAT_00557704 == '\0') {
        param2 = *(uint *)((int)__dest + 0x58);
        uVar3 = *(uint *)((int)__dest + 0x50);
        uVar6 = *(uint *)((int)__dest + 0x38);
        uVar7 = *(uint *)((int)__dest + 0x40);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x58);
        param2 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        uVar3 = *(uint *)((int)__dest + 0x50);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        uVar6 = *(uint *)((int)__dest + 0x38);
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
        uVar7 = *(uint *)((int)__dest + 0x40);
        uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"d11_txfrag %u d11_txmulti %u d11_txretry %u d11_txretrie %u\n",param2,
                      uVar3,uVar6,uVar7);
      pcVar4 = pcVar4 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x48);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x48);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"d11_txfrmsnt %u\n",uVar3);
      pcVar4 = pcVar4 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x78);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x78);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4,"%s %u ","rxnobuf",uVar3);
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x88);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x88);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rxfragerr",uVar3);
      pcVar4 = pcVar4 + iVar2 + iVar5;
      *pcVar4 = '\n';
      pcVar4[1] = '\0';
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x80);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x80);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4 + 1,"%s %u ","rxrunt",uVar3);
      pcVar4 = pcVar4 + 1 + iVar2;
      *pcVar4 = '\n';
      pcVar4[1] = '\0';
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)((int)__dest + 0x90);
      }
      else {
        uVar3 = *(uint *)((int)__dest + 0x90);
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar2 = sprintf(pcVar4 + 1,"d11_rxmulti %u \n",uVar3);
      local_70 = pcVar4 + 1 + iVar2;
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)((int)__dest + 2);
      }
      else {
        uVar1 = *(ushort *)((int)__dest + 2) << 8 | *(ushort *)((int)__dest + 2) >> 8;
      }
      if (0x98 < uVar1) {
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)((int)__dest + 0x98);
        }
        else {
          uVar3 = *(uint *)((int)__dest + 0x98);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(local_70,"%s %u ","txexptime",uVar3);
        local_70 = local_70 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)((int)__dest + 0xa0);
        }
        else {
          uVar3 = *(uint *)((int)__dest + 0xa0);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(local_70,"%s %u ","txrts",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)((int)__dest + 0xa8);
        }
        else {
          uVar3 = *(uint *)((int)__dest + 0xa8);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(local_70 + iVar2,"%s %u ","txnocts",uVar3);
        local_70 = local_70 + iVar2 + iVar5;
      }
      *local_70 = '\n';
      local_70[1] = '\0';
      fputs(PTR_DAT_00551644,stdout);
      if (__dest != (void *)0x0) {
        free(__dest);
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



int FUN_004566f4(int *param_1,undefined4 *param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined1 *__ptr;
  uint auStack_10 [2];
  
  iVar2 = FUN_004ba35c(param_1,(char *)*param_2,auStack_10);
  if (iVar2 == 0) {
    __ptr = (undefined1 *)calloc(1,0x109);
    if (__ptr == (undefined1 *)0x0) {
      iVar2 = -0x1b;
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar1 = 1;
      }
      else {
        uVar1 = 0x100;
      }
      *__ptr = (char)uVar1;
      __ptr[1] = (char)((ushort)uVar1 >> 8);
      __ptr[2] = 0x10;
      __ptr[3] = 0;
      __ptr[4] = 0;
      __ptr[5] = 1;
      FUN_004b3288(param_1,__ptr,0x109);
      free(__ptr);
      iVar2 = 0;
    }
  }
  return iVar2;
}



int FUN_00456884(int *param_1,undefined4 *param_2)

{
  undefined *param0;
  ushort uVar1;
  int iVar2;
  ushort *__dest;
  uint uVar3;
  char *pcVar4;
  int iVar5;
  void *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar2 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar2 == 0) {
    __dest = (ushort *)malloc(0x80);
    if (__dest == (ushort *)0x0) {
      printf("\tCan not allocate %d bytes for wl delta stats struct\n",0x80);
      iVar2 = -0x1b;
    }
    else {
      memcpy(__dest,local_c,0x80);
      if (DAT_00557704 == '\0') {
        uVar1 = *__dest;
      }
      else {
        uVar1 = *__dest << 8 | *__dest >> 8;
      }
      *__dest = uVar1;
      if (DAT_00557704 == '\0') {
        uVar1 = __dest[1];
      }
      else {
        uVar1 = __dest[1] << 8 | __dest[1] >> 8;
      }
      __dest[1] = uVar1;
      if (*__dest == 2) {
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 2);
        }
        else {
          uVar3 = *(uint *)(__dest + 2);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(param0,"%s %u ","txframe",uVar3);
        pcVar4 = param0 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 4);
        }
        else {
          uVar3 = *(uint *)(__dest + 4);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","txbyte",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 6);
        }
        else {
          uVar3 = *(uint *)(__dest + 6);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","txretrans",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 8);
        }
        else {
          uVar3 = *(uint *)(__dest + 8);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","txfail",uVar3);
        pcVar4 = pcVar4 + iVar2 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 10);
        }
        else {
          uVar3 = *(uint *)(__dest + 10);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rxframe",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0xc);
        }
        else {
          uVar3 = *(uint *)(__dest + 0xc);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rxbyte",uVar3);
        pcVar4 = pcVar4 + iVar2 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0xe);
        }
        else {
          uVar3 = *(uint *)(__dest + 0xe);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx1mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x10);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x10);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx2mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x12);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x12);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx5mbps5",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x14);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x14);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rx6mbps",uVar3);
        pcVar4 = pcVar4 + iVar2 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x16);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x16);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx9mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x18);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x18);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx11mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x1a);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x1a);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx12mbps",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x1c);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x1c);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rx18mbps",uVar3);
        pcVar4 = pcVar4 + iVar2 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x1e);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x1e);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx24mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x20);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x20);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx36mbps",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x22);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x22);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rx48mbps",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x24);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x24);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar2,"%s %u ","rx54mbps",uVar3);
        pcVar4 = pcVar4 + iVar2 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4[1] = '\n';
        pcVar4[2] = '\0';
        pcVar4 = pcVar4 + 2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x38);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x38);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rxbadplcp",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x3a);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x3a);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","rxcrsglitch",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x3c);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x3c);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","bphy_rxcrsglitch",uVar3);
        pcVar4 = pcVar4 + iVar2;
        if (DAT_00557704 == '\0') {
          uVar3 = *(uint *)(__dest + 0x3e);
        }
        else {
          uVar3 = *(uint *)(__dest + 0x3e);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        iVar2 = sprintf(pcVar4,"%s %u ","bphy_badplcp",uVar3);
        pcVar4[iVar2] = '\n';
        (pcVar4 + iVar2)[1] = '\0';
        fputs(PTR_DAT_00551644,stdout);
        if (__dest != (ushort *)0x0) {
          free(__dest);
        }
        iVar2 = 0;
      }
      else {
        printf("\tIncorrect version of delta stats struct: expected %d; got %d\n",2,(uint)*__dest);
        free(__dest);
        iVar2 = -1;
      }
    }
  }
  return iVar2;
}



int FUN_004577c4(int *param_1,undefined4 *param_2)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  char *local_118;
  uint local_114;
  ushort local_d4;
  ushort local_d2;
  uint auStack_d0 [48];
  void *local_10;
  uint local_c;
  
  local_118 = PTR_DAT_00551644;
  local_c = 0;
  iVar1 = FUN_0044527c(param_1,(char *)*param_2,(void *)0x0,0,&local_10);
  if (iVar1 == 0) {
    memcpy(&local_d4,local_10,0xc4);
    if (DAT_00557704 != '\0') {
      local_d4 = local_d4 << 8 | local_d4 >> 8;
      local_d2 = local_d2 << 8 | local_d2 >> 8;
    }
    if (local_d4 == 1) {
      iVar1 = FUN_004b9f94(param_1,0x75,(char *)&local_c,4);
      if (-1 < iVar1) {
        if (DAT_00557704 != '\0') {
          local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                    local_c >> 0x18;
        }
        for (local_114 = 0; local_114 < 4; local_114 = local_114 + 1) {
          if (DAT_00557704 == '\0') {
            uVar3 = auStack_d0[local_114 * 2];
            uVar2 = auStack_d0[local_114 * 2 + 1];
            uVar4 = auStack_d0[(local_114 + 4) * 2];
            uVar5 = auStack_d0[(local_114 + 4) * 2 + 1];
          }
          else {
            uVar2 = auStack_d0[local_114 * 2];
            uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
            uVar2 = auStack_d0[local_114 * 2 + 1];
            uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
            uVar4 = auStack_d0[(local_114 + 4) * 2];
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar5 = auStack_d0[(local_114 + 4) * 2 + 1];
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          iVar1 = sprintf(local_118,
                          "\n%s: tx frames: %u bytes: %u failed frames: %u failed bytes: %u\n",
                          &UNK_005181a8 + local_114 * 6,uVar3,uVar2,uVar4,uVar5);
          if (DAT_00557704 == '\0') {
            uVar3 = auStack_d0[(local_114 + 8) * 2];
            uVar2 = auStack_d0[(local_114 + 8) * 2 + 1];
            uVar4 = auStack_d0[(local_114 + 0xc) * 2];
            uVar5 = auStack_d0[(local_114 + 0xc) * 2 + 1];
          }
          else {
            uVar2 = auStack_d0[(local_114 + 8) * 2];
            uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
            uVar2 = auStack_d0[(local_114 + 8) * 2 + 1];
            uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
            uVar4 = auStack_d0[(local_114 + 0xc) * 2];
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar5 = auStack_d0[(local_114 + 0xc) * 2 + 1];
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          iVar6 = sprintf(local_118 + iVar1,
                          "       rx frames: %u bytes: %u failed frames: %u failed bytes: %u\n",
                          uVar3,uVar2,uVar4,uVar5);
          local_118 = local_118 + iVar1 + iVar6;
          if (local_c != 0) {
            if (DAT_00557704 == '\0') {
              uVar2 = auStack_d0[(local_114 + 0x10) * 2];
              uVar3 = auStack_d0[(local_114 + 0x10) * 2 + 1];
            }
            else {
              uVar2 = auStack_d0[(local_114 + 0x10) * 2];
              uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                      uVar2 >> 0x18;
              uVar3 = auStack_d0[(local_114 + 0x10) * 2 + 1];
              uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 |
                      uVar3 >> 0x18;
            }
            iVar1 = sprintf(local_118,"       foward frames: %u bytes: %u \n",uVar2,uVar3);
            local_118 = local_118 + iVar1;
          }
          if (DAT_00557704 == '\0') {
            uVar2 = auStack_d0[(local_114 + 0x14) * 2];
          }
          else {
            uVar2 = auStack_d0[(local_114 + 0x14) * 2];
            uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
          }
          iVar1 = sprintf(local_118,"       tx frames time expired: %u \n",uVar2);
          local_118 = local_118 + iVar1;
        }
        *local_118 = '\n';
        local_118[1] = '\0';
        fputs(PTR_DAT_00551644,stdout);
        iVar1 = 0;
      }
    }
    else {
      printf("\tIncorrect version of counters struct: expected %d; got %d\n",1,(uint)local_d4);
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_004580cc(int *param_1,undefined4 *param_2)

{
  undefined *param0;
  int iVar1;
  uint *__dest;
  uint uVar2;
  char *pcVar3;
  int iVar4;
  void *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar1 == 0) {
    __dest = (uint *)malloc(0x68);
    if (__dest == (uint *)0x0) {
      printf("\tCan not allocate %d bytes for wl swdiv stats struct\n",0x68);
      iVar1 = -1;
    }
    else {
      memcpy(__dest,local_c,0x68);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0x17];
      }
      else {
        uVar2 = __dest[0x17];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(param0,"%s %u ","rx_policy",uVar2);
      pcVar3 = param0 + iVar1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0x18];
      }
      else {
        uVar2 = __dest[0x18];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","tx_policy",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0x19];
      }
      else {
        uVar2 = __dest[0x19];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","cell_policy",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = *__dest;
      }
      else {
        uVar2 = *__dest;
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","auto_en",uVar2);
      pcVar3 = pcVar3 + iVar1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[1];
      }
      else {
        uVar2 = __dest[1];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","active_ant",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[2];
      }
      else {
        uVar2 = __dest[2];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","rxcount",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0x15];
      }
      else {
        uVar2 = __dest[0x15];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","tx_auto_en",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0x16];
      }
      else {
        uVar2 = __dest[0x16];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","tx_active_ant",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[3];
      }
      else {
        uVar2 = __dest[3];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","avg_snr_per_ant0",uVar2);
      pcVar3 = pcVar3 + iVar1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[4];
      }
      else {
        uVar2 = __dest[4];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","avg_snr_per_ant1",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[5];
      }
      else {
        uVar2 = __dest[5];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","avg_snr_per_ant2",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[6];
      }
      else {
        uVar2 = __dest[6];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","swap_ge_rxcount0",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[7];
      }
      else {
        uVar2 = __dest[7];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","swap_ge_rxcount1",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[8];
      }
      else {
        uVar2 = __dest[8];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","swap_ge_snrthresh0",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[9];
      }
      else {
        uVar2 = __dest[9];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","swap_ge_snrthresh1",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[10];
      }
      else {
        uVar2 = __dest[10];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","swap_txfail0",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0xb];
      }
      else {
        uVar2 = __dest[0xb];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","swap_txfail1",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0xc];
      }
      else {
        uVar2 = __dest[0xc];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","swap_timer0",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0xd];
      }
      else {
        uVar2 = __dest[0xd];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","swap_timer1",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3 = pcVar3 + 1;
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0xe];
      }
      else {
        uVar2 = __dest[0xe];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar1 = sprintf(pcVar3,"%s %u ","swap_alivecheck0",uVar2);
      if (DAT_00557704 == '\0') {
        uVar2 = __dest[0xf];
      }
      else {
        uVar2 = __dest[0xf];
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      iVar4 = sprintf(pcVar3 + iVar1,"%s %u ","swap_alivecheck1",uVar2);
      pcVar3 = pcVar3 + iVar1 + iVar4;
      *pcVar3 = '\n';
      pcVar3[1] = '\0';
      pcVar3[1] = '\n';
      pcVar3[2] = '\0';
      fputs(PTR_DAT_00551644,stdout);
      if (__dest != (uint *)0x0) {
        free(__dest);
      }
      iVar1 = 0;
    }
  }
  return iVar1;
}



int FUN_00458ecc(int *param_1,undefined4 *param_2)

{
  undefined *puVar1;
  int iVar2;
  size_t sVar3;
  undefined4 auStack_10 [2];
  
  puVar1 = PTR_DAT_00551644;
  iVar2 = FUN_0044527c(param_1,(char *)*param_2,(void *)0x0,0,auStack_10);
  if (iVar2 == 0) {
    sVar3 = strlen(PTR_DAT_00551644);
    puVar1[sVar3] = 10;
    (puVar1 + sVar3)[1] = 0;
    fputs(PTR_DAT_00551644,stdout);
    iVar2 = 0;
  }
  return iVar2;
}



int FUN_00458fa4(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  size_t sVar3;
  uint param2;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    printf(" Usage: %s testindex[1-4]\n",(char *)*param_2);
    iVar2 = -0x2c;
  }
  else {
    local_c = atoi(*(char **)(param_3 + 4));
    puVar1 = PTR_DAT_00551644;
    *(undefined4 *)PTR_DAT_00551644 = 0x67616964;
    puVar1[4] = 0;
    sVar3 = strlen(PTR_DAT_00551644);
    if (DAT_00557704 != '\0') {
      local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                local_c >> 0x18;
    }
    memcpy(PTR_DAT_00551644 + sVar3 + 1,&local_c,4);
    iVar2 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
    if (-1 < iVar2) {
      param2 = *(uint *)PTR_DAT_00551644;
      if (DAT_00557704 != '\0') {
        local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                  local_c >> 0x18;
        param2 = param2 << 0x18 | (param2 & 0xff00) << 8 | (param2 & 0xff0000) >> 8 | param2 >> 0x18
        ;
      }
      if (param2 == 0) {
        printf("\ndiag test %d passed\n",local_c);
      }
      else {
        printf("\ndiag test %d failed(error code %d)\n",local_c,param2);
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



int FUN_00459260(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  ushort uVar3;
  int *piVar4;
  int iVar5;
  uint uVar6;
  size_t sVar7;
  uint local_10 [2];
  
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    printf(" Usage: %s antenna_index[0-3]\n",(char *)*param_2);
    iVar5 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10[0] = atoi((char *)*piVar4);
    }
    else {
      uVar6 = atoi((char *)*piVar4);
      local_10[0] = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    puVar2 = PTR_DAT_00551644;
    *(undefined4 *)PTR_DAT_00551644 = 0x7968706e;
    pcVar1 = puVar2 + 4;
    pcVar1[0] = '_';
    pcVar1[1] = 'r';
    pcVar1[2] = 's';
    pcVar1[3] = 's';
    pcVar1 = puVar2 + 8;
    pcVar1[0] = 'i';
    pcVar1[1] = 'a';
    pcVar1[2] = 'n';
    pcVar1[3] = 't';
    puVar2[0xc] = '\0';
    sVar7 = strlen(PTR_DAT_00551644);
    memcpy(PTR_DAT_00551644 + sVar7 + 1,local_10,4);
    iVar5 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                      (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
        uVar3 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      printf("\nnphy_rssiant ant%d = %d\n",local_10[0],(int)(short)uVar3);
      iVar5 = 0;
    }
  }
  return iVar5;
}



undefined4 FUN_00459510(char *param_1,undefined1 *param_2)

{
  char *pcVar1;
  ulong uVar2;
  int local_20;
  char *local_1c;
  undefined1 *local_18;
  char local_10;
  char local_f;
  undefined1 local_e;
  
  local_20 = 0;
  local_1c = param_1;
  local_18 = param_2;
  while( true ) {
    if (2 < local_20) {
      return 0;
    }
    local_10 = *local_1c;
    local_f = local_1c[1];
    local_e = 0;
    uVar2 = strtoul(&local_10,(char **)0x0,0x10);
    *local_18 = (char)uVar2;
    local_18 = local_18 + 1;
    pcVar1 = local_1c + 2;
    if ((local_20 < 2) && (pcVar1 = local_1c + 3, local_1c[2] != ':')) break;
    local_1c = pcVar1;
    local_20 = local_20 + 1;
  }
  return 0xffffffff;
}



undefined4 FUN_00459628(char *param_1,undefined1 *param_2,int param_3)

{
  ulong uVar1;
  char *local_20;
  undefined1 *local_1c;
  int local_18;
  char local_10;
  char local_f;
  undefined1 local_e;
  
  local_20 = param_1;
  local_1c = param_2;
  for (local_18 = 0; local_18 < param_3; local_18 = local_18 + 1) {
    local_10 = *local_20;
    local_f = local_20[1];
    local_e = 0;
    uVar1 = strtoul(&local_10,(char **)0x0,0x10);
    *local_1c = (char)uVar1;
    local_1c = local_1c + 1;
    local_20 = local_20 + 2;
  }
  return 0;
}



undefined4 FUN_00459704(char *param_1,void *param_2,size_t param_3)

{
  size_t sVar1;
  byte bVar2;
  size_t sVar3;
  undefined4 uVar4;
  int iVar5;
  char *local_res0;
  size_t local_18;
  int local_14;
  
  local_14 = 0;
  local_res0 = param_1;
  if ((*param_1 == '0') && (param_1[1] == 'x')) {
    local_res0 = param_1 + 2;
  }
  memset(param_2,0,param_3);
  sVar3 = strlen(local_res0);
  if (sVar3 == 0) {
    uVar4 = 0xffffffff;
  }
  else {
    sVar1 = sVar3;
    while (((local_18 = sVar1 - 1, -1 < (int)local_18 && (local_14 < (int)param_3)) &&
           ((*(ushort *)(__ctype_b + local_res0[local_18] * 2) & 0x10) != 0))) {
      if ((*(ushort *)(__ctype_b + local_res0[local_18] * 2) & 8) == 0) {
        if ((*(ushort *)(__ctype_b + local_res0[local_18] * 2) & 2) == 0) {
          bVar2 = local_res0[local_18] - 0x37;
        }
        else {
          iVar5 = toupper((int)local_res0[local_18]);
          bVar2 = (char)iVar5 - 0x37;
        }
      }
      else {
        bVar2 = local_res0[local_18] - 0x30;
      }
      if (0xf < bVar2) break;
      if ((int)sVar1 % 2 == (uint)((sVar3 & 1) == 0)) {
        *(byte *)((int)param_2 + local_14) = *(char *)((int)param_2 + local_14) + bVar2 * '\x10';
        local_14 = local_14 + 1;
        sVar1 = local_18;
      }
      else {
        *(byte *)((int)param_2 + local_14) = bVar2;
        sVar1 = local_18;
      }
    }
    if ((local_18 == 0xffffffff) && (local_14 <= (int)param_3)) {
      uVar4 = 0;
    }
    else {
      uVar4 = 0xffffffff;
    }
  }
  return uVar4;
}



int FUN_004599dc(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  char cVar2;
  byte bVar3;
  size_t sVar4;
  int iVar5;
  int local_48;
  undefined1 *local_44;
  byte local_40;
  int local_3c;
  uint local_38;
  uint local_24;
  undefined1 auStack_20 [16];
  int local_10 [2];
  
  local_24 = 1;
  if (*(int *)(param_3 + 4) == 0) {
    bVar1 = true;
    local_44 = (undefined1 *)malloc(4);
    if (local_44 == (undefined1 *)0x0) {
      fprintf(stderr,"fail to allocate event_msgsstructure of %d bytes\n",4);
      return -0x1b;
    }
    memset(local_44,0,4);
    local_44[1] = 0;
    local_44[2] = 0x40;
    *local_44 = 1;
    memset(PTR_DAT_00551644,0,0x44);
    local_48 = FUN_0044527c(param_1,(char *)*param_2,local_44,4,local_10);
    if (local_48 == 0) {
      local_3c = local_10[0] + 4;
      local_40 = *(byte *)(local_10[0] + 2);
    }
    else {
      iVar5 = FUN_004ba35c(param_1,"bcmerror",&local_24);
      if ((iVar5 == 0) && (local_24 == 0xffffffe9)) {
        puts("old firmware support only 128 eventsgetting only the first 128 events");
        local_48 = FUN_0044527c(param_1,"event_msgs",(void *)0x0,0,local_10);
        if (local_48 == 0) {
          local_3c = local_10[0];
          local_40 = 0x10;
        }
      }
    }
    if (local_48 == 0) {
      printf("0x");
      local_38 = (uint)local_40;
      while (local_38 = local_38 - 1, -1 < (int)local_38) {
        if ((*(char *)(local_3c + local_38) != '\0') || (local_38 == 0)) {
          bVar1 = false;
        }
        if (!bVar1) {
          printf("%02x",(uint)*(byte *)(local_3c + local_38));
        }
      }
      putchar(10);
    }
  }
  else {
    sVar4 = strlen(*(char **)(param_3 + 4));
    if (sVar4 < 0x80) {
      sVar4 = strlen(*(char **)(param_3 + 4));
      cVar2 = (char)(sVar4 >> 1);
    }
    else {
      cVar2 = '@';
    }
    bVar3 = cVar2 + 4;
    local_44 = (undefined1 *)malloc((uint)bVar3);
    if (local_44 == (undefined1 *)0x0) {
      fprintf(stderr,"fail to allocate event_msgsstructure of %d bytes\n",(uint)bVar3);
      return -0x1b;
    }
    memset(local_44,0,(uint)bVar3);
    local_44[2] = cVar2;
    local_44[1] = 3;
    *local_44 = 1;
    local_48 = FUN_00459704(*(char **)(param_3 + 4),local_44 + 4,(uint)(byte)local_44[2]);
    if (local_48 == 0) {
      local_48 = FUN_00445444(param_1,(char *)*param_2,local_44,(uint)bVar3);
      if (((local_48 != 0) && (iVar5 = FUN_004ba35c(param_1,"bcmerror",&local_24), iVar5 == 0)) &&
         (local_24 == 0xffffffe9)) {
        puts("old firmware support only 128 eventssetting only the first 128 events");
        memset(auStack_20,0,0x10);
        local_48 = FUN_00459704(*(char **)(param_3 + 4),auStack_20,0x10);
        if (local_48 == 0) {
          local_48 = FUN_00445444(param_1,"event_msgs",auStack_20,0x10);
        }
      }
    }
    else {
      fprintf(stderr,"Invalid mask %d\n",(uint)(byte)local_44[2]);
    }
  }
  free(local_44);
  return local_48;
}



int FUN_00459ee8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int local_28;
  undefined1 auStack_20 [16];
  int local_10 [2];
  
  bVar1 = true;
  if (*(int *)(param_3 + 4) == 0) {
    memset(PTR_DAT_00551644,0,0x2000);
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (iVar2 == 0) {
      printf("0x");
      for (local_28 = 0xf; -1 < local_28; local_28 = local_28 + -1) {
        if ((*(char *)(local_10[0] + local_28) != '\0') || (local_28 == 0)) {
          bVar1 = false;
        }
        if (!bVar1) {
          printf("%02x",(uint)*(byte *)(local_10[0] + local_28));
        }
      }
      putchar(10);
    }
  }
  else {
    memset(auStack_20,0,0x10);
    iVar2 = FUN_00459704(*(char **)(param_3 + 4),auStack_20,0x10);
    if (iVar2 == 0) {
      iVar2 = FUN_00445444(param_1,(char *)*param_2,auStack_20,0x10);
    }
    else {
      iVar2 = -2;
    }
  }
  return iVar2;
}



int FUN_0045a0d0(int *param_1,int param_2,int param_3)

{
  ushort uVar1;
  int *piVar2;
  undefined2 extraout_var;
  int iVar3;
  int local_20;
  uint local_18;
  undefined4 local_14 [3];
  
  local_18 = 0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_20 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_18,4);
    uVar1 = FUN_00402eb0(local_18);
    local_18 = CONCAT22(extraout_var,uVar1);
    if ((local_20 < 0) || (local_18 == 0)) {
      if (local_18 == 0) {
        printf("invalid chanspec (0x%x)\n",0);
      }
    }
    else {
      FUN_004c02bc(uVar1,PTR_DAT_00551644);
      printf("%s (0x%x)\n",PTR_DAT_00551644,local_18);
      local_20 = 0;
    }
  }
  else {
    iVar3 = atoi((char *)*piVar2);
    if (iVar3 == 1) {
      local_14[0] = 0;
      local_20 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),(char *)local_14,8);
    }
    else {
      iVar3 = atoi((char *)*piVar2);
      if (iVar3 == 2) {
        local_20 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),(char *)&local_18,4);
        if ((-1 < local_20) && (local_18 != 0)) {
          local_20 = FUN_004ba428(param_1,"chanspec",local_18);
        }
      }
      else {
        local_20 = -2;
      }
    }
  }
  return local_20;
}



int FUN_0045a344(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  char *__s;
  size_t sVar2;
  char *pcVar3;
  char *local_18 [3];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_18);
    if (-1 < iVar1) {
      puts(local_18[0]);
      iVar1 = 0;
    }
  }
  else {
    __s = *(char **)(param_3 + 4);
    pcVar3 = (char *)*param_2;
    sVar2 = strlen(__s);
    iVar1 = FUN_00445444(param_1,pcVar3,__s,sVar2 + 1);
  }
  return iVar1;
}



undefined4 FUN_0045a43c(char *param_1)

{
  bool bVar1;
  undefined4 uVar2;
  int iVar3;
  
  if (DAT_00559710 == (undefined4 *)0x0) {
    uVar2 = 1;
  }
  else {
    bVar1 = false;
    while (!bVar1) {
      iVar3 = strcmp((char *)*DAT_00559710,param_1);
      if (iVar3 == 0) {
        return 1;
      }
      bVar1 = true;
    }
    uVar2 = 0;
  }
  return uVar2;
}



void FUN_0045a4e8(ushort *param_1)

{
  ushort uVar1;
  uint uVar2;
  
  if (DAT_00557704 == '\0') {
    uVar1 = *param_1;
  }
  else {
    uVar1 = *param_1 << 8 | *param_1 >> 8;
  }
  *param_1 = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[1];
  }
  else {
    uVar1 = param_1[1] << 8 | param_1[1] >> 8;
  }
  param_1[1] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 2);
  }
  else {
    uVar2 = *(uint *)(param_1 + 2);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 2) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[6];
  }
  else {
    uVar1 = param_1[6] << 8 | param_1[6] >> 8;
  }
  param_1[6] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[7];
  }
  else {
    uVar1 = param_1[7] << 8 | param_1[7] >> 8;
  }
  param_1[7] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 8);
  }
  else {
    uVar2 = *(uint *)(param_1 + 8);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 8) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 10);
  }
  else {
    uVar2 = *(uint *)(param_1 + 10);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 10) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0xc);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0xc);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0xc) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0xe);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0xe);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0xe) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x10);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x10);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x10) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x12);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x12);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x12) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x14);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x14);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x14) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x16);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x16);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x16) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x18);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x18);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x18) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x1a);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x1a);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x1a) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x1c);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x1c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x1c) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[0x1e];
  }
  else {
    uVar1 = param_1[0x1e] << 8 | param_1[0x1e] >> 8;
  }
  param_1[0x1e] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[0x1f];
  }
  else {
    uVar1 = param_1[0x1f] << 8 | param_1[0x1f] >> 8;
  }
  param_1[0x1f] = uVar1;
  return;
}



void FUN_0045ac44(ushort *param_1)

{
  ushort uVar1;
  uint uVar2;
  
  if (DAT_00557704 == '\0') {
    uVar1 = *param_1;
  }
  else {
    uVar1 = *param_1 << 8 | *param_1 >> 8;
  }
  *param_1 = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[1];
  }
  else {
    uVar1 = param_1[1] << 8 | param_1[1] >> 8;
  }
  param_1[1] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 2);
  }
  else {
    uVar2 = *(uint *)(param_1 + 2);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 2) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[6];
  }
  else {
    uVar1 = param_1[6] << 8 | param_1[6] >> 8;
  }
  param_1[6] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[7];
  }
  else {
    uVar1 = param_1[7] << 8 | param_1[7] >> 8;
  }
  param_1[7] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 8);
  }
  else {
    uVar2 = *(uint *)(param_1 + 8);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 8) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 10);
  }
  else {
    uVar2 = *(uint *)(param_1 + 10);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 10) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0xc);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0xc);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0xc) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0xe);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0xe);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0xe) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x10);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x10);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x10) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x12);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x12);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x12) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x14);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x14);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x14) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x16);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x16);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x16) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x18);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x18);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x18) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x1a);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x1a);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x1a) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(param_1 + 0x1c);
  }
  else {
    uVar2 = *(uint *)(param_1 + 0x1c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  *(uint *)(param_1 + 0x1c) = uVar2;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[0x1e];
  }
  else {
    uVar1 = param_1[0x1e] << 8 | param_1[0x1e] >> 8;
  }
  param_1[0x1e] = uVar1;
  if (DAT_00557704 == '\0') {
    uVar1 = param_1[0x1f];
  }
  else {
    uVar1 = param_1[0x1f] << 8 | param_1[0x1f] >> 8;
  }
  param_1[0x1f] = uVar1;
  return;
}



void FUN_0045b3a0(void)

{
  fwrite("Too few arguments\n",1,0x12,stderr);
  fwrite("wl cac_addts ver dtoken tid dir psb up a b c d e ...\n",1,0x35,stderr);
  fwrite("\twhere ver is the structure version\n",1,0x24,stderr);
  fwrite("\twhere dtoken is the dialog token [range 1-255]\n",1,0x30,stderr);
  fwrite("\twhere tid is the tspec identifier [range 0-7]\n",1,0x2f,stderr);
  fwrite("\twhere dir is direction [uplink | downlink | bi-directional]\n",1,0x3d,stderr);
  fwrite("\twhere psb is power save mode [legacy|U-APSD]\n",1,0x2e,stderr);
  fwrite("\twhere up is user priority [range 0-7]\n",1,0x27,stderr);
  fwrite("\twhere a is the nominal MSDU size\n",1,0x22,stderr);
  fwrite("\twhere b is bool for fixed size msdu [ 0 and 1]\n",1,0x30,stderr);
  fwrite("\twhere c is the maximum MSDU size\n",1,0x22,stderr);
  fwrite("\twhere d is the minimum service interval\n",1,0x29,stderr);
  fwrite("\twhere e is the maximum service interval\n",1,0x29,stderr);
  fwrite("\twhere f is the inactivity interval\n",1,0x24,stderr);
  fwrite("\twhere g is the suspension interval\n",1,0x24,stderr);
  fwrite("\twhere h is the minimum data rate\n",1,0x22,stderr);
  fwrite("\twhere i is the mean data rate\n",1,0x1f,stderr);
  fwrite("\twhere j is the peak data rate\n",1,0x1f,stderr);
  fwrite("\twhere k is the max burst size\n",1,0x1f,stderr);
  fwrite("\twhere l is the delay bound\n",1,0x1c,stderr);
  fwrite("\twhere m is the surplus bandwidth [fixed point notation]\n",1,0x39,stderr);
  fwrite("\twhere n is the minimum PHY rate\n",1,0x21,stderr);
  return;
}



void FUN_0045b6e0(void)

{
  fwrite("Too few arguments\n",1,0x12,stderr);
  fwrite("wl cac_delts ver a b c \n",1,0x18,stderr);
  fwrite("\twhere ver is the tspec version\n",1,0x20,stderr);
  fwrite("\twhere a is byte[0] of tsinfo (bits 0-7)\n",1,0x29,stderr);
  fwrite("\twhere b is byte[1] of tsinfo (bits 8-15)\n",1,0x2a,stderr);
  fwrite("\twhere c is byte[2] of tsinfo (bits 16-23)\n",1,0x2b,stderr);
  return;
}



int FUN_0045b7e0(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  long lVar5;
  long lVar6;
  int local_88;
  byte local_84;
  byte local_83;
  uint local_80;
  uint local_7c;
  uint local_58;
  int local_54;
  ushort local_50 [4];
  byte local_48;
  byte local_47;
  undefined1 local_46;
  ushort local_44;
  undefined2 local_42;
  long local_40;
  long local_3c;
  long local_38;
  long local_34;
  long local_2c;
  long local_28;
  long local_24;
  long local_20;
  long local_1c;
  uint local_18;
  undefined2 local_14;
  undefined1 local_10;
  char *local_c;
  
  local_58 = 0;
  local_54 = 0;
  local_c = (char *)0x0;
  iVar2 = FUN_004ba1f8(param_1,"apsta",(char *)&local_54,4);
  if (iVar2 != 0) {
    return iVar2;
  }
  if (local_54 == 0) {
    iVar2 = FUN_004b9f94(param_1,0x75,(char *)&local_58,4);
    if (iVar2 != 0) {
      return iVar2;
    }
    if (DAT_00557704 == '\0') {
      bVar1 = local_58 != 0;
    }
    else {
      bVar1 = (((local_58 & 0xff) != 0 || (local_58 & 0xff00) != 0) || (local_58 & 0xff0000) != 0)
              || local_58 >> 0x18 != 0;
    }
    if (bVar1) {
      fwrite("This command can ONLY be executed on a STA or APSTA\n",1,0x34,stderr);
      return 0;
    }
  }
  iVar2 = strcmp((char *)*param_3,"cac_addts");
  if (iVar2 == 0) {
    local_88 = 1;
  }
  else {
    iVar2 = strcmp((char *)*param_3,"cac_delts");
    if (iVar2 != 0) {
      fwrite("unknown command\n",1,0x10,stderr);
      return -0x2c;
    }
    local_88 = 2;
  }
  piVar3 = param_3 + 1;
  if (*piVar3 == 0) {
    if (local_88 == 1) {
      FUN_0045b3a0();
    }
    else {
      FUN_0045b6e0();
    }
    return -2;
  }
  memset(local_50,0,0x44);
  pcVar4 = (char *)*piVar3;
  iVar2 = strcmp(pcVar4,"UDL");
  if (iVar2 != 0) {
    strcmp(pcVar4,"UUL");
  }
  if (local_88 == 1) {
    for (local_80 = 0; piVar3[local_80] != 0; local_80 = local_80 + 1) {
    }
    if (local_80 < 0x14) {
      FUN_0045b3a0();
      return -0x2c;
    }
    local_50[1] = 0x40;
    lVar5 = strtol((char *)*piVar3,&local_c,0);
    local_50[0] = (ushort)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[2],&local_c,0);
    local_10 = (undefined1)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[3],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    pcVar4 = (char *)param_3[4];
    iVar2 = strcmp(pcVar4,"uplink");
    if (iVar2 == 0) {
      local_84 = 0;
    }
    else {
      iVar2 = strcmp(pcVar4,"downlink");
      if (iVar2 == 0) {
        local_84 = 0x20;
      }
      else {
        iVar2 = strcmp(pcVar4,"bi-directional");
        if (iVar2 != 0) {
          return -0x2c;
        }
        local_84 = 0x60;
      }
    }
    pcVar4 = (char *)param_3[5];
    iVar2 = strcmp(pcVar4,"legacy");
    if (iVar2 == 0) {
      local_83 = 0;
    }
    else {
      iVar2 = strcmp(pcVar4,"U-APSD");
      if (iVar2 != 0) {
        return -0x2c;
      }
      local_83 = 4;
    }
    lVar6 = strtol((char *)param_3[6],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_48 = (char)lVar5 << 1 | local_84 | 0x80;
    local_47 = (char)lVar6 << 3 | local_83;
    local_46 = 0;
    lVar5 = strtol((char *)param_3[7],&local_c,0);
    local_44 = (ushort)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[8],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    if (lVar5 == 1) {
      local_44 = local_44 | 0x8000;
    }
    lVar5 = strtol((char *)param_3[9],&local_c,0);
    local_42 = (undefined2)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_40 = strtol((char *)param_3[10],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_3c = strtol((char *)param_3[0xb],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_38 = strtol((char *)param_3[0xc],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_34 = strtol((char *)param_3[0xd],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_2c = strtol((char *)param_3[0xe],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_28 = strtol((char *)param_3[0xf],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_24 = strtol((char *)param_3[0x10],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_20 = strtol((char *)param_3[0x11],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_1c = strtol((char *)param_3[0x12],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[0x13],&local_c,0);
    local_14 = (undefined2)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    local_18 = strtol((char *)param_3[0x14],&local_c,0);
    if (*local_c != '\0') {
      return -0x2c;
    }
    printf("Setting min_phy_rate to 0x%x\n",local_18);
  }
  else {
    for (local_7c = 0; piVar3[local_7c] != 0; local_7c = local_7c + 1) {
    }
    if (local_7c < 4) {
      FUN_0045b6e0();
      return -0x2c;
    }
    local_50[1] = 0x40;
    lVar5 = strtol((char *)*piVar3,&local_c,0);
    local_50[0] = (ushort)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[2],&local_c,0);
    local_48 = (byte)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[3],&local_c,0);
    local_47 = (byte)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
    lVar5 = strtol((char *)param_3[4],&local_c,0);
    local_46 = (undefined1)lVar5;
    if (*local_c != '\0') {
      return -0x2c;
    }
  }
  FUN_0045a4e8(local_50);
  iVar2 = FUN_00445444(param_1,(char *)*param_2,local_50,0x44);
  return iVar2;
}



int FUN_0045c414(int *param_1,undefined4 *param_2)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  int local_28;
  uint *local_14;
  uint local_10;
  int local_c;
  
  local_c = 0;
  iVar2 = FUN_004ba1f8(param_1,"apsta",(char *)&local_c,4);
  if (iVar2 != 0) {
    return iVar2;
  }
  if (local_c == 0) {
    iVar2 = FUN_004b9f94(param_1,0x75,(char *)&local_10,4);
    if (iVar2 != 0) {
      return iVar2;
    }
    if (DAT_00557704 == '\0') {
      bVar1 = local_10 != 0;
    }
    else {
      bVar1 = (((local_10 & 0xff) != 0 || (local_10 & 0xff00) != 0) || (local_10 & 0xff0000) != 0)
              || local_10 >> 0x18 != 0;
    }
    if (bVar1) {
      fwrite("This command can ONLY be executed on a STA or APSTA\n",1,0x34,stderr);
      return 0;
    }
  }
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
  if (-1 < iVar2) {
    if (DAT_00557704 == '\0') {
      uVar3 = *local_14;
    }
    else {
      uVar3 = *local_14;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *local_14 = uVar3;
    for (local_28 = 0; local_28 < (int)*local_14; local_28 = local_28 + 1) {
      printf("tsinfo 0x%02X 0x%02X 0x%02X  TID %d  User Prio %d  Direction %d\n",
             (uint)*(byte *)((int)local_14 + local_28 * 3 + 4),
             (uint)*(byte *)((int)local_14 + local_28 * 3 + 5),
             (uint)*(byte *)((int)local_14 + local_28 * 3 + 6),
             (int)(*(byte *)((int)local_14 + local_28 * 3 + 4) & 0x1e) >> 1,
             (int)(*(byte *)((int)local_14 + local_28 * 3 + 5) & 0x38) >> 3,
             (int)(*(byte *)((int)local_14 + local_28 * 3 + 4) & 0x60) >> 5);
    }
    iVar2 = 0;
  }
  return iVar2;
}



int FUN_0045c74c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  uint local_68;
  ushort *local_58;
  uint local_54;
  undefined1 auStack_50 [8];
  undefined1 local_48;
  undefined1 local_47;
  undefined1 local_46;
  char *local_c;
  
  local_c = (char *)0x0;
  local_68 = 0;
  iVar1 = FUN_004b9f94(param_1,0x75,(char *)&local_54,4);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                 local_54 >> 0x18;
    }
    if (local_54 == 0) {
      for (; ((undefined4 *)(param_3 + 4))[local_68] != 0; local_68 = local_68 + 1) {
      }
      if (local_68 < 3) {
        fwrite("Too few arguments\n",1,0x12,stderr);
        fwrite("wl cac_tspec 0xaa 0xbb 0xcc \n",1,0x1d,stderr);
        fwrite("\twhere 0xaa is byte[0] of tsinfo (bits 0-7)\n",1,0x2c,stderr);
        fwrite("\twhere 0xbb is byte[1] of tsinfo (bits 8-15)\n",1,0x2d,stderr);
        fwrite("\twhere 0xcc is byte[2] of tsinfo (bits 16-23)\n",1,0x2e,stderr);
        iVar1 = -0x2c;
      }
      else {
        memset(auStack_50,0,0x44);
        lVar2 = strtol(*(char **)(param_3 + 4),&local_c,0);
        local_48 = (undefined1)lVar2;
        if (*local_c == '\0') {
          lVar2 = strtol(*(char **)(param_3 + 8),&local_c,0);
          local_47 = (undefined1)lVar2;
          if (*local_c == '\0') {
            lVar2 = strtol(*(char **)(param_3 + 0xc),&local_c,0);
            local_46 = (undefined1)lVar2;
            if (*local_c == '\0') {
              iVar1 = FUN_00445198(param_1,(char *)*param_2,auStack_50,0x44,&local_58);
              if (-1 < iVar1) {
                FUN_0045ac44(local_58);
                FUN_0045d554(local_58);
                iVar1 = 0;
              }
            }
            else {
              iVar1 = -0x2c;
            }
          }
          else {
            iVar1 = -0x2c;
          }
        }
        else {
          iVar1 = -0x2c;
        }
      }
    }
    else {
      fwrite("This command can only be executed on the STA\n",1,0x2d,stderr);
      iVar1 = -1;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int FUN_0045cadc(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ulong uVar2;
  ulong uVar3;
  ulong uVar4;
  ulong uVar5;
  int iVar6;
  ulong uVar7;
  char *pcVar8;
  size_t sVar9;
  int *piVar10;
  int *local_res8;
  int local_50;
  ulong local_34 [4];
  ulong local_24;
  ulong local_20;
  ulong local_1c;
  ulong local_18;
  int local_14 [2];
  
  local_14[0] = 0;
  local_res8 = (int *)(param_3 + 4);
  iVar6 = FUN_004b9f94(param_1,0x75,(char *)local_14,4);
  puVar1 = PTR_DAT_00551644;
  if (-1 < iVar6) {
    if (local_14[0] == 0) {
      printf("%s: AP only\n",(char *)*param_2);
      iVar6 = -1;
    }
    else {
      *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
      pcVar8 = puVar1 + 4;
      pcVar8[0] = 'm';
      pcVar8[1] = 'a';
      pcVar8[2] = 'x';
      pcVar8[3] = 'b';
      pcVar8 = puVar1 + 8;
      pcVar8[0] = 'w';
      pcVar8[1] = '_';
      pcVar8[2] = 'p';
      pcVar8[3] = 'a';
      pcVar8 = puVar1 + 0xc;
      pcVar8[0] = 'r';
      pcVar8[1] = 'a';
      pcVar8[2] = 'm';
      pcVar8[3] = 's';
      puVar1[0x10] = '\0';
      iVar6 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
      if (-1 < iVar6) {
        memcpy(local_34,PTR_DAT_00551644,0x10);
        if (*local_res8 == 0) {
          puts("WME bandwidth limit: ");
          for (local_50 = 0; local_50 < 4; local_50 = local_50 + 1) {
            printf("%s: bandwidth limit %d\n",&UNK_005181a8 + local_50 * 6,local_34[local_50]);
          }
        }
        else {
          local_24 = local_34[0];
          local_20 = local_34[1];
          local_1c = local_34[2];
          local_18 = local_34[3];
          uVar2 = local_24;
          uVar3 = local_20;
          uVar4 = local_1c;
          uVar5 = local_18;
          do {
            local_18 = uVar5;
            local_1c = uVar4;
            local_20 = uVar3;
            local_24 = uVar2;
            puVar1 = PTR_DAT_00551644;
            pcVar8 = (char *)*local_res8;
            piVar10 = local_res8 + 1;
            if (pcVar8 == (char *)0x0) {
              *(undefined4 *)PTR_DAT_00551644 = 0x5f656d77;
              pcVar8 = puVar1 + 4;
              pcVar8[0] = 'm';
              pcVar8[1] = 'a';
              pcVar8[2] = 'x';
              pcVar8[3] = 'b';
              pcVar8 = puVar1 + 8;
              pcVar8[0] = 'w';
              pcVar8[1] = '_';
              pcVar8[2] = 'p';
              pcVar8[3] = 'a';
              pcVar8 = puVar1 + 0xc;
              pcVar8[0] = 'r';
              pcVar8[1] = 'a';
              pcVar8[2] = 'm';
              pcVar8[3] = 's';
              puVar1[0x10] = '\0';
              puVar1 = PTR_DAT_00551644;
              sVar9 = strlen(PTR_DAT_00551644);
              memcpy(puVar1 + sVar9 + 1,&local_24,0x10);
              iVar6 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,0x2000);
              return iVar6;
            }
            local_res8 = local_res8 + 2;
            if ((char *)*piVar10 == (char *)0x0) {
              printf("Need value following %s\n",pcVar8);
              return -0x2c;
            }
            uVar7 = strtoul((char *)*piVar10,(char **)0x0,0);
            iVar6 = strcmp(pcVar8,"be");
            uVar2 = uVar7;
            uVar3 = local_20;
            uVar4 = local_1c;
            uVar5 = local_18;
          } while ((((iVar6 == 0) ||
                    (iVar6 = strcmp(pcVar8,"bk"), uVar2 = local_24, uVar3 = uVar7, uVar4 = local_1c,
                    uVar5 = local_18, iVar6 == 0)) ||
                   (iVar6 = strcmp(pcVar8,"vi"), uVar2 = local_24, uVar3 = local_20, uVar4 = uVar7,
                   uVar5 = local_18, iVar6 == 0)) ||
                  (iVar6 = strcmp(pcVar8,"vo"), uVar2 = local_24, uVar3 = local_20, uVar4 = local_1c
                  , uVar5 = uVar7, iVar6 == 0));
          printf("Unknown access category: %s\n",pcVar8);
          iVar6 = -0x2c;
        }
      }
    }
  }
  return iVar6;
}



int FUN_0045cf2c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined3 extraout_var;
  int local_30;
  int *local_20;
  uint local_1c [2];
  undefined1 auStack_14 [12];
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("MAC address must be specified");
    iVar2 = -0x2c;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      puts("Malformed MAC address parameter");
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004b9f94(param_1,0x75,(char *)local_1c,4);
      if (iVar2 == 0) {
        if (DAT_00557704 != '\0') {
          local_1c[0] = local_1c[0] << 0x18 | (local_1c[0] & 0xff00) << 8 |
                        (local_1c[0] & 0xff0000) >> 8 | local_1c[0] >> 0x18;
        }
        iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_14,6,&local_20);
        if (-1 < iVar2) {
          for (local_30 = 0; local_30 < *local_20; local_30 = local_30 + 1) {
            printf("tsinfo 0x%02X 0x%02X 0x%02X  TID %d  User Prio %d  Direction %d\n",
                   (uint)*(byte *)((int)local_20 + local_30 * 3 + 4),
                   (uint)*(byte *)((int)local_20 + local_30 * 3 + 5),
                   (uint)*(byte *)((int)local_20 + local_30 * 3 + 6),
                   (int)(*(byte *)((int)local_20 + local_30 * 3 + 4) & 0x1e) >> 1,
                   (int)(*(byte *)((int)local_20 + local_30 * 3 + 5) & 0x38) >> 3,
                   (int)(*(byte *)((int)local_20 + local_30 * 3 + 4) & 0x60) >> 5);
          }
          iVar2 = 0;
        }
      }
    }
  }
  return iVar2;
}



int FUN_0045d1ec(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  long lVar3;
  undefined3 extraout_var;
  uint local_68;
  ushort *local_5c;
  undefined1 auStack_58 [16];
  undefined1 local_48;
  undefined1 local_47;
  undefined1 local_46;
  char *local_c;
  
  for (local_68 = 0; ((undefined4 *)(param_3 + 4))[local_68] != 0; local_68 = local_68 + 1) {
  }
  if (local_68 < 4) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    fwrite("wl cac_tspec 0xaa 0xbb 0xcc xx:xx:xx:xx:xx:xx\n",1,0x2e,stderr);
    fwrite("\twhere 0xaa is byte[0] of tsinfo (bits 0-7)\n",1,0x2c,stderr);
    fwrite("\twhere 0xbb is byte[1] of tsinfo (bits 8-15)\n",1,0x2d,stderr);
    fwrite("\twhere 0xcc is byte[2] of tsinfo (bits 16-23)\n",1,0x2e,stderr);
    fwrite("\twhere xx:xx:xx:xx:xx:xx is mac address )\n",1,0x2a,stderr);
    iVar2 = -0x2c;
  }
  else {
    memset(auStack_58,0,0x4c);
    lVar3 = strtol(*(char **)(param_3 + 4),&local_c,0);
    local_48 = (undefined1)lVar3;
    if (*local_c == '\0') {
      lVar3 = strtol(*(char **)(param_3 + 8),&local_c,0);
      local_47 = (undefined1)lVar3;
      if (*local_c == '\0') {
        lVar3 = strtol(*(char **)(param_3 + 0xc),&local_c,0);
        local_46 = (undefined1)lVar3;
        if (*local_c == '\0') {
          if (*(int *)(param_3 + 0x10) == 0) {
            puts("MAC address must be specified");
            iVar2 = -0x2c;
          }
          else {
            bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x10),auStack_58);
            if (CONCAT31(extraout_var,bVar1) == 0) {
              puts("Malformed MAC address parameter");
              iVar2 = -0x2c;
            }
            else {
              iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_58,0x4c,&local_5c);
              if (-1 < iVar2) {
                FUN_0045ac44(local_5c);
                FUN_0045d554(local_5c);
                iVar2 = 0;
              }
            }
          }
        }
        else {
          iVar2 = -0x2c;
        }
      }
      else {
        iVar2 = -0x2c;
      }
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



void FUN_0045d554(ushort *param_1)

{
  uint uVar1;
  int iVar2;
  char *param2;
  char *local_18;
  
  if (*param_1 == 2) {
    if (param_1[1] < 0x40) {
      printf("\tTSPEC arg length too short: expected %d; got %d\n",0x40,(uint)param_1[1]);
    }
    else {
      uVar1 = *(uint *)(param_1 + 2) & 7;
      if (uVar1 == 1) {
        local_18 = "ACCEPTED";
      }
      else if (uVar1 == 0) {
        local_18 = "PENDING";
      }
      else if (uVar1 == 2) {
        local_18 = "REJECTED";
      }
      else {
        local_18 = "UNKNOWN";
      }
      printf("version %d\n",(uint)*param_1);
      printf("length %d\n",(uint)param_1[1]);
      printf("TID %d %s\n",(int)((byte)param_1[4] & 0x1e) >> 1,local_18);
      printf("tsinfo 0x%02x 0x%02x 0x%02x\n",(uint)(byte)param_1[4],
             (uint)*(byte *)((int)param_1 + 9),(uint)(byte)param_1[5]);
      if ((int)(*(byte *)((int)param_1 + 9) & 4) >> 2 == 0) {
        printf("AC [%d] : Legacy Power save\n",
               (uint)(byte)(&DAT_00519a18)
                           [(byte)(&DAT_00519a20)[(int)(*(byte *)((int)param_1 + 9) & 0x38) >> 3]]);
      }
      else {
        uVar1 = (uint)(byte)(&DAT_00519a18)
                            [(byte)(&DAT_00519a20)[(int)(*(byte *)((int)param_1 + 9) & 0x38) >> 3]];
        iVar2 = (int)((byte)param_1[4] & 0x60) >> 5;
        if (iVar2 == 1) {
          printf("AC[%d] : Delivery enabled\n",uVar1);
        }
        else if (iVar2 == 3) {
          printf("AC[%d] : Trig & Delv enabled\n",uVar1);
        }
        else if (iVar2 == 0) {
          printf("AC[%d] : Trigger enabled\n",uVar1);
        }
      }
      if ((short)param_1[6] < 0) {
        param2 = "fixed size";
      }
      else {
        param2 = "";
      }
      printf("nom_msdu_size %d %s\n",param_1[6] & 0x7fff,param2);
      printf("max_msdu_size %d\n",(uint)param_1[7]);
      printf("min_srv_interval %d\n",*(int *)(param_1 + 8));
      printf("max_srv_interval %d\n",*(int *)(param_1 + 10));
      printf("inactivity_interval %d\n",*(int *)(param_1 + 0xc));
      printf("suspension_interval %d\n",*(int *)(param_1 + 0xe));
      printf("srv_start_time %d\n",*(int *)(param_1 + 0x10));
      printf("min_data_rate %d\n",*(int *)(param_1 + 0x12));
      printf("mean_data_rate %d\n",*(int *)(param_1 + 0x14));
      printf("peak_data_rate %d\n",*(int *)(param_1 + 0x16));
      printf("max_burst_size %d\n",*(int *)(param_1 + 0x18));
      printf("delay_bound %d\n",*(int *)(param_1 + 0x1a));
      printf("min_phy_rate %d\n",*(int *)(param_1 + 0x1c));
      printf("surplus_bw %d\n",(uint)param_1[0x1e]);
      printf("medium_time %d\n",(uint)param_1[0x1f]);
    }
  }
  else {
    printf("\tIncorrect version of TSPEC struct: expected %d; got %d\n",2,(uint)*param_1);
  }
  return;
}



int FUN_0045da10(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  long lVar3;
  undefined3 extraout_var;
  uint local_68;
  undefined4 uStack_5c;
  char *local_58;
  undefined1 auStack_54 [8];
  ushort local_4c [4];
  undefined1 local_44;
  undefined1 local_43;
  undefined1 local_42;
  
  local_58 = (char *)0x0;
  for (local_68 = 0; ((undefined4 *)(param_3 + 4))[local_68] != 0; local_68 = local_68 + 1) {
  }
  if (local_68 < 4) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    fwrite("wl cac_delts_ea ver 0xaa 0xbb 0xcc xx:xx:xx:xx:xx:xx\n",1,0x35,stderr);
    fwrite("\twhere ver is the tspec version\n",1,0x20,stderr);
    fwrite("\twhere 0xaa is byte[0] of tsinfo (bits 0-7)\n",1,0x2c,stderr);
    fwrite("\twhere 0xbb is byte[1] of tsinfo (bits 8-15)\n",1,0x2d,stderr);
    fwrite("\twhere 0xcc is byte[2] of tsinfo (bits 16-23)\n",1,0x2e,stderr);
    fwrite("\twhere xx:xx:xx:xx:xx:xx is mac address )\n",1,0x2a,stderr);
    iVar2 = -0x2c;
  }
  else {
    memset(auStack_54,0,0x4c);
    local_4c[1] = 0x40;
    lVar3 = strtol(*(char **)(param_3 + 4),&local_58,0);
    local_4c[0] = (ushort)lVar3;
    if (*local_58 == '\0') {
      lVar3 = strtol(*(char **)(param_3 + 8),&local_58,0);
      local_44 = (undefined1)lVar3;
      if (*local_58 == '\0') {
        lVar3 = strtol(*(char **)(param_3 + 0xc),&local_58,0);
        local_43 = (undefined1)lVar3;
        if (*local_58 == '\0') {
          lVar3 = strtol(*(char **)(param_3 + 0x10),&local_58,0);
          local_42 = (undefined1)lVar3;
          if (*local_58 == '\0') {
            if (*(int *)(param_3 + 0x14) == 0) {
              puts("MAC address must be specified");
              iVar2 = -0x2c;
            }
            else {
              bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x14),auStack_54);
              if (CONCAT31(extraout_var,bVar1) == 0) {
                puts("Malformed MAC address parameter");
                iVar2 = -0x2c;
              }
              else {
                FUN_0045a4e8(local_4c);
                iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_54,0x4c,&uStack_5c);
                if (-1 < iVar2) {
                  iVar2 = 0;
                }
              }
            }
          }
          else {
            iVar2 = -0x2c;
          }
        }
        else {
          iVar2 = -0x2c;
        }
      }
      else {
        iVar2 = -0x2c;
      }
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_0045ddec(int *param_1,int param_2,undefined4 *param_3)

{
  char *pcVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  char *local_30;
  int local_28;
  uint local_24;
  ushort local_20;
  byte local_18 [8];
  char *local_10;
  uint local_c;
  
  local_30 = "fixed";
  local_18[0] = 0;
  local_18[1] = 0;
  local_18[2] = 0;
  local_18[3] = 0;
  local_18[4] = 0;
  local_10 = (char *)0x0;
  local_c = 0;
  local_20 = 0;
  pcVar1 = (char *)*param_3;
  piVar2 = param_3 + 1;
  if (*piVar2 == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      iVar3 = -1;
    }
    else {
      iVar3 = FUN_004ba1f8(param_1,"txchain",(char *)&local_c,4);
      if (-1 < iVar3) {
        for (local_24 = 0; (int)local_24 < 4; local_24 = local_24 + 1) {
          if ((1 << (local_24 & 0x1f) & local_c) == 0) {
            local_20 = (ushort)(0xf << ((local_24 & 7) << 2)) | local_20;
          }
        }
        iVar3 = FUN_004ba1f8(param_1,pcVar1,(char *)local_18,5);
        if (-1 < iVar3) {
          printf("C3C2C1C0: ");
          for (local_24 = 0; (int)local_24 < 4; local_24 = local_24 + 1) {
            if ((char)local_18[local_24] < '\0') {
              local_30 = "auto";
            }
            printf("0x%04X %s ",(uint)local_20 | local_18[local_24] & 0x33,local_30);
          }
          putchar(10);
        }
      }
    }
  }
  else {
    for (local_28 = 0; piVar2[local_28] != 0; local_28 = local_28 + 1) {
    }
    if (((local_28 < 2) || (3 < local_28)) && (local_28 < 5)) {
      uVar4 = strtol((char *)*piVar2,&local_10,0);
      local_18[0] = (char)uVar4;
      printf("UTX 0x%02x\n",uVar4 & 0xff);
      if (*local_10 == '\0') {
        if (local_28 == 1) {
          local_18[1] = local_18[0];
          local_18[2] = local_18[0];
          local_18[3] = local_18[0];
        }
        else {
          uVar4 = strtol((char *)param_3[2],&local_10,0);
          local_18[1] = (char)uVar4;
          printf("URX 0x%02x\n",uVar4 & 0xff);
          if (*local_10 != '\0') {
            printf("Invaild URX parameter: %s\n",(char *)param_3[3]);
            return -0x2c;
          }
          uVar4 = strtol((char *)param_3[3],&local_10,0);
          local_18[2] = (char)uVar4;
          printf("DTX 0x%02x\n",uVar4 & 0xff);
          if (*local_10 != '\0') {
            printf("Invaild DTX parameter: %s\n",(char *)param_3[4]);
            return -0x2c;
          }
          uVar4 = strtol((char *)param_3[4],&local_10,0);
          local_18[3] = (char)uVar4;
          printf("DRX 0x%02x\n",uVar4 & 0xff);
          if (*local_10 != '\0') {
            printf("Invaild DRX parameter: %s\n",(char *)param_3[5]);
            return -0x2c;
          }
        }
        iVar3 = FUN_004ba2e4(param_1,pcVar1,local_18,5);
      }
      else {
        printf("Invaild UTX parameter: %s\n",(char *)param_3[2]);
        iVar3 = -0x2c;
      }
    }
    else {
      printf("invalid %d args\n",local_28);
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



int FUN_0045e2f4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  int *local_res8;
  int local_20;
  char local_14 [4];
  char *local_10 [2];
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,local_14,4);
    if (-1 < iVar1) {
      printf("txcore offsets qdBm: %d %d %d %d\n",(int)local_14[0],(int)local_14[1],(int)local_14[2]
             ,(int)local_14[3]);
      iVar1 = 0;
    }
  }
  else {
    memset(local_14,0,4);
    local_20 = 0;
    for (; (local_20 < 4 && (*local_res8 != 0)); local_res8 = local_res8 + 1) {
      lVar2 = strtol((char *)*local_res8,local_10,0);
      if (*local_10[0] != '\0') {
        return -0x2c;
      }
      if (0 < lVar2) {
        return -2;
      }
      local_14[local_20] = (char)lVar2;
      local_20 = local_20 + 1;
    }
    iVar1 = FUN_004ba2e4(param_1,(char *)*param_2,local_14,4);
  }
  return iVar1;
}



int FUN_0045e4c8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  int *local_res8;
  byte local_d4;
  char local_d3;
  byte local_d2;
  char local_d1;
  ushort local_d0;
  byte local_cd;
  undefined4 auStack_b8 [3];
  int local_ac;
  char local_a7;
  char local_a6;
  char *local_24;
  uint local_1c;
  byte local_18 [4];
  uint local_14;
  uint local_10;
  
  local_d4 = 0;
  local_d3 = '\0';
  local_d2 = 0;
  local_d1 = '\0';
  local_d0 = 0;
  bVar2 = false;
  local_cd = 0;
  bVar3 = false;
  local_18[0] = 0;
  local_18[1] = 0;
  local_18[2] = 0;
  local_18[3] = 0;
  bVar1 = false;
  local_14 = 0;
  local_10 = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    if ((int)param_2[2] < 0) {
      iVar4 = -1;
    }
    else {
      iVar4 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_14,8);
      if (-1 < iVar4) {
        printf("txcore enabled bitmap (Nsts {4..1}) 0x%02x 0x%02x 0x%02x 0x%02x\n",local_14 >> 0x18,
               local_14 >> 0x10 & 0xff,local_14 >> 8 & 0xff,local_14 & 0xff);
        printf("txcore mask OFDM 0x%02x  CCK 0x%04x\n",local_10 >> 8 & 0xff,
               local_10 & 0xf | local_10 >> 8 & 0x8000);
        iVar4 = 0;
      }
    }
  }
  else {
    iVar4 = atoi((char *)*local_res8);
    if (iVar4 != -1) {
      FUN_004cbd80(auStack_b8,"wl_txcore",0x510500,0);
      while (iVar4 = FUN_004cbe18(auStack_b8,local_res8), iVar4 != -1) {
        if (iVar4 == 1) {
          return -0x2c;
        }
        local_res8 = local_res8 + local_ac;
        if (local_a6 == 's') {
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for streams\n","wl_txcore",local_24
                   );
            return -2;
          }
          local_d3 = '\x01';
          local_d4 = (byte)local_1c & 0xf;
          if (4 < local_d4) {
            fprintf(stderr,"%s: Nsts > %d\n","wl_txcore",local_1c);
          }
        }
        if (local_a6 == 'c') {
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for stf core\n","wl_txcore",
                    local_24);
            return -2;
          }
          local_d1 = '\x01';
          local_d2 = (byte)(local_1c << 4);
          if (local_d2 == 0) {
            fprintf(stderr,"%s: %1d-stream core cannot be zero\n","wl_txcore",(uint)local_d4);
            return -2;
          }
        }
        if (local_a6 == 'o') {
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for streams\n","wl_txcore",local_24
                   );
            return -2;
          }
          bVar3 = true;
          local_cd = (byte)local_1c & 0xf;
          if ((local_1c & 0xf) == 0) {
            fprintf(stderr,"%s: OFDM core cannot be zero\n","wl_txcore");
            return -2;
          }
        }
        if (local_a6 == 'k') {
          if (local_a7 == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for streams\n","wl_txcore",local_24
                   );
            return -2;
          }
          bVar2 = true;
          local_d0 = (ushort)local_1c;
          if (local_d0 == 0) {
            fprintf(stderr,"%s: CCK core cannot be zero\n","wl_txcore");
            return -2;
          }
        }
        if ((local_d3 != '\0') && (local_d1 != '\0')) {
          local_d1 = '\0';
          local_d3 = '\0';
          bVar1 = true;
          local_18[(byte)(local_d4 - 1)] = local_d2 | local_d4;
        }
      }
      if (local_d3 != local_d1) {
        fprintf(stderr,"%s: require to set both -s x -c y\n","wl_txcore");
        return -2;
      }
      if (bVar1) {
        local_14 = local_14 | local_18[0] | (uint)local_18[1] << 8 | (uint)local_18[2] << 0x10 |
                   (uint)local_18[3] << 0x18;
      }
      if (bVar2) {
        local_10 = local_10 | local_d0 & 0xf | (local_d0 & 0xf000) << 8;
      }
      if (bVar3) {
        local_10 = local_10 | (uint)local_cd << 8;
      }
    }
    iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_14,8);
  }
  return iVar4;
}



int FUN_0045eb10(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint param1;
  undefined2 local_14;
  undefined2 local_12;
  undefined2 local_10;
  int local_c;
  
  local_c = 0;
  if (*(char **)(param_3 + 4) == (char *)0x0) {
    iVar1 = -0x2c;
  }
  else {
    param1 = atoi(*(char **)(param_3 + 4));
    if (param1 < 7) {
      local_12 = (undefined2)param1;
      local_14 = 0xa5a5;
      if (*(char **)(param_3 + 8) == (char *)0x0) {
        iVar1 = FUN_0044527c(param_1,"txfifo_sz",&local_14,6,&local_c);
        iVar1 = -(iVar1 >> 0x1f);
        if (iVar1 == 0) {
          printf("fifo %d size %d\n",param1,(uint)*(ushort *)(local_c + 4));
        }
      }
      else {
        iVar1 = atoi(*(char **)(param_3 + 8));
        local_10 = (undefined2)iVar1;
        iVar1 = FUN_00445444(param_1,"txfifo_sz",&local_14,6);
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



int FUN_0045ec98(int *param_1,undefined4 param_2,int *param_3)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  int *local_res8;
  uint local_20;
  uint local_1c;
  uint local_18;
  ushort local_14;
  ushort local_12;
  undefined1 local_10;
  undefined1 local_f;
  byte local_e;
  byte local_d;
  uint local_c;
  
  local_20 = 2;
  local_14 = 8;
  local_1c = 0x1e;
  local_c = 0;
  local_12 = 0x1e;
  local_18 = 0x3c;
  local_10 = 2;
  local_f = 0;
  local_e = 10;
  local_d = 2;
  local_res8 = param_3;
  while (piVar2 = local_res8 + 1, *piVar2 != 0) {
    iVar3 = strcasecmp((char *)*piVar2,"scanfrq");
    if (iVar3 == 0) {
      local_res8 = local_res8 + 2;
      if (*local_res8 == 0) {
        fwrite("Missing scanfrq option\n",1,0x17,stderr);
        return -0x2c;
      }
      local_1c = atoi((char *)*local_res8);
    }
    else {
      iVar3 = strcasecmp((char *)*piVar2,"netimeout");
      if (iVar3 == 0) {
        local_res8 = local_res8 + 2;
        if (*local_res8 == 0) {
          fwrite("Missing netimeout option\n",1,0x19,stderr);
          return -0x2c;
        }
        local_18 = atoi((char *)*local_res8);
      }
      else {
        iVar3 = strcasecmp((char *)*piVar2,"rssi_delta");
        if (iVar3 == 0) {
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("Missing rssi_delta option\n",1,0x1a,stderr);
            return -0x2c;
          }
          iVar3 = atoi((char *)*local_res8);
          local_12 = (ushort)iVar3;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar2,"sort");
          if (iVar3 == 0) {
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing sort option\n",1,0x14,stderr);
              return -0x2c;
            }
            local_14 = local_14 & 0xfffe;
            iVar3 = strcasecmp((char *)*local_res8,"listorder");
            if (iVar3 != 0) {
              iVar3 = strcasecmp((char *)*local_res8,"rssi");
              if (iVar3 != 0) {
                fprintf(stderr,"Invalid sort option %s\n",(char *)*local_res8);
                return -0x2c;
              }
              local_14 = local_14 | 1;
            }
          }
          else {
            iVar3 = strcasecmp((char *)*piVar2,"immediateevent");
            if (iVar3 == 0) {
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                fwrite("Missing immediateevent option\n",1,0x1e,stderr);
                return -0x2c;
              }
              iVar3 = strcasecmp((char *)*local_res8,"1");
              if (iVar3 == 0) {
                local_14 = local_14 | 0x100;
              }
              else {
                iVar3 = strcasecmp((char *)*local_res8,"0");
                if (iVar3 != 0) {
                  fwrite("Invalid immediateevent option\n",1,0x1e,stderr);
                  return -0x2c;
                }
                local_14 = local_14 & 0xfeff;
              }
            }
            else {
              iVar3 = strcasecmp((char *)*piVar2,"bkgscan");
              if (iVar3 == 0) {
                local_res8 = local_res8 + 2;
                if (*local_res8 == 0) {
                  fwrite("Missing bkgscan option\n",1,0x17,stderr);
                  return -0x2c;
                }
                local_14 = local_14 & 0xfffb;
                iVar3 = atoi((char *)*local_res8);
                if (iVar3 != 0) {
                  local_14 = local_14 | 4;
                }
              }
              else {
                iVar3 = strcasecmp((char *)*piVar2,"immediate");
                if (iVar3 == 0) {
                  local_14 = local_14 & 0xfff7;
                  local_res8 = local_res8 + 2;
                  if (*local_res8 == 0) {
                    fwrite("Missing immediate option\n",1,0x19,stderr);
                    return -0x2c;
                  }
                  iVar3 = atoi((char *)*local_res8);
                  if (iVar3 != 0) {
                    local_14 = local_14 | 8;
                  }
                }
                else {
                  iVar3 = strcasecmp((char *)*piVar2,"bdscan");
                  if (iVar3 == 0) {
                    local_res8 = local_res8 + 2;
                    if (*local_res8 == 0) {
                      fwrite("Missing bdscan option\n",1,0x16,stderr);
                      return -0x2c;
                    }
                    local_14 = local_14 & 0xffdf;
                    iVar3 = atoi((char *)*local_res8);
                    if (iVar3 != 0) {
                      local_14 = local_14 | 0x20;
                    }
                  }
                  else {
                    iVar3 = strcasecmp((char *)*piVar2,"separate");
                    if (iVar3 == 0) {
                      local_res8 = local_res8 + 2;
                      if (*local_res8 == 0) {
                        fwrite("Missing seperate option\n",1,0x18,stderr);
                        return -1;
                      }
                      local_14 = local_14 & 0xf7ff;
                      iVar3 = atoi((char *)*local_res8);
                      if (iVar3 != 0) {
                        local_14 = local_14 | 0x800;
                      }
                    }
                    else {
                      iVar3 = strcasecmp((char *)*piVar2,"adapt");
                      if (iVar3 == 0) {
                        local_res8 = local_res8 + 2;
                        if (*local_res8 == 0) {
                          fwrite("Missing adaptive scan option\n",1,0x1d,stderr);
                          return -0x2c;
                        }
                        local_14 = local_14 & 0xff3f;
                        iVar3 = strcasecmp((char *)*local_res8,"off");
                        if (iVar3 != 0) {
                          iVar3 = strcasecmp((char *)*local_res8,"smart");
                          if (iVar3 == 0) {
                            local_14 = local_14 | 0x40;
                          }
                          else {
                            iVar3 = strcasecmp((char *)*local_res8,"strict");
                            if (iVar3 == 0) {
                              local_14 = local_14 | 0x80;
                            }
                            else {
                              iVar3 = strcasecmp((char *)*local_res8,"slow");
                              if (iVar3 != 0) {
                                fprintf(stderr,"Invalid adaptive scan option %s\n",
                                        (char *)*local_res8);
                                return -0x2c;
                              }
                              local_14 = local_14 | 0xc0;
                            }
                          }
                        }
                      }
                      else {
                        iVar3 = strcasecmp((char *)*piVar2,"bestn");
                        if (iVar3 == 0) {
                          local_res8 = local_res8 + 2;
                          iVar3 = atoi((char *)*local_res8);
                          local_10 = (undefined1)iVar3;
                        }
                        else {
                          iVar3 = strcasecmp((char *)*piVar2,"mscan");
                          if (iVar3 == 0) {
                            local_res8 = local_res8 + 2;
                            iVar3 = atoi((char *)*local_res8);
                            local_f = (undefined1)iVar3;
                          }
                          else {
                            iVar3 = strcasecmp((char *)*piVar2,"repeat");
                            if (iVar3 == 0) {
                              local_res8 = local_res8 + 2;
                              uVar1 = atoi((char *)*local_res8);
                              local_e = (byte)uVar1;
                              if ((local_e == 0) || (0x14 < local_e)) {
                                fprintf(stderr,"repeat %d out of range (1-20)\n",uVar1 & 0xff);
                                return -0x2c;
                              }
                            }
                            else {
                              iVar3 = strcasecmp((char *)*piVar2,"exp");
                              if (iVar3 == 0) {
                                local_res8 = local_res8 + 2;
                                uVar1 = atoi((char *)*local_res8);
                                local_d = (byte)uVar1;
                                if ((local_d == 0) || (5 < local_d)) {
                                  fprintf(stderr,"exp %d out of range (1-5)\n",uVar1 & 0xff);
                                  return -2;
                                }
                              }
                              else {
                                iVar3 = strcasecmp((char *)*piVar2,"slowfrq");
                                if (iVar3 == 0) {
                                  local_res8 = local_res8 + 2;
                                  if (*local_res8 == 0) {
                                    fwrite("Missing slowfrq option\n",1,0x17,stderr);
                                    return -0x2c;
                                  }
                                  local_c = atoi((char *)*local_res8);
                                }
                                else {
                                  iVar3 = strcasecmp((char *)*piVar2,"bestn_bssid");
                                  if (iVar3 == 0) {
                                    local_res8 = local_res8 + 2;
                                    if (*local_res8 == 0) {
                                      fwrite("Missing bestn_bssid option\n",1,0x1b,stderr);
                                      return -0x2c;
                                    }
                                    local_14 = local_14 & 0xefff;
                                    iVar3 = atoi((char *)*local_res8);
                                    if (iVar3 != 0) {
                                      local_14 = local_14 | 0x1000;
                                    }
                                  }
                                  else {
                                    iVar3 = strcasecmp((char *)*piVar2,"auto");
                                    if (iVar3 == 0) {
                                      local_res8 = local_res8 + 2;
                                      if (*local_res8 == 0) {
                                        fwrite("Missing auto option\n",1,0x14,stderr);
                                        return -0x2c;
                                      }
                                      iVar3 = strcasecmp((char *)*local_res8,"1");
                                      if (iVar3 == 0) {
                                        local_14 = local_14 | 0x10;
                                      }
                                      else {
                                        iVar3 = strcasecmp((char *)*local_res8,"0");
                                        if (iVar3 != 0) {
                                          fwrite("Invalid auto option\n",1,0x14,stderr);
                                          return -0x2c;
                                        }
                                        local_14 = local_14 & 0xffef;
                                      }
                                    }
                                    else {
                                      iVar3 = strcasecmp((char *)*piVar2,"event");
                                      if (iVar3 != 0) {
                                        fprintf(stderr,"Invalid parameter %s\n",(char *)*piVar2);
                                        return -0x2c;
                                      }
                                      local_res8 = local_res8 + 2;
                                      if (*local_res8 == 0) {
                                        fwrite("Missing event option\n",1,0x15,stderr);
                                        return -0x2c;
                                      }
                                      iVar3 = strcasecmp((char *)*local_res8,"none");
                                      if (iVar3 == 0) {
                                        local_14 = local_14 & 0x9fff;
                                      }
                                      else {
                                        iVar3 = strcasecmp((char *)*local_res8,"reconnect");
                                        if (iVar3 == 0) {
                                          local_14 = local_14 & 0xbfff | 0x2000;
                                        }
                                        else {
                                          iVar3 = strcasecmp((char *)*local_res8,"recover");
                                          if (iVar3 == 0) {
                                            local_14 = local_14 & 0xdfff | 0x4000;
                                          }
                                          else {
                                            iVar3 = strcasecmp((char *)*local_res8,"all");
                                            if (iVar3 != 0) {
                                              fwrite("Invalid event option\n",1,0x15,stderr);
                                              return -0x2c;
                                            }
                                            local_14 = local_14 | 0x6000;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ((((local_14 & 0xc0) == 0xc0) && (local_c == 0)) ||
     (((local_14 & 0xc0) != 0xc0 && (local_c != 0)))) {
    fwrite("SLOW_ADAPT flag and slowfrq value not match\n",1,0x2c,stderr);
    return -2;
  }
  if (DAT_00557704 != '\0') {
    local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
               local_20 >> 0x18;
    local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
               local_1c >> 0x18;
    local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
               local_18 >> 0x18;
    local_14 = local_14 << 8 | local_14 >> 8;
    local_12 = local_12 << 8 | local_12 >> 8;
    local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
              local_c >> 0x18;
  }
  iVar3 = FUN_004ba2e4(param_1,"pfn_set",&local_20,0x18);
  if (iVar3 != 0) {
    return iVar3;
  }
  return 0;
}



undefined4 FUN_0045ff30(char param_1)

{
  undefined4 uVar1;
  
  if ((((param_1 < '0') || ('9' < param_1)) && (param_1 < 'a')) &&
     ((('z' < param_1 && (param_1 < 'A')) && ('Z' < param_1)))) {
    uVar1 = 0;
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



char FUN_0045ffc8(char param_1)

{
  char cVar1;
  
  if ((param_1 < '0') || ('9' < param_1)) {
    if ((param_1 < 'a') || ('z' < param_1)) {
      if ((param_1 < 'A') || ('Z' < param_1)) {
        fwrite("non-hex\n",1,8,stderr);
        cVar1 = -1;
      }
      else {
        cVar1 = param_1 + -0x37;
      }
    }
    else {
      cVar1 = param_1 + -0x57;
    }
  }
  else {
    cVar1 = param_1 + -0x30;
  }
  return cVar1;
}



int FUN_004600bc(int *param_1,undefined4 param_2,int *param_3)

{
  char cVar1;
  size_t *__s;
  int iVar2;
  ulong uVar3;
  int *piVar4;
  uint uVar5;
  size_t sVar6;
  int *local_res8;
  int local_48;
  int local_44;
  int local_40;
  size_t *local_3c;
  
  __s = (size_t *)malloc(0x380);
  if (__s == (size_t *)0x0) {
    fprintf(stderr,"Failed to allocate buffer for %d bytes\n",0x380);
    local_48 = -0x1b;
  }
  else {
    memset(__s,0,0x380);
    local_3c = __s;
    for (local_44 = 0; local_44 < 0x10; local_44 = local_44 + 1) {
      local_3c[0xb] = 0;
      local_3c[0xc] = 0;
      local_3c[0xd] = 0;
      local_3c[10] = 1;
      local_3c[9] = 0;
      local_3c = local_3c + 0xe;
    }
    local_40 = -1;
    local_res8 = param_3;
    local_3c = __s;
    while (piVar4 = local_res8 + 1, *piVar4 != 0) {
      iVar2 = strcasecmp((char *)*piVar4,"ssid");
      if (iVar2 == 0) {
        local_res8 = local_res8 + 2;
        if (*local_res8 == 0) {
          fwrite("no value for ssid\n",1,0x12,stderr);
          local_48 = -0x2c;
          goto LAB_00461854;
        }
        local_40 = local_40 + 1;
        if (0xf < local_40) {
          fwrite("exceed max 16 SSID per pfn_add\n",1,0x1f,stderr);
          local_48 = -2;
          goto LAB_00461854;
        }
        if (0 < local_40) {
          if (DAT_00557704 == '\0') {
            uVar5 = local_3c[9];
          }
          else {
            uVar5 = local_3c[9];
            uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
          }
          local_3c[9] = uVar5;
          local_3c = local_3c + 0xe;
        }
        strncpy((char *)(local_3c + 1),(char *)*local_res8,0x20);
        sVar6 = strlen((char *)(local_3c + 1));
        *local_3c = sVar6;
        if (0x20 < *local_3c) {
          fprintf(stderr,"SSID too long: %s\n",(char *)*local_res8);
          local_48 = -2;
          goto LAB_00461854;
        }
        if (DAT_00557704 == '\0') {
          sVar6 = *local_3c;
        }
        else {
          uVar5 = *local_3c;
          sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        }
        *local_3c = sVar6;
      }
      else {
        iVar2 = strcasecmp((char *)*piVar4,"hidden");
        if (iVar2 == 0) {
          if (*local_3c == 0) {
            fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
            local_48 = -0x2c;
            goto LAB_00461854;
          }
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("no value for hidden\n",1,0x14,stderr);
            local_48 = -0x2c;
            goto LAB_00461854;
          }
          iVar2 = *(char *)*local_res8 + -0x30;
          if ((iVar2 != 1) && (iVar2 != 0)) {
            fwrite("invalid hidden setting, use 0/1\n",1,0x20,stderr);
            local_48 = -0x2c;
            goto LAB_00461854;
          }
          local_3c[9] = local_3c[9] | iVar2 * 4;
        }
        else {
          iVar2 = strcasecmp((char *)*piVar4,"imode");
          if (iVar2 == 0) {
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing option for imode\n",1,0x19,stderr);
              local_48 = -0x2c;
              goto LAB_00461854;
            }
            if (*local_3c == 0) {
              fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
              local_48 = -0x2c;
              goto LAB_00461854;
            }
            iVar2 = strcasecmp((char *)*local_res8,"bss");
            if (iVar2 == 0) {
              local_3c[10] = 1;
            }
            else {
              iVar2 = strcasecmp((char *)*local_res8,"ibss");
              if (iVar2 != 0) {
                fprintf(stderr,"Invalid imode arg %s\n",(char *)*local_res8);
                local_48 = -0x2c;
                goto LAB_00461854;
              }
              local_3c[10] = 0;
            }
            if (DAT_00557704 == '\0') {
              sVar6 = local_3c[10];
            }
            else {
              uVar5 = local_3c[10];
              sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                      uVar5 >> 0x18;
            }
            local_3c[10] = sVar6;
          }
          else {
            iVar2 = strcasecmp((char *)*piVar4,"amode");
            if (iVar2 == 0) {
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                fwrite("Missing option for amode\n",1,0x19,stderr);
                local_48 = -0x2c;
                goto LAB_00461854;
              }
              if (*local_3c == 0) {
                fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                local_48 = -0x2c;
                goto LAB_00461854;
              }
              iVar2 = strcasecmp((char *)*local_res8,"open");
              if (iVar2 == 0) {
                local_3c[0xb] = 0;
              }
              else {
                iVar2 = strcasecmp((char *)*local_res8,"shared");
                if (iVar2 != 0) {
                  fprintf(stderr,"Invalid imode arg %s\n",(char *)*local_res8);
                  local_48 = -0x2c;
                  goto LAB_00461854;
                }
                local_3c[0xb] = 1;
              }
              if (DAT_00557704 == '\0') {
                sVar6 = local_3c[0xb];
              }
              else {
                uVar5 = local_3c[0xb];
                sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
              }
              local_3c[0xb] = sVar6;
            }
            else {
              iVar2 = strcasecmp((char *)*piVar4,"wpa_auth");
              if (iVar2 == 0) {
                local_res8 = local_res8 + 2;
                if (*local_res8 == 0) {
                  fwrite("Missing option for wpa_auth\n",1,0x1c,stderr);
                  local_48 = -0x2c;
                  goto LAB_00461854;
                }
                if (*local_3c == 0) {
                  fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                  local_48 = -0x2c;
                  goto LAB_00461854;
                }
                iVar2 = strcasecmp((char *)*local_res8,"wpapsk");
                if (iVar2 == 0) {
                  local_3c[0xc] = 4;
                }
                else {
                  iVar2 = strcasecmp((char *)*local_res8,"wpa2psk");
                  if (iVar2 == 0) {
                    local_3c[0xc] = 0x80;
                  }
                  else {
                    iVar2 = strcasecmp((char *)*local_res8,"wpadisabled");
                    if (iVar2 == 0) {
                      local_3c[0xc] = 0;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*local_res8,"any");
                      if (iVar2 == 0) {
                        local_3c[0xc] = 0xffff;
                      }
                      else {
                        uVar3 = strtoul((char *)*local_res8,(char **)0x0,0);
                        if (uVar3 == 0) {
                          fprintf(stderr,"Invalid wpa_auth option %s\n",(char *)*local_res8);
                          local_48 = -0x2c;
                          goto LAB_00461854;
                        }
                        local_3c[0xc] = uVar3;
                      }
                    }
                  }
                }
                if (DAT_00557704 == '\0') {
                  sVar6 = local_3c[0xc];
                }
                else {
                  uVar5 = local_3c[0xc];
                  sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                }
                local_3c[0xc] = sVar6;
              }
              else {
                iVar2 = strcasecmp((char *)*piVar4,"wsec");
                if (iVar2 == 0) {
                  local_res8 = local_res8 + 2;
                  if (*local_res8 == 0) {
                    fwrite("Missing option for wsec\n",1,0x18,stderr);
                    local_48 = -0x2c;
                    goto LAB_00461854;
                  }
                  if (*local_3c == 0) {
                    fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                    local_48 = -0x2c;
                    goto LAB_00461854;
                  }
                  iVar2 = strcasecmp((char *)*local_res8,
                                     (char *)&PTR_s__mgmt_filters_remove_0051a42c);
                  if (iVar2 == 0) {
                    local_3c[0xd] = 1;
                  }
                  else {
                    iVar2 = strcasecmp((char *)*local_res8,"TKIP");
                    if (iVar2 == 0) {
                      local_3c[0xd] = 2;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*local_res8,(char *)&PTR_DAT_0051a430);
                      if (iVar2 == 0) {
                        local_3c[0xd] = 4;
                      }
                      else {
                        iVar2 = strcasecmp((char *)*local_res8,"TKIPAES");
                        if (iVar2 != 0) {
                          fprintf(stderr,"Invalid wsec option %s\n",(char *)*local_res8);
                          local_48 = -0x2c;
                          goto LAB_00461854;
                        }
                        local_3c[0xd] = 6;
                      }
                    }
                  }
                  if (DAT_00557704 == '\0') {
                    sVar6 = local_3c[0xd];
                  }
                  else {
                    uVar5 = local_3c[0xd];
                    sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                            uVar5 >> 0x18;
                  }
                  local_3c[0xd] = sVar6;
                }
                else {
                  iVar2 = strcasecmp((char *)*piVar4,"suppress");
                  if (iVar2 == 0) {
                    local_res8 = local_res8 + 2;
                    if (*local_res8 == 0) {
                      fwrite("Missing option for suppress\n",1,0x1c,stderr);
                      local_48 = -0x2c;
                      goto LAB_00461854;
                    }
                    if (*local_3c == 0) {
                      fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                      local_48 = -0x2c;
                      goto LAB_00461854;
                    }
                    iVar2 = strcasecmp((char *)*local_res8,"found");
                    if (iVar2 == 0) {
                      local_3c[9] = local_3c[9] | 8;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*local_res8,"lost");
                      if (iVar2 == 0) {
                        local_3c[9] = local_3c[9] | 0x10;
                      }
                      else {
                        iVar2 = strcasecmp((char *)*local_res8,"neither");
                        if (iVar2 != 0) {
                          fprintf(stderr,"Invalid suppress option %s\n",(char *)*local_res8);
                          local_48 = -0x2c;
                          goto LAB_00461854;
                        }
                        local_3c[9] = local_3c[9] & 0xffffffe7;
                      }
                    }
                  }
                  else {
                    iVar2 = strcasecmp((char *)*piVar4,"rssi");
                    if (iVar2 == 0) {
                      local_res8 = local_res8 + 2;
                      if (*local_res8 == 0) {
                        fwrite("Missing option for rssi\n",1,0x18,stderr);
                        local_48 = -0x2c;
                        goto LAB_00461854;
                      }
                      uVar5 = atoi((char *)*local_res8);
                      if (*local_3c == 0) {
                        fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                        local_48 = -0x2c;
                        goto LAB_00461854;
                      }
                      if (((int)uVar5 < -0x80) || (0 < (int)uVar5)) {
                        fprintf(stderr,"Invalid rssi option %s\n",(char *)*local_res8);
                        local_48 = -2;
                        goto LAB_00461854;
                      }
                      local_3c[9] = local_3c[9] | (uVar5 & 0xff) << 8;
                    }
                    else {
                      iVar2 = strcasecmp((char *)*piVar4,"trig");
                      if (iVar2 == 0) {
                        local_res8 = local_res8 + 2;
                        if (*local_res8 == 0) {
                          fwrite("Missing option for trigger\n",1,0x1b,stderr);
                          local_48 = -0x2c;
                          goto LAB_00461854;
                        }
                        if (*local_3c == 0) {
                          fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                          local_48 = -0x2c;
                          goto LAB_00461854;
                        }
                        iVar2 = strcasecmp((char *)*local_res8,"a");
                        if (iVar2 == 0) {
                          local_3c[9] = local_3c[9] | 0x20;
                        }
                        else {
                          iVar2 = strcasecmp((char *)*local_res8,"bg");
                          if (iVar2 == 0) {
                            local_3c[9] = local_3c[9] | 0x40;
                          }
                          else {
                            iVar2 = strcasecmp((char *)*local_res8,"abg");
                            if (iVar2 != 0) {
                              fprintf(stderr,"Invalid trigger option %s\n",(char *)*local_res8);
                              local_48 = -0x2c;
                              goto LAB_00461854;
                            }
                            local_3c[9] = local_3c[9] | 0x60;
                          }
                        }
                      }
                      else {
                        iVar2 = strcasecmp((char *)*piVar4,"same_network");
                        if (iVar2 == 0) {
                          local_res8 = local_res8 + 2;
                          if (*local_res8 == 0) {
                            fwrite("Missing option for same_network\n",1,0x20,stderr);
                            local_48 = -0x2c;
                            goto LAB_00461854;
                          }
                          if (*local_3c == 0) {
                            fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                            local_48 = -0x2c;
                            goto LAB_00461854;
                          }
                          cVar1 = *(char *)*local_res8;
                          if ((cVar1 != '1') && (cVar1 != '0')) {
                            fwrite("invalid same_network setting, use 0/1\n",1,0x26,stderr);
                            local_48 = -0x2c;
                            goto LAB_00461854;
                          }
                          if (cVar1 != '0') {
                            local_3c[9] = local_3c[9] | 0x10000;
                          }
                        }
                        else {
                          iVar2 = strcasecmp((char *)*piVar4,"no_aging");
                          if (iVar2 == 0) {
                            local_res8 = local_res8 + 2;
                            if (*local_res8 == 0) {
                              fwrite("Missing option for same_network\n",1,0x20,stderr);
                              local_48 = -0x2c;
                              goto LAB_00461854;
                            }
                            if (*local_3c == 0) {
                              fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                              local_48 = -0x2c;
                              goto LAB_00461854;
                            }
                            cVar1 = *(char *)*local_res8;
                            if ((cVar1 != '1') && (cVar1 != '0')) {
                              fwrite("invalid same_network setting, use 0/1\n",1,0x26,stderr);
                              local_48 = -0x2c;
                              goto LAB_00461854;
                            }
                            if (cVar1 != '0') {
                              local_3c[9] = local_3c[9] | 0x20000;
                            }
                          }
                          else {
                            iVar2 = strcasecmp((char *)*piVar4,"imprecise");
                            if (iVar2 == 0) {
                              local_res8 = local_res8 + 2;
                              if (*local_res8 == 0) {
                                fwrite("Missing option for imprecise match\n",1,0x23,stderr);
                                local_48 = -0x2c;
                                goto LAB_00461854;
                              }
                              if (*local_3c == 0) {
                                fwrite("Wrong! Start with SSID\n",1,0x17,stderr);
                                local_48 = -0x2c;
                                goto LAB_00461854;
                              }
                              cVar1 = *(char *)*local_res8;
                              if ((cVar1 != '1') && (cVar1 != '0')) {
                                fwrite("invalid imprecise setting, use 0/1\n",1,0x23,stderr);
                                local_48 = -0x2c;
                                goto LAB_00461854;
                              }
                              if (cVar1 != '0') {
                                local_3c[9] = local_3c[9] | 0x80;
                              }
                            }
                            else {
                              iVar2 = strcasecmp((char *)*piVar4,"clear");
                              if (iVar2 != 0) {
                                fprintf(stderr,"Invalid parameter %s\n",(char *)*piVar4);
                                local_48 = -0x2c;
                                goto LAB_00461854;
                              }
                              local_res8 = local_res8 + 2;
                              if (*local_res8 == 0) {
                                fwrite("Missing option for clear\n",1,0x19,stderr);
                                local_48 = -0x2c;
                                goto LAB_00461854;
                              }
                              if (0 < local_40) {
                                fwrite("Will only clear, ssids ignored\n",1,0x1f,stderr);
                              }
                              local_40 = 0;
                              __s[9] = 0x40000;
                              local_3c = __s;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (DAT_00557704 == '\0') {
      sVar6 = local_3c[9];
    }
    else {
      uVar5 = local_3c[9];
      sVar6 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    local_3c[9] = sVar6;
    local_48 = FUN_004ba2e4(param_1,"pfn_add",__s,(local_40 + 1) * 0x38);
    if (local_48 == 0) {
      free(__s);
      local_48 = 0;
    }
    else {
      fwrite("pfn_add fail\n",1,0xd,stderr);
LAB_00461854:
      free(__s);
    }
  }
  return local_48;
}



int FUN_0046187c(int *param_1,int param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  ulong uVar3;
  int *piVar4;
  int *local_res8;
  int local_48;
  ushort local_1c [2];
  char local_18;
  char local_17;
  ushort local_16;
  ushort local_14;
  ushort local_12;
  ushort local_10;
  ushort local_e;
  char *local_c;
  
  local_48 = 0;
  local_c = (char *)0x0;
  if (param_3[1] == 0) {
    if (*(int *)(param_2 + 8) < 0) {
      iVar1 = -1;
    }
    else {
      memset(local_1c,0,0x10);
      iVar1 = FUN_004ba1f8(param_1,"pfn_ssid_cfg",(char *)local_1c,0x10);
      if (iVar1 < 0) {
        fprintf(stderr,"Failed to get pfn_ssid_cfg %d\n",iVar1);
      }
      else if (local_1c[0] == 1) {
        if (DAT_00557704 != '\0') {
          local_16 = local_16 << 8 | local_16 >> 8;
        }
        fprintf(stderr,"min2G_rssi %d min5G_rssi %d init_score_max %d\n",(int)local_17,(int)local_18
                ,(uint)local_16);
        if (DAT_00557704 != '\0') {
          local_e = local_e << 8 | local_e >> 8;
        }
        if (DAT_00557704 != '\0') {
          local_10 = local_10 << 8 | local_10 >> 8;
        }
        if (DAT_00557704 != '\0') {
          local_12 = local_12 << 8 | local_12 >> 8;
        }
        fprintf(stderr,"band_5g_bonus %d secure_bonus %d same_ssid_bonus %d\n",(uint)local_e,
                (uint)local_10,(uint)local_12);
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 8 | local_14 >> 8;
        }
        fprintf(stderr,"cur_bssid_bonus %d\n",(uint)local_14);
        iVar1 = 0;
      }
      else {
        fprintf(stderr,"Mismatched version expected %d, got %d\n",1,(uint)local_1c[0]);
      }
    }
  }
  else {
    if (DAT_00557704 == '\0') {
      local_1c[0] = 1;
    }
    else {
      local_1c[0] = 0x100;
    }
    local_1c[1] = 0;
    local_e = 0;
    local_10 = 0;
    local_12 = 0;
    if (DAT_00557704 == '\0') {
      local_16 = 0x6e;
    }
    else {
      local_16 = 0x6e00;
    }
    local_14 = 0;
    local_17 = 0xce;
    local_18 = 0xd3;
    local_res8 = param_3;
    while (piVar4 = local_res8 + 1, *piVar4 != 0) {
      iVar1 = strcasecmp((char *)*piVar4,"min5g_rssi");
      if (iVar1 == 0) {
        local_res8 = local_res8 + 2;
        if (*local_res8 == 0) {
          fwrite("Missing option for rssi\n",1,0x18,stderr);
          return -0x2c;
        }
        lVar2 = strtol((char *)*local_res8,&local_c,0);
        if (*local_c != '\0') {
          return -0x2c;
        }
        if ((lVar2 < -0x80) || (0 < lVar2)) {
          fprintf(stderr,"Invalid rssi option %s\n",(char *)*local_res8);
          return -2;
        }
        local_18 = (char)lVar2;
      }
      else {
        iVar1 = strcasecmp((char *)*piVar4,"min2g_rssi");
        if (iVar1 == 0) {
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("Missing option for rssi\n",1,0x18,stderr);
            return -0x2c;
          }
          lVar2 = strtol((char *)*local_res8,&local_c,0);
          if (*local_c != '\0') {
            return -0x2c;
          }
          if ((lVar2 < -0x80) || (0 < lVar2)) {
            fprintf(stderr,"Invalid rssi option %s\n",(char *)*local_res8);
            return -2;
          }
          local_17 = (char)lVar2;
        }
        else {
          iVar1 = strcasecmp((char *)*piVar4,"init_score_max");
          if (iVar1 == 0) {
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing option for init_score_max\n",1,0x22,stderr);
              return -0x2c;
            }
            uVar3 = strtoul((char *)*local_res8,&local_c,0);
            local_16 = (ushort)uVar3;
            if (*local_c != '\0') {
              return -0x2c;
            }
            if (DAT_00557704 != '\0') {
              local_16 = local_16 << 8 | local_16 >> 8;
            }
          }
          else {
            iVar1 = strcasecmp((char *)*piVar4,"cur_bssid_bonus");
            if (iVar1 == 0) {
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                fwrite("Missing option for cur_bssid_bonus\n",1,0x23,stderr);
                return -0x2c;
              }
              uVar3 = strtoul((char *)*local_res8,&local_c,0);
              local_14 = (ushort)uVar3;
              if (*local_c != '\0') {
                return -0x2c;
              }
              if (DAT_00557704 != '\0') {
                local_14 = local_14 << 8 | local_14 >> 8;
              }
            }
            else {
              iVar1 = strcasecmp((char *)*piVar4,"same_ssid_bonus");
              if (iVar1 == 0) {
                local_res8 = local_res8 + 2;
                if (*local_res8 == 0) {
                  fwrite("Missing option for same_ssid_bonus\n",1,0x23,stderr);
                  return -0x2c;
                }
                uVar3 = strtoul((char *)*local_res8,&local_c,0);
                local_12 = (ushort)uVar3;
                if (*local_c != '\0') {
                  return -0x2c;
                }
                if (DAT_00557704 != '\0') {
                  local_12 = local_12 << 8 | local_12 >> 8;
                }
              }
              else {
                iVar1 = strcasecmp((char *)*piVar4,"secure_bonus");
                if (iVar1 == 0) {
                  local_res8 = local_res8 + 2;
                  if (*local_res8 == 0) {
                    fwrite("Missing option for secure_bonus\n",1,0x20,stderr);
                    return -0x2c;
                  }
                  uVar3 = strtoul((char *)*local_res8,&local_c,0);
                  local_10 = (ushort)uVar3;
                  if (*local_c != '\0') {
                    return -0x2c;
                  }
                  if (DAT_00557704 != '\0') {
                    local_10 = local_10 << 8 | local_10 >> 8;
                  }
                }
                else {
                  iVar1 = strcasecmp((char *)*piVar4,"band_5g_bonus");
                  if (iVar1 == 0) {
                    local_res8 = local_res8 + 2;
                    if (*local_res8 == 0) {
                      fwrite("Missing option for band_5g_bonus\n",1,0x21,stderr);
                      return -0x2c;
                    }
                    uVar3 = strtoul((char *)*local_res8,&local_c,0);
                    local_e = (ushort)uVar3;
                    if (*local_c != '\0') {
                      return -0x2c;
                    }
                    if (DAT_00557704 != '\0') {
                      local_e = local_e << 8 | local_e >> 8;
                    }
                  }
                  else {
                    iVar1 = strcasecmp((char *)*piVar4,"clear");
                    local_res8 = piVar4;
                    if ((iVar1 == 0) && (local_1c[1] = 1, local_48 != 0)) {
                      fwrite("Params will ONLY be cleared\n",1,0x1c,stderr);
                    }
                  }
                }
              }
            }
          }
        }
      }
      local_48 = local_48 + 1;
    }
    iVar1 = FUN_004ba2e4(param_1,"pfn_ssid_cfg",local_1c,0x10);
    if (iVar1 != 0) {
      fprintf(stderr,"Failed to set pfn_ssid_cfg %d\n",iVar1);
    }
  }
  return iVar1;
}



int FUN_004624f0(int *param_1,undefined4 param_2,int *param_3)

{
  char *pcVar1;
  char cVar2;
  byte bVar3;
  ushort uVar4;
  char *__s;
  int iVar5;
  int *piVar6;
  int *local_res8;
  int local_38;
  char *local_34;
  int local_30;
  int local_2c;
  char *local_28;
  
  local_28 = (char *)0x0;
  if (param_3[1] == 0) {
    fwrite("Invalid command\n",1,0x10,stderr);
    local_38 = -0x2c;
  }
  else {
    __s = (char *)malloc(0x4b0);
    if (__s == (char *)0x0) {
      fprintf(stderr,"Failed to allocate buffer for %d bytes\n",0x4b0);
      local_38 = -0x1b;
    }
    else {
      memset(__s,0,0x4b0);
      local_2c = 0;
      local_res8 = param_3;
      while (piVar6 = local_res8 + 1, *piVar6 != 0) {
        iVar5 = strcasecmp((char *)*piVar6,"bssid");
        if (iVar5 == 0) {
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("Missing option for bssid\n",1,0x19,stderr);
            local_38 = -0x2c;
            goto LAB_00462d58;
          }
          if (0x95 < local_2c) {
            fwrite("exceed max 150 BSSID per pfn_add_bssid\n",1,0x27,stderr);
            local_38 = -2;
            goto LAB_00462d58;
          }
          pcVar1 = __s;
          if (local_2c != 0) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(ushort *)(local_28 + 6);
            }
            else {
              uVar4 = *(ushort *)(local_28 + 6) << 8 | *(ushort *)(local_28 + 6) >> 8;
            }
            *(ushort *)(local_28 + 6) = uVar4;
            pcVar1 = local_28 + 8;
          }
          local_28 = pcVar1;
          local_34 = (char *)*local_res8;
          for (local_30 = 0; local_30 < 6; local_30 = local_30 + 1) {
            iVar5 = FUN_0045ff30(*local_34);
            if ((iVar5 == 0) || (iVar5 = FUN_0045ff30(local_34[1]), iVar5 == 0)) {
              fwrite("non-hex in BSSID\n",1,0x11,stderr);
              local_38 = -2;
              goto LAB_00462d58;
            }
            cVar2 = FUN_0045ffc8(*local_34);
            bVar3 = FUN_0045ffc8(local_34[1]);
            local_28[local_30] = cVar2 << 4 | bVar3;
            local_34 = local_34 + 3;
          }
          local_2c = local_2c + 1;
        }
        else {
          iVar5 = strcasecmp((char *)*piVar6,"suppress");
          if (iVar5 == 0) {
            if ((local_28 == (char *)0x0) ||
               (((((*local_28 == '\0' && local_28[1] == '\0') && local_28[2] == '\0') &&
                 local_28[3] == '\0') && local_28[4] == '\0') && local_28[5] == '\0')) {
              fwrite("Wrong! Start with BSSID\n",1,0x18,stderr);
              local_38 = -2;
              goto LAB_00462d58;
            }
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing option for suppress\n",1,0x1c,stderr);
              local_38 = -0x2c;
              goto LAB_00462d58;
            }
            iVar5 = strcasecmp((char *)*local_res8,"found");
            if (iVar5 == 0) {
              *(ushort *)(local_28 + 6) = *(ushort *)(local_28 + 6) | 8;
            }
            else {
              iVar5 = strcasecmp((char *)*local_res8,"lost");
              if (iVar5 == 0) {
                *(ushort *)(local_28 + 6) = *(ushort *)(local_28 + 6) | 0x10;
              }
              else {
                iVar5 = strcasecmp((char *)*local_res8,"neither");
                if (iVar5 != 0) {
                  fprintf(stderr,"Invalid suppress option %s\n",(char *)*local_res8);
                  local_38 = -0x2c;
                  goto LAB_00462d58;
                }
                *(ushort *)(local_28 + 6) = *(ushort *)(local_28 + 6) & 0xffe7;
              }
            }
          }
          else {
            iVar5 = strcasecmp((char *)*piVar6,"rssi");
            if (iVar5 != 0) {
              fprintf(stderr,"Invalid parameter %s\n",(char *)*piVar6);
              local_38 = -0x2c;
              goto LAB_00462d58;
            }
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing option for rssi\n",1,0x18,stderr);
              local_38 = -0x2c;
              goto LAB_00462d58;
            }
            iVar5 = atoi((char *)*local_res8);
            if ((local_28 == (char *)0x0) ||
               (((((*local_28 == '\0' && local_28[1] == '\0') && local_28[2] == '\0') &&
                 local_28[3] == '\0') && local_28[4] == '\0') && local_28[5] == '\0')) {
              fwrite("Wrong! Start with BSSID\n",1,0x18,stderr);
              local_38 = -2;
              goto LAB_00462d58;
            }
            if ((iVar5 < -0x80) || (0 < iVar5)) {
              fprintf(stderr,"Invalid rssi option %s\n",(char *)*local_res8);
              local_38 = -2;
              goto LAB_00462d58;
            }
            *(ushort *)(local_28 + 6) = *(ushort *)(local_28 + 6) | (ushort)(iVar5 << 8);
          }
        }
      }
      if (DAT_00557704 == '\0') {
        uVar4 = *(ushort *)(local_28 + 6);
      }
      else {
        uVar4 = *(ushort *)(local_28 + 6) << 8 | *(ushort *)(local_28 + 6) >> 8;
      }
      *(ushort *)(local_28 + 6) = uVar4;
      local_38 = FUN_004ba2e4(param_1,"pfn_add_bssid",__s,local_2c << 3);
      if (local_38 == 0) {
        free(__s);
        local_38 = 0;
      }
      else {
        fwrite("pfn_add_bssid fail\n",1,0x13,stderr);
LAB_00462d58:
        free(__s);
      }
    }
  }
  return local_38;
}



int FUN_00462d84(int *param_1,undefined4 param_2,int *param_3)

{
  int *piVar1;
  int iVar2;
  int *local_res8;
  uint local_a8;
  uint local_94;
  uint local_90;
  undefined1 auStack_8c [128];
  uint local_c;
  
  local_a8 = 0;
  memset(&local_94,0,0x8c);
  local_94 = 0;
  local_90 = 0;
  local_res8 = param_3;
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          piVar1 = local_res8 + 1;
          if (*piVar1 == 0) {
            local_90 = local_a8;
            if (DAT_00557704 != '\0') {
              local_94 = local_94 << 0x18 | (local_94 & 0xff00) << 8 | (local_94 & 0xff0000) >> 8 |
                         local_94 >> 0x18;
              local_90 = local_a8 << 0x18 | (local_a8 & 0xff00) << 8 | (local_a8 & 0xff0000) >> 8 |
                         local_a8 >> 0x18;
              local_c = local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 |
                        local_c >> 0x18;
            }
            iVar2 = FUN_004ba2e4(param_1,"pfn_cfg",&local_94,0x8c);
            if (iVar2 != 0) {
              fwrite("pfn_cfg fail\n",1,0xd,stderr);
              return iVar2;
            }
            return 0;
          }
          iVar2 = strcasecmp((char *)*piVar1,"report");
          if (iVar2 != 0) break;
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("no value for report\n",1,0x14,stderr);
            return -0x2c;
          }
          iVar2 = strcasecmp((char *)*local_res8,"all");
          if (iVar2 == 0) {
            local_94 = 0;
          }
          else {
            iVar2 = strcasecmp((char *)*local_res8,"ssidonly");
            if (iVar2 == 0) {
              local_94 = 1;
            }
            else {
              iVar2 = strcasecmp((char *)*local_res8,"bssidonly");
              if (iVar2 != 0) {
                fprintf(stderr,"Invalid report option %s\n",(char *)*local_res8);
                return -0x2c;
              }
              local_94 = 2;
            }
          }
        }
        iVar2 = strcasecmp((char *)*piVar1,"channel");
        if (iVar2 != 0) break;
        local_res8 = local_res8 + 2;
        if (*local_res8 == 0) {
          fwrite("Missing option for channel\n",1,0x1b,stderr);
          return -0x2c;
        }
        local_a8 = FUN_0042232c((char *)*local_res8,(int)auStack_8c,0x40);
        if ((int)local_a8 < 0) {
          fwrite("error parsing channel\n",1,0x16,stderr);
          return -2;
        }
      }
      iVar2 = strcasecmp((char *)*piVar1,"prohibited");
      if (iVar2 != 0) break;
      local_res8 = local_res8 + 2;
      if (*local_res8 == 0) {
        fwrite("Missing prohibited option value\n",1,0x20,stderr);
        return -0x2c;
      }
      local_c = local_c & 0xfffffffe;
      iVar2 = atoi((char *)*local_res8);
      if (iVar2 != 0) {
        local_c = local_c | 1;
      }
    }
    iVar2 = strcasecmp((char *)*piVar1,"history_off");
    if (iVar2 != 0) {
      fprintf(stderr,"Invalid parameter %s\n",(char *)*piVar1);
      return -0x2c;
    }
    local_res8 = local_res8 + 2;
    if (*local_res8 == 0) break;
    local_c = local_c & 0xfffffffd;
    iVar2 = atoi((char *)*local_res8);
    if (iVar2 != 0) {
      local_c = local_c | 2;
    }
  }
  fwrite("Missing history_off option value\n",1,0x21,stderr);
  return -0x2c;
}



int FUN_00463328(int *param_1,undefined4 param_2,int param_3)

{
  int local_10;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_10 = FUN_004ba35c(param_1,"pfn",&local_c);
    if (local_10 == 0) {
      FUN_00402444(local_c);
    }
  }
  else {
    local_c = atoi(*(char **)(param_3 + 4));
    local_10 = FUN_004ba428(param_1,"pfn",(uint)(local_c != 0));
  }
  return local_10;
}



int FUN_00463400(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int *__s;
  byte *local_20;
  uint local_1c;
  uint local_18;
  
  if (*(int *)(param_3 + 4) == 0) {
    __s = (int *)malloc(0x400);
    if (__s == (int *)0x0) {
      fprintf(stderr,"Failed to allocate buffer of %d bytes\n",0x400);
      iVar1 = -0x1b;
    }
    else {
      bzero(__s,0x400);
      while (__s[1] != 1) {
        iVar1 = FUN_004ba1f8(param_1,"pfnbest",(char *)__s,0x400);
        if (iVar1 != 0) {
          fwrite("pfnbest fail\n",1,0xd,stderr);
          free(__s);
          return iVar1;
        }
        if (0x17 < (uint)__s[2]) {
          fwrite("invalid data\n",1,0xd,stderr);
          free(__s);
          return -1;
        }
        printf("ver %d, status %d, count %d\n",*__s,__s[1],__s[2]);
        local_20 = (byte *)(__s + 4);
        for (local_1c = 0; local_1c < (uint)__s[2]; local_1c = local_1c + 1) {
          for (local_18 = 0; local_18 < local_20[7]; local_18 = local_18 + 1) {
            putchar((uint)local_20[local_18 + 8]);
          }
          putchar(10);
          printf("%02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_20,(uint)local_20[1],
                 (uint)local_20[2],(uint)local_20[3],(uint)local_20[4],(uint)local_20[5]);
          printf("channel: %d, RSSI: %d, timestamp: %d\n",(uint)local_20[6],
                 (int)*(short *)(local_20 + 0x28),(uint)*(ushort *)(local_20 + 0x2a));
          local_20 = local_20 + 0x2c;
        }
      }
      free(__s);
      iVar1 = 0;
    }
  }
  else {
    fprintf(stderr,"Invalid parameter %s\n",*(char **)(param_3 + 4));
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00463730(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int *__s;
  byte *local_20;
  uint local_1c;
  uint local_18;
  
  if (*(int *)(param_3 + 4) == 0) {
    __s = (int *)malloc(0x400);
    if (__s == (int *)0x0) {
      fprintf(stderr,"Failed to allocate buffer of %d bytes\n",0x400);
      iVar1 = -1;
    }
    else {
      bzero(__s,0x400);
      while ((short)__s[1] == 0) {
        iVar1 = FUN_004ba1f8(param_1,"pfnlbest",(char *)__s,0x400);
        if (iVar1 != 0) {
          fwrite("pfnbest fail\n",1,0xd,stderr);
          return iVar1;
        }
        printf("ver %d, status %d, count %d\n",*__s,(uint)*(ushort *)(__s + 1),
               (uint)*(ushort *)((int)__s + 6));
        local_20 = (byte *)(__s + 6);
        for (local_1c = 0; local_1c < *(ushort *)((int)__s + 6); local_1c = local_1c + 1) {
          for (local_18 = 0; local_18 < local_20[7]; local_18 = local_18 + 1) {
            putchar((uint)local_20[local_18 + 8]);
          }
          putchar(10);
          printf("%02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_20,(uint)local_20[1],
                 (uint)local_20[2],(uint)local_20[3],(uint)local_20[4],(uint)local_20[5]);
          printf("channel: %d, flags: %d, RSSI: %d, timestamp: %d\n",(uint)local_20[6],
                 (uint)*(ushort *)(local_20 + 0x28),(int)*(short *)(local_20 + 0x2a),
                 *(int *)(local_20 + 0x2c));
          printf("RTT0: %d, RTT1: %d\n",(uint)*(ushort *)(local_20 + 0x30),
                 (uint)*(ushort *)(local_20 + 0x32));
          local_20 = local_20 + 0x34;
        }
      }
      free(__s);
      iVar1 = 0;
    }
  }
  else {
    fprintf(stderr,"Invalid parameter %s\n",*(char **)(param_3 + 4));
    iVar1 = -1;
  }
  return iVar1;
}



int FUN_00463a40(int *param_1,undefined4 param_2,int param_3)

{
  byte *pbVar1;
  int iVar2;
  byte *__s;
  byte *local_18;
  uint local_14;
  
  if (*(int *)(param_3 + 4) == 0) {
    __s = (byte *)malloc(0x400);
    if (__s == (byte *)0x0) {
      fprintf(stderr,"Failed to allocate buffer of %d bytes\n",0x400);
      iVar2 = -1;
    }
    else {
      memset(__s,0,0x400);
      while (*(int *)(__s + 4) != 1) {
        iVar2 = FUN_004ba1f8(param_1,"pfnbest_bssid",(char *)__s,0x400);
        if (iVar2 != 0) {
          fwrite("pfnbest_bssid fail\n",1,0x13,stderr);
          return iVar2;
        }
        printf("ver %d, status %d, count %d\n",*(int *)__s,*(int *)(__s + 4),*(int *)(__s + 8));
        pbVar1 = __s;
        for (local_14 = 0; local_18 = pbVar1 + 0xc, local_14 < *(uint *)(__s + 8);
            local_14 = local_14 + 1) {
          printf("%02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_18,(uint)pbVar1[0xd],
                 (uint)pbVar1[0xe],(uint)pbVar1[0xf],(uint)pbVar1[0x10],(uint)pbVar1[0x11]);
          printf("channel: %d, RSSI: %d, timestamp: %d\n",(uint)pbVar1[0x12],(int)(char)pbVar1[0x13]
                 ,(uint)*(ushort *)(pbVar1 + 0x16));
          pbVar1 = local_18;
        }
      }
      iVar2 = 0;
    }
  }
  else {
    fprintf(stderr,"Invalid parameter %s\n",*(char **)(param_3 + 4));
    iVar2 = -1;
  }
  return iVar2;
}



int FUN_00463cb0(int *param_1,undefined4 param_2,int param_3)

{
  int local_10;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_10 = FUN_004ba35c(param_1,"pfn_suspend",&local_c);
    if (local_10 == 0) {
      FUN_00402444(local_c);
    }
  }
  else {
    local_c = atoi(*(char **)(param_3 + 4));
    local_10 = FUN_004ba428(param_1,"pfn_suspend",(uint)(local_c != 0));
  }
  return local_10;
}



int FUN_00463d88(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint local_c;
  
  if ((*(int *)(param_3 + 4) == 0) ||
     (iVar1 = strcasecmp(*(char **)(param_3 + 4),"bestn"), iVar1 != 0)) {
    fwrite("Missing bestn option\n",1,0x15,stderr);
    iVar1 = -1;
  }
  else if (*(int *)(param_3 + 8) == 0) {
    fwrite("Missing bestn value\n",1,0x14,stderr);
    iVar1 = -1;
  }
  else {
    local_c = atoi(*(char **)(param_3 + 8));
    iVar1 = FUN_004ba428(param_1,"pfnmem",local_c);
    if (iVar1 == 0) {
      iVar1 = FUN_004ba35c(param_1,"pfnmem",&local_c);
      if (iVar1 == 0) {
        FUN_00402444(local_c);
      }
      else {
        fwrite("pfnmem get wrong!\n",1,0x12,stderr);
      }
    }
    else {
      fwrite("pfnmem set wrong!\n",1,0x12,stderr);
    }
  }
  return iVar1;
}



void FUN_00463f64(undefined4 *param_1,int param_2)

{
  byte *local_18;
  uint local_14;
  uint local_10;
  
  local_18 = (byte *)(param_1 + 4);
  if (param_2 == 0x21) {
    puts("WLC_E_PFN_NET_FOUND:");
  }
  else if (param_2 == 0x22) {
    puts("WLC_E_PFN_NET_LOST:");
  }
  else if (param_2 == 0x52) {
    puts("WLC_E_PFN_BSSID_NET_FOUND:");
  }
  else {
    if (param_2 != 0x53) {
      return;
    }
    puts("WLC_E_PFN_BSSID_NET_LOST:");
  }
  printf("ver %d, status %d, count %d\n",*param_1,param_1[1],param_1[2]);
  for (local_14 = 0; local_14 < (uint)param_1[2]; local_14 = local_14 + 1) {
    printf("%d. ",local_14 + 1);
    for (local_10 = 0; local_10 < local_18[7]; local_10 = local_10 + 1) {
      putchar((uint)local_18[local_10 + 8]);
    }
    putchar(10);
    printf("BSSID %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_18,(uint)local_18[1],
           (uint)local_18[2],(uint)local_18[3],(uint)local_18[4],(uint)local_18[5]);
    printf("channel %d, RSSI %d, timestamp %d\n",(uint)local_18[6],(int)*(short *)(local_18 + 0x28),
           (uint)*(ushort *)(local_18 + 0x2a));
    local_18 = local_18 + 0x2c;
  }
  return;
}



undefined4 FUN_004641c4(char *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  size_t sVar2;
  int __fd;
  int iVar3;
  uint uVar4;
  uint param3;
  uint param4;
  undefined1 local_res0 [16];
  byte *local_2a0;
  uint local_29c;
  uint local_298;
  sockaddr local_260;
  char acStack_24c [16];
  char local_23c [16];
  char local_22c [42];
  ushort local_202;
  uint local_200;
  uint local_1f0;
  byte local_1ec;
  byte local_1eb;
  byte local_1ea;
  byte local_1e9;
  byte local_1e8;
  byte local_1e7;
  int local_1d4;
  int local_1d0;
  uint local_1cc;
  byte local_1c4 [424];
  char acStack_1c [20];
  
  builtin_strncpy(local_22c,"eth1",5);
  local_22c[5] = 0;
  local_22c[6] = 0;
  local_22c[7] = 0;
  local_22c[8] = 0;
  local_22c[9] = 0;
  local_22c[10] = 0;
  local_22c[0xb] = 0;
  local_22c[0xc] = 0;
  local_22c[0xd] = 0;
  local_22c[0xe] = 0;
  local_22c[0xf] = 0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    if (param_1 != (char *)0x0) {
      strncpy(local_22c,param_1,0xf);
    }
  }
  else {
    sVar2 = strlen((char *)*piVar1);
    if (0xf < sVar2) {
      printf("Interface name %s too long\n",(char *)*piVar1);
      return 0xffffffff;
    }
    strncpy(local_22c,(char *)*piVar1,0x10);
  }
  memset(acStack_24c,0,0x20);
  strncpy(acStack_24c,local_22c,0x10);
  __fd = socket(0x11,3,0x6c88);
  if (__fd < 0) {
    printf("Cannot create socket %d\n",__fd);
  }
  else {
    iVar3 = ioctl(__fd,0x8933,acStack_24c);
    if (iVar3 < 0) {
      printf("Cannot get index %d\n",iVar3);
      close(__fd);
    }
    else {
      memset(&local_260,0,0x14);
      local_260.sa_family = 0x11;
      local_260.sa_data[0] = -0x78;
      local_260.sa_data[1] = 'l';
      local_260.sa_data[2] = local_23c[0];
      local_260.sa_data[3] = local_23c[1];
      local_260.sa_data[4] = local_23c[2];
      local_260.sa_data[5] = local_23c[3];
      iVar3 = bind(__fd,&local_260,0x14);
      if (-1 < iVar3) {
        do {
          while( true ) {
            recv(__fd,local_22c + 0x10,0x200,0);
            uVar4 = local_200 << 0x18 | (local_200 & 0xff00) << 8 | (local_200 & 0xff0000) >> 8 |
                    local_200 >> 0x18;
            if (local_res0 != (undefined1 *)0x1ec) {
              sprintf(acStack_1c,"%02x:%02x:%02x:%02x:%02x:%02x",(uint)local_1ec,(uint)local_1eb,
                      (uint)local_1ea,(uint)local_1e9,(uint)local_1e8,(uint)local_1e7);
            }
            if ((((local_1f0 & 0xff) != 0 || (local_1f0 & 0xff00) != 0) ||
                (local_1f0 & 0xff0000) != 0) || local_1f0 >> 0x18 != 0) break;
            if (uVar4 == 0x52) {
              puts("Got WLC_E_PFN_SCAN_NONE");
            }
            if (uVar4 == 0x53) {
              puts("Got WLC_E_PFN_SCAN_ALLGONE");
            }
            if (uVar4 == 0x39) {
              puts("Got WLC_E_PFN_BEST_BATCHING");
            }
          }
          if (uVar4 == 0x8a) {
            local_2a0 = local_1c4;
            param3 = local_1cc & 0xffff;
            param4 = local_1cc >> 0x10;
            printf("ver %d, status %d, found %d, lost %d\n",local_1d4,local_1d0,param3,param4);
            if (param3 != 0) {
              puts("Network found:");
            }
            for (local_29c = 0; local_29c < param3; local_29c = local_29c + 1) {
              printf("%d. ",local_29c + 1);
              for (local_298 = 0; local_298 < local_2a0[7]; local_298 = local_298 + 1) {
                putchar((uint)local_2a0[local_298 + 8]);
              }
              putchar(10);
              printf("BSSID %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_2a0,(uint)local_2a0[1],
                     (uint)local_2a0[2],(uint)local_2a0[3],(uint)local_2a0[4],(uint)local_2a0[5]);
              printf("channel %d, RSSI %d, timestamp %d\n",(uint)local_2a0[6],
                     (int)*(short *)(local_2a0 + 0x28),(uint)*(ushort *)(local_2a0 + 0x2a));
              local_2a0 = local_2a0 + 0x2c;
            }
            if (param4 != 0) {
              puts("Network lost:");
            }
            for (local_29c = 0; local_29c < param4; local_29c = local_29c + 1) {
              printf("%d. ",local_29c + 1);
              for (local_298 = 0; local_298 < local_2a0[7]; local_298 = local_298 + 1) {
                putchar((uint)local_2a0[local_298 + 8]);
              }
              putchar(10);
              printf("BSSID %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*local_2a0,(uint)local_2a0[1],
                     (uint)local_2a0[2],(uint)local_2a0[3],(uint)local_2a0[4],(uint)local_2a0[5]);
              printf("channel %d, RSSI %d, timestamp %d\n",(uint)local_2a0[6],
                     (int)*(short *)(local_2a0 + 0x28),(uint)*(ushort *)(local_2a0 + 0x2a));
              local_2a0 = local_2a0 + 0x2c;
            }
          }
          else if ((((uVar4 == 0x21) || (uVar4 == 0x22)) || (uVar4 == 0x52)) || (uVar4 == 0x53)) {
            FUN_00463f64(&local_1d4,uVar4);
          }
          if ((uVar4 == 0x10) || (uVar4 == 0x12)) {
            if ((local_202 >> 8 & 1) == 0) {
              printf("MACEVENT Link down :%s\n",acStack_1c);
            }
            else {
              printf("MACEVENT Link up :%s\n",acStack_1c);
            }
          }
        } while( true );
      }
      printf("Cannot get index %d\n",iVar3);
      close(__fd);
    }
  }
  return 0xffffffff;
}



int FUN_00464ab8(int *param_1,undefined4 param_2,int param_3)

{
  int local_18;
  uint local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = FUN_004ba35c(param_1,"shub",local_10);
    if (DAT_00557704 != '\0') {
      local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                    (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
    }
    if (local_18 == 0) {
      FUN_00402444(local_10[0]);
    }
  }
  else {
    local_10[0] = atoi(*(char **)(param_3 + 4));
    local_18 = FUN_004ba428(param_1,"shub",(uint)(local_10[0] != 0));
  }
  return local_18;
}



undefined4 FUN_00464bf0(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  undefined4 local_18;
  int local_14;
  undefined2 local_10;
  undefined2 local_e;
  undefined2 local_c;
  
  local_18 = 0;
  for (local_14 = 0; *(int *)(param_3 + local_14 * 4) != 0; local_14 = local_14 + 1) {
  }
  if (local_14 < 4) {
    local_18 = 0xffffffd4;
  }
  else if (*(int *)(param_3 + 4) == 0) {
    puts("Incorrect Usage");
    local_18 = 0xffffffd4;
  }
  else {
    iVar1 = atoi(*(char **)(param_3 + 4));
    local_10 = (undefined2)iVar1;
    iVar1 = atoi(*(char **)(param_3 + 8));
    local_e = (undefined2)iVar1;
    iVar1 = atoi(*(char **)(param_3 + 0xc));
    local_c = (undefined2)iVar1;
    FUN_004ba2e4(param_1,"shub_req",&local_10,6);
  }
  return local_18;
}



int FUN_00464d44(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  size_t sVar2;
  int iVar3;
  int iVar4;
  void *__buf;
  ssize_t sVar5;
  byte *pbVar6;
  uint uVar7;
  int local_a0;
  byte local_9c;
  int local_98;
  int local_94;
  int local_90;
  sockaddr local_5c;
  char acStack_48 [16];
  char local_38 [16];
  char local_28 [24];
  byte local_10;
  
  builtin_strncpy(local_28,"eth1",5);
  local_28[5] = 0;
  local_28[6] = 0;
  local_28[7] = 0;
  local_28[8] = 0;
  local_28[9] = 0;
  local_28[10] = 0;
  local_28[0xb] = 0;
  local_28[0xc] = 0;
  local_28[0xd] = 0;
  local_28[0xe] = 0;
  local_28[0xf] = 0;
  local_9c = 4;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    if (param_1 != (int *)0x0) {
      strncpy(local_28,(char *)param_1,0xf);
    }
  }
  else {
    sVar2 = strlen((char *)*piVar1);
    if (0xf < sVar2) {
      printf("Interface name %s too long\n",(char *)*piVar1);
      return -1;
    }
    strncpy(local_28,(char *)*piVar1,0xf);
    if (*(int *)(param_3 + 8) != 0) {
      iVar3 = atoi(*(char **)(param_3 + 8));
      local_9c = (byte)iVar3;
    }
  }
  memset(acStack_48,0,0x20);
  strncpy(acStack_48,local_28,0xf);
  memset(local_28 + 0x10,0,0x10);
  iVar3 = FUN_004ba1f8(param_1,"event_msgs",local_28 + 0x10,0x10);
  if (iVar3 == 0) {
    local_10 = local_10 | 0x20;
    iVar3 = FUN_004ba2e4(param_1,"event_msgs",local_28 + 0x10,0x10);
    if (iVar3 == 0) {
      iVar3 = socket(0x11,3,0x6c88);
      if (iVar3 < 0) {
        printf("Cannot create socket %d\n",iVar3);
        iVar3 = -1;
      }
      else {
        iVar4 = ioctl(iVar3,0x8933,acStack_48);
        if (iVar4 < 0) {
          printf("Cannot get index %d\n",iVar4);
          close(iVar3);
          iVar3 = -1;
        }
        else {
          memset(&local_5c,0,0x14);
          local_5c.sa_family = 0x11;
          local_5c.sa_data[0] = -0x78;
          local_5c.sa_data[1] = 'l';
          local_5c.sa_data[2] = local_38[0];
          local_5c.sa_data[3] = local_38[1];
          local_5c.sa_data[4] = local_38[2];
          local_5c.sa_data[5] = local_38[3];
          iVar4 = bind(iVar3,&local_5c,0x14);
          if (iVar4 < 0) {
            printf("Cannot bind %d\n",iVar4);
            close(iVar3);
            iVar3 = -1;
          }
          else {
            __buf = malloc(0x800);
            if (__buf == (void *)0x0) {
              printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
              close(iVar3);
              iVar3 = -0x1b;
            }
            else {
              while( true ) {
                do {
                  do {
                    do {
                      do {
                        sVar5 = recv(iVar3,__buf,0x800,0);
                        uVar7 = *(uint *)((int)__buf + 0x1c);
                      } while ((uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 |
                               uVar7 >> 0x18) != 0x45);
                    } while (sVar5 < 1);
                    piVar1 = (int *)((int)__buf + 0x48);
                    uVar7 = *(uint *)((int)__buf + 0x20);
                    uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 |
                            uVar7 >> 0x18;
                    if ((local_9c & 1) != 0) {
                      printf("WLC_E_ESCAN_RESULT, (sync_id,status) = (%d,%d)\n",
                             (uint)*(ushort *)((int)__buf + 0x50),uVar7);
                    }
                    if ((local_9c & 2) != 0) {
                      for (local_a0 = 0; local_a0 < (int)(uint)*(ushort *)((int)__buf + 0x52);
                          local_a0 = local_a0 + 1) {
                        FUN_004242c8((uint *)(piVar1 + local_a0 * 0x20 + 3));
                      }
                    }
                    if ((local_9c & 4) != 0) {
                      if (uVar7 == 8) {
                        printf("sync_id: %d, WLC_E_STATUS_PARTIAL\n",
                               (uint)*(ushort *)((int)__buf + 0x50));
                        for (local_a0 = 0; local_a0 < (int)(uint)*(ushort *)((int)__buf + 0x52);
                            local_a0 = local_a0 + 1) {
                          FUN_004242c8((uint *)(piVar1 + local_a0 * 0x20 + 3));
                        }
                      }
                      if (uVar7 == 0) {
                        printf("sync_id: %d, WLC_E_STATUS_SUCCESS => SCAN_DONE\n",
                               (uint)*(ushort *)((int)__buf + 0x50));
                      }
                      else if (uVar7 != 8) {
                        printf("sync_id: %d, status:%d, misc. error/abort\n",
                               (uint)*(ushort *)((int)__buf + 0x50),uVar7);
                      }
                    }
                  } while ((local_9c & 8) == 0);
                  local_98 = *(int *)((int)__buf + 0xcc);
                  local_94 = 0x8c;
                  local_90 = (int)__buf + 0xd4;
                } while (uVar7 != 8);
                printf("MOREINFO: (sync_id,buflen,ielen) = (%d,%d,%d)\n",
                       (uint)*(ushort *)((int)__buf + 0x50),*piVar1,*(int *)((int)__buf + 0xcc));
                for (; 0 < local_98; local_98 = local_98 + (-2 - (uint)*pbVar6)) {
                  local_94 = local_94 + *(byte *)(local_90 + 1) + 2;
                  pbVar6 = (byte *)(local_90 + 1);
                  local_90 = local_90 + *(byte *)(local_90 + 1) + 2;
                }
                if (0x7ff < local_94) break;
                if ((local_98 != 0) &&
                   (printf("ERROR: IE tlv sanity check failed for (ssid,sync_id,buflen,ielen,remainder) = (%s,%d,%d,%d,%d)\n"
                           ,(char *)((int)__buf + 0x67),(uint)*(ushort *)((int)__buf + 0x50),*piVar1
                           ,*(int *)((int)__buf + 0xcc),local_98), *piVar1 != 0x8c)) {
                  for (local_a0 = 0; local_a0 < *piVar1 + -0x8c; local_a0 = local_a0 + 1) {
                    printf("%02x ",(uint)*(byte *)((int)__buf + local_a0 + 0xd4));
                  }
                  putchar(10);
                }
              }
              free(__buf);
              close(iVar3);
              iVar3 = 0;
            }
          }
        }
      }
    }
  }
  return iVar3;
}



int FUN_004655c8(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined4 *__s;
  int __fd;
  uint uVar4;
  int iVar5;
  void *__buf;
  ssize_t sVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  undefined4 uVar9;
  int local_c0;
  int local_bc;
  undefined4 *local_b4;
  undefined4 *local_b0;
  undefined4 *local_ac;
  undefined4 *local_a8;
  size_t local_60;
  sockaddr local_5c;
  char acStack_48 [16];
  char local_38 [16];
  char local_28 [24];
  byte local_10;
  
  local_bc = 0;
  builtin_strncpy(local_28,"eth1",5);
  local_28[5] = 0;
  local_28[6] = 0;
  local_28[7] = 0;
  local_28[8] = 0;
  local_28[9] = 0;
  local_28[10] = 0;
  local_28[0xb] = 0;
  local_28[0xc] = 0;
  local_28[0xd] = 0;
  local_28[0xe] = 0;
  local_28[0xf] = 0;
  bVar1 = false;
  local_b4 = (undefined4 *)0x0;
  local_b0 = (undefined4 *)0x0;
  local_60 = 0x230;
  __s = (undefined4 *)malloc(0x230);
  if (__s == (undefined4 *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",local_60);
    return -0x1b;
  }
  memset(__s,0,local_60);
  local_c0 = FUN_0041eee4(param_1,param_2,param_3,__s + 2,&local_60);
  if (local_c0 == 0) {
    memset(acStack_48,0,0x20);
    if (param_1 == (int *)0x0) {
      strncpy(acStack_48,local_28,0xf);
    }
    else {
      strncpy(acStack_48,(char *)param_1,0xf);
    }
    memset(local_28 + 0x10,0,0x10);
    local_c0 = FUN_004ba1f8(param_1,"event_msgs",local_28 + 0x10,0x10);
    if (local_c0 == 0) {
      if ((local_10 & 0x20) == 0) {
        local_10 = local_10 | 0x20;
        local_c0 = FUN_004ba2e4(param_1,"event_msgs",local_28 + 0x10,0x10);
        if (local_c0 != 0) goto LAB_0046601c;
        bVar1 = true;
      }
      __fd = socket(0x11,3,0x6c88);
      if (__fd < 0) {
        printf("Cannot create socket %d\n",__fd);
        local_c0 = -1;
      }
      else {
        local_c0 = ioctl(__fd,0x8933,acStack_48);
        if (local_c0 < 0) {
          printf("Cannot get index %d\n",local_c0);
        }
        else {
          memset(&local_5c,0,0x14);
          local_5c.sa_family = 0x11;
          local_5c.sa_data[0] = -0x78;
          local_5c.sa_data[1] = 'l';
          local_5c.sa_data[2] = local_38[0];
          local_5c.sa_data[3] = local_38[1];
          local_5c.sa_data[4] = local_38[2];
          local_5c.sa_data[5] = local_38[3];
          local_c0 = bind(__fd,&local_5c,0x14);
          if (local_c0 < 0) {
            printf("Cannot bind %d\n",local_c0);
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar9 = 1;
            }
            else {
              uVar9 = 0x1000000;
            }
            *__s = uVar9;
            if (DAT_00557704 == '\0') {
              uVar2 = 1;
            }
            else {
              uVar2 = 0x100;
            }
            *(undefined2 *)(__s + 1) = uVar2;
            uVar4 = time((time_t *)0x0);
            srand(uVar4);
            if (DAT_00557704 == '\0') {
              iVar5 = rand();
              uVar3 = (ushort)iVar5;
            }
            else {
              iVar5 = rand();
              uVar3 = (ushort)iVar5 << 8 | (ushort)iVar5 >> 8;
            }
            *(ushort *)((int)__s + 6) = uVar3;
            local_60 = local_60 + 8;
            local_c0 = FUN_004ba160(param_1,"escan",__s,local_60,PTR_DAT_00551644,0x2000);
            if (local_c0 == 0) {
              __buf = malloc(0x800);
              puVar8 = local_b4;
              puVar7 = local_b0;
              if (__buf == (void *)0x0) {
                printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
                local_c0 = -0x1b;
              }
              else {
LAB_00465b18:
                while( true ) {
                  do {
                    do {
                      local_b0 = puVar7;
                      local_b4 = puVar8;
                      sVar6 = recv(__fd,__buf,0x800,0);
                      uVar4 = *(uint *)((int)__buf + 0x1c);
                      puVar8 = local_b4;
                      puVar7 = local_b0;
                    } while ((uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                             uVar4 >> 0x18) != 0x45);
                  } while (sVar6 < 1);
                  uVar4 = *(uint *)((int)__buf + 0x20);
                  uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                          uVar4 >> 0x18;
                  if (uVar4 != 8) {
                    if (uVar4 == 0) {
                      for (local_ac = local_b4; local_ac != (undefined4 *)0x0;
                          local_ac = (undefined4 *)*local_ac) {
                        FUN_004242c8(local_ac + 1);
                      }
                    }
                    else {
                      printf("sync_id: %d, status:%d, misc. error/abort\n",
                             (uint)*(ushort *)((int)__buf + 0x50),uVar4);
                    }
                    goto LAB_00465f98;
                  }
                  if ((0x7f < *(uint *)((int)__buf + 0x58)) &&
                     (*(uint *)((int)__buf + 0x58) < 0x5dd)) break;
                  fprintf(stderr,"Cannot trust bi->length %d, skipping\n",
                          *(int *)((int)__buf + 0x58));
                }
                for (local_ac = local_b4; local_ac != (undefined4 *)0x0;
                    local_ac = (undefined4 *)*local_ac) {
                  local_a8 = local_ac + 1;
                  iVar5 = FUN_00422974((void *)((int)__buf + 0x5c),local_ac + 3,6);
                  if ((((iVar5 == 0) &&
                       (((*(ushort *)((int)__buf + 0x9c) ^ *(ushort *)(local_ac + 0x13)) & 0xc000)
                        == 0)) && (*(char *)((int)__buf + 0x66) == *(char *)((int)local_ac + 0x16)))
                     && (iVar5 = FUN_00422974((void *)((int)__buf + 0x67),
                                              (void *)((int)local_ac + 0x17),
                                              (uint)*(byte *)((int)__buf + 0x66)), iVar5 == 0))
                  break;
                }
                if (local_ac != (undefined4 *)0x0) {
                  if (*(short *)((int)__buf + 0xa2) != 0) {
                    if ((((*(byte *)(local_a8 + 0x18) ^ *(byte *)((int)__buf + 0xb4)) & 4) == 0) &&
                       ((*(short *)((int)local_a8 + 0x4e) == 0 ||
                        (*(short *)((int)local_a8 + 0x4e) < *(short *)((int)__buf + 0xa2))))) {
                      *(undefined2 *)((int)local_a8 + 0x4e) = *(undefined2 *)((int)__buf + 0xa2);
                      *(undefined2 *)(local_a8 + 0x1f) = *(undefined2 *)((int)__buf + 0xd0);
                      *(undefined1 *)(local_a8 + 0x14) = *(undefined1 *)((int)__buf + 0xa4);
                    }
                    else if (((*(byte *)((int)__buf + 0xb4) & 4) != 0) &&
                            ((*(byte *)(local_a8 + 0x18) & 4) == 0)) {
                      *(undefined2 *)((int)local_a8 + 0x4e) = *(undefined2 *)((int)__buf + 0xa2);
                      *(undefined2 *)(local_a8 + 0x1f) = *(undefined2 *)((int)__buf + 0xd0);
                      *(undefined1 *)(local_a8 + 0x14) = *(undefined1 *)((int)__buf + 0xa4);
                      *(byte *)(local_a8 + 0x18) = *(byte *)(local_a8 + 0x18) | 4;
                    }
                  }
                  goto LAB_00465b18;
                }
                puVar7 = (undefined4 *)malloc(*(int *)((int)__buf + 0x58) + 4);
                if (puVar7 != (undefined4 *)0x0) {
                  *puVar7 = 0;
                  memcpy(puVar7 + 1,(void *)((int)__buf + 0x54),*(size_t *)((int)__buf + 0x58));
                  puVar8 = puVar7;
                  if (local_b0 != (undefined4 *)0x0) {
                    *local_b0 = puVar7;
                    puVar8 = local_b4;
                  }
                  goto LAB_00465b18;
                }
                perror("can\'t allocate memory for bss");
LAB_00465f98:
                local_ac = local_b4;
                while (local_ac != (undefined4 *)0x0) {
                  puVar8 = (undefined4 *)*local_ac;
                  free(local_ac);
                  local_ac = puVar8;
                }
                free(__buf);
              }
            }
          }
        }
        close(__fd);
      }
    }
  }
LAB_0046601c:
  free(__s);
  if ((bVar1) && (local_bc = FUN_004ba1f8(param_1,"event_msgs",local_28 + 0x10,0x10), local_bc == 0)
     ) {
    local_10 = local_10 & 0xdf;
    local_bc = FUN_004ba2e4(param_1,"event_msgs",local_28 + 0x10,0x10);
  }
  if (local_bc != 0) {
    fprintf(stderr,"Failed to revert event mask, error %d\n",local_bc);
  }
  if (local_c0 != 0) {
    local_bc = local_c0;
  }
  return local_bc;
}



int FUN_004660fc(int *param_1)

{
  int iVar1;
  undefined1 auStack_1c [2];
  byte local_1a;
  byte local_18;
  byte local_12;
  
  memset(auStack_1c,0,0x10);
  local_1a = local_1a | 1;
  local_18 = local_18 | 6;
  local_12 = local_12 | 0xc;
  iVar1 = FUN_004ba2e4(param_1,"event_msgs",auStack_1c,0x10);
  if (iVar1 == 0) {
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_004661d8(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  int iVar5;
  uint *puVar6;
  uint uVar7;
  ulong uVar8;
  int *local_res8;
  undefined2 local_28;
  ushort local_26;
  ushort local_24;
  ulong local_20;
  ulong local_1c;
  ushort local_18;
  undefined1 local_16;
  undefined1 local_15;
  ulong local_14;
  char *local_10 [2];
  
  memset(&local_28,0,0x18);
  if (DAT_00557704 == '\0') {
    local_28 = 1;
  }
  else {
    local_28 = 0x100;
  }
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    iVar5 = FUN_004ba0cc(param_1,(char *)*param_2,&local_28,0x18,PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar2 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (uVar2 == 1) {
        if (DAT_00557704 == '\0') {
          uVar2 = *(ushort *)(PTR_DAT_00551644 + 2);
          uVar3 = *(ushort *)(PTR_DAT_00551644 + 4);
        }
        else {
          uVar2 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 | *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
          uVar3 = *(ushort *)(PTR_DAT_00551644 + 4) << 8 | *(ushort *)(PTR_DAT_00551644 + 4) >> 8;
        }
        if (uVar3 == 0) {
          puts("Override not configured");
        }
        else {
          if (uVar2 == 0) {
            printf("Active, remaining duration %d\n",(uint)uVar3);
          }
          else {
            printf("Scheduled in %d, duration %d\n",(uint)uVar2,(uint)uVar3);
          }
          puVar6 = (uint *)(puVar1 + 8);
          if (DAT_00557704 == '\0') {
            uVar7 = *puVar6;
          }
          else {
            uVar7 = *puVar6;
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
          }
          *puVar6 = uVar7;
          if (DAT_00557704 == '\0') {
            uVar7 = *(uint *)(puVar1 + 0xc);
          }
          else {
            uVar7 = *(uint *)(puVar1 + 0xc);
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
          }
          *(uint *)(puVar1 + 0xc) = uVar7;
          if (DAT_00557704 == '\0') {
            uVar2 = *(ushort *)(puVar1 + 0x10);
          }
          else {
            uVar2 = *(ushort *)(puVar1 + 0x10) << 8 | *(ushort *)(puVar1 + 0x10) >> 8;
          }
          *(ushort *)(puVar1 + 0x10) = uVar2;
          if (DAT_00557704 == '\0') {
            uVar7 = *(uint *)(puVar1 + 0x14);
          }
          else {
            uVar7 = *(uint *)(puVar1 + 0x14);
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
          }
          *(uint *)(puVar1 + 0x14) = uVar7;
          printf("Scan frequency: %d\n",*puVar6);
          if (*(int *)(puVar1 + 0xc) != 0) {
            if (DAT_00557704 == '\0') {
              uVar7 = *(uint *)(puVar1 + 0xc);
            }
            else {
              uVar7 = *(uint *)(puVar1 + 0xc);
              uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 |
                      uVar7 >> 0x18;
            }
            printf("Net timeout: %d\n",uVar7);
          }
          if ((*(ushort *)(puVar1 + 0x10) & 1) != 0) {
            printf("Adapt: %s\n",(&PTR_DAT_00555f64)[(*(ushort *)(puVar1 + 0x10) & 6) >> 1]);
          }
          if (puVar1[0x12] != '\0') {
            printf("  Exp: %d\n",(uint)(byte)puVar1[0x12]);
          }
          if (puVar1[0x13] != '\0') {
            printf("  Repeat: %d\n",(uint)(byte)puVar1[0x13]);
          }
          if (*(int *)(puVar1 + 0x14) != 0) {
            printf("  Slow: %d\n",*(int *)(puVar1 + 0x14));
          }
        }
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar2 = *(ushort *)PTR_DAT_00551644;
        }
        else {
          uVar2 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
        }
        fprintf(stderr,"Incorrect version (%d != %d).\n",(uint)uVar2,1);
        iVar5 = -1;
      }
    }
  }
  else {
    uVar8 = strtoul((char *)*piVar4,local_10,0);
    uVar2 = (ushort)uVar8;
    if (*local_10[0] == '\0') {
      if (*(int *)(param_3 + 8) == 0) {
        fwrite("Duration required\n",1,0x12,stderr);
        iVar5 = -1;
      }
      else {
        uVar8 = strtoul(*(char **)(param_3 + 8),local_10,0);
        uVar3 = (ushort)uVar8;
        local_res8 = (int *)(param_3 + 0xc);
        if (uVar3 == 0) {
          if (uVar2 != 0) {
            fwrite("Start with no duration invalid\n",1,0x1f,stderr);
            return -1;
          }
        }
        else {
          if ((*local_res8 == 0) || (iVar5 = strcmp((char *)*local_res8,"scanfrq"), iVar5 != 0)) {
            fwrite("scanfrq required as first parameter\n",1,0x24,stderr);
            return -1;
          }
          if (*(int *)(param_3 + 0x10) == 0) {
            fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
            return -1;
          }
          local_20 = strtoul(*(char **)(param_3 + 0x10),local_10,0);
          if (*local_10[0] != '\0') {
            fprintf(stderr,"Non-numeric scanfrq %s\n",*(char **)(param_3 + 0x10));
            return -1;
          }
          local_res8 = (int *)(param_3 + 0x14);
          while ((*local_res8 != 0 && (local_20 != 0))) {
            if ((*local_res8 == 0) || (iVar5 = strcmp((char *)*local_res8,"netimeout"), iVar5 != 0))
            {
              if ((*local_res8 == 0) || (iVar5 = strcmp((char *)*local_res8,"adapt"), iVar5 != 0)) {
                if ((*local_res8 == 0) || (iVar5 = strcmp((char *)*local_res8,"repeat"), iVar5 != 0)
                   ) {
                  if ((*local_res8 == 0) || (iVar5 = strcmp((char *)*local_res8,"exp"), iVar5 != 0))
                  {
                    if ((*local_res8 == 0) ||
                       (iVar5 = strcmp((char *)*local_res8,"slowfrq"), iVar5 != 0)) break;
                    if (local_res8[1] == 0) {
                      fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                      return -1;
                    }
                    local_14 = strtoul((char *)local_res8[1],local_10,0);
                    if (*local_10[0] != '\0') {
                      fprintf(stderr,"Non-numeric slowfrq value %s\n",(char *)local_res8[1]);
                      return -1;
                    }
                    local_res8 = local_res8 + 2;
                  }
                  else {
                    if (local_res8[1] == 0) {
                      fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                      return -1;
                    }
                    uVar8 = strtoul((char *)local_res8[1],local_10,0);
                    local_16 = (undefined1)uVar8;
                    if (*local_10[0] != '\0') {
                      fprintf(stderr,"Non-numeric exp value %s\n",(char *)local_res8[1]);
                      return -1;
                    }
                    local_res8 = local_res8 + 2;
                  }
                }
                else {
                  if (local_res8[1] == 0) {
                    fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                    return -1;
                  }
                  uVar8 = strtoul((char *)local_res8[1],local_10,0);
                  local_15 = (undefined1)uVar8;
                  if (*local_10[0] != '\0') {
                    fprintf(stderr,"Non-numeric repeat value %s\n",(char *)local_res8[1]);
                    return -1;
                  }
                  local_res8 = local_res8 + 2;
                }
              }
              else {
                if (local_res8[1] == 0) {
                  fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                  return -1;
                }
                piVar4 = local_res8 + 1;
                iVar5 = strcmp((char *)*piVar4,"off");
                if (iVar5 != 0) {
                  iVar5 = strcmp((char *)*piVar4,"smart");
                  if (iVar5 == 0) {
                    local_18 = local_18 | 2;
                  }
                  else {
                    iVar5 = strcmp((char *)*piVar4,"strict");
                    if (iVar5 == 0) {
                      local_18 = local_18 | 4;
                    }
                    else {
                      iVar5 = strcmp((char *)*piVar4,"slow");
                      if (iVar5 != 0) {
                        fprintf(stderr,"Invalid adaptive scan option %s\n",(char *)*piVar4);
                        return -1;
                      }
                      local_18 = local_18 | 6;
                    }
                  }
                }
                local_18 = local_18 | 1;
                local_res8 = local_res8 + 2;
              }
            }
            else {
              if (local_res8[1] == 0) {
                fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                return -1;
              }
              local_1c = strtoul((char *)local_res8[1],local_10,0);
              if (*local_10[0] != '\0') {
                fprintf(stderr,"Non-numeric netimeout %s\n",(char *)local_res8[1]);
                return -1;
              }
              local_res8 = local_res8 + 2;
            }
          }
          if (DAT_00557704 != '\0') {
            local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                       local_14 >> 0x18;
          }
        }
        if (*local_res8 == 0) {
          local_26 = uVar2;
          if (DAT_00557704 != '\0') {
            uVar3 = uVar3 << 8 | uVar3 >> 8;
            local_26 = uVar2 << 8 | uVar2 >> 8;
          }
          local_24 = uVar3;
          iVar5 = FUN_004ba160(param_1,(char *)*param_2,&local_28,0x18,PTR_DAT_00551644,0x2000);
        }
        else {
          fprintf(stderr,"Input error at %s\n",(char *)*local_res8);
          iVar5 = -1;
        }
      }
    }
    else {
      fprintf(stderr,"Non-numeric start value %s\n",(char *)*piVar4);
      iVar5 = -1;
    }
  }
  return iVar5;
}



int FUN_004673b4(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  char *__s;
  char local_14 [2];
  undefined1 auStack_12 [10];
  
  memset(local_14,0,8);
  local_14[0] = '\x01';
  if (param_3[1] == 0) {
    iVar2 = FUN_004ba1f8(param_1,"pfn_macaddr",local_14,8);
    if (-1 < iVar2) {
      __s = FUN_0041d780((int)auStack_12);
      puts(__s);
    }
  }
  else {
    bVar1 = FUN_0041d6ac((char *)param_3[1],auStack_12);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      fprintf(stderr,"Invalid MAC address %s\n",(char *)*param_3);
      iVar2 = -1;
    }
    else {
      iVar2 = FUN_004ba2e4(param_1,"pfn_macaddr",local_14,8);
    }
  }
  return iVar2;
}



int FUN_00467508(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  int *piVar3;
  int iVar4;
  ulong uVar5;
  uint uVar6;
  ulong *puVar7;
  ulong uVar8;
  int *local_res8;
  uint *local_94;
  uint local_90;
  undefined2 local_54;
  ushort local_52;
  ulong auStack_50 [2];
  ushort uStack_48;
  undefined1 auStack_46 [2];
  ulong auStack_44 [13];
  char *local_10 [2];
  
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    fwrite("Requires at least <groupid>\n",1,0x1c,stderr);
    iVar4 = -1;
  }
  else {
    memset(&local_54,0,0x44);
    if (DAT_00557704 == '\0') {
      local_54 = 1;
      uVar5 = strtoul((char *)*piVar3,local_10,0);
      local_52 = (ushort)uVar5;
    }
    else {
      local_54 = 0x100;
      uVar5 = strtoul((char *)*piVar3,local_10,0);
      local_52 = (ushort)uVar5 << 8 | (ushort)uVar5 >> 8;
    }
    if (*local_10[0] == '\0') {
      local_res8 = (int *)(param_3 + 8);
      if (*local_res8 == 0) {
        iVar4 = FUN_004ba0cc(param_1,(char *)*param_2,&local_54,4,PTR_DAT_00551644,0x2000);
        if (-1 < iVar4) {
          if (DAT_00557704 == '\0') {
            uVar1 = *(ushort *)PTR_DAT_00551644;
          }
          else {
            uVar1 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
          }
          if (uVar1 == 1) {
            if (*(ushort *)(PTR_DAT_00551644 + 2) == local_52) {
              local_94 = (uint *)(PTR_DAT_00551644 + 4);
              for (local_90 = 0; local_90 < 4; local_90 = local_90 + 1) {
                if (*local_94 != 0) {
                  if (DAT_00557704 == '\0') {
                    uVar6 = *local_94;
                  }
                  else {
                    uVar6 = *local_94;
                    uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                            uVar6 >> 0x18;
                  }
                  *local_94 = uVar6;
                  if (DAT_00557704 == '\0') {
                    uVar6 = local_94[1];
                  }
                  else {
                    uVar6 = local_94[1];
                    uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                            uVar6 >> 0x18;
                  }
                  local_94[1] = uVar6;
                  if (DAT_00557704 == '\0') {
                    uVar1 = (ushort)local_94[2];
                  }
                  else {
                    uVar1 = (ushort)local_94[2] << 8 | (ushort)local_94[2] >> 8;
                  }
                  *(ushort *)(local_94 + 2) = uVar1;
                  if (DAT_00557704 == '\0') {
                    uVar6 = local_94[3];
                  }
                  else {
                    uVar6 = local_94[3];
                    uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                            uVar6 >> 0x18;
                  }
                  local_94[3] = uVar6;
                  printf("State %d:\n  Scan frequency: %d\n",local_90,*local_94);
                  if (local_94[1] != 0) {
                    if (DAT_00557704 == '\0') {
                      uVar6 = local_94[1];
                    }
                    else {
                      uVar6 = local_94[1];
                      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                              uVar6 >> 0x18;
                    }
                    printf("  Net timeout: %d\n",uVar6);
                  }
                  if ((local_94[2] & 1) != 0) {
                    printf("  Adapt: %s\n",(&PTR_DAT_00555f64)[((ushort)local_94[2] & 6) >> 1]);
                  }
                  if (*(char *)((int)local_94 + 10) != '\0') {
                    printf("  Exp: %d\n",(uint)*(byte *)((int)local_94 + 10));
                  }
                  if (*(char *)((int)local_94 + 0xb) != '\0') {
                    printf("  Repeat: %d\n",(uint)*(byte *)((int)local_94 + 0xb));
                  }
                  if (local_94[3] != 0) {
                    printf("  Slow: %d\n",local_94[3]);
                  }
                }
                local_94 = local_94 + 4;
              }
            }
            else {
              uVar1 = local_52;
              if (DAT_00557704 != '\0') {
                uVar1 = local_52 << 8 | local_52 >> 8;
              }
              if (DAT_00557704 == '\0') {
                uVar2 = *(ushort *)(PTR_DAT_00551644 + 2);
              }
              else {
                uVar2 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 |
                        *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
              }
              fprintf(stderr,"Groupid modified (%d -> %d)?\n",(uint)uVar1,(uint)uVar2);
              iVar4 = -1;
            }
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar1 = *(ushort *)PTR_DAT_00551644;
            }
            else {
              uVar1 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
            }
            fprintf(stderr,"Incorrect version (%d != %d).\n",(uint)uVar1,1);
            iVar4 = -1;
          }
        }
      }
      else {
        while ((*local_res8 != 0 && (iVar4 = strcmp((char *)*local_res8,"state"), iVar4 == 0))) {
          if (local_res8[1] == 0) {
            fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
            return -1;
          }
          uVar5 = strtoul((char *)local_res8[1],local_10,0);
          if (*local_10[0] != '\0') {
            fprintf(stderr,"Non-numeric state %s\n",(char *)local_res8[1]);
            return -1;
          }
          if (3 < uVar5) {
            fprintf(stderr,"Invalid state %d\n",uVar5);
            return -1;
          }
          piVar3 = local_res8 + 2;
          puVar7 = auStack_50 + uVar5 * 4;
          if (*puVar7 != 0) {
            fprintf(stderr,"Repeated state (%d)\n",uVar5);
            return -1;
          }
          if ((*piVar3 == 0) || (iVar4 = strcmp((char *)*piVar3,"scanfrq"), iVar4 != 0)) {
            fwrite("State requires scanfrq\n",1,0x17,stderr);
            return -1;
          }
          if (local_res8[3] == 0) {
            fprintf(stderr,"Missing value for \'%s\'\n",(char *)*piVar3);
            return -1;
          }
          uVar8 = strtoul((char *)local_res8[3],local_10,0);
          *puVar7 = uVar8;
          if (*local_10[0] != '\0') {
            fprintf(stderr,"Non-numeric scanfrq %s\n",(char *)local_res8[3]);
            return -1;
          }
          local_res8 = local_res8 + 4;
          if (*puVar7 != 0) {
            while (*local_res8 != 0) {
              if ((*local_res8 == 0) ||
                 (iVar4 = strcmp((char *)*local_res8,"netimeout"), iVar4 != 0)) {
                if ((*local_res8 == 0) || (iVar4 = strcmp((char *)*local_res8,"adapt"), iVar4 != 0))
                {
                  if ((*local_res8 == 0) ||
                     (iVar4 = strcmp((char *)*local_res8,"repeat"), iVar4 != 0)) {
                    if ((*local_res8 == 0) ||
                       (iVar4 = strcmp((char *)*local_res8,"exp"), iVar4 != 0)) {
                      if ((*local_res8 == 0) ||
                         (iVar4 = strcmp((char *)*local_res8,"slowfrq"), iVar4 != 0)) break;
                      if (local_res8[1] == 0) {
                        fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                        return -1;
                      }
                      uVar8 = strtoul((char *)local_res8[1],local_10,0);
                      auStack_44[uVar5 * 4] = uVar8;
                      if (*local_10[0] != '\0') {
                        fprintf(stderr,"Non-numeric slowfrq value %s\n",(char *)local_res8[1]);
                        return -1;
                      }
                      local_res8 = local_res8 + 2;
                    }
                    else {
                      if (local_res8[1] == 0) {
                        fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                        return -1;
                      }
                      uVar8 = strtoul((char *)local_res8[1],local_10,0);
                      auStack_46[uVar5 * 0x10] = (char)uVar8;
                      if (*local_10[0] != '\0') {
                        fprintf(stderr,"Non-numeric exp value %s\n",(char *)local_res8[1]);
                        return -1;
                      }
                      local_res8 = local_res8 + 2;
                    }
                  }
                  else {
                    if (local_res8[1] == 0) {
                      fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                      return -1;
                    }
                    uVar8 = strtoul((char *)local_res8[1],local_10,0);
                    auStack_46[uVar5 * 0x10 + 1] = (char)uVar8;
                    if (*local_10[0] != '\0') {
                      fprintf(stderr,"Non-numeric repeat value %s\n",(char *)local_res8[1]);
                      return -1;
                    }
                    local_res8 = local_res8 + 2;
                  }
                }
                else {
                  if (local_res8[1] == 0) {
                    fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                    return -1;
                  }
                  piVar3 = local_res8 + 1;
                  iVar4 = strcmp((char *)*piVar3,"off");
                  if (iVar4 == 0) {
                    (&uStack_48)[uVar5 * 8] = (&uStack_48)[uVar5 * 8];
                  }
                  else {
                    iVar4 = strcmp((char *)*piVar3,"smart");
                    if (iVar4 == 0) {
                      (&uStack_48)[uVar5 * 8] = (&uStack_48)[uVar5 * 8] | 2;
                    }
                    else {
                      iVar4 = strcmp((char *)*piVar3,"strict");
                      if (iVar4 == 0) {
                        (&uStack_48)[uVar5 * 8] = (&uStack_48)[uVar5 * 8] | 4;
                      }
                      else {
                        iVar4 = strcmp((char *)*piVar3,"slow");
                        if (iVar4 != 0) {
                          fprintf(stderr,"Invalid adaptive scan option %s\n",(char *)*piVar3);
                          return -1;
                        }
                        (&uStack_48)[uVar5 * 8] = (&uStack_48)[uVar5 * 8] | 6;
                      }
                    }
                  }
                  (&uStack_48)[uVar5 * 8] = (&uStack_48)[uVar5 * 8] | 1;
                  local_res8 = local_res8 + 2;
                }
              }
              else {
                if (local_res8[1] == 0) {
                  fprintf(stderr,"Missing value for \'%s\'\n",(char *)*local_res8);
                  return -1;
                }
                uVar8 = strtoul((char *)local_res8[1],local_10,0);
                auStack_50[uVar5 * 4 + 1] = uVar8;
                if (*local_10[0] != '\0') {
                  fprintf(stderr,"Non-numeric netimeout %s\n",(char *)local_res8[1]);
                  return -1;
                }
                local_res8 = local_res8 + 2;
              }
            }
            if (DAT_00557704 == '\0') {
              uVar8 = *puVar7;
            }
            else {
              uVar6 = *puVar7;
              uVar8 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                      uVar6 >> 0x18;
            }
            *puVar7 = uVar8;
            if (DAT_00557704 == '\0') {
              uVar6 = auStack_50[uVar5 * 4 + 1];
            }
            else {
              uVar6 = auStack_50[uVar5 * 4 + 1];
              uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                      uVar6 >> 0x18;
            }
            auStack_50[uVar5 * 4 + 1] = uVar6;
            if (DAT_00557704 == '\0') {
              uVar1 = (&uStack_48)[uVar5 * 8];
            }
            else {
              uVar1 = (&uStack_48)[uVar5 * 8] << 8 | (&uStack_48)[uVar5 * 8] >> 8;
            }
            (&uStack_48)[uVar5 * 8] = uVar1;
            if (DAT_00557704 == '\0') {
              uVar6 = auStack_44[uVar5 * 4];
            }
            else {
              uVar6 = auStack_44[uVar5 * 4];
              uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                      uVar6 >> 0x18;
            }
            auStack_44[uVar5 * 4] = uVar6;
          }
        }
        if (*local_res8 == 0) {
          iVar4 = FUN_004ba160(param_1,(char *)*param_2,&local_54,0x44,PTR_DAT_00551644,0x2000);
        }
        else {
          fprintf(stderr,"Input error at %s\n",(char *)*local_res8);
          iVar4 = -1;
        }
      }
    }
    else {
      fprintf(stderr,"Non-numeric groupid %s\n",(char *)*piVar3);
      iVar4 = -1;
    }
  }
  return iVar4;
}



int FUN_004687e8(int *param_1,undefined4 *param_2,int param_3)

{
  char cVar1;
  uchar param3;
  undefined *puVar2;
  ushort uVar3;
  ushort uVar4;
  int iVar5;
  int *piVar6;
  ulong uVar7;
  uint uVar8;
  size_t sVar9;
  int *local_res8;
  ushort *local_cc;
  ushort *local_c8;
  byte local_c4;
  undefined2 local_98 [2];
  ushort local_94;
  byte local_92;
  ushort local_90 [64];
  ushort local_10 [2];
  char *local_c;
  
  local_res8 = (int *)(param_3 + 4);
  memset(local_98,0,0x88);
  if (DAT_00557704 == '\0') {
    local_98[0] = 1;
  }
  else {
    local_98[0] = 0x100;
  }
  if ((*local_res8 != 0) && (iVar5 = strcmp((char *)*local_res8,"type"), iVar5 == 0)) {
    piVar6 = (int *)(param_3 + 8);
    if (*piVar6 == 0) {
      fwrite("No type value specified\n",1,0x18,stderr);
      return -1;
    }
    uVar7 = strtoul((char *)*piVar6,&local_c,0);
    if (*local_c != '\0') {
      fprintf(stderr,"Non-numeric type value %s\n",(char *)*piVar6);
      return -1;
    }
    if ((short)uVar7 != 0) {
      fwrite("Nonzero type not yet implemented\n",1,0x21,stderr);
      return -1;
    }
    local_res8 = (int *)(param_3 + 0xc);
  }
  if (*local_res8 == 0) {
    iVar5 = FUN_004ba0cc(param_1,(char *)*param_2,local_98,4,PTR_DAT_00551644,0x2000);
    puVar2 = PTR_DAT_00551644;
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar4 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar4 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (uVar4 == 1) {
        if (DAT_00557704 == '\0') {
          uVar4 = *(ushort *)(PTR_DAT_00551644 + 2);
        }
        else {
          uVar4 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 | *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
        }
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(PTR_DAT_00551644 + 4);
        }
        else {
          uVar3 = *(ushort *)(PTR_DAT_00551644 + 4) << 8 | *(ushort *)(PTR_DAT_00551644 + 4) >> 8;
        }
        printf("Type %d, mask %04x, %d state mappings:\n",(uint)uVar4,(uint)uVar3,
               (uint)(byte)PTR_DAT_00551644[6]);
        uVar8 = FUN_004bf2b8((int)(puVar2 + 4),2);
        if (uVar8 < 4) {
          if (DAT_00557704 == '\0') {
            local_c4 = puVar2[6];
          }
          else {
            local_c4 = 0;
          }
          if ((local_c4 == 0) && (uVar8 == 0)) {
            puts("No map configured");
          }
          else if ((uint)local_c4 != 1 << (uVar8 & 0x1f)) {
            fprintf(stderr,"Bit/count mismatch (%d != %d)\n",uVar8,(uint)local_c4);
            return -1;
          }
          local_cc = (ushort *)(puVar2 + 8);
          for (; local_c4 != 0; local_c4 = local_c4 - 1) {
            if (*(char *)((int)local_cc + 0xf) != '\0') {
              param3 = *(uchar *)((int)local_cc + 0xf);
              *(undefined1 *)((int)local_cc + 0xf) = 0;
              fprintf(stderr,"Invalid name: %s%c\n",(char *)(local_cc + 2),param3);
              return -1;
            }
            if (DAT_00557704 == '\0') {
              uVar4 = *local_cc;
            }
            else {
              uVar4 = *local_cc << 8 | *local_cc >> 8;
            }
            if (DAT_00557704 == '\0') {
              uVar3 = local_cc[1];
            }
            else {
              uVar3 = local_cc[1] << 8 | local_cc[1] >> 8;
            }
            printf(" Value: %04x  State: %d  (%s)\n",(uint)uVar4,(uint)uVar3,(char *)(local_cc + 2))
            ;
            local_cc = local_cc + 8;
          }
        }
        else {
          fprintf(stderr,"Invalid mask: more than %d bits\n",3);
          iVar5 = -1;
        }
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar4 = *(ushort *)PTR_DAT_00551644;
        }
        else {
          uVar4 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
        }
        fprintf(stderr,"Incorrect version (%d != %d).\n",(uint)uVar4,1);
        iVar5 = -1;
      }
    }
  }
  else {
    uVar7 = strtoul((char *)*local_res8,&local_c,0x10);
    local_10[0] = (ushort)uVar7;
    if (*local_c == '\0') {
      uVar8 = FUN_004bf2b8((int)local_10,2);
      if (uVar8 < 4) {
        local_94 = local_10[0];
        if (DAT_00557704 != '\0') {
          local_94 = local_10[0] << 8 | local_10[0] >> 8;
        }
        local_c4 = (byte)(1 << (uVar8 & 0x1f));
        local_cc = local_90;
        local_92 = local_c4;
        while ((local_res8 = local_res8 + 1, local_c4 != 0 && (*local_res8 != 0))) {
          uVar7 = strtoul((char *)*local_res8,&local_c,0x10);
          uVar4 = (ushort)uVar7;
          if (((char *)*local_res8 == local_c) || (*local_c != '/')) {
            fprintf(stderr,"Invalid value, or missing /state: %s\n",(char *)*local_res8);
            return -1;
          }
          if ((uVar7 & 0xffff & ~(uint)local_10[0]) != 0) {
            fprintf(stderr,"Value bits outside mask: %04x/%04x -> %04x\n",uVar7 & 0xffff,
                    (uint)local_10[0],uVar7 & 0xffff & ~(uint)local_10[0]);
            return -1;
          }
          if (DAT_00557704 != '\0') {
            uVar4 = uVar4 << 8 | uVar4 >> 8;
          }
          for (local_c8 = local_90; local_c8 < local_cc; local_c8 = local_c8 + 8) {
            if (uVar4 == *local_c8) {
              if (DAT_00557704 != '\0') {
                uVar4 = uVar4 << 8 | uVar4 >> 8;
              }
              fprintf(stderr,"Invalid repeated value: %04x\n",(uint)uVar4);
              return -1;
            }
          }
          *local_cc = uVar4;
          local_c = local_c + 1;
          if ((*local_c == '\0') || (*local_c == '/')) {
            fprintf(stderr,"Missing required /<state>: %s\n",(char *)*local_res8);
            return -1;
          }
          uVar7 = strtoul(local_c,&local_c,0);
          uVar4 = (ushort)uVar7;
          if ((*local_c != '\0') && (*local_c != '/')) {
            fprintf(stderr,"Non-numeric state value %s\n",local_c);
            return -1;
          }
          if ((uint)local_92 <= (uVar7 & 0xffff)) {
            fprintf(stderr,"Invalid state %d, must be 0-%d\n",uVar7 & 0xffff,local_92 - 1);
            return -1;
          }
          if (DAT_00557704 != '\0') {
            uVar4 = uVar4 << 8 | uVar4 >> 8;
          }
          local_cc[1] = uVar4;
          cVar1 = *local_c;
          local_c = local_c + 1;
          if (cVar1 == '/') {
            sVar9 = strlen(local_c);
            if (10 < sVar9) {
              fprintf(stderr,"Name %s too long, limit %d chars\n",local_c,10);
              return -1;
            }
            if ((*(ushort *)(__ctype_b + *local_c * 2) & 8) != 0) {
              fprintf(stderr,"Names cannot start with a digit: %s\n",local_c);
              return -1;
            }
            iVar5 = strcmp(local_c,"gpio");
            if (iVar5 == 0) {
              fwrite("Name \'gpio\' is reserved\n",1,0x18,stderr);
              return -1;
            }
            strcpy((char *)(local_cc + 2),local_c);
          }
          local_c4 = local_c4 - 1;
          local_cc = local_cc + 8;
        }
        if (local_c4 == 0) {
          if (*local_res8 == 0) {
            iVar5 = FUN_004ba160(param_1,(char *)*param_2,local_98,0x88,PTR_DAT_00551644,0x2000);
          }
          else {
            fprintf(stderr,"Too many arguments for %d possible states at %s\n",(uint)local_92,
                    (char *)*local_res8);
            iVar5 = -1;
          }
        }
        else {
          fprintf(stderr,"Specify all %d possible values, missing %d\n",(uint)local_92,
                  (uint)local_c4);
          iVar5 = -1;
        }
      }
      else {
        fprintf(stderr,"Invalid mask: more than %d bits\n",3);
        iVar5 = -1;
      }
    }
    else {
      fprintf(stderr,"Cannot parse mask %s\n",(char *)*local_res8);
      iVar5 = -1;
    }
  }
  return iVar5;
}



int FUN_00469594(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  int *piVar5;
  ulong uVar6;
  char *param3;
  size_t sVar7;
  char *param4;
  int *local_res8;
  undefined2 local_20 [2];
  ushort local_1c;
  undefined1 local_1a;
  char acStack_19 [13];
  char *local_c;
  
  local_res8 = (int *)(param_3 + 4);
  memset(local_20,0,0x14);
  if (DAT_00557704 == '\0') {
    local_20[0] = 1;
  }
  else {
    local_20[0] = 0x100;
  }
  if ((*local_res8 != 0) && (iVar4 = strcmp((char *)*local_res8,"type"), iVar4 == 0)) {
    piVar5 = (int *)(param_3 + 8);
    if (*piVar5 == 0) {
      fwrite("No type value specified\n",1,0x18,stderr);
      return -1;
    }
    uVar6 = strtoul((char *)*piVar5,&local_c,0);
    if (*local_c != '\0') {
      fprintf(stderr,"Non-numeric type value %s\n",(char *)*piVar5);
      return -1;
    }
    if ((short)uVar6 != 0) {
      fwrite("Nonzero type not yet implemented\n",1,0x21,stderr);
      return -1;
    }
    local_res8 = (int *)(param_3 + 0xc);
  }
  if (*local_res8 == 0) {
    iVar4 = FUN_004ba0cc(param_1,(char *)*param_2,local_20,4,PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar4) {
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar2 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (uVar2 == 1) {
        if (PTR_DAT_00551644[0x12] != '\0') {
          fwrite("Invalid name\n",1,0xd,stderr);
          puVar1[0x12] = 0;
        }
        if (DAT_00557704 == '\0') {
          uVar2 = *(ushort *)(puVar1 + 2);
        }
        else {
          uVar2 = *(ushort *)(puVar1 + 2) << 8 | *(ushort *)(puVar1 + 2) >> 8;
        }
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)(puVar1 + 4);
        }
        else {
          uVar3 = *(ushort *)(puVar1 + 4) << 8 | *(ushort *)(puVar1 + 4) >> 8;
        }
        if (puVar1 == (undefined *)0xfffffff9) {
          param3 = "(unknown)";
        }
        else {
          param3 = puVar1 + 7;
        }
        if (puVar1[6] == '\0') {
          param4 = "auto";
        }
        else {
          param4 = "forced";
        }
        printf("Type %d: state %d, name %s (%s)\n",(uint)uVar2,(uint)uVar3,param3,param4);
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar2 = *(ushort *)PTR_DAT_00551644;
        }
        else {
          uVar2 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
        }
        fprintf(stderr,"Incorrect version (%d != %d).\n",(uint)uVar2,1);
        iVar4 = -1;
      }
    }
  }
  else {
    if ((*(ushort *)(__ctype_b + *(char *)*local_res8 * 2) & 8) == 0) {
      iVar4 = strcmp((char *)*local_res8,"gpio");
      if (iVar4 == 0) {
        local_1a = 0;
      }
      else {
        sVar7 = strlen((char *)*local_res8);
        if (10 < sVar7) {
          fprintf(stderr,"Name %s too long, limit %d chars\n",(char *)*local_res8,10);
          return -1;
        }
        strcpy(acStack_19,(char *)*local_res8);
        local_1a = 1;
      }
    }
    else {
      uVar6 = strtoul((char *)*local_res8,&local_c,0);
      local_1c = (ushort)uVar6;
      if (*local_c != '\0') {
        fprintf(stderr,"Non-numeric state: %s\n",(char *)*local_res8);
        return -1;
      }
      if (DAT_00557704 != '\0') {
        local_1c = local_1c << 8 | local_1c >> 8;
      }
      local_1a = 1;
    }
    if (local_res8[1] == 0) {
      iVar4 = FUN_004ba160(param_1,(char *)*param_2,local_20,0x14,PTR_DAT_00551644,0x2000);
    }
    else {
      fprintf(stderr,"Too many arguments at %s\n",(char *)local_res8[1]);
      iVar4 = -1;
    }
  }
  return iVar4;
}



int FUN_00469c68(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  ushort local_c;
  ushort local_a;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_c,4);
    if (-1 < iVar1) {
      if (DAT_00557704 != '\0') {
        local_c = local_c << 8 | local_c >> 8;
      }
      if (DAT_00557704 != '\0') {
        local_a = local_a << 8 | local_a >> 8;
      }
      printf("    listen period=%u listen interval=%u\n",(uint)local_c,(uint)local_a);
      iVar1 = 0;
    }
  }
  else if (*(int *)(param_3 + 8) == 0) {
    iVar1 = -0x2c;
  }
  else {
    iVar1 = atoi(*(char **)(param_3 + 4));
    local_c = (ushort)iVar1;
    iVar1 = atoi(*(char **)(param_3 + 8));
    local_a = (ushort)iVar1;
    iVar1 = FUN_004ba2e4(param_1,"p2po_listen",&local_c,4);
  }
  return iVar1;
}



int FUN_00469e44(char *param_1)

{
  size_t sVar1;
  ulong uVar2;
  int local_20;
  char *local_1c;
  char local_14;
  char local_13;
  undefined1 local_12;
  
  sVar1 = strlen(param_1);
  local_1c = param_1;
  for (local_20 = 0; local_20 < (int)(sVar1 >> 1); local_20 = local_20 + 1) {
    local_14 = *local_1c;
    local_13 = local_1c[1];
    local_12 = 0;
    uVar2 = strtoul(&local_14,(char **)0x0,0x10);
    param_1[local_20] = (char)uVar2;
    local_1c = local_1c + 2;
  }
  return local_20;
}



int FUN_00469f18(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  size_t __size;
  void *__ptr;
  size_t local_28;
  size_t local_24;
  char *local_20;
  char *local_1c;
  
  if (((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) ||
     (*(int *)(param_3 + 0xc) == 0)) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    return -0x2c;
  }
  iVar1 = atoi(*(char **)(param_3 + 4));
  if (iVar1 == 1) {
    local_20 = *(char **)(param_3 + 8);
    local_1c = *(char **)(param_3 + 0xc);
    local_28 = FUN_00469e44(local_20);
    local_24 = FUN_00469e44(local_1c);
  }
  else {
    if (iVar1 != 2) {
      fwrite("<protocol> should be <1|2>\n",1,0x1b,stderr);
      return -0x2c;
    }
    iVar2 = memcmp(*(void **)(param_3 + 8),&DAT_0051b608,4);
    if ((iVar2 != 0) || (iVar2 = memcmp(*(void **)(param_3 + 0xc),&DAT_0051b608,4), iVar2 != 0)) {
      fwrite("UPnP query/response string must start with 0x10",1,0x2f,stderr);
      return -0x2c;
    }
    local_20 = (char *)(*(int *)(param_3 + 8) + 3);
    local_1c = (char *)(*(int *)(param_3 + 0xc) + 3);
    uVar3 = strtoul("0x10",(char **)0x0,0x10);
    *local_20 = (char)uVar3;
    uVar3 = strtoul("0x10",(char **)0x0,0x10);
    *local_1c = (char)uVar3;
    local_28 = strlen(local_20);
    local_24 = strlen(local_1c);
  }
  __size = local_28 + local_24 + 7;
  __ptr = malloc(__size);
  if (__ptr == (void *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    iVar1 = -0x1b;
  }
  else {
    *(char *)((int)__ptr + 1) = (char)iVar1;
    *(short *)((int)__ptr + 2) = (short)local_28;
    *(short *)((int)__ptr + 4) = (short)local_24;
    memcpy((void *)((int)__ptr + 6),local_20,local_28);
    memcpy((void *)((int)__ptr + local_28 + 6),local_1c,local_24);
    iVar1 = FUN_004ba160(param_1,"p2po_addsvc",__ptr,__size,PTR_DAT_00551644,0x2000);
    free(__ptr);
  }
  return iVar1;
}



undefined4 FUN_0046a2a4(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  ulong uVar2;
  size_t __size;
  void *__ptr;
  undefined4 uVar3;
  int local_20;
  size_t local_1c;
  char *local_18;
  
  if ((*(int *)(param_3 + 4) == 0) ||
     ((**(char **)(param_3 + 4) != '0' && (*(int *)(param_3 + 8) == 0)))) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    return 0xffffffd4;
  }
  if (**(char **)(param_3 + 4) == '0') {
    local_20 = 0;
    local_1c = 0;
  }
  else {
    local_20 = atoi(*(char **)(param_3 + 4));
    if (local_20 == 1) {
      local_18 = *(char **)(param_3 + 8);
      local_1c = FUN_00469e44(local_18);
    }
    else {
      if (local_20 != 2) {
        fwrite("<protocol> should be <1|2>\n",1,0x1b,stderr);
        return 0xffffffd4;
      }
      iVar1 = memcmp(*(void **)(param_3 + 8),&DAT_0051b608,4);
      if (iVar1 != 0) {
        fwrite("UPnP query string must start with 0x10",1,0x26,stderr);
        return 0xffffffd4;
      }
      local_18 = (char *)(*(int *)(param_3 + 8) + 3);
      uVar2 = strtoul("0x10",(char **)0x0,0x10);
      *local_18 = (char)uVar2;
      local_1c = strlen(local_18);
    }
  }
  if (local_1c == 0) {
    __size = 8;
  }
  else {
    __size = local_1c + 7;
  }
  __ptr = malloc(__size);
  if (__ptr == (void *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    uVar3 = 0xffffffe5;
  }
  else {
    *(char *)((int)__ptr + 1) = (char)local_20;
    *(short *)((int)__ptr + 2) = (short)local_1c;
    if (local_1c != 0) {
      memcpy((void *)((int)__ptr + 6),local_18,local_1c);
    }
    uVar3 = FUN_004ba2e4(param_1,"p2po_delsvc",__ptr,__size);
    free(__ptr);
  }
  return uVar3;
}



undefined4 FUN_0046a5a4(int *param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  ulong uVar5;
  size_t __size;
  undefined1 *__ptr;
  size_t local_28;
  char *local_24;
  
  if ((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    uVar1 = 0xffffffd4;
  }
  else {
    iVar2 = atoi(*(char **)(param_3 + 4));
    if ((iVar2 < 0) || (0xff < iVar2)) {
      fwrite("<transaction id> should be between 0 and 255\n",1,0x2d,stderr);
      uVar1 = 0xffffffd4;
    }
    else {
      iVar3 = atoi(*(char **)(param_3 + 8));
      if (*(int *)(param_3 + 0xc) == 0) {
        local_28 = 0;
      }
      else if (iVar3 == 1) {
        local_24 = *(char **)(param_3 + 0xc);
        local_28 = FUN_00469e44(local_24);
      }
      else {
        if (iVar3 != 2) {
          fwrite("<protocol> should be <0|1|2>\n",1,0x1d,stderr);
          return 0xffffffd4;
        }
        iVar4 = memcmp(*(void **)(param_3 + 0xc),&DAT_0051b608,4);
        if (iVar4 != 0) {
          fwrite("UPnP query string must start with 0x10",1,0x26,stderr);
          return 0xffffffd4;
        }
        local_24 = (char *)(*(int *)(param_3 + 0xc) + 3);
        uVar5 = strtoul("0x10",(char **)0x0,0x10);
        *local_24 = (char)uVar5;
        local_28 = strlen(local_24);
      }
      if (local_28 == 0) {
        __size = 8;
      }
      else {
        __size = local_28 + 7;
      }
      __ptr = (undefined1 *)malloc(__size);
      if (__ptr == (undefined1 *)0x0) {
        fwrite("Not enough memory\n",1,0x12,stderr);
        uVar1 = 0xffffffe5;
      }
      else {
        *__ptr = (char)iVar2;
        __ptr[1] = (char)iVar3;
        *(short *)(__ptr + 2) = (short)local_28;
        if (local_28 != 0) {
          memcpy(__ptr + 6,local_24,local_28);
        }
        uVar1 = FUN_004ba2e4(param_1,"p2po_sd_req_resp",__ptr,__size);
        free(__ptr);
      }
    }
  }
  return uVar1;
}



int FUN_0046a8f4(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba35c(param_1,"p2po_listen_channel",local_10);
    if (-1 < iVar1) {
      if (DAT_00557704 != '\0') {
        local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                      (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
      }
      printf("P2P Offload Listen Channel: %d\n",local_10[0]);
      iVar1 = 0;
    }
  }
  else {
    local_10[0] = atoi(*(char **)(param_3 + 4));
    iVar1 = FUN_004ba428(param_1,"p2po_listen_channel",local_10[0]);
  }
  return iVar1;
}



int FUN_0046aa2c(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  ushort uVar3;
  size_t __size;
  undefined1 *__s;
  int iVar4;
  uint uVar5;
  uint local_30;
  int local_2c;
  int local_28;
  uint local_24;
  
  for (local_30 = 0; *(int *)(param_3 + local_30 * 4) != 0; local_30 = local_30 + 1) {
  }
  if (local_30 == 0) {
    local_2c = -1;
  }
  else if (local_30 == 1) {
    local_2c = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,PTR_DAT_00551644,0x600);
    puVar1 = PTR_DAT_00551644;
    if (-1 < local_2c) {
      puts("P2P Offload Find configuration:");
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)puVar1;
      }
      else {
        uVar2 = *(ushort *)puVar1 << 8 | *(ushort *)puVar1 >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(puVar1 + 2);
      }
      else {
        uVar3 = *(ushort *)(puVar1 + 2) << 8 | *(ushort *)(puVar1 + 2) >> 8;
      }
      printf("    Version: %u    Length: %u\n",(uint)uVar2,(uint)uVar3);
      printf("    Scan for non-P2P APs: %d\n",(uint)((puVar1[9] & 1) != 0));
      if (DAT_00557704 == '\0') {
        uVar5 = *(uint *)(puVar1 + 4);
      }
      else {
        uVar5 = *(uint *)(puVar1 + 4);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("    Search home time: %d\n",uVar5);
      printf("    # of social channels: %u\n",(uint)(byte)puVar1[8]);
      printf("    Social channels:");
      for (local_28 = 0; local_28 < (int)(uint)(byte)puVar1[8]; local_28 = local_28 + 1) {
        printf(" %u",(uint)*(ushort *)(puVar1 + (local_28 + 4) * 2 + 2));
      }
      putchar(10);
    }
  }
  else if (local_30 < 4) {
    fwrite("At least 1 social channel is required.\n",1,0x27,stderr);
    local_2c = -2;
  }
  else {
    __size = (local_30 + 4) * 2;
    __s = (undefined1 *)malloc(__size);
    if (__s == (undefined1 *)0x0) {
      printf("Cannot not allocate %d bytes for p2po_find_config buffer\n",__size);
      local_2c = -0x1b;
    }
    else {
      memset(__s,0,__size);
      *__s = 2;
      __s[1] = 0;
      __s[2] = 0xc;
      __s[3] = 0;
      iVar4 = atoi(*(char **)(param_3 + 4));
      __s[9] = (char)iVar4;
      iVar4 = atoi(*(char **)(param_3 + 4));
      *(int *)(__s + 4) = iVar4;
      local_28 = 0;
      for (local_24 = 3; local_24 < local_30; local_24 = local_24 + 1) {
        iVar4 = atoi(*(char **)(param_3 + local_24 * 4));
        if ((short)iVar4 == 0) {
          printf("Invalid channel %s\n",*(char **)(param_3 + local_24 * 4));
          break;
        }
        __s[(local_28 + 4) * 2 + 2] = (char)iVar4;
        __s[(local_28 + 4) * 2 + 3] = (char)((uint)iVar4 >> 8);
        local_28 = local_28 + 1;
      }
      __s[8] = (char)local_28;
      local_2c = FUN_004ba160(param_1,(char *)*param_2,__s,__size,PTR_DAT_00551644,0x600);
      free(__s);
    }
  }
  return local_2c;
}



int FUN_0046b004(int *param_1)

{
  ushort uVar1;
  int __fd;
  void *__buf;
  ssize_t sVar2;
  ushort *puVar3;
  char *pcVar4;
  uint uVar5;
  int local_98;
  ushort *local_94;
  int local_90;
  sockaddr local_5c;
  char acStack_48 [16];
  char local_38 [16];
  char local_28 [28];
  byte local_c;
  
  builtin_strncpy(local_28,"eth1",5);
  local_28[5] = 0;
  local_28[6] = 0;
  local_28[7] = 0;
  local_28[8] = 0;
  local_28[9] = 0;
  local_28[10] = 0;
  local_28[0xb] = 0;
  local_28[0xc] = 0;
  local_28[0xd] = 0;
  local_28[0xe] = 0;
  local_28[0xf] = 0;
  memset(acStack_48,0,0x20);
  if (param_1 == (int *)0x0) {
    strncpy(acStack_48,local_28,0xf);
  }
  else {
    strncpy(acStack_48,(char *)param_1,0xf);
  }
  memset(local_28 + 0x10,0,0x10);
  local_c = local_c | 0xc0;
  local_98 = FUN_004ba2e4(param_1,"event_msgs",local_28 + 0x10,0x10);
  if (local_98 == 0) {
    __fd = socket(0x11,3,0x6c88);
    if (__fd < 0) {
      printf("Cannot create socket %d\n",__fd);
      local_98 = -1;
    }
    else {
      local_98 = ioctl(__fd,0x8933,acStack_48);
      if (local_98 < 0) {
        printf("Cannot get index %d\n",local_98);
      }
      else {
        memset(&local_5c,0,0x14);
        local_5c.sa_family = 0x11;
        local_5c.sa_data[0] = -0x78;
        local_5c.sa_data[1] = 'l';
        local_5c.sa_data[2] = local_38[0];
        local_5c.sa_data[3] = local_38[1];
        local_5c.sa_data[4] = local_38[2];
        local_5c.sa_data[5] = local_38[3];
        local_98 = bind(__fd,&local_5c,0x14);
        if (local_98 < 0) {
          printf("Cannot bind %d\n",local_98);
        }
        else {
          __buf = malloc(0x800);
          if (__buf != (void *)0x0) {
            do {
              do {
                do {
                  do {
                    sVar2 = recv(__fd,__buf,0x800,0);
                    uVar5 = *(uint *)((int)__buf + 0x1c);
                  } while (sVar2 < 0x48);
                } while ((uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                         uVar5 >> 0x18) != 0x66);
                uVar5 = *(uint *)((int)__buf + 0x20);
                uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
                puVar3 = (ushort *)((int)__buf + 0x48);
                if (DAT_00557704 == '\0') {
                  uVar1 = *puVar3;
                }
                else {
                  uVar1 = *puVar3 << 8 | *puVar3 >> 8;
                }
                *(char *)puVar3 = (char)uVar1;
                *(char *)((int)__buf + 0x49) = (char)(uVar1 >> 8);
                if (uVar5 == 8) {
                  pcVar4 = "WLC_E_STATUS_PARTIAL";
                }
                else if (uVar5 == 0) {
                  pcVar4 = "WLC_E_STATUS_SUCCESS";
                }
                else if (uVar5 == 1) {
                  pcVar4 = "WLC_E_STATUS_FAIL";
                }
                else {
                  pcVar4 = "unknown";
                }
                printf("WLC_E_SERVICE_FOUND: %s\n",pcVar4);
                printf("   channel         = %d\n",(uint)*puVar3);
                pcVar4 = FUN_0041d780((int)__buf + 0x30);
                printf("   peer            = %s\n",pcVar4);
              } while (uVar5 != 0);
              local_94 = (ushort *)((int)__buf + 0x4b);
              for (local_90 = 0; local_90 < (int)(uint)*(byte *)((int)__buf + 0x4a);
                  local_90 = local_90 + 1) {
                printf("   [TLV %d]\n",local_90);
                if (DAT_00557704 == '\0') {
                  uVar1 = *local_94;
                }
                else {
                  uVar1 = *local_94 << 8 | *local_94 >> 8;
                }
                *(char *)local_94 = (char)uVar1;
                *(char *)((int)local_94 + 1) = (char)(uVar1 >> 8);
                if ((char)local_94[1] == '\0') {
                  pcVar4 = "ALL";
                }
                else if ((char)local_94[1] == '\x01') {
                  pcVar4 = "BONJOUR";
                }
                else if ((char)local_94[1] == '\x02') {
                  pcVar4 = "UPnP";
                }
                else if ((char)local_94[1] == '\x03') {
                  pcVar4 = "WS-Discovery";
                }
                else if ((char)local_94[1] == -1) {
                  pcVar4 = "Vendor specific";
                }
                else {
                  pcVar4 = "Unknown";
                }
                printf("   protocol type   = %s\n",pcVar4);
                printf("   transaction id  = %u\n",(uint)*(byte *)((int)local_94 + 3));
                printf("   status code     = %u\n",(uint)(byte)local_94[2]);
                printf("   length          = %u\n",(uint)*local_94);
                FUN_0041e248((int)local_94 + 5,(uint)*local_94);
                local_94 = (ushort *)((int)local_94 + *local_94 + 5);
              }
            } while( true );
          }
          printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
          local_98 = -0x1b;
        }
      }
      close(__fd);
    }
  }
  return local_98;
}



int FUN_0046b804(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  ushort local_10;
  ushort local_e;
  ushort local_c;
  ushort local_a;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar4 = FUN_004ba0cc(param_1,"p2po_gas_config",&local_10,8,PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar4) {
      puts("P2P Offload GAS state machine tunable parameters:");
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)puVar1;
      }
      else {
        uVar2 = *(ushort *)puVar1 << 8 | *(ushort *)puVar1 >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(puVar1 + 2);
      }
      else {
        uVar3 = *(ushort *)(puVar1 + 2) << 8 | *(ushort *)(puVar1 + 2) >> 8;
      }
      printf("    max_retrans=%u resp_timeout=%u\n",(uint)uVar2,(uint)uVar3);
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(puVar1 + 4);
      }
      else {
        uVar2 = *(ushort *)(puVar1 + 4) << 8 | *(ushort *)(puVar1 + 4) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(puVar1 + 6);
      }
      else {
        uVar3 = *(ushort *)(puVar1 + 6) << 8 | *(ushort *)(puVar1 + 6) >> 8;
      }
      printf("    max_comeback_delay=%u max_retries=%u\n",(uint)uVar2,(uint)uVar3);
      iVar4 = 0;
    }
  }
  else if ((((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) ||
           (*(int *)(param_3 + 0xc) == 0)) || (*(int *)(param_3 + 0x10) == 0)) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    iVar4 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      iVar4 = atoi(*(char **)(param_3 + 4));
      local_10 = (ushort)iVar4;
    }
    else {
      iVar4 = atoi(*(char **)(param_3 + 4));
      local_10 = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
    }
    if (DAT_00557704 == '\0') {
      iVar4 = atoi(*(char **)(param_3 + 8));
      local_e = (ushort)iVar4;
    }
    else {
      iVar4 = atoi(*(char **)(param_3 + 8));
      local_e = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
    }
    if (DAT_00557704 == '\0') {
      iVar4 = atoi(*(char **)(param_3 + 0xc));
      local_c = (ushort)iVar4;
    }
    else {
      iVar4 = atoi(*(char **)(param_3 + 0xc));
      local_c = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
    }
    if (DAT_00557704 == '\0') {
      iVar4 = atoi(*(char **)(param_3 + 0x10));
      local_a = (ushort)iVar4;
    }
    else {
      iVar4 = atoi(*(char **)(param_3 + 0x10));
      local_a = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
    }
    iVar4 = FUN_004ba160(param_1,(char *)*param_2,&local_10,8,PTR_DAT_00551644,0x600);
  }
  return iVar4;
}



void FUN_0046bcfc(char *param_1,uint param_2,void *param_3)

{
  size_t local_res4;
  char acStack_30 [40];
  
  local_res4 = param_2;
  if (0x20 < param_2) {
    local_res4 = 0x20;
  }
  memcpy(acStack_30,param_3,local_res4);
  acStack_30[local_res4] = '\0';
  printf("%s%u,%s\n",param_1,local_res4,acStack_30);
  return;
}



int FUN_0046bd90(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  int local_e8 [56];
  
  puVar1 = PTR_DAT_00551644;
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    iVar2 = -0x2c;
  }
  else {
    bzero(local_e8,0xdb);
    local_e8[0] = atoi(*(char **)(param_3 + 4));
    iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,local_e8,0xdb,puVar1,0x2000);
    if (-1 < iVar2) {
      printf("Seek service hdl=%u\n",*(uint *)puVar1);
      printf("    hash=0x%02x%02x%02x%02x%02x%02x\n",(uint)(byte)puVar1[10],(uint)(byte)puVar1[0xb],
             (uint)(byte)puVar1[0xc],(uint)(byte)puVar1[0xd],(uint)(byte)puVar1[0xe],
             (uint)(byte)puVar1[0xf]);
      printf("    mac=%02x:%02x:%02x:%02x:%02x:%02x\n",(uint)(byte)puVar1[4],(uint)(byte)puVar1[5],
             (uint)(byte)puVar1[6],(uint)(byte)puVar1[7],(uint)(byte)puVar1[8],(uint)(byte)puVar1[9]
            );
      printf("    name length=%u\n",(uint)(byte)puVar1[0x10]);
      printf("    name=%s\n",puVar1 + 0x11);
      printf("    info_req length=%u\n",(uint)(byte)puVar1[0xd9]);
      printf("    info_req=%s\n",puVar1 + 0xda);
    }
  }
  return iVar2;
}



int FUN_0046bff8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int *__s;
  size_t sVar3;
  undefined3 extraout_var;
  char *__ptr;
  size_t local_20;
  int local_1c;
  
  if (*(int *)(param_3 + 8) == 0) {
    iVar2 = FUN_0046bd90(param_1,param_2,param_3);
    return iVar2;
  }
  if (*(int *)(param_3 + 0x10) == 0) {
    fwrite("Too few arguments for iovar SET\n",1,0x20,stderr);
    return -0x2c;
  }
  __s = (int *)malloc(0x1d9);
  if (__s == (int *)0x0) {
    fprintf(stderr,"malloc error, size=%d\n",0x1d9);
    return -0x1b;
  }
  memset(__s,0,0x1d9);
  iVar2 = atoi(*(char **)(param_3 + 4));
  *__s = iVar2;
  if (*(int *)(param_3 + 8) != 0) {
    sVar3 = strlen(*(char **)(param_3 + 8));
    if (sVar3 != 0xe) {
      fprintf(stderr,"bad argument: %s\n",*(char **)(param_3 + 8));
      fwrite("<svc_hash> must be 6 hex bytes, eg. \'0x112233aabbcc\'\n",1,0x35,stderr);
      local_1c = -0x2c;
      goto LAB_0046c528;
    }
    iVar2 = FUN_0043dc20(*(char **)(param_3 + 8),(int)__s + 10);
    if (iVar2 != 6) {
      fprintf(stderr,"invalid hex string: %s\n",*(char **)(param_3 + 8));
      fwrite("<svc_hash> must be 6 hex bytes, eg. \'0x112233aabbcc\'\n",1,0x35,stderr);
      local_1c = -0x2c;
      goto LAB_0046c528;
    }
  }
  bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0xc),__s + 1);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    fprintf(stderr,"invalid MAC address: %s\n",*(char **)(param_3 + 8));
    fwrite("<macaddr> must be like \'00:90:4c:7a:8b:fe\'\n",1,0x2b,stderr);
    local_1c = -0x2c;
  }
  else {
    if (*(int *)(param_3 + 0x10) == 0) {
      memcpy((void *)((int)__s + 0x11),"org.wi-fi.wfds",0xe);
      sVar3 = strlen((char *)((int)__s + 0x11));
      *(char *)(__s + 4) = (char)sVar3;
    }
    else {
      sVar3 = strlen(*(char **)(param_3 + 0x10));
      memcpy((void *)((int)__s + 0x11),*(void **)(param_3 + 0x10),sVar3);
      *(char *)(__s + 4) = (char)sVar3;
    }
    FUN_0046bcfc("svc_name: ",(uint)*(byte *)(__s + 4),(void *)((int)__s + 0x11));
    if (*(int *)(param_3 + 0x14) == 0) {
      *(undefined1 *)((int)__s + 0xd9) = 0;
    }
    else {
      local_20 = strlen(*(char **)(param_3 + 0x14));
      if (0xff < (int)local_20) {
        local_20 = 0xff;
      }
      memcpy((void *)((int)__s + 0xda),*(void **)(param_3 + 0x14),local_20);
      *(char *)((int)__s + 0xd9) = (char)local_20;
    }
    FUN_0046bcfc("svc_info_req: ",(uint)*(byte *)((int)__s + 0xd9),(void *)((int)__s + 0xda));
    sVar3 = strlen((char *)*param_2);
    __ptr = (char *)malloc(sVar3 + 0x1da);
    local_1c = FUN_004ba160(param_1,(char *)*param_2,__s,0x1d9,__ptr,sVar3 + 0x1da);
    free(__ptr);
    if (local_1c != 0) {
      fprintf(stderr,"%s failed: %d\n",(char *)*param_2,local_1c);
    }
  }
LAB_0046c528:
  free(__s);
  return local_1c;
}



int FUN_0046c550(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *__ptr;
  
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("No seek_hdl is specified\n",1,0x19,stderr);
    iVar1 = -0x2c;
  }
  else {
    __ptr = (int *)malloc(4);
    if (__ptr == (int *)0x0) {
      fprintf(stderr,"malloc error, size=%u\n",4);
      iVar1 = -0x1b;
    }
    else {
      iVar1 = atoi(*(char **)(param_3 + 4));
      *__ptr = iVar1;
      iVar1 = FUN_004ba160(param_1,(char *)*param_2,__ptr,4,PTR_DAT_00551644,0x2000);
      free(__ptr);
    }
  }
  return iVar1;
}



int FUN_0046c680(int *param_1,undefined4 *param_2,int param_3)

{
  size_t sVar1;
  uint *__ptr;
  int local_100;
  int local_f0 [57];
  
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    local_100 = -0x2c;
  }
  else {
    bzero(local_f0,0xdd);
    local_f0[0] = atoi(*(char **)(param_3 + 4));
    sVar1 = strlen((char *)*param_2);
    sVar1 = sVar1 + 0xfec6;
    __ptr = (uint *)malloc(sVar1);
    if (__ptr == (uint *)0x0) {
      fprintf(stderr,"malloc error, size=%d\n",sVar1);
      local_100 = -0x1b;
    }
    else {
      local_100 = FUN_004ba0cc(param_1,(char *)*param_2,local_f0,0xdd,(char *)__ptr,sVar1);
      if (-1 < local_100) {
        printf("Advertise service hdl=%u\n",*__ptr);
        printf("    hash=0x%02x%02x%02x%02x%02x%02x\n",(uint)(byte)__ptr[1],
               (uint)*(byte *)((int)__ptr + 5),(uint)*(byte *)((int)__ptr + 6),
               (uint)*(byte *)((int)__ptr + 7),(uint)(byte)__ptr[2],(uint)*(byte *)((int)__ptr + 9))
        ;
        printf("    advertisement_id=0x%x\n",*(uint *)((int)__ptr + 10));
        printf("    config_method=0x%x\n",(uint)*(ushort *)((int)__ptr + 0xe));
        printf("    name length=%u\n",(uint)(byte)__ptr[4]);
        printf("    name=%s\n",(char *)((int)__ptr + 0x11));
        printf("    status=%u\n",(uint)*(byte *)((int)__ptr + 0xd9));
        printf("    info length=%u\n",(uint)*(ushort *)((int)__ptr + 0xda));
        printf("    info=%s\n",(char *)(__ptr + 0x37));
      }
    }
    free(__ptr);
  }
  return local_100;
}



int FUN_0046c988(int *param_1,undefined4 *param_2,int param_3)

{
  size_t sVar1;
  int iVar2;
  int *__ptr;
  size_t sVar3;
  char *__ptr_00;
  ushort local_30;
  int local_2c;
  int local_28;
  int local_24;
  
  local_30 = 0;
  local_2c = 0;
  if (*(int *)(param_3 + 8) == 0) {
    local_28 = FUN_0046c680(param_1,param_2,param_3);
  }
  else if (*(int *)(param_3 + 0x18) == 0) {
    fwrite("Too few arguments for iovar SET\n",1,0x20,stderr);
    local_28 = -0x2c;
  }
  else {
    if (*(int *)(param_3 + 0x1c) != 0) {
      sVar1 = strlen(*(char **)(param_3 + 0x1c));
      local_30 = (ushort)sVar1;
      if ((7 < local_30) && (iVar2 = memcmp(*(void **)(param_3 + 0x1c),"gendata",7), iVar2 == 0)) {
        local_2c = atoi((char *)(*(int *)(param_3 + 0x1c) + 7));
        if (65000 < local_2c) {
          fprintf(stderr,"gendata length %d too long, max is %d\n",local_2c,65000);
          return -0x2c;
        }
        local_30 = (ushort)local_2c;
      }
    }
    sVar1 = local_30 + 0xdd;
    __ptr = (int *)malloc(sVar1);
    if (__ptr == (int *)0x0) {
      fprintf(stderr,"malloc error, size=%d\n",sVar1);
      local_28 = -0x1b;
    }
    else {
      iVar2 = atoi(*(char **)(param_3 + 4));
      *__ptr = iVar2;
      sVar3 = strlen(*(char **)(param_3 + 8));
      if (sVar3 == 10) {
        iVar2 = FUN_0043dc20(*(char **)(param_3 + 8),(int)__ptr + 10);
        if (iVar2 == 4) {
          sVar3 = strlen(*(char **)(param_3 + 0xc));
          if (sVar3 == 6) {
            iVar2 = FUN_0043dc20(*(char **)(param_3 + 0xc),(int)__ptr + 0xe);
            if (iVar2 == 2) {
              sVar3 = strlen(*(char **)(param_3 + 0x10));
              if (sVar3 == 0xe) {
                iVar2 = FUN_0043dc20(*(char **)(param_3 + 0x10),(int)(__ptr + 1));
                if (iVar2 == 6) {
                  sVar3 = strlen(*(char **)(param_3 + 0x14));
                  *(char *)(__ptr + 4) = (char)sVar3;
                  memcpy((void *)((int)__ptr + 0x11),*(void **)(param_3 + 0x14),
                         (uint)*(byte *)(__ptr + 4));
                  iVar2 = atoi(*(char **)(param_3 + 0x18));
                  *(char *)((int)__ptr + 0xd9) = (char)iVar2;
                  if (local_30 == 0) {
                    *(undefined1 *)((int)__ptr + 0xda) = 0;
                    *(undefined1 *)((int)__ptr + 0xdb) = 0;
                  }
                  else {
                    *(char *)((int)__ptr + 0xda) = (char)local_30;
                    *(char *)((int)__ptr + 0xdb) = (char)(local_30 >> 8);
                    if (65000 < *(ushort *)((int)__ptr + 0xda)) {
                      *(undefined1 *)((int)__ptr + 0xda) = 0xe8;
                      *(undefined1 *)((int)__ptr + 0xdb) = 0xfd;
                    }
                    if (local_2c == 0) {
                      memcpy(__ptr + 0x37,*(void **)(param_3 + 0x1c),
                             (uint)*(ushort *)((int)__ptr + 0xda));
                    }
                  }
                  if (0 < local_2c) {
                    fprintf(stderr,"Generating %u bytes of service info data\n",
                            (uint)*(ushort *)((int)__ptr + 0xda));
                    for (local_24 = 0; local_24 < (int)(uint)*(ushort *)((int)__ptr + 0xda);
                        local_24 = local_24 + 1) {
                      *(char *)((int)__ptr + local_24 + 0xdc) =
                           (char)local_24 + (char)(local_24 / 10) * -10 + '0';
                    }
                  }
                  sVar3 = strlen((char *)*param_2);
                  sVar3 = sVar3 + sVar1 + 1;
                  __ptr_00 = (char *)malloc(sVar3);
                  local_28 = FUN_004ba160(param_1,(char *)*param_2,__ptr,sVar1,__ptr_00,sVar3);
                  free(__ptr_00);
                  if (local_28 != 0) {
                    fprintf(stderr,"%s failed: %d\n",(char *)*param_2,local_28);
                  }
                }
                else {
                  fprintf(stderr,"Incorrect <hash> parameter: %s\n",*(char **)(param_3 + 0x10));
                  fwrite("<hash> must be 6 hex bytes, eg. \'0x1133557799aa\'\n",1,0x31,stderr);
                  local_28 = -0x2c;
                }
              }
              else {
                fprintf(stderr,"Bad <hash> parameter: %s\n",*(char **)(param_3 + 0x10));
                fwrite("<hash> must be 6 hex bytes, eg. \'0x1133557799aa\'\n",1,0x31,stderr);
                local_28 = -0x2c;
              }
            }
            else {
              fwrite("<cfg_meth> must be 2 hex bytes, eg. \'0x0080\'\n",1,0x2d,stderr);
              local_28 = -0x2c;
            }
          }
          else {
            fwrite("<cfg_meth> must be 2 hex bytes, eg. \'0x0080\'\n",1,0x2d,stderr);
            local_28 = -0x2c;
          }
        }
        else {
          fwrite("<adv_id> must be 4 hex bytes, eg. \'0x8899aabb\'\n",1,0x2f,stderr);
          local_28 = -0x2c;
        }
      }
      else {
        fwrite("<adv_id> must be 4 hex bytes, eg. \'0x8899aabb\'\n",1,0x2f,stderr);
        local_28 = -0x2c;
      }
      free(__ptr);
    }
  }
  return local_28;
}



int FUN_0046d15c(int *param_1,undefined4 *param_2,int param_3)

{
  int *__ptr;
  int iVar1;
  
  __ptr = (int *)malloc(4);
  if (__ptr == (int *)0x0) {
    fprintf(stderr,"malloc error, size=%u\n",4);
    iVar1 = -0x1b;
  }
  else if (*(int *)(param_3 + 4) == 0) {
    fwrite("No advertise_hdl is specified\n",1,0x1e,stderr);
    free(__ptr);
    iVar1 = -0x2c;
  }
  else {
    iVar1 = atoi(*(char **)(param_3 + 4));
    *__ptr = iVar1;
    iVar1 = FUN_004ba160(param_1,(char *)*param_2,__ptr,4,PTR_DAT_00551644,0x2000);
    free(__ptr);
  }
  return iVar1;
}



undefined4 FUN_0046d2a0(int *param_1,undefined4 *param_2,int *param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort *__s;
  int iVar3;
  int *piVar4;
  int *local_res8;
  undefined4 local_28;
  
  __s = (ushort *)malloc(0x10a);
  if (__s == (ushort *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    local_28 = 0xffffffe5;
  }
  else {
    memset(__s,0,0x10a);
    *__s = 0xffff;
    __s[1] = 0xffff;
    __s[2] = 0xffff;
    __s[3] = 0xffff;
    local_res8 = param_3;
    while (piVar4 = local_res8 + 1, *piVar4 != 0) {
      iVar3 = strcasecmp((char *)*piVar4,"max_retransmit");
      if (iVar3 == 0) {
        local_res8 = local_res8 + 2;
        if (*local_res8 == 0) {
          fwrite("Missing max retransmit\n",1,0x17,stderr);
          local_28 = 0xffffffd4;
          goto LAB_0046d990;
        }
        iVar3 = atoi((char *)*local_res8);
        *__s = (ushort)iVar3;
      }
      else {
        iVar3 = strcasecmp((char *)*piVar4,"response_timeout");
        if (iVar3 == 0) {
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            fwrite("Missing response timeout\n",1,0x19,stderr);
            local_28 = 0xffffffd4;
            goto LAB_0046d990;
          }
          iVar3 = atoi((char *)*local_res8);
          __s[1] = (ushort)iVar3;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar4,"max_comeback_delay");
          if (iVar3 == 0) {
            local_res8 = local_res8 + 2;
            if (*local_res8 == 0) {
              fwrite("Missing max comeback delay\n",1,0x1b,stderr);
              local_28 = 0xffffffd4;
              goto LAB_0046d990;
            }
            iVar3 = atoi((char *)*local_res8);
            __s[2] = (ushort)iVar3;
          }
          else {
            iVar3 = strcasecmp((char *)*piVar4,"max_retries");
            if (iVar3 == 0) {
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                fwrite("Missing retries\n",1,0x10,stderr);
                local_28 = 0xffffffd4;
                goto LAB_0046d990;
              }
              iVar3 = atoi((char *)*local_res8);
              __s[3] = (ushort)iVar3;
            }
            else {
              iVar3 = strcasecmp((char *)*piVar4,"query");
              if (iVar3 != 0) {
                fprintf(stderr,"Invalid parameter %s\n",(char *)*piVar4);
                local_28 = 0xffffffd4;
                goto LAB_0046d990;
              }
              local_res8 = local_res8 + 2;
              if (*local_res8 == 0) {
                fwrite("Missing ANQP query\n",1,0x13,stderr);
                local_28 = 0xffffffd4;
                goto LAB_0046d990;
              }
              iVar3 = FUN_00469e44((char *)*local_res8);
              __s[4] = (ushort)iVar3;
              if (__s[4] == 0) {
                fwrite("Invalid ANQP query\n",1,0x13,stderr);
                local_28 = 0xffffffd4;
                goto LAB_0046d990;
              }
              if (0x100 < __s[4]) {
                fprintf(stderr,"ANQP query size %d exceeds %d\n",(uint)__s[4],0x100);
                local_28 = 0xffffffd4;
                goto LAB_0046d990;
              }
              memcpy(__s + 5,(void *)*local_res8,(uint)__s[4]);
            }
          }
        }
      }
    }
    uVar1 = __s[4];
    if (DAT_00557704 == '\0') {
      uVar2 = *__s;
    }
    else {
      uVar2 = *__s << 8 | *__s >> 8;
    }
    *__s = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = __s[1];
    }
    else {
      uVar2 = __s[1] << 8 | __s[1] >> 8;
    }
    __s[1] = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = __s[2];
    }
    else {
      uVar2 = __s[2] << 8 | __s[2] >> 8;
    }
    __s[2] = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = __s[3];
    }
    else {
      uVar2 = __s[3] << 8 | __s[3] >> 8;
    }
    __s[3] = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = __s[4];
    }
    else {
      uVar2 = __s[4] << 8 | __s[4] >> 8;
    }
    __s[4] = uVar2;
    local_28 = FUN_004ba2e4(param_1,(char *)*param_2,__s,uVar1 + 10);
LAB_0046d990:
    free(__s);
  }
  return local_28;
}



void FUN_0046d9b8(int *param_1,undefined4 *param_2)

{
  FUN_004ba2e4(param_1,(char *)*param_2,(void *)0x0,0);
  return;
}



undefined4 FUN_0046da0c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  ushort *__s;
  int iVar4;
  undefined3 extraout_var;
  undefined4 local_30;
  ushort *local_2c;
  int local_28;
  
  __s = (ushort *)malloc(0x202);
  if (__s == (ushort *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    local_30 = 0xffffffe5;
  }
  else {
    memset(__s,0,0x202);
    local_2c = __s + 1;
    local_28 = 1;
    while ((*(int *)(param_3 + local_28 * 4) != 0 && (*(int *)(param_3 + (local_28 + 1) * 4) != 0)))
    {
      if (DAT_00557704 == '\0') {
        iVar4 = atoi(*(char **)(param_3 + local_28 * 4));
        uVar2 = (ushort)iVar4;
      }
      else {
        iVar4 = atoi(*(char **)(param_3 + local_28 * 4));
        uVar2 = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
      }
      *local_2c = uVar2;
      if (*local_2c == 0) {
        fwrite("Invalid channel\n",1,0x10,stderr);
        local_30 = 0xffffffd4;
        goto LAB_0046dd04;
      }
      bVar1 = FUN_0041d6ac(*(char **)(param_3 + (local_28 + 1) * 4),local_2c + 1);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        fwrite("Invalid address\n",1,0x10,stderr);
        local_30 = 0xffffffd4;
        goto LAB_0046dd04;
      }
      *__s = *__s + 1;
      local_28 = local_28 + 2;
      local_2c = local_2c + 4;
    }
    uVar2 = *__s;
    if (DAT_00557704 == '\0') {
      uVar3 = *__s;
    }
    else {
      uVar3 = *__s << 8 | *__s >> 8;
    }
    *__s = uVar3;
    local_30 = FUN_004ba2e4(param_1,(char *)*param_2,__s,(uint)uVar2 * 8 + 2);
LAB_0046dd04:
    free(__s);
  }
  return local_30;
}



int FUN_0046dd2c(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  char *__s;
  int iVar3;
  size_t sVar4;
  int *local_res8;
  int local_b8;
  int local_b4;
  byte abStack_90 [136];
  
  __s = (char *)malloc(0x904);
  if (__s == (char *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    return -0x1b;
  }
  memset(__s,0,0x904);
  if (*(int *)(param_3 + 4) == 0) {
    local_b8 = FUN_004ba1f8(param_1,(char *)*param_2,__s,0x904);
    if (-1 < local_b8) {
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)(__s + 2);
      }
      else {
        uVar1 = *(ushort *)(__s + 2) << 8 | *(ushort *)(__s + 2) >> 8;
      }
      *(ushort *)(__s + 2) = uVar1;
      for (local_b4 = 0; local_b4 < (int)(uint)*(ushort *)(__s + 2); local_b4 = local_b4 + 1) {
        FUN_0041e0e8(abStack_90,(int)(__s + local_b4 * 0x24 + 8),*(int *)(__s + local_b4 * 0x24 + 4)
                    );
        puts((char *)abStack_90);
      }
    }
  }
  else {
    local_res8 = (int *)(param_3 + 4);
    iVar3 = strcasecmp((char *)*local_res8,"clear");
    if (iVar3 == 0) {
      *__s = '\x01';
    }
    else {
      iVar3 = strcasecmp((char *)*local_res8,"set");
      if (iVar3 == 0) {
        *__s = '\x01';
        while (local_res8 = local_res8 + 1, *local_res8 != 0) {
          sVar4 = strlen((char *)*local_res8);
          if (0x40 < *(ushort *)(__s + 2)) {
            fwrite("Too many BSSID\n",1,0xf,stderr);
            local_b8 = -0x2c;
            goto LAB_0046e308;
          }
          if (0x20 < (int)sVar4) {
            fwrite("SSID too long\n",1,0xe,stderr);
            local_b8 = -0x2c;
            goto LAB_0046e308;
          }
          *(size_t *)(__s + (uint)*(ushort *)(__s + 2) * 0x24 + 4) = sVar4;
          memcpy(__s + (uint)*(ushort *)(__s + 2) * 0x24 + 8,(void *)*local_res8,sVar4);
          *(short *)(__s + 2) = *(short *)(__s + 2) + 1;
        }
      }
      else {
        iVar3 = strcasecmp((char *)*local_res8,"append");
        if (iVar3 != 0) {
          fprintf(stderr,"Invalid parameter %s\n",(char *)*local_res8);
          local_b8 = -0x2c;
          goto LAB_0046e308;
        }
        while (local_res8 = local_res8 + 1, *local_res8 != 0) {
          sVar4 = strlen((char *)*local_res8);
          if (0x40 < *(ushort *)(__s + 2)) {
            fwrite("Too many BSSID\n",1,0xf,stderr);
            local_b8 = -0x2c;
            goto LAB_0046e308;
          }
          if (0x20 < (int)sVar4) {
            fwrite("SSID too long\n",1,0xe,stderr);
            local_b8 = -0x2c;
            goto LAB_0046e308;
          }
          *(size_t *)(__s + (uint)*(ushort *)(__s + 2) * 0x24 + 4) = sVar4;
          memcpy(__s + (uint)*(ushort *)(__s + 2) * 0x24 + 8,(void *)*local_res8,sVar4);
          *(short *)(__s + 2) = *(short *)(__s + 2) + 1;
        }
      }
    }
    uVar1 = *(ushort *)(__s + 2);
    if (DAT_00557704 == '\0') {
      uVar2 = *(ushort *)(__s + 2);
    }
    else {
      uVar2 = *(ushort *)(__s + 2) << 8 | *(ushort *)(__s + 2) >> 8;
    }
    *(ushort *)(__s + 2) = uVar2;
    local_b8 = FUN_004ba2e4(param_1,(char *)*param_2,__s,(uint)uVar1 * 0x24 + 4);
  }
LAB_0046e308:
  free(__s);
  return local_b8;
}



int FUN_0046e330(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  ushort uVar3;
  char *__s;
  char *__s_00;
  int iVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int *local_res8;
  int local_28;
  int local_24;
  
  __s = (char *)malloc(0x184);
  if (__s == (char *)0x0) {
    fwrite("Not enough memory\n",1,0x12,stderr);
    return -0x1b;
  }
  memset(__s,0,0x184);
  if (*(int *)(param_3 + 4) == 0) {
    local_28 = FUN_004ba1f8(param_1,(char *)*param_2,__s,0x184);
    if (-1 < local_28) {
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(__s + 2);
      }
      else {
        uVar2 = *(ushort *)(__s + 2) << 8 | *(ushort *)(__s + 2) >> 8;
      }
      *(ushort *)(__s + 2) = uVar2;
      for (local_24 = 0; local_24 < (int)(uint)*(ushort *)(__s + 2); local_24 = local_24 + 1) {
        __s_00 = FUN_0041d780((int)(__s + local_24 * 6 + 4));
        puts(__s_00);
      }
    }
  }
  else {
    local_res8 = (int *)(param_3 + 4);
    iVar4 = strcasecmp((char *)*local_res8,"clear");
    if (iVar4 == 0) {
      *__s = '\x01';
    }
    else {
      iVar4 = strcasecmp((char *)*local_res8,"set");
      if (iVar4 == 0) {
        *__s = '\x01';
        while (local_res8 = local_res8 + 1, *local_res8 != 0) {
          if (0x40 < *(ushort *)(__s + 2)) {
            fwrite("Too many BSSID\n",1,0xf,stderr);
            local_28 = -0x2c;
            goto LAB_0046e84c;
          }
          bVar1 = FUN_0041d6ac((char *)*local_res8,__s + (uint)*(ushort *)(__s + 2) * 6 + 4);
          if (CONCAT31(extraout_var,bVar1) == 0) {
            fwrite("Invalid BSSID\n",1,0xe,stderr);
            local_28 = -0x2c;
            goto LAB_0046e84c;
          }
          *(short *)(__s + 2) = *(short *)(__s + 2) + 1;
        }
      }
      else {
        iVar4 = strcasecmp((char *)*local_res8,"append");
        if (iVar4 != 0) {
          fprintf(stderr,"Invalid parameter %s\n",(char *)*local_res8);
          local_28 = -0x2c;
          goto LAB_0046e84c;
        }
        while (local_res8 = local_res8 + 1, *local_res8 != 0) {
          if (0x40 < *(ushort *)(__s + 2)) {
            fwrite("Too many BSSID\n",1,0xf,stderr);
            local_28 = -0x2c;
            goto LAB_0046e84c;
          }
          bVar1 = FUN_0041d6ac((char *)*local_res8,__s + (uint)*(ushort *)(__s + 2) * 6 + 4);
          if (CONCAT31(extraout_var_00,bVar1) == 0) {
            fwrite("Invalid BSSID\n",1,0xe,stderr);
            local_28 = -0x2c;
            goto LAB_0046e84c;
          }
          *(short *)(__s + 2) = *(short *)(__s + 2) + 1;
        }
      }
    }
    uVar2 = *(ushort *)(__s + 2);
    if (DAT_00557704 == '\0') {
      uVar3 = *(ushort *)(__s + 2);
    }
    else {
      uVar3 = *(ushort *)(__s + 2) << 8 | *(ushort *)(__s + 2) >> 8;
    }
    *(ushort *)(__s + 2) = uVar3;
    local_28 = FUN_004ba2e4(param_1,(char *)*param_2,__s,(uint)uVar2 * 6 + 4);
  }
LAB_0046e84c:
  free(__s);
  return local_28;
}



int FUN_0046e874(int *param_1)

{
  ushort uVar1;
  int __fd;
  void *__buf;
  ssize_t sVar2;
  ushort *puVar3;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  int local_98;
  sockaddr local_60;
  char acStack_4c [16];
  char local_3c [16];
  char local_2c [28];
  byte local_10;
  byte local_f;
  
  builtin_strncpy(local_2c,"eth1",5);
  local_2c[5] = 0;
  local_2c[6] = 0;
  local_2c[7] = 0;
  local_2c[8] = 0;
  local_2c[9] = 0;
  local_2c[10] = 0;
  local_2c[0xb] = 0;
  local_2c[0xc] = 0;
  local_2c[0xd] = 0;
  local_2c[0xe] = 0;
  local_2c[0xf] = 0;
  memset(acStack_4c,0,0x20);
  if (param_1 == (int *)0x0) {
    strncpy(acStack_4c,local_2c,0xf);
  }
  else {
    strncpy(acStack_4c,(char *)param_1,0xf);
  }
  memset(local_2c + 0x10,0,0x10);
  local_10 = local_10 | 0x80;
  local_f = local_f | 1;
  local_98 = FUN_004ba2e4(param_1,"event_msgs",local_2c + 0x10,0x10);
  if (local_98 == 0) {
    __fd = socket(0x11,3,0x6c88);
    if (__fd < 0) {
      printf("Cannot create socket %d\n",__fd);
      local_98 = -1;
    }
    else {
      local_98 = ioctl(__fd,0x8933,acStack_4c);
      if (local_98 < 0) {
        printf("Cannot get index %d\n",local_98);
      }
      else {
        memset(&local_60,0,0x14);
        local_60.sa_family = 0x11;
        local_60.sa_data[0] = -0x78;
        local_60.sa_data[1] = 'l';
        local_60.sa_data[2] = local_3c[0];
        local_60.sa_data[3] = local_3c[1];
        local_60.sa_data[4] = local_3c[2];
        local_60.sa_data[5] = local_3c[3];
        local_98 = bind(__fd,&local_60,0x14);
        if (local_98 < 0) {
          printf("Cannot bind %d\n",local_98);
        }
        else {
          __buf = malloc(0x800);
          if (__buf != (void *)0x0) {
            do {
              while( true ) {
                do {
                  sVar2 = recv(__fd,__buf,0x800,0);
                  uVar5 = *(uint *)((int)__buf + 0x1c);
                  uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                } while (sVar2 < 0x48);
                uVar6 = *(uint *)((int)__buf + 0x20);
                uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                        uVar6 >> 0x18;
                if (uVar5 == 0x67) break;
                if (uVar5 == 0x68) {
                  if (uVar6 == 0) {
                    pcVar4 = "WLC_E_STATUS_SUCCESS";
                  }
                  else {
                    pcVar4 = "unknown";
                  }
                  printf("WLC_E_GAS_COMPLETE: %s\n",pcVar4);
                }
              }
              puVar3 = (ushort *)((int)__buf + 0x48);
              if (DAT_00557704 == '\0') {
                uVar1 = *puVar3;
              }
              else {
                uVar1 = *puVar3 << 8 | *puVar3 >> 8;
              }
              *(char *)puVar3 = (char)uVar1;
              *(char *)((int)__buf + 0x49) = (char)(uVar1 >> 8);
              if (DAT_00557704 == '\0') {
                uVar1 = *(ushort *)((int)__buf + 0x4c);
              }
              else {
                uVar1 = *(ushort *)((int)__buf + 0x4c) << 8 | *(ushort *)((int)__buf + 0x4c) >> 8;
              }
              *(char *)((int)__buf + 0x4c) = (char)uVar1;
              *(char *)((int)__buf + 0x4d) = (char)(uVar1 >> 8);
              if (DAT_00557704 == '\0') {
                uVar1 = *(ushort *)((int)__buf + 0x4e);
              }
              else {
                uVar1 = *(ushort *)((int)__buf + 0x4e) << 8 | *(ushort *)((int)__buf + 0x4e) >> 8;
              }
              *(char *)((int)__buf + 0x4e) = (char)uVar1;
              *(char *)((int)__buf + 0x4f) = (char)(uVar1 >> 8);
              if (uVar6 == 8) {
                pcVar4 = "WLC_E_STATUS_PARTIAL";
              }
              else if (uVar6 == 0) {
                pcVar4 = "WLC_E_STATUS_SUCCESS";
              }
              else if (uVar6 == 1) {
                pcVar4 = "WLC_E_STATUS_FAIL";
              }
              else {
                pcVar4 = "unknown";
              }
              printf("WLC_E_GAS_FRAGMENT_RX: %s\n",pcVar4);
              printf("   channel         = %d\n",(uint)*puVar3);
              pcVar4 = FUN_0041d780((int)__buf + 0x30);
              printf("   peer            = %s\n",pcVar4);
              printf("   dialog token    = 0x%02x (%d)\n",(uint)*(byte *)((int)__buf + 0x4a),
                     (uint)*(byte *)((int)__buf + 0x4a));
              printf("   fragment id     = 0x%02x\n",(uint)*(byte *)((int)__buf + 0x4b));
              if (*(short *)((int)__buf + 0x4c) == 0) {
                pcVar4 = "SUCCESS";
              }
              else if (*(short *)((int)__buf + 0x4c) == 1) {
                pcVar4 = "UNSPECIFIED";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x3b) {
                pcVar4 = "ADVERTISEMENT_PROTOCOL_NOT_SUPPORTED";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x3c) {
                pcVar4 = "NO_OUTSTANDING_REQUEST";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x3d) {
                pcVar4 = "RESPONSE_NOT_RECEIVED_FROM_SERVER";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x3e) {
                pcVar4 = "TIMEOUT";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x3f) {
                pcVar4 = "QUERY_RESPONSE_TOO_LARGE";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x41) {
                pcVar4 = "SERVER_UNREACHABLE";
              }
              else if (*(short *)((int)__buf + 0x4c) == 0x4f) {
                pcVar4 = "TRANSMISSION_FAILURE";
              }
              else {
                pcVar4 = "unknown";
              }
              printf("   GAS status      = %s\n",pcVar4);
              printf("   GAS data length = %d\n",(uint)*(ushort *)((int)__buf + 0x4e));
              if (*(short *)((int)__buf + 0x4e) != 0) {
                FUN_0041e248((int)__buf + 0x50,(uint)*(ushort *)((int)__buf + 0x4e));
              }
            } while( true );
          }
          printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
          local_98 = -0x1b;
        }
      }
      close(__fd);
    }
  }
  return local_98;
}



int FUN_0046f230(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  size_t sVar2;
  undefined1 *__ptr;
  undefined4 *local_res8;
  int local_28;
  uint local_14;
  int local_10 [2];
  
  local_14 = 0;
  local_10[0] = 0;
  if (param_3[1] == 0) {
    fwrite("Too few arguments\n",1,0x12,stderr);
    local_28 = -1;
  }
  else {
    local_28 = FUN_004024e8(param_3 + 1,*param_3,&local_14,local_10);
    if (local_28 == 0) {
      local_res8 = param_3;
      if (local_10[0] != 0) {
        local_res8 = param_3 + local_10[0];
      }
      iVar1 = atoi((char *)local_res8[1]);
      if ((iVar1 < 0) || (0xff < iVar1)) {
        fwrite("Invalid length\n",1,0xf,stderr);
        local_28 = -1;
      }
      else {
        if (0 < iVar1) {
          if (local_res8[2] == 0) {
            fwrite("Data bytes should be specified for non-zero length\n",1,0x33,stderr);
            return -1;
          }
          sVar2 = strlen((char *)local_res8[2]);
          if (sVar2 != iVar1 << 1) {
            fwrite("Please specify all the data bytes for this IE\n",1,0x2e,stderr);
            return -1;
          }
        }
        sVar2 = iVar1 + 2;
        __ptr = (undefined1 *)malloc(sVar2);
        if (__ptr == (undefined1 *)0x0) {
          fprintf(stderr,"Error allocating %d bytes for IE params\n",sVar2);
          local_28 = -1;
        }
        else {
          *__ptr = 0xdd;
          __ptr[1] = (char)iVar1;
          if ((iVar1 < 1) ||
             (local_28 = FUN_00459628((char *)local_res8[2],__ptr + 2,iVar1), local_28 == 0)) {
            if (local_14 == 0xffffffff) {
              local_28 = FUN_00445444(param_1,"hs20_ie",__ptr,sVar2);
            }
            else {
              local_28 = FUN_00445758(param_1,"hs20_ie",local_14,__ptr,sVar2,PTR_DAT_00551644,0x2000
                                     );
            }
            free(__ptr);
          }
          else {
            fwrite("Error parsing data arg\n",1,0x17,stderr);
            free(__ptr);
          }
        }
      }
    }
  }
  return local_28;
}



int FUN_0046f5a8(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int *local_res8;
  int local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  undefined *local_2c;
  char *local_28;
  char *local_18;
  uint *local_14;
  uint local_10 [2];
  
  local_38 = 0;
  local_34 = 0;
  local_30 = 0;
  local_2c = (undefined *)0x0;
  local_14 = (uint *)0x0;
  iVar1 = strcmp((char *)*param_2,"toe_ol");
  if (iVar1 == 0) {
    local_2c = &DAT_00555f74;
  }
  else {
    iVar1 = strcmp((char *)*param_2,"arp_ol");
    if (iVar1 == 0) {
      local_2c = &DAT_00555f8c;
    }
  }
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
  if (-1 < iVar1) {
    if (DAT_00557704 == '\0') {
      local_10[0] = *local_14;
    }
    else {
      uVar2 = *local_14;
      local_10[0] = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      printf("0x%x ",local_10[0]);
      for (local_40 = 0; uVar2 = *(uint *)(local_2c + local_40 * 8), uVar2 != 0;
          local_40 = local_40 + 1) {
        if (((local_10[0] & uVar2) != 0) && (uVar2 != local_38)) {
          printf(" %s",*(char **)(local_2c + local_40 * 8 + 4));
        }
        local_38 = uVar2;
      }
      putchar(10);
      iVar1 = 0;
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_28 = (char *)*local_res8;
        if ((*local_28 == '+') || (*local_28 == '-')) {
          local_28 = local_28 + 1;
        }
        else {
          local_30 = 0xffffffff;
        }
        local_3c = strtoul(local_28,&local_18,0);
        if (*local_18 != '\0') {
          local_40 = 0;
          while ((local_3c = *(uint *)(local_2c + local_40 * 8), local_3c != 0 &&
                 (iVar1 = strcasecmp(*(char **)(local_2c + local_40 * 8 + 4),local_28), iVar1 != 0))
                ) {
            local_40 = local_40 + 1;
          }
          if (local_3c == 0) {
            fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45,
                   stderr);
            fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
            for (local_40 = 0; uVar2 = *(uint *)(local_2c + local_40 * 8), uVar2 != 0;
                local_40 = local_40 + 1) {
              if (uVar2 == local_38) {
                fprintf(stderr,", %s",*(char **)(local_2c + local_40 * 8 + 4));
              }
              else {
                fprintf(stderr,"\n0x%04x %s",uVar2,*(char **)(local_2c + local_40 * 8 + 4));
              }
              local_38 = uVar2;
            }
            fputc(10,stderr);
            return 0;
          }
        }
        if (*(char *)*local_res8 == '-') {
          local_30 = local_30 | local_3c;
        }
        else {
          local_34 = local_34 | local_3c;
        }
      }
      local_10[0] = ~local_30 & local_10[0] | local_34;
      if (DAT_00557704 != '\0') {
        local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                      (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
      }
      iVar1 = FUN_00445444(param_1,(char *)*param_2,local_10,4);
    }
  }
  return iVar1;
}



int FUN_0046fb2c(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  undefined3 extraout_var;
  int local_40;
  void *local_3c;
  void *local_38;
  undefined1 auStack_2c [16];
  undefined1 auStack_1c [16];
  void *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (void *)0x0;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar3) {
      local_38 = local_c;
      memset(auStack_1c,0,0x10);
      local_3c = local_c;
      while (iVar4 = memcmp(auStack_1c,local_3c,0x10), iVar4 != 0) {
        for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
          uVar1 = *(ushort *)((int)local_38 + local_40 * 2);
          printf("%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
          if (local_40 < 7) {
            putchar(0x3a);
          }
        }
        puts("\r");
        local_38 = (void *)((int)local_38 + 0x10);
        local_3c = (void *)((int)local_3c + 0x10);
      }
    }
  }
  else {
    bVar2 = FUN_0041dbbc(*(char **)(param_3 + 4),(int)auStack_2c);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      iVar3 = -0x2c;
    }
    else {
      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_2c,0x10);
    }
  }
  return iVar3;
}



undefined4 FUN_0046fd38(int param_1)

{
  ushort uVar1;
  undefined4 uVar2;
  uint local_18;
  
  if (param_1 == 0) {
    printf("null");
    uVar2 = 0xffffffff;
  }
  else {
    for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {
      uVar1 = *(ushort *)(param_1 + local_18 * 2);
      printf("%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
      if (local_18 < 7) {
        putchar(0x3a);
      }
    }
    uVar2 = 0;
  }
  return uVar2;
}



int FUN_0046fe30(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint local_84;
  undefined2 local_30;
  undefined2 local_2e;
  undefined4 local_2c;
  undefined2 local_28 [8];
  undefined1 local_18;
  ushort *local_14;
  uint *local_10 [2];
  
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    iVar4 = FUN_0046fb2c(param_1,param_2,param_3);
  }
  else {
    iVar4 = strcasecmp((char *)*piVar3,"ver");
    if (iVar4 == 0) {
      local_14 = (ushort *)0x0;
      if (DAT_00557704 == '\0') {
        local_30 = 1;
      }
      else {
        local_30 = 0x100;
      }
      local_2e = 0;
      if (DAT_00557704 == '\0') {
        local_2c = 10;
      }
      else {
        local_2c = 0xa000000;
      }
      local_28[0] = 0;
      iVar4 = FUN_00445198(param_1,(char *)*param_2,&local_30,10,&local_14);
      if (iVar4 < 0) {
        iVar4 = -0x17;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar2 = *local_14;
        }
        else {
          uVar2 = *local_14 << 8 | *local_14 >> 8;
        }
        *local_14 = uVar2;
        if (DAT_00557704 == '\0') {
          uVar2 = local_14[1];
        }
        else {
          uVar2 = local_14[1] << 8 | local_14[1] >> 8;
        }
        local_14[1] = uVar2;
        if (DAT_00557704 == '\0') {
          uVar5 = *(uint *)(local_14 + 2);
        }
        else {
          uVar5 = *(uint *)(local_14 + 2);
          uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        }
        *(uint *)(local_14 + 2) = uVar5;
        if (DAT_00557704 == '\0') {
          uVar2 = local_14[4];
        }
        else {
          uVar2 = local_14[4] << 8 | local_14[4] >> 8;
        }
        local_14[4] = uVar2;
        if (((*local_14 == 1) && (local_14[1] == 0)) && (*(int *)(local_14 + 2) == 10)) {
          printf("nd_hostip ver %d\n",(uint)local_14[4]);
        }
        else {
          puts("nd_hostip ver 0");
          iVar4 = -0x17;
        }
      }
    }
    else {
      iVar4 = strcasecmp((char *)*piVar3,"add");
      if (iVar4 == 0) {
        if (DAT_00557704 == '\0') {
          local_30 = 1;
          local_2e = 1;
          local_2c = 0x1c;
        }
        else {
          local_30 = 0x100;
          local_2e = 0x100;
          local_2c = 0x1c000000;
        }
        if (*(int *)(param_3 + 8) == 0) {
          iVar4 = -0x2c;
        }
        else {
          bVar1 = FUN_0041dbbc(*(char **)(param_3 + 8),(int)local_28);
          if (CONCAT31(extraout_var,bVar1) == 0) {
            iVar4 = -0x2c;
          }
          else {
            local_18 = 0;
            if ((((*(int *)(param_3 + 0xc) != 0) &&
                 (iVar4 = strcasecmp(*(char **)(param_3 + 0xc),"-t"), iVar4 == 0)) &&
                (*(int *)(param_3 + 0x10) != 0)) &&
               (iVar4 = strcasecmp(*(char **)(param_3 + 0x10),"ac"), iVar4 == 0)) {
              local_18 = 1;
            }
            iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_30,0x1c);
          }
        }
      }
      else {
        iVar4 = strcasecmp((char *)*piVar3,"del");
        if (iVar4 == 0) {
          if (DAT_00557704 == '\0') {
            local_30 = 1;
          }
          else {
            local_30 = 0x100;
          }
          piVar3 = (int *)(param_3 + 8);
          if (*piVar3 == 0) {
            if (DAT_00557704 == '\0') {
              local_2e = 5;
              local_2c = 8;
            }
            else {
              local_2e = 0x500;
              local_2c = 0x8000000;
            }
            iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_30,8);
          }
          else {
            iVar4 = strcasecmp((char *)*piVar3,"-t");
            if (iVar4 == 0) {
              piVar3 = (int *)(param_3 + 0xc);
              if (*piVar3 == 0) {
                iVar4 = -0x2c;
              }
              else {
                iVar4 = strcasecmp((char *)*piVar3,"uc");
                if (iVar4 == 0) {
                  if (DAT_00557704 == '\0') {
                    local_2e = 3;
                    local_2c = 8;
                  }
                  else {
                    local_2e = 0x300;
                    local_2c = 0x8000000;
                  }
                }
                else {
                  iVar4 = strcasecmp((char *)*piVar3,"ac");
                  if (iVar4 != 0) {
                    return -0x2c;
                  }
                  if (DAT_00557704 == '\0') {
                    local_2e = 4;
                    local_2c = 8;
                  }
                  else {
                    local_2e = 0x400;
                    local_2c = 0x8000000;
                  }
                }
                iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_30,8);
              }
            }
            else {
              bVar1 = FUN_0041dbbc((char *)*piVar3,(int)local_28);
              if (CONCAT31(extraout_var_00,bVar1) == 0) {
                iVar4 = -0x2c;
              }
              else {
                if (DAT_00557704 == '\0') {
                  local_2e = 2;
                  local_2c = 0x1c;
                }
                else {
                  local_2e = 0x200;
                  local_2c = 0x1c000000;
                }
                local_18 = 0;
                iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_30,0x1c);
              }
            }
          }
        }
        else {
          iVar4 = strcasecmp((char *)*piVar3,"list");
          if (iVar4 == 0) {
            local_10[0] = (uint *)0x0;
            if (DAT_00557704 == '\0') {
              local_30 = 1;
              local_2e = 6;
              local_2c = 8;
            }
            else {
              local_30 = 0x100;
              local_2e = 0x600;
              local_2c = 0x8000000;
            }
            iVar4 = FUN_00445198(param_1,(char *)*param_2,&local_30,8,local_10);
            if (iVar4 == 0) {
              if (DAT_00557704 == '\0') {
                uVar5 = *local_10[0];
              }
              else {
                uVar5 = *local_10[0];
                uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
              }
              *local_10[0] = uVar5;
              for (local_84 = 0; local_84 < *local_10[0]; local_84 = local_84 + 1) {
                uVar5 = local_10[0][local_84 * 5 + 5];
                FUN_0046fd38((int)(local_10[0] + local_84 * 5 + 1));
                if ((char)uVar5 == '\0') {
                  puts(" unicast\r");
                }
                else if ((char)uVar5 == '\x01') {
                  puts(" anycast\r");
                }
                else {
                  puts(" unknown type\n");
                }
              }
            }
          }
          else {
            iVar4 = FUN_0046fb2c(param_1,param_2,param_3);
          }
        }
      }
    }
  }
  return iVar4;
}



int FUN_00470bdc(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int *local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    local_10[0] = (int *)0x0;
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    piVar1 = local_10[0];
    if (iVar2 < 0) {
      return iVar2;
    }
    printf("host_ip_entries %d\r\n",*local_10[0]);
    printf("host_ip_overflow %d\r\n",piVar1[1]);
    printf("peer_request %d\r\n",piVar1[2]);
    printf("peer_request_drop %d\r\n",piVar1[3]);
    printf("peer_reply_drop %d\r\n",piVar1[4]);
    printf("peer_service %d\r\n",piVar1[5]);
  }
  else {
    puts("Cannot set nd stats");
  }
  return 0;
}



int FUN_00470d44(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  undefined3 extraout_var;
  int local_40;
  void *local_3c;
  void *local_38;
  undefined1 auStack_2c [16];
  undefined1 auStack_1c [16];
  void *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (void *)0x0;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar3) {
      local_38 = local_c;
      memset(auStack_1c,0,0x10);
      local_3c = local_c;
      while (iVar4 = memcmp(auStack_1c,local_3c,0x10), iVar4 != 0) {
        for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
          uVar1 = *(ushort *)((int)local_38 + local_40 * 2);
          printf("%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
          if (local_40 < 7) {
            putchar(0x3a);
          }
        }
        puts("\r");
        local_38 = (void *)((int)local_38 + 0x10);
        local_3c = (void *)((int)local_3c + 0x10);
      }
    }
  }
  else {
    bVar2 = FUN_0041dbbc(*(char **)(param_3 + 4),(int)auStack_2c);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      iVar3 = -0x2c;
    }
    else {
      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_2c,0x10);
    }
  }
  return iVar3;
}



int FUN_00470f50(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  undefined3 extraout_var;
  int local_40;
  void *local_3c;
  void *local_38;
  undefined1 auStack_2c [16];
  undefined1 auStack_1c [16];
  void *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (void *)0x0;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar3) {
      local_38 = local_c;
      memset(auStack_1c,0,0x10);
      local_3c = local_c;
      while (iVar4 = memcmp(auStack_1c,local_3c,0x10), iVar4 != 0) {
        for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
          uVar1 = *(ushort *)((int)local_38 + local_40 * 2);
          printf("%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
          if (local_40 < 7) {
            putchar(0x3a);
          }
        }
        puts("\r");
        local_38 = (void *)((int)local_38 + 0x10);
        local_3c = (void *)((int)local_3c + 0x10);
      }
    }
  }
  else {
    bVar2 = FUN_0041dbbc(*(char **)(param_3 + 4),(int)auStack_2c);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      iVar3 = -0x2c;
    }
    else {
      iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_2c,0x10);
    }
  }
  return iVar3;
}



int FUN_0047115c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  char *__s;
  int iVar3;
  undefined3 extraout_var;
  byte *local_20;
  undefined1 auStack_18 [4];
  undefined1 auStack_14 [4];
  byte *local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    local_10[0] = (byte *)0x0;
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (-1 < iVar2) {
      memset(auStack_14,0,4);
      local_20 = local_10[0];
      while (iVar3 = memcmp(auStack_14,local_20,4), iVar3 != 0) {
        __s = FUN_0041e064(local_20);
        puts(__s);
        local_20 = local_20 + 4;
      }
      printf("Total %d host addresses\n",(int)local_20 - (int)local_10[0] >> 2);
    }
  }
  else {
    bVar1 = FUN_0041d840(*(char **)(param_3 + 4),(int)auStack_18);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_00445444(param_1,(char *)*param_2,auStack_18,4);
    }
  }
  return iVar2;
}



int FUN_004712e8(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  void *pvVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  undefined3 extraout_var;
  int local_40;
  void *local_3c;
  undefined1 auStack_2c [16];
  undefined1 auStack_1c [16];
  void *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (void *)0x0;
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pvVar2 = local_c;
    if (-1 < iVar4) {
      memset(auStack_1c,0,0x10);
      local_3c = local_c;
      while (iVar5 = memcmp(auStack_1c,local_3c,0x10), iVar5 != 0) {
        for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
          uVar1 = *(ushort *)((int)pvVar2 + local_40 * 2);
          printf("%x",(uint)(ushort)(uVar1 << 8 | uVar1 >> 8));
        }
        if (local_40 < 7) {
          putchar(0x3a);
        }
        local_3c = (void *)((int)local_3c + 0x10);
      }
      puts("\r");
    }
  }
  else {
    bVar3 = FUN_0041dbbc(*(char **)(param_3 + 4),(int)auStack_2c);
    if (CONCAT31(extraout_var,bVar3) == 0) {
      iVar4 = -1;
    }
    else {
      iVar4 = FUN_00445444(param_1,(char *)*param_2,auStack_2c,0x10);
    }
  }
  return iVar4;
}



int FUN_004714f8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  undefined3 extraout_var;
  char *local_1c;
  uint local_18 [2];
  undefined1 auStack_10 [8];
  
  local_1c = (char *)0x0;
  memset(local_18,0,0xc);
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_18[0] = 0xffffffff;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,local_18,0xc,&local_1c);
  }
  else {
    iVar3 = strcasecmp((char *)*piVar2,"enable");
    if (iVar3 == 0) {
      local_18[0] = 0xffffffff;
      local_18[1] = 1;
      FUN_00445444(param_1,(char *)*param_2,local_18,0xc);
      return -1;
    }
    iVar3 = strcasecmp((char *)*piVar2,"disable");
    if (iVar3 == 0) {
      local_18[0] = 0xffffffff;
      local_18[1] = 0;
      FUN_00445444(param_1,(char *)*param_2,local_18,0xc);
      return -1;
    }
    local_18[0] = atoi((char *)*piVar2);
    local_18[0] = local_18[0] & 0xff;
    if (local_18[0] == 0xdd) {
      if (*(int *)(param_3 + 8) == 0) {
        iVar3 = FUN_00445198(param_1,(char *)*param_2,local_18,0xc,&local_1c);
      }
      else {
        bVar1 = FUN_0041d840(*(char **)(param_3 + 8),(int)auStack_10);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          return -1;
        }
        piVar2 = (int *)(param_3 + 0xc);
        if (*piVar2 != 0) {
          iVar3 = strcasecmp((char *)*piVar2,"enable");
          if (iVar3 == 0) {
            local_18[1] = 1;
          }
          else {
            iVar3 = strcasecmp((char *)*piVar2,"disable");
            if (iVar3 != 0) {
              return -1;
            }
            local_18[1] = 0;
          }
          FUN_00445444(param_1,(char *)*param_2,local_18,0xc);
          return -1;
        }
        iVar3 = FUN_00445198(param_1,(char *)*param_2,local_18,0xc,&local_1c);
      }
    }
    else {
      if (0xde < local_18[0]) {
        return -1;
      }
      piVar2 = (int *)(param_3 + 8);
      if (*piVar2 != 0) {
        iVar3 = strcasecmp((char *)*piVar2,"enable");
        if (iVar3 == 0) {
          local_18[1] = 1;
        }
        else {
          iVar3 = strcasecmp((char *)*piVar2,"disable");
          if (iVar3 != 0) {
            return -1;
          }
          local_18[1] = 0;
        }
        FUN_00445444(param_1,(char *)*param_2,local_18,0xc);
        return -1;
      }
      iVar3 = FUN_00445198(param_1,(char *)*param_2,local_18,0xc,&local_1c);
    }
  }
  if ((-1 < iVar3) && (local_1c != (char *)0x0)) {
    puts(local_1c);
  }
  return iVar3;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int FUN_0047193c(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  bool bVar2;
  FILE *param0;
  bool bVar3;
  char *pcVar4;
  undefined3 extraout_var;
  int iVar5;
  int *local_res8;
  int local_108;
  int local_104;
  int local_eb;
  undefined1 local_e7;
  undefined1 local_e6;
  char local_e4 [2];
  undefined1 local_e2;
  int local_e1;
  undefined1 local_dd;
  undefined1 local_dc;
  int local_c4;
  undefined4 auStack_c0 [3];
  int local_b4;
  char local_af;
  char local_ae;
  char *local_2c;
  int local_24;
  undefined4 local_20;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined4 local_18;
  undefined1 local_14;
  undefined1 local_13;
  
  local_108 = 0;
  local_c4 = 0;
  bVar2 = false;
  bVar3 = false;
  local_20 = 0x7f5e0001;
  local_1c = 0xff;
  local_1b = 0xff;
  local_18 = 0x3333;
  local_14 = 0;
  local_13 = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    local_108 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c4);
    iVar5 = local_c4;
    if (-1 < local_108) {
      bVar1 = *(byte *)(local_c4 + 1);
      printf("\n Num of transmitters %02x ",(uint)bVar1);
      printf("\n Transmitter Mac \t AR  Mac");
      printf("\t rmc_ar_timeout\t amt_idx   flag ");
      for (local_104 = 0; (local_104 < 0x20 && (local_104 < (int)(uint)bVar1));
          local_104 = local_104 + 1) {
        pcVar4 = FUN_0041d780(iVar5 + local_104 * 0x12 + 2);
        printf("\n %s \t",pcVar4);
        pcVar4 = FUN_0041d780(iVar5 + local_104 * 0x12 + 8);
        printf(" %s \t",pcVar4);
        printf(" %d \t %d      %04x",(uint)*(ushort *)(iVar5 + local_104 * 0x12 + 0xe),
               (uint)*(byte *)(iVar5 + local_104 * 0x12 + 0x10),
               (uint)*(ushort *)(iVar5 + local_104 * 0x12 + 0x12));
      }
      putchar(10);
      local_108 = 0;
    }
  }
  else {
    FUN_004cbd80(auStack_c0,*param_2,0,0);
    while (iVar5 = FUN_004cbe18(auStack_c0,local_res8), iVar5 != -1) {
      if (iVar5 == 1) {
        return -0x2c;
      }
      local_res8 = local_res8 + local_b4;
      if (local_ae == 'i') {
        if ((local_af == '\0') || ((local_24 != 8 && (local_24 != 0)))) {
          fprintf(stderr,"%s: Invalid mode value\n",(char *)*param_2);
          return 0;
        }
        local_e4[0] = (char)local_24;
        bVar2 = true;
      }
      if (local_ae == 't') {
        bVar3 = FUN_0041d6ac(local_2c,&local_eb);
        if (CONCAT31(extraout_var,bVar3) == 0) {
          fprintf(stderr,"%s: could not parse \"%s\" as a MAC address\n",(char *)*param_2,local_2c);
          return 0;
        }
        bVar3 = true;
      }
    }
    if (bVar2) {
      if (bVar3) {
        if (local_e4[0] == '\b') {
          local_e1 = local_eb;
          local_dd = local_e7;
          local_dc = local_e6;
          local_e2 = 2;
          iVar5 = memcmp(&local_e1,&local_20,3);
          if (((iVar5 == 0) && (-1 < local_e1)) ||
             (iVar5 = memcmp(&local_e1,&local_18,2), iVar5 == 0)) {
            param0 = stderr;
            pcVar4 = FUN_0041d780((int)&local_e1);
            fprintf(param0,"\nAdding multi-cast mac %s\n",pcVar4);
            local_108 = FUN_00445444(param_1,(char *)*param_2,local_e4,0x1e);
          }
          else {
            fwrite("multicast mac started with01:00:5e:0... or 33:33:...\n",1,0x35,stderr);
            local_108 = -2;
          }
        }
        else {
          printf("\n Invalid index ");
          local_108 = -0x2c;
        }
      }
      else {
        printf("\n Invalid without mac address");
        local_108 = -0x2c;
      }
    }
  }
  return local_108;
}



int FUN_00471ec4(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  long lVar4;
  int local_178;
  int local_174;
  uint local_170;
  char *local_160;
  byte *local_15c;
  byte local_158 [4];
  char acStack_154 [322];
  short local_12;
  short local_e;
  
  local_174 = 0;
  local_160 = (char *)0x0;
  local_15c = (byte *)0x0;
  local_158[0] = 0;
  piVar2 = (int *)(param_3 + 4);
  iVar3 = FUN_0044527c(param_1,(char *)*param_2,local_158,1,&local_15c);
  if (iVar3 == 0) {
    bVar1 = *local_15c;
    if (*piVar2 == 0) {
      fprintf(stderr,"%s mode %d \n","wl_mcast_ackreq",(uint)*local_15c);
    }
    else {
      for (local_170 = 0; piVar2[local_170] != 0; local_170 = local_170 + 1) {
      }
      if (local_170 == 0) {
        iVar3 = -1;
      }
      else {
        lVar4 = strtol((char *)*piVar2,&local_160,0);
        local_158[0] = (byte)lVar4;
        if ((*local_160 == '\0') && (local_158[0] < 3)) {
          if (local_170 < 2) {
            local_178 = FUN_00445444(param_1,(char *)*param_2,local_158,1);
            if ((local_178 == 0) && ((local_158[0] == 2 || ((local_158[0] == 0 && (bVar1 == 2))))))
            {
              for (local_174 = 0; local_174 < 0xb; local_174 = local_174 + 1) {
                local_178 = FUN_004ba1f8(param_1,"rmc_status",acStack_154,0x146);
                if (local_178 < 0) {
                  return local_178;
                }
                if (local_12 != -0x19) {
                  if (local_12 == -0x27) {
                    fprintf(stderr,"%s: error in setting mode: no ack receive%d tx code %d \n",
                            "wl_mcast_ackreq",(uint)local_158[0],0xffd9);
                    local_178 = -1;
                  }
                  else {
                    local_178 = 0;
                  }
                  break;
                }
                local_e = -1;
                do {
                  local_e = local_e + -1;
                } while (local_e != 0);
                local_e = 0xffff;
              }
            }
            if ((local_178 < 0) || (10 < local_174)) {
              fprintf(stderr,"%s: Error setting %d err %d \n","wl_mcast_ackreq",(uint)local_158[0],
                      local_178);
            }
            else {
              fprintf(stderr,"%s: setting %d err %d \n","wl_mcast_ackreq",(uint)local_158[0],
                      local_178);
            }
          }
          else {
            fprintf(stderr,"%s: could not parse extra argument %s:\n","wl_mcast_ackreq",
                    *(char **)(param_3 + 8));
          }
          iVar3 = 0;
        }
        else {
          iVar3 = -1;
        }
      }
    }
  }
  else {
    fprintf(stderr,"Error getting variable %s\n",(char *)*piVar2);
  }
  return iVar3;
}



int FUN_004722d4(int *param_1,undefined4 *param_2,int param_3)

{
  uchar param5;
  int iVar1;
  char *param1;
  uchar param3;
  uchar param4;
  int local_158;
  byte local_150;
  byte local_14f;
  byte abStack_14e [322];
  ushort local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_150,0x146);
    if (iVar1 < 0) {
      return iVar1;
    }
    if (local_150 == 1) {
      if (local_14f == 0) {
        puts("No clients associated");
      }
      else {
        for (local_158 = 0; local_158 < (int)(uint)local_14f; local_158 = local_158 + 1) {
          param1 = FUN_0041d780((int)(abStack_14e + local_158 * 10 + 4));
          if ((abStack_14e[local_158 * 10] & 2) == 0) {
            param3 = ' ';
          }
          else {
            param3 = 'A';
          }
          if ((abStack_14e[local_158 * 10] & 1) == 0) {
            param4 = ' ';
          }
          else {
            param4 = 'B';
          }
          if ((abStack_14e[local_158 * 10] & 4) == 0) {
            param5 = ' ';
          }
          else {
            param5 = 'R';
          }
          printf("%s\t%d\t%c%c%c\n",param1,(int)*(short *)(abStack_14e + local_158 * 10 + 2),param3,
                 param4,param5);
        }
        printf("Notification Frame TimePeriod: %d ms\n",(uint)local_c);
      }
    }
    else {
      printf("Wrong Version %d %d\n",1,(uint)local_150);
    }
  }
  else {
    puts("Cannot set reliable multicast status");
  }
  return 0;
}



int FUN_00472530(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int local_18;
  uint local_10 [2];
  
  local_18 = -1;
  pcVar1 = (char *)*param_2;
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = FUN_004ba35c(param_1,pcVar1,local_10);
    if (-1 < local_18) {
      printf("Action Frame tx time period: %dms\n",local_10[0]);
    }
  }
  else {
    local_10[0] = strtol(*(char **)(param_3 + 4),(char **)0x0,10);
    local_10[0] = local_10[0] & 0xffff;
    if ((local_10[0] < 300) || (20000 < local_10[0])) {
      printf("\"Out of range\": valid range %dms - %dms\n",300,20000);
    }
    else {
      local_18 = FUN_004ba428(param_1,pcVar1,local_10[0]);
    }
  }
  return local_18;
}



int FUN_0047266c(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int local_18;
  uint local_10 [2];
  
  local_18 = -1;
  pcVar1 = (char *)*param_2;
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = FUN_004ba35c(param_1,pcVar1,local_10);
    if (-1 < local_18) {
      printf("Active Receiver time out: %dms\n",local_10[0]);
    }
  }
  else {
    local_10[0] = strtol(*(char **)(param_3 + 4),(char **)0x0,10);
    local_10[0] = local_10[0] & 0xffff;
    if ((local_10[0] < 0x15e) || (40000 < local_10[0])) {
      printf("\"Out of range\": valid range %dms - %dms\n",0x15e,40000);
    }
    else {
      local_18 = FUN_004ba428(param_1,pcVar1,local_10[0]);
    }
  }
  return local_18;
}



int FUN_004727ac(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int iVar2;
  long lVar3;
  uint local_10 [2];
  
  pcVar1 = (char *)*param_2;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_004ba35c(param_1,pcVar1,local_10);
    if (-1 < iVar2) {
      printf("rmc rssi: %d\n",local_10[0]);
    }
  }
  else {
    lVar3 = strtol(*(char **)(param_3 + 4),(char **)0x0,10);
    local_10[0] = (uint)(char)lVar3;
    iVar2 = FUN_004ba428(param_1,pcVar1,local_10[0]);
  }
  return iVar2;
}



int FUN_004728a8(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *param0;
  ushort *puVar1;
  int *piVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  long lVar6;
  int local_98;
  byte local_94;
  ushort local_4c;
  ushort local_4a;
  ushort local_48;
  ushort local_46;
  ushort local_44;
  ushort local_42;
  ushort local_40;
  ushort local_3e;
  ushort local_3a;
  ushort local_38;
  ushort local_36;
  ushort local_30;
  ushort local_2e;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  ushort local_14;
  ushort local_12;
  char *local_10;
  ushort *local_c;
  
  param0 = PTR_DAT_00551644;
  local_10 = (char *)0x0;
  local_c = (ushort *)0x0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_98 = FUN_00445198(param_1,(char *)*param_2,&local_4c,0x3c,&local_c);
    puVar1 = local_c;
    if (local_98 == 0) {
      memcpy(&local_4c,local_c,0x3c);
      if (DAT_00557704 == '\0') {
        local_4c = *puVar1;
        local_4a = puVar1[1];
      }
      else {
        local_4c = *puVar1 << 8 | *puVar1 >> 8;
        local_4a = puVar1[1] << 8 | puVar1[1] >> 8;
      }
      if (local_4c == 1) {
        if (DAT_00557704 != '\0') {
          local_48 = local_48 << 8 | local_48 >> 8;
        }
        iVar3 = sprintf(param0,"%s %u ","dupcnt",(uint)local_48);
        pcVar4 = param0 + iVar3;
        if (DAT_00557704 != '\0') {
          local_46 = local_46 << 8 | local_46 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","ackreq_err",(uint)local_46);
        if (DAT_00557704 != '\0') {
          local_44 = local_44 << 8 | local_44 >> 8;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","af_tx_err",(uint)local_44);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_42 = local_42 << 8 | local_42 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","null_tx_err",(uint)local_42);
        pcVar4 = pcVar4 + iVar3;
        if (DAT_00557704 != '\0') {
          local_40 = local_40 << 8 | local_40 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","af_unicast_tx_err",(uint)local_40);
        if (DAT_00557704 != '\0') {
          local_3e = local_3e << 8 | local_3e >> 8;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","mc_no_amt_slot",(uint)local_3e);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_3a = local_3a << 8 | local_3a >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_not_mirrored",(uint)local_3a);
        pcVar4 = pcVar4 + iVar3;
        if (DAT_00557704 != '\0') {
          local_38 = local_38 << 8 | local_38 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_existing_tr",(uint)local_38);
        if (DAT_00557704 != '\0') {
          local_36 = local_36 << 8 | local_36 >> 8;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","mc_exist_in_amt",(uint)local_36);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_30 = local_30 << 8 | local_30 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_utilized",(uint)local_30);
        pcVar4 = pcVar4 + iVar3;
        if (DAT_00557704 != '\0') {
          local_2e = local_2e << 8 | local_2e >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_taken_other_tr",(uint)local_2e);
        if (DAT_00557704 != '\0') {
          local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                     local_2c >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","rmc_rx_frames_mac",local_2c);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                     local_28 >> 0x18;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","rmc_tx_frames_mac",local_28);
        pcVar4 = pcVar4 + iVar3;
        if (DAT_00557704 != '\0') {
          local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                     local_20 >> 0x18;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_ar_role_selected",local_20);
        if (DAT_00557704 != '\0') {
          local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                     local_1c >> 0x18;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","mc_ar_role_deleted",local_1c);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_noacktimer_expired",local_18);
        pcVar4 = pcVar4 + iVar3;
        if (DAT_00557704 != '\0') {
          local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                     local_24 >> 0x18;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_null_ar_cnt",local_24);
        if (DAT_00557704 != '\0') {
          local_14 = local_14 << 8 | local_14 >> 8;
        }
        iVar5 = sprintf(pcVar4 + iVar3,"%s %u ","mc_no_wl_clk",(uint)local_14);
        pcVar4 = pcVar4 + iVar3 + iVar5;
        *pcVar4 = '\n';
        pcVar4[1] = '\0';
        pcVar4 = pcVar4 + 1;
        if (DAT_00557704 != '\0') {
          local_12 = local_12 << 8 | local_12 >> 8;
        }
        iVar3 = sprintf(pcVar4,"%s %u ","mc_tr_cnt_exceeded",(uint)local_12);
        pcVar4[iVar3] = '\n';
        (pcVar4 + iVar3)[1] = '\0';
        fputs(PTR_DAT_00551644,stdout);
      }
      else {
        printf("\tIncorrect version of counters struct: expected %d; got %d\n",1,(uint)*puVar1);
        local_98 = -1;
      }
    }
  }
  else {
    for (local_94 = 0; piVar2[local_94] != 0; local_94 = local_94 + 1) {
    }
    lVar6 = strtol((char *)*piVar2,&local_10,0);
    if ((char)lVar6 == -1) {
      fwrite("clearing rmc counters\n",1,0x16,stderr);
      local_98 = FUN_00445444(param_1,(char *)*param_2,&local_4c,0x3c);
    }
    else {
      fwrite("Invalid arg, only -1is allowed to clear counters\n",1,0x31,stderr);
      local_98 = -2;
    }
  }
  return local_98;
}



// WARNING: Removing unreachable block (ram,0x0047367c)

int FUN_00473588(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int iVar2;
  uint local_10 [2];
  
  pcVar1 = (char *)*param_2;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_004ba35c(param_1,pcVar1,local_10);
    if (-1 < iVar2) {
      printf("rmc rssi delta: %d\n",local_10[0]);
    }
  }
  else {
    local_10[0] = strtol(*(char **)(param_3 + 4),(char **)0x0,10);
    local_10[0] = local_10[0] & 0xffff;
    iVar2 = FUN_004ba428(param_1,pcVar1,local_10[0]);
  }
  return iVar2;
}



int FUN_004736a8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  char *__s;
  undefined3 extraout_var;
  size_t sVar4;
  int local_20;
  undefined1 uStack_14;
  undefined1 auStack_13 [7];
  int local_c;
  
  local_c = 0;
  memset(&uStack_14,0,7);
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar3) {
      __s = FUN_0041d780(local_c + 1);
      puts(__s);
      iVar3 = 0;
    }
  }
  else {
    for (local_20 = 0; piVar2[local_20] != 0; local_20 = local_20 + 1) {
    }
    if ((local_20 == 0) || (*piVar2 == 0)) {
      puts("Too few arguments");
      iVar3 = -1;
    }
    else {
      printf(" %s \n",(char *)*piVar2);
      bVar1 = FUN_0041d6ac((char *)*piVar2,auStack_13);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        sVar4 = strlen((char *)*piVar2);
        if ((sVar4 != 1) || (iVar3 = atoi((char *)*piVar2), iVar3 != 0)) {
          puts("Invalid argument, Please enter mac address\nor enter \"0\" for auto ar selection");
          return -1;
        }
        memset(&uStack_14,0,7);
      }
      iVar3 = FUN_00445444(param_1,(char *)*param_2,&uStack_14,7);
    }
  }
  return iVar3;
}



int FUN_004738ec(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  size_t sVar2;
  ulong uVar3;
  char *local_2c;
  int local_28;
  int local_24;
  byte *local_1c;
  undefined1 auStack_18 [4];
  undefined2 local_14;
  char acStack_10 [8];
  
  local_1c = (byte *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_1c);
    if (-1 < iVar1) {
      printf("0x%x%x%x 0x%x",(uint)*local_1c,(uint)local_1c[1],(uint)local_1c[2],
             (uint)*(ushort *)(local_1c + 4));
    }
  }
  else {
    local_2c = *(char **)(param_3 + 4);
    sVar2 = strlen(local_2c);
    if ((7 < sVar2) &&
       ((iVar1 = strncmp("0x",local_2c,2), iVar1 == 0 ||
        (iVar1 = strncmp("0X",local_2c,2), iVar1 == 0)))) {
      local_2c = local_2c + 2;
    }
    sVar2 = strlen(local_2c);
    if (sVar2 == 6) {
      for (local_28 = 0; local_28 < 3; local_28 = local_28 + 1) {
        for (local_24 = 0; local_24 < 2; local_24 = local_24 + 1) {
          acStack_10[local_24] = *local_2c;
          local_2c = local_2c + 1;
        }
        acStack_10[local_24] = '\0';
        uVar3 = strtoul(acStack_10,(char **)0x0,0x10);
        auStack_18[local_28] = (char)uVar3;
      }
      if (*(int *)(param_3 + 8) == 0) {
        iVar1 = -1;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0x10);
        local_14 = (undefined2)uVar3;
        iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_18,6);
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_00473ba4(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  uint *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (uint *)0x0;
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    puVar1 = local_c;
    if (iVar2 < 0) {
      return iVar2;
    }
    if (DAT_00557704 == '\0') {
      uVar3 = *local_c;
    }
    else {
      uVar3 = *local_c;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_ip_entries = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[1];
    }
    else {
      uVar3 = puVar1[1];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_ip_overflow = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[2];
    }
    else {
      uVar3 = puVar1[2];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("arp_table_entries = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[3];
    }
    else {
      uVar3 = puVar1[3];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("arp_table_overflow = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[4];
    }
    else {
      uVar3 = puVar1[4];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_request = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[5];
    }
    else {
      uVar3 = puVar1[5];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_reply = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[6];
    }
    else {
      uVar3 = puVar1[6];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_service = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[7];
    }
    else {
      uVar3 = puVar1[7];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("peer_request = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[8];
    }
    else {
      uVar3 = puVar1[8];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("peer_request_drop = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[9];
    }
    else {
      uVar3 = puVar1[9];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("peer_reply = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[10];
    }
    else {
      uVar3 = puVar1[10];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("peer_reply_drop = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xb];
    }
    else {
      uVar3 = puVar1[0xb];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("peer_service = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = *puVar1;
    }
    else {
      uVar3 = *puVar1;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("host_ip_entries = %d\n",uVar3);
  }
  else {
    puts("Cannot set arp stats, use \'wl arp_stats_clear\' to clear the counters");
  }
  return 0;
}



int FUN_00474278(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  uint *local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_c = (uint *)0x0;
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    puVar1 = local_c;
    if (iVar2 < 0) {
      return iVar2;
    }
    if (DAT_00557704 == '\0') {
      uVar3 = *local_c;
    }
    else {
      uVar3 = *local_c;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_summed = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[1];
    }
    else {
      uVar3 = puVar1[1];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_iph_fill = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[2];
    }
    else {
      uVar3 = puVar1[2];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_tcp_fill = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[3];
    }
    else {
      uVar3 = puVar1[3];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_udp_fill = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[4];
    }
    else {
      uVar3 = puVar1[4];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_icmp_fill = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[5];
    }
    else {
      uVar3 = puVar1[5];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_iph_good = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[6];
    }
    else {
      uVar3 = puVar1[6];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_iph_bad = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[7];
    }
    else {
      uVar3 = puVar1[7];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_tcp_good = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[8];
    }
    else {
      uVar3 = puVar1[8];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_tcp_bad = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[9];
    }
    else {
      uVar3 = puVar1[9];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_udp_good = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[10];
    }
    else {
      uVar3 = puVar1[10];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_udp_bad = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xb];
    }
    else {
      uVar3 = puVar1[0xb];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_icmp_good = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xc];
    }
    else {
      uVar3 = puVar1[0xc];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_icmp_bad = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xd];
    }
    else {
      uVar3 = puVar1[0xd];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_tcp_errinj = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xe];
    }
    else {
      uVar3 = puVar1[0xe];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_udp_errinj = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0xf];
    }
    else {
      uVar3 = puVar1[0xf];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("tx_icmp_errinj = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0x10];
    }
    else {
      uVar3 = puVar1[0x10];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_tcp_errinj = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0x11];
    }
    else {
      uVar3 = puVar1[0x11];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_udp_errinj = %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[0x12];
    }
    else {
      uVar3 = puVar1[0x12];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("rx_icmp_errinj = %d\n",uVar3);
  }
  else {
    puts("Cannot set toe stats, use \'wl toe_stats_clear\' to clear the counters");
  }
  return 0;
}



void FUN_00474c1c(int param_1)

{
  uint local_10;
  uint local_c;
  
  puts("Rates");
  for (local_10 = 0; local_10 < 0x6d; local_10 = local_10 + 1) {
    if (*(int *)(param_1 + local_10 * 4) != 0) {
      if ((local_10 & 1) * 100 < 2) {
        printf("%.2d\t%d Mbit/s\n",*(int *)(param_1 + local_10 * 4),local_10 >> 1);
      }
      else {
        printf("%.2d\t%d.%d Mbit/s\n",*(int *)(param_1 + local_10 * 4),local_10 >> 1,
               ((local_10 & 1) * 100) / 0x14);
      }
    }
  }
  puts("MCS indexes:");
  for (local_10 = 0; local_10 < 0x18; local_10 = local_10 + 1) {
    if (*(int *)(param_1 + (local_10 + 0x6c) * 4 + 4) != 0) {
      printf("%d\tMCS %d\n",*(int *)(param_1 + (local_10 + 0x6c) * 4 + 4),local_10);
    }
  }
  puts("VHT indexes:");
  for (local_c = 0; local_c < 3; local_c = local_c + 1) {
    for (local_10 = 0; local_10 < 10; local_10 = local_10 + 1) {
      if (*(int *)(param_1 + (local_10 * 3 + local_c + 0x84) * 4 + 4) != 0) {
        printf("%d\tVHT %d Nss %d\n",*(int *)(param_1 + (local_10 * 3 + local_c + 0x84) * 4 + 4),
               local_10,local_c + 1);
      }
    }
  }
  return;
}



int FUN_00474ed4(int *param_1,undefined4 *param_2)

{
  int iVar1;
  int local_10 [2];
  
  local_10[0] = 0;
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
  if (-1 < iVar1) {
    FUN_00474c1c(local_10[0]);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00474f68(int *param_1,int param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  bool bVar3;
  undefined3 extraout_var;
  int iVar4;
  size_t sVar5;
  undefined4 *puVar6;
  long lVar7;
  undefined4 local_10;
  undefined1 local_c;
  undefined1 local_b;
  
  if ((*(int *)(param_3 + 4) == 0) ||
     (bVar3 = FUN_0041d6ac(*(char **)(param_3 + 4),&local_10), puVar2 = PTR_DAT_00551644,
     CONCAT31(extraout_var,bVar3) == 0)) {
    iVar4 = -0x2c;
  }
  else {
    *(undefined4 *)PTR_DAT_00551644 = 0x5f63616d;
    pcVar1 = puVar2 + 4;
    pcVar1[0] = 'r';
    pcVar1[1] = 'a';
    pcVar1[2] = 't';
    pcVar1[3] = 'e';
    pcVar1 = puVar2 + 8;
    pcVar1[0] = '_';
    pcVar1[1] = 'h';
    pcVar1[2] = 'i';
    pcVar1[3] = 's';
    puVar2[0xc] = 't';
    puVar2[0xd] = 'o';
    puVar2[0xe] = '\0';
    sVar5 = strlen(PTR_DAT_00551644);
    puVar6 = (undefined4 *)(PTR_DAT_00551644 + sVar5 + 1);
    *puVar6 = local_10;
    *(undefined1 *)(puVar6 + 1) = local_c;
    *(undefined1 *)((int)puVar6 + 5) = local_b;
    if (*(int *)(param_3 + 8) == 0) {
      iVar4 = -0x2c;
    }
    else {
      lVar7 = strtol(*(char **)(param_3 + 8),(char **)0x0,0);
      *(char *)((int)puVar6 + 6) = (char)lVar7;
      if ((*(char *)((int)puVar6 + 6) == '\x10') || (*(char *)((int)puVar6 + 6) == '\x04')) {
        if (*(int *)(param_3 + 0xc) == 0) {
          *(undefined1 *)((int)puVar6 + 7) = 0x40;
        }
        else {
          lVar7 = strtol(*(char **)(param_3 + 0xc),(char **)0x0,10);
          *(char *)((int)puVar6 + 7) = (char)lVar7;
        }
        if ((*(char *)((int)puVar6 + 6) == '\x10') && (0x40 < *(byte *)((int)puVar6 + 7))) {
          *(undefined1 *)((int)puVar6 + 7) = 0x40;
        }
        else if ((*(char *)((int)puVar6 + 6) == '\x04') && (0x20 < *(byte *)((int)puVar6 + 7))) {
          *(undefined1 *)((int)puVar6 + 7) = 0x20;
        }
        iVar4 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
        puVar2 = PTR_DAT_00551644;
        if (-1 < iVar4) {
          FUN_00474c1c((int)PTR_DAT_00551644);
          printf("First TSF Timestamp: %08x%08x\n",*(uint *)(puVar2 + 0x290),
                 *(uint *)(puVar2 + 0x28c));
          printf("Last TSF Timestamp : %08x%08x\n",*(uint *)(puVar2 + 0x298),
                 *(uint *)(puVar2 + 0x294));
          iVar4 = 0;
        }
      }
      else {
        puts("Only Access Category 0x10 and 0x4 is supported");
        iVar4 = -2;
      }
    }
  }
  return iVar4;
}



int FUN_004752a0(int *param_1,undefined4 *param_2)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int local_30;
  int local_2c;
  uint *local_10 [2];
  
  local_10[0] = (uint *)0x0;
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
  puVar1 = local_10[0];
  if (-1 < iVar2) {
    if (DAT_00557704 == '\0') {
      uVar3 = *local_10[0];
    }
    else {
      uVar3 = *local_10[0];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("Lost frame count %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[1];
    }
    else {
      uVar3 = puVar1[1];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("RSSI %d\n",uVar3);
    if (DAT_00557704 == '\0') {
      uVar3 = puVar1[2];
    }
    else {
      uVar3 = puVar1[2];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("Signal to noise ratio %d\n",uVar3);
    printf("rx1mbps %d rx2mbps %d rx5mbps5 %d\nrx6mbps %d rx9mbps %d, rx11mbps %d\nrx12mbps %d rx18mbps %d rx24mbps %d\nrx36mbps %d rx48mbps %d rx54mbps %d\n"
           ,(uint)*(ushort *)((int)puVar1 + 0x12),(uint)*(ushort *)((int)puVar1 + 0xe),
           (uint)(ushort)puVar1[4],(uint)*(ushort *)((int)puVar1 + 0x1a),
           (uint)*(ushort *)((int)puVar1 + 0x22),(uint)(ushort)puVar1[3],(uint)(ushort)puVar1[6],
           (uint)(ushort)puVar1[8],(uint)*(ushort *)((int)puVar1 + 0x16),
           (uint)*(ushort *)((int)puVar1 + 0x1e),(uint)(ushort)puVar1[5],(uint)(ushort)puVar1[7]);
    for (local_30 = 0; local_30 < 8; local_30 = local_30 + 1) {
      for (local_2c = 0; local_2c < 4; local_2c = local_2c + 1) {
        printf("rxmcs%d %d ",local_30 * 4 + local_2c,
               (uint)*(ushort *)((int)puVar1 + (local_30 * 4 + local_2c) * 2 + 0x24));
      }
      putchar(10);
    }
    printf("rxmcsother %d\n",(uint)(ushort)puVar1[0x19]);
    iVar2 = 0;
  }
  return iVar2;
}



int FUN_00475620(int *param_1)

{
  int iVar1;
  uint local_18;
  uint local_10 [2];
  
  iVar1 = FUN_004ba35c(param_1,"patrim",local_10);
  if (-1 < iVar1) {
    for (local_18 = 0; local_18 < 0xc; local_18 = local_18 + 1) {
      if (*(ushort *)(&DAT_0051cd68 + local_18 * 8) == local_10[0]) {
        puts((&PTR_DAT_0051cd6c)[local_18 * 2]);
        return 0;
      }
    }
    iVar1 = -1;
  }
  return iVar1;
}



int FUN_00475710(int *param_1,undefined4 *param_2)

{
  int iVar1;
  uint local_118;
  uint local_114;
  int local_110;
  uint auStack_108 [64];
  
  iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)auStack_108,0x100);
  if (-1 < iVar1) {
    for (local_110 = 0; local_110 < 0x40; local_110 = local_110 + 1) {
      local_118 = auStack_108[local_110] >> 0xc;
      if (0x7ff < local_118) {
        local_118 = local_118 - 0x1000;
      }
      local_114 = auStack_108[local_110] & 0xfff;
      if (0x7ff < local_114) {
        local_114 = local_114 - 0x1000;
      }
      printf("%d %d\n",local_118,local_114);
    }
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00475838(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char *pcVar3;
  int *local_res8;
  int local_88;
  long local_64;
  short local_60;
  short local_5c;
  short local_58;
  char *pcStack_54;
  char acStack_50 [48];
  uint local_20;
  
  memset(acStack_50,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
  if (iVar1 < 0) {
    return iVar1;
  }
  if (DAT_00557704 != '\0') {
    local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
               local_20 >> 0x18;
  }
  if (local_20 == 4) {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_64,0x10);
      if (-1 < iVar1) {
        printf("%d  %d  %d  %d\n",((int)(short)local_64 << 0x16) >> 0x16,
               ((int)local_60 << 0x16) >> 0x16,((int)local_5c << 0x16) >> 0x16,
               ((int)local_58 << 0x16) >> 0x16);
        return 0;
      }
      return iVar1;
    }
    for (local_88 = 0; local_88 < 4; local_88 = local_88 + 1) {
      pcVar3 = (char *)*local_res8;
      local_res8 = local_res8 + 1;
      lVar2 = strtol(pcVar3,&pcStack_54,0);
      if ((0x1ff < lVar2) || (lVar2 < -0x200)) {
        return -2;
      }
      (&local_64)[local_88] = lVar2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_64,0x10);
  }
  else {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_64,8);
      if (-1 < iVar1) {
        printf("%d  %d\n",((int)(short)local_64 << 0x16) >> 0x16,((int)local_60 << 0x16) >> 0x16);
        return 0;
      }
      return iVar1;
    }
    for (local_88 = 0; local_88 < 2; local_88 = local_88 + 1) {
      pcVar3 = (char *)*local_res8;
      local_res8 = local_res8 + 1;
      lVar2 = strtol(pcVar3,&pcStack_54,0);
      if ((0x1ff < lVar2) || (lVar2 < -0x200)) {
        return -2;
      }
      (&local_64)[local_88] = lVar2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_64,8);
  }
  if (-1 < iVar1) {
    return 0;
  }
  return iVar1;
}



int FUN_00475c94(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char *pcVar3;
  int *local_res8;
  int local_70;
  char local_5c [4];
  char local_58;
  char local_57;
  char local_56;
  char local_55;
  char local_54;
  char local_53;
  char local_52;
  char local_51;
  char *pcStack_50;
  char acStack_4c [48];
  uint local_1c;
  
  memset(acStack_4c,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_4c,0x44);
  if (iVar1 < 0) {
    return iVar1;
  }
  if (DAT_00557704 != '\0') {
    local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
               local_1c >> 0x18;
  }
  if (local_1c == 4) {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,local_5c,0xc);
      if (-1 < iVar1) {
        local_5c[2] = (char)(((int)local_5c[2] << 3) >> 3);
        local_5c[3] = (char)(((int)local_5c[3] << 3) >> 3);
        local_58 = (char)(((int)local_58 << 3) >> 3);
        local_57 = (char)(((int)local_57 << 3) >> 3);
        local_54 = (char)(((int)local_54 << 3) >> 3);
        local_53 = (char)(((int)local_53 << 3) >> 3);
        local_52 = (char)(((int)local_52 << 3) >> 3);
        local_51 = (char)(((int)local_51 << 3) >> 3);
        printf("%d  %d  %d  %d  %d  %d  %d  %d  %d  %d  %d  %d\n",(int)local_5c[0],(int)local_5c[1],
               (int)local_5c[2],(int)local_5c[3],(int)local_58,(int)local_57,(int)local_56,
               (int)local_55,(int)local_54,(int)local_53,(int)local_52,(int)local_51);
        return 0;
      }
      return iVar1;
    }
    for (local_70 = 0; local_70 < 0xc; local_70 = local_70 + 1) {
      pcVar3 = (char *)*local_res8;
      local_res8 = local_res8 + 1;
      lVar2 = strtol(pcVar3,&pcStack_50,0);
      if (((local_70 < 2) && ((0x3f < lVar2 || (lVar2 < -0x40)))) ||
         ((1 < local_70 && ((0xf < lVar2 || (lVar2 < -0xf)))))) {
        return -2;
      }
      local_5c[local_70] = (char)lVar2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,local_5c,0xc);
  }
  else {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,local_5c,0xc);
      if (-1 < iVar1) {
        local_5c[2] = (char)(((int)local_5c[2] << 3) >> 3);
        local_5c[3] = (char)(((int)local_5c[3] << 3) >> 3);
        local_58 = (char)(((int)local_58 << 3) >> 3);
        local_57 = (char)(((int)local_57 << 3) >> 3);
        printf("%d  %d  %d  %d  %d  %d\n",(int)local_5c[0],(int)local_5c[1],(int)local_5c[2],
               (int)local_5c[3],(int)local_58,(int)local_57);
        return 0;
      }
      return iVar1;
    }
    for (local_70 = 0; local_70 < 6; local_70 = local_70 + 1) {
      pcVar3 = (char *)*local_res8;
      local_res8 = local_res8 + 1;
      lVar2 = strtol(pcVar3,&pcStack_50,0);
      if ((1 < local_70) && ((0xf < lVar2 || (lVar2 < -0xf)))) {
        return -2;
      }
      local_5c[local_70] = (char)lVar2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,local_5c,6);
  }
  if (-1 < iVar1) {
    return 0;
  }
  return iVar1;
}



int FUN_0047622c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  int local_78;
  char *local_74;
  byte abStack_64 [16];
  char *pcStack_54;
  char acStack_50 [72];
  
  memset(acStack_50,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
  if (iVar1 != 0) {
    return iVar1;
  }
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)abStack_64,0xe);
    if (iVar1 < 0) {
      return iVar1;
    }
    for (local_78 = 0; local_78 < 0xc; local_78 = local_78 + 2) {
      printf("0x%x%x,",(uint)abStack_64[local_78],(uint)abStack_64[local_78 + 1]);
    }
    printf("0x%x%x\n",(uint)abStack_64[local_78],(uint)abStack_64[local_78 + 1]);
  }
  else {
    local_74 = strtok(*(char **)(param_3 + 4),",");
    local_78 = 0;
    while (local_74 != (char *)0x0) {
      lVar2 = strtol(local_74,&pcStack_54,0);
      abStack_64[local_78] = (byte)lVar2 >> 4;
      abStack_64[local_78 + 1] = (byte)lVar2 & 0xf;
      local_74 = strtok((char *)0x0,",");
      local_78 = local_78 + 2;
    }
    if (local_78 != 0xe) {
      puts("Insufficient arguments ");
      return -2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,abStack_64,0xe);
    if (iVar1 < 0) {
      return iVar1;
    }
  }
  return 0;
}



int FUN_00476524(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char *__nptr;
  int *local_res8;
  int local_90;
  uint local_8c;
  int local_88;
  char acStack_6c [9];
  undefined1 auStack_63 [9];
  undefined1 auStack_5a [10];
  char *pcStack_50;
  char acStack_4c [48];
  uint local_1c;
  
  memset(acStack_4c,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_4c,0x44);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
    }
    if (local_1c == 0xb) {
      local_res8 = (int *)(param_3 + 4);
      if (*local_res8 == 0) {
        iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_6c,0x1c);
        if (iVar1 < 0) {
          return iVar1;
        }
        for (local_90 = 0;
            (local_90 < 0x12 &&
            (((local_90 % 9 != 0 || (local_90 < 1)) || (putchar(10), acStack_6c[local_90] != -1))));
            local_90 = local_90 + 1) {
          printf("%d ",(int)acStack_6c[local_90]);
        }
        if (local_90 == 0x12) {
          putchar(10);
        }
      }
      else {
        local_88 = 0;
        for (local_8c = 0; local_res8[local_8c] != 0; local_8c = local_8c + 1) {
        }
        for (local_90 = 0; local_90 < (int)(local_8c & 0xff); local_90 = local_90 + 1) {
          __nptr = (char *)*local_res8;
          local_res8 = local_res8 + 1;
          lVar2 = strtol(__nptr,&pcStack_50,0);
          if ((0x3f < lVar2) || (lVar2 < -0x40)) {
            return -2;
          }
          if (local_8c == 9) {
            acStack_6c[local_90] = (char)lVar2;
          }
          else {
            if (local_90 == 0) {
              acStack_6c[local_88] = '\0';
              local_88 = local_88 + 1;
            }
            else if (local_90 == 8) {
              acStack_6c[local_88] = '\x01';
              local_88 = local_88 + 1;
            }
            else if (local_90 == 0x10) {
              acStack_6c[local_88] = '\x02';
              local_88 = local_88 + 1;
            }
            acStack_6c[local_88] = (char)lVar2;
            local_88 = local_88 + 1;
          }
        }
        iVar1 = FUN_00445444(param_1,(char *)*param_2,acStack_6c,9);
        if (iVar1 < 0) {
          return iVar1;
        }
        if ((0xf < (int)local_8c) &&
           (iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_63,9), iVar1 < 0)) {
          return iVar1;
        }
        if ((local_8c == 0x18) &&
           (iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_5a,9), iVar1 < 0)) {
          return iVar1;
        }
      }
      iVar1 = 0;
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_00476a28(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char *__nptr;
  int *local_res8;
  int local_88;
  uint local_80;
  int local_7c;
  char acStack_64 [5];
  undefined1 auStack_5f [5];
  undefined1 auStack_5a [10];
  char *pcStack_50;
  char acStack_4c [48];
  uint local_1c;
  
  memset(acStack_4c,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_4c,0x44);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
    }
    if (local_1c == 0xb) {
      local_res8 = (int *)(param_3 + 4);
      if (*local_res8 == 0) {
        iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_64,0x12);
        if (iVar1 < 0) {
          return iVar1;
        }
        for (local_88 = 0; local_88 < 0xf; local_88 = local_88 + 1) {
          if (local_88 % 5 == 0) {
            if (0 < local_88) {
              putchar(10);
            }
            if (acStack_64[local_88] == -1) break;
          }
          printf("%d ",(int)acStack_64[local_88]);
        }
        if (local_88 == 0xf) {
          putchar(10);
        }
      }
      else {
        local_7c = 0;
        for (local_80 = 0; local_res8[local_80] != 0; local_80 = local_80 + 1) {
        }
        for (local_88 = 0; local_88 < (int)(local_80 & 0xff); local_88 = local_88 + 1) {
          __nptr = (char *)*local_res8;
          local_res8 = local_res8 + 1;
          lVar2 = strtol(__nptr,&pcStack_50,0);
          if ((0x3f < lVar2) || (lVar2 < -0x40)) {
            return -2;
          }
          if (local_80 == 5) {
            acStack_64[local_88] = (char)lVar2;
          }
          else {
            if (local_88 == 0) {
              acStack_64[local_7c] = '\0';
              local_7c = local_7c + 1;
            }
            else if (local_88 == 4) {
              acStack_64[local_7c] = '\x01';
              local_7c = local_7c + 1;
            }
            else if (local_88 == 8) {
              acStack_64[local_7c] = '\x02';
              local_7c = local_7c + 1;
            }
            acStack_64[local_7c] = (char)lVar2;
            local_7c = local_7c + 1;
          }
        }
        iVar1 = FUN_00445444(param_1,(char *)*param_2,acStack_64,5);
        if (iVar1 < 0) {
          return iVar1;
        }
        if ((7 < (int)local_80) &&
           (iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_5f,5), iVar1 < 0)) {
          return iVar1;
        }
        if ((local_80 == 0xc) &&
           (iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_5a,5), iVar1 < 0)) {
          return iVar1;
        }
      }
      iVar1 = 0;
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_00476f5c(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  size_t sVar2;
  int iVar3;
  int iVar4;
  long lVar5;
  char *__nptr;
  int *local_res8;
  uint local_a0;
  int local_9c;
  byte local_97;
  uint local_94;
  int local_90;
  char acStack_70 [28];
  char *pcStack_54;
  char acStack_50 [48];
  uint local_20;
  undefined4 uStack_c;
  
  sVar2 = strlen("rssi_cal_rev");
  iVar3 = FUN_00445360(param_1,"nvram_get","rssi_cal_rev",sVar2 + 1,&uStack_c);
  if (iVar3 == 0) {
    local_9c = strtol(PTR_DAT_00551644,&pcStack_54,0);
  }
  if ((iVar3 < 0) || ((iVar3 == 0 && (local_9c == 0)))) {
    local_97 = 6;
  }
  else {
    local_97 = 0xc;
  }
  bVar1 = local_97 + 1;
  memset(acStack_50,0,0x44);
  iVar4 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
  if (iVar4 == 0) {
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
    }
    iVar4 = iVar3;
    if (local_20 == 0xb) {
      local_res8 = (int *)(param_3 + 4);
      if (*local_res8 == 0) {
        iVar3 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_70,0x1c);
        if (iVar3 < 0) {
          return iVar3;
        }
        for (local_a0 = 0; (int)local_a0 < (int)(uint)(byte)(bVar1 * '\x03');
            local_a0 = local_a0 + 1) {
          if (bVar1 == 0) {
            trap(7);
          }
          if ((int)local_a0 % (int)(uint)bVar1 == 0) {
            if (0 < (int)local_a0) {
              putchar(10);
            }
            if (acStack_70[local_a0] == -1) break;
          }
          printf("%d ",(int)acStack_70[local_a0]);
        }
        if ((byte)(bVar1 * '\x03') == local_a0) {
          putchar(10);
        }
      }
      else {
        local_90 = 0;
        for (local_94 = 0; local_res8[local_94] != 0; local_94 = local_94 + 1) {
        }
        for (local_a0 = 0; (int)local_a0 < (int)(local_94 & 0xff); local_a0 = local_a0 + 1) {
          __nptr = (char *)*local_res8;
          local_res8 = local_res8 + 1;
          lVar5 = strtol(__nptr,&pcStack_54,0);
          if ((0x3f < lVar5) || (lVar5 < -0x40)) {
            return -2;
          }
          if (bVar1 == local_94) {
            acStack_70[local_a0] = (char)lVar5;
          }
          else {
            if (local_a0 == 0) {
              acStack_70[local_90] = '\0';
              local_90 = local_90 + 1;
            }
            if (local_97 == local_a0) {
              acStack_70[local_90] = '\x01';
              local_90 = local_90 + 1;
            }
            if ((uint)local_97 << 1 == local_a0) {
              acStack_70[local_90] = '\x02';
              local_90 = local_90 + 1;
            }
            acStack_70[local_90] = (char)lVar5;
            local_90 = local_90 + 1;
          }
        }
        iVar3 = FUN_00445444(param_1,(char *)*param_2,acStack_70,(uint)bVar1);
        if (iVar3 < 0) {
          return iVar3;
        }
        if (((int)((uint)local_97 << 1) <= (int)local_94) &&
           (iVar3 = FUN_00445444(param_1,(char *)*param_2,acStack_70 + bVar1,(uint)bVar1), iVar3 < 0
           )) {
          return iVar3;
        }
        if (((uint)local_97 * 3 == local_94) &&
           (iVar3 = FUN_00445444(param_1,(char *)*param_2,acStack_70 + (uint)bVar1 * 2,(uint)bVar1),
           iVar3 < 0)) {
          return iVar3;
        }
      }
      iVar4 = 0;
    }
  }
  return iVar4;
}



int FUN_00477558(int *param_1,undefined4 *param_2,int param_3)

{
  uint param3;
  int iVar1;
  long lVar2;
  char *__nptr;
  int *local_res8;
  uint local_90;
  byte local_8c;
  uint local_88;
  char acStack_6c [20];
  char *pcStack_58;
  char acStack_54 [48];
  uint local_24;
  uint local_10 [2];
  
  local_8c = 0;
  local_10[0] = 0;
  memset(acStack_54,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_54,0x44);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
    }
    if (local_24 == 0xb) {
      iVar1 = FUN_004ba35c(param_1,"hw_rxchain",local_10);
      param3 = local_10[0];
      if (-1 < iVar1) {
        for (; 0 < (int)local_10[0]; local_10[0] = (int)local_10[0] >> 1) {
          local_8c = ((byte)local_10[0] & 1) + local_8c;
        }
        local_res8 = (int *)(param_3 + 4);
        if (*local_res8 == 0) {
          iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_6c,0x12);
          if (iVar1 < 0) {
            return iVar1;
          }
          for (local_90 = 0; (int)local_90 < (int)(uint)local_8c; local_90 = local_90 + 1) {
            printf("%d ",(int)acStack_6c[local_90]);
          }
          if (local_8c == local_90) {
            putchar(10);
          }
        }
        else {
          for (local_88 = 0; local_res8[local_88] != 0; local_88 = local_88 + 1) {
          }
          if (local_8c != local_88) {
            printf("IOVAR # of input args = %d does not match # input = %d by coremask = %d\n",
                   local_88,(uint)local_8c,param3);
            return iVar1;
          }
          for (local_90 = 0; (int)local_90 < (int)(uint)local_8c; local_90 = local_90 + 1) {
            __nptr = (char *)*local_res8;
            local_res8 = local_res8 + 1;
            lVar2 = strtol(__nptr,&pcStack_58,0);
            if ((0x3f < lVar2) || (lVar2 < -0x40)) {
              return -2;
            }
            acStack_6c[local_90] = (char)lVar2;
          }
          iVar1 = FUN_00445444(param_1,(char *)*param_2,acStack_6c,(uint)local_8c);
          if (iVar1 < 0) {
            return iVar1;
          }
        }
        iVar1 = 0;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_00477914(int *param_1,undefined4 *param_2,int param_3)

{
  uint param3;
  int iVar1;
  long lVar2;
  char *__nptr;
  int *local_res8;
  uint local_98;
  byte local_94;
  uint local_90;
  char acStack_74 [28];
  char *pcStack_58;
  char acStack_54 [48];
  uint local_24;
  uint local_10 [2];
  
  local_94 = 0;
  local_10[0] = 0;
  memset(acStack_54,0,0x44);
  iVar1 = FUN_004b9f94(param_1,0x62,acStack_54,0x44);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
    }
    if (local_24 == 0xb) {
      iVar1 = FUN_004ba35c(param_1,"hw_rxchain",local_10);
      param3 = local_10[0];
      if (-1 < iVar1) {
        for (; 0 < (int)local_10[0]; local_10[0] = (int)local_10[0] >> 1) {
          local_94 = ((byte)local_10[0] & 1) + local_94;
        }
        local_res8 = (int *)(param_3 + 4);
        if (*local_res8 == 0) {
          iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_74,0x1c);
          if (iVar1 < 0) {
            return iVar1;
          }
          for (local_98 = 0; (int)local_98 < (int)(uint)local_94; local_98 = local_98 + 1) {
            printf("%d ",(int)acStack_74[local_98]);
          }
          if (local_94 == local_98) {
            putchar(10);
          }
        }
        else {
          for (local_90 = 0; local_res8[local_90] != 0; local_90 = local_90 + 1) {
          }
          if (local_94 != local_90) {
            printf("IOVAR # of input args = %d does not match # input = %d by coremask = %d\n",
                   local_90,(uint)local_94,param3);
            return iVar1;
          }
          for (local_98 = 0; (int)local_98 < (int)(uint)local_94; local_98 = local_98 + 1) {
            __nptr = (char *)*local_res8;
            local_res8 = local_res8 + 1;
            lVar2 = strtol(__nptr,&pcStack_58,0);
            if ((0x3f < lVar2) || (lVar2 < -0x40)) {
              return -2;
            }
            acStack_74[local_98] = (char)lVar2;
          }
          iVar1 = FUN_00445444(param_1,(char *)*param_2,acStack_74,0x1c);
          if (iVar1 < 0) {
            return iVar1;
          }
        }
        iVar1 = 0;
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_00477cd0(int *param_1,undefined4 *param_2,int param_3)

{
  long lVar1;
  int iVar2;
  long local_20;
  long local_1c;
  long local_18;
  long local_14;
  char *pcStack_10;
  uint *local_c;
  
  local_c = (uint *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = -0x2c;
  }
  else {
    lVar1 = strtol(*(char **)(param_3 + 4),&pcStack_10,0);
    if (*(int *)(param_3 + 8) == 0) {
      iVar2 = -0x2c;
    }
    else {
      local_1c = strtol(*(char **)(param_3 + 8),&pcStack_10,0);
      if (*(int *)(param_3 + 0xc) == 0) {
        iVar2 = -0x2c;
      }
      else {
        local_18 = strtol(*(char **)(param_3 + 0xc),&pcStack_10,0);
        if ((lVar1 < 0) || (local_1c < 0)) {
          iVar2 = -2;
        }
        else if (((local_18 == 8) || (local_18 == 0x10)) || (local_18 == 0x20)) {
          local_20 = lVar1;
          if (*(int *)(param_3 + 0x10) == 0) {
            iVar2 = FUN_00445198(param_1,(char *)*param_2,&local_20,0x10,&local_c);
            if (iVar2 < 0) {
              return iVar2;
            }
            printf("0x%x(%d)\n",*local_c,*local_c);
          }
          else {
            local_14 = strtol(*(char **)(param_3 + 0x10),&pcStack_10,0);
            iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_20,0x10);
            if (iVar2 < 0) {
              return iVar2;
            }
          }
          iVar2 = 0;
        }
        else {
          iVar2 = -2;
        }
      }
    }
  }
  return iVar2;
}



int FUN_00477fa8(int *param_1,undefined4 *param_2,int param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int param1;
  int param2;
  int param3;
  uint local_80;
  int local_78;
  uint local_68 [4];
  undefined4 local_58;
  char *local_54;
  char acStack_50 [48];
  uint local_20;
  
  local_68[0] = 0;
  local_68[1] = 0;
  local_68[2] = 0;
  local_68[3] = 0;
  local_58 = 0;
  for (local_78 = 0; *(int *)(param_3 + local_78 * 4) != 0; local_78 = local_78 + 1) {
  }
  uVar1 = local_78 - 1;
  for (local_80 = 0; local_80 < 4; local_80 = local_80 + 1) {
    if (local_80 < uVar1) {
      uVar2 = strtol(*(char **)(param_3 + (local_80 + 1) * 4),&local_54,0);
      local_68[local_80] = uVar2;
      if (*local_54 != '\0') {
        puts("error");
        return -0x2c;
      }
    }
  }
  if (local_78 == 1) {
    iVar3 = FUN_004ba35c(param_1,(char *)*param_2,local_68);
    if (-1 < iVar3) {
      if (DAT_00557704 != '\0') {
        local_68[0] = local_68[0] << 0x18 | (local_68[0] & 0xff00) << 8 |
                      (local_68[0] & 0xff0000) >> 8 | local_68[0] >> 0x18;
      }
      local_58._0_1_ = (char)local_68[0];
      param1 = (int)(char)local_58;
      local_58._1_1_ = (char)(local_68[0] >> 8);
      param2 = (int)local_58._1_1_;
      local_58._2_1_ = (char)(local_68[0] >> 0x10);
      param3 = (int)local_58._2_1_;
      local_58 = local_68[0];
      printf("txpwrindex for core{0...3}: %d %d %d %d\n",param1,param2,param3,
             (int)(char)(local_68[0] >> 0x18));
    }
  }
  else {
    memset(acStack_50,0,0x44);
    iVar3 = FUN_004b9f94(param_1,0x62,acStack_50,0x44);
    if (-1 < iVar3) {
      if (DAT_00557704 != '\0') {
        local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                   local_20 >> 0x18;
      }
      if (local_20 == 7) {
        if (uVar1 != 3) {
          puts("HTPHY must specify 3 core txpwrindex");
          return -0x2c;
        }
      }
      else if ((local_20 == 4) && (uVar1 != 2)) {
        puts("NPHY must specify 2 core txpwrindex");
        return -0x2c;
      }
      iVar3 = FUN_004ba160(param_1,(char *)*param_2,local_68,0x10,PTR_DAT_00551644,0x2000);
    }
  }
  return iVar3;
}



int FUN_00478368(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  int iVar2;
  ushort *__ptr;
  int local_20;
  ushort *local_18 [3];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,"force_vsdb_chans",(void *)0x0,0,local_18);
    local_20 = -(iVar2 >> 0x1f);
    if (local_20 == 0) {
      printf("Chans : %x %x \n",(uint)*local_18[0],(uint)local_18[0][1]);
    }
    else {
      puts("wl_phy_maxpower: fail to get maxpower");
    }
  }
  else if ((*(int *)(param_3 + 4) == 0) || (*(int *)(param_3 + 8) == 0)) {
    local_20 = -0x2c;
  }
  else {
    __ptr = (ushort *)malloc(4);
    if (__ptr == (ushort *)0x0) {
      puts("unable to allocate Memory ");
      local_20 = -0x1b;
    }
    else {
      uVar1 = FUN_004c0638(*(char **)(param_3 + 4));
      *__ptr = uVar1;
      uVar1 = FUN_004c0638(*(char **)(param_3 + 8));
      __ptr[1] = uVar1;
      if (((*__ptr & 0xff) == 0) || ((__ptr[1] & 0xff) == 0)) {
        *__ptr = 0;
        __ptr[1] = 0;
      }
      local_20 = FUN_004ba160(param_1,(char *)*param_2,__ptr,4,PTR_DAT_00551644,0x2000);
      if (__ptr != (ushort *)0x0) {
        free(__ptr);
      }
    }
  }
  return local_20;
}



int FUN_004785a4(int *param_1,undefined4 *param_2,int param_3)

{
  uint param1;
  int iVar1;
  long lVar2;
  uint local_38;
  int local_30;
  byte local_28 [4];
  byte abStack_24 [16];
  char *local_14 [2];
  
  for (local_30 = 0; *(int *)(param_3 + local_30 * 4) != 0; local_30 = local_30 + 1) {
  }
  param1 = local_30 - 1;
  if ((param1 == 0) || (param1 == 0x14)) {
    if (param1 == 0) {
      iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)local_28,0x14);
      if (-1 < iVar1) {
        printf("\t2G:    %4d %4d %4d %4d\n",(uint)local_28[0],(uint)local_28[1],(uint)local_28[2],
               (uint)local_28[3]);
        for (local_38 = 0; local_38 < 4; local_38 = local_38 + 1) {
          printf("\t5G[%1d]  %4d %4d %4d %4d\n",local_38,(uint)abStack_24[local_38 * 4],
                 (uint)abStack_24[local_38 * 4 + 1],(uint)abStack_24[local_38 * 4 + 2],
                 (uint)abStack_24[local_38 * 4 + 3]);
        }
      }
    }
    else {
      memset(local_28,0x7f,0x14);
      for (local_38 = 0; local_38 < param1; local_38 = local_38 + 1) {
        lVar2 = strtol(*(char **)(param_3 + (local_38 + 1) * 4),local_14,0);
        local_28[local_38] = (byte)lVar2;
        if (*local_14[0] != '\0') {
          puts("error");
          return -0x2c;
        }
      }
      printf("\t2G:    %4d %4d %4d %4d\n",(uint)local_28[0],(uint)local_28[1],(uint)local_28[2],
             (uint)local_28[3]);
      for (local_38 = 0; local_38 < 4; local_38 = local_38 + 1) {
        printf("\t5G[%1d]  %4d %4d %4d %4d\n",local_38,(uint)abStack_24[local_38 * 4],
               (uint)abStack_24[local_38 * 4 + 1],(uint)abStack_24[local_38 * 4 + 2],
               (uint)abStack_24[local_38 * 4 + 3]);
      }
      iVar1 = FUN_004ba2e4(param_1,(char *)*param_2,local_28,0x14);
    }
  }
  else {
    printf("Error: Input %d SAR values, need total %d SAR values\n",param1,0x14);
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00478948(int *param_1,undefined4 *param_2)

{
  int iVar1;
  uint uVar2;
  uint local_28;
  uint *local_c;
  
  iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar1 == 0) {
    printf("PMU Control          : 0x%08x\n",*local_c);
    printf("PMU Capabilities     : 0x%08x\n",local_c[1]);
    printf("PMU Status           : 0x%08x\n",local_c[2]);
    printf("Resource State       : 0x%08x\n",local_c[3]);
    printf("Resurce Pending      : 0x%08x\n",local_c[4]);
    printf("PMU Timer            : 0x%08x\n",local_c[5]);
    printf("Minimum Resource Mask: 0x%08x\n",local_c[6]);
    printf("Maximum Resource Mask: 0x%08x\n",local_c[7]);
    uVar2 = local_c[1];
    for (local_28 = 0; local_28 < uVar2 >> 0x1b; local_28 = local_28 + 1) {
      printf("PMU ChipControl[%d]   : 0x%08x\n",local_28,local_c[local_28 + 8]);
    }
    uVar2 = local_c[1];
    for (local_28 = 0; local_28 < (uVar2 & 0x7c00000) >> 0x16; local_28 = local_28 + 1) {
      printf("PMU RegControl[%d]    : 0x%08x\n",local_28,local_c[local_28 + 0xc]);
    }
    uVar2 = local_c[1];
    for (local_28 = 0; local_28 < (uVar2 & 0x3e0000) >> 0x11; local_28 = local_28 + 1) {
      printf("PMU PllControl[%d]    : 0x%08x\n",local_28,local_c[local_28 + 0x11]);
    }
    uVar2 = local_c[1];
    for (local_28 = 0; local_28 < (uVar2 & 0x1f00) >> 8; local_28 = local_28 + 1) {
      printf("PMU Resource Up/Down Timer[%d]    : 0x%08x\n",local_28,local_c[local_28 + 0x16]);
    }
    uVar2 = local_c[1];
    for (local_28 = 0; local_28 < (uVar2 & 0x1f00) >> 8; local_28 = local_28 + 1) {
      printf("PMU Resource Dependancy Mask[%d]    : 0x%08x\n",local_28,local_c[local_28 + 0x35]);
    }
    iVar1 = 0;
  }
  return iVar1;
}



undefined4 FUN_00478d10(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined3 extraout_var;
  ulong uVar4;
  undefined1 auStack_14 [6];
  undefined1 local_e;
  
  uVar2 = FUN_0040192c(param_3 + 4);
  if (uVar2 < 2) {
    uVar3 = 0xffffffd4;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      uVar3 = 0xffffffd4;
    }
    else {
      uVar4 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      local_e = (undefined1)uVar4;
      uVar3 = FUN_004ba2e4(param_1,(char *)*param_2,auStack_14,7);
    }
  }
  return uVar3;
}



int FUN_00478df8(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  short *psVar2;
  int iVar3;
  int *piVar4;
  size_t sVar5;
  char *pcVar6;
  char *pcVar7;
  ushort *puVar8;
  ushort *local_108;
  char *local_104;
  int local_100;
  int local_f8;
  int local_f4;
  int local_f0;
  int local_ec;
  int local_e8;
  int local_e4;
  ushort auStack_d4 [48];
  char local_74 [4];
  ulong local_70;
  undefined4 auStack_6c [21];
  short *local_18;
  uint local_14;
  uint local_10 [2];
  
  local_108 = (ushort *)&DAT_004e9c38;
  local_74[0] = ' ';
  local_74[1] = '\0';
  local_18 = (short *)0x0;
  local_14 = 0;
  local_10[0] = 0;
  iVar3 = FUN_004ba35c(param_1,"paparambwver",&local_14);
  if (iVar3 != 0) {
    puts("Cannot find any paparam bandwith version");
  }
  local_100 = FUN_004ba35c(param_1,"sromrev",local_10);
  if (local_14 == 1) {
    local_108 = &DAT_004e9f08;
  }
  else if (local_14 == 2) {
    local_108 = (ushort *)&DAT_004e9f5c;
  }
  else {
    if (local_10[0] == 0xc) {
      local_108 = (ushort *)&DAT_004e9e48;
    }
    if ((int)local_10[0] < 0xc) {
      local_108 = (ushort *)&DAT_004e9c38;
    }
  }
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    while (*local_108 != 0xf) {
      auStack_d4[0] = *local_108;
      auStack_d4[1] = local_108[1];
      auStack_d4[2] = local_108[2];
      local_ec = 3;
      sVar5 = strlen(*(char **)(local_108 + 4));
      pcVar6 = (char *)malloc(sVar5 + 1);
      if (pcVar6 == (char *)0x0) {
        return -0x1b;
      }
      strcpy(pcVar6,*(char **)(local_108 + 4));
      local_100 = FUN_0044527c(param_1,(char *)*param_2,auStack_d4,0x60,&local_18);
      psVar2 = local_18;
      if (local_100 < 0) {
        printf("phy %x band %x chain %d err %d\n",(uint)*local_108,(uint)local_108[2],
               (uint)local_108[1],local_100);
        free(pcVar6);
        return local_100;
      }
      if (*local_18 == 0xf) {
        local_108 = local_108 + 6;
        free(pcVar6);
      }
      else {
        local_104 = strtok(pcVar6,local_74);
        if ((*local_108 == 0xb) || (*local_108 == 0xc)) {
          local_e8 = 0;
          if (local_10[0] == 0xc) {
            if ((local_108[1] == 0) || (local_108[1] == 6)) {
              local_e8 = 4;
            }
            else if (((local_108[1] == 0x12) || (local_108[1] == 0x13)) || (local_108[1] == 0x14)) {
              local_e8 = 0x14;
            }
          }
          if ((int)local_10[0] < 0xc) {
            if (local_108[1] == 0) {
              local_e8 = 3;
            }
            else if (local_108[1] == 5) {
              local_e8 = 0xc;
            }
          }
          printf("%s=",local_104);
          for (local_e4 = 0; local_e4 < local_e8; local_e4 = local_e4 + 1) {
            if (local_e4 != 0) {
              putchar(0x2c);
            }
            printf("0x%x",(uint)(ushort)psVar2[local_e4 + 3]);
          }
          putchar(10);
        }
        else {
          do {
            puVar8 = (ushort *)(psVar2 + local_ec);
            local_ec = local_ec + 1;
            printf("%s=0x%x\n",local_104,(uint)*puVar8);
            local_104 = strtok((char *)0x0,local_74);
          } while (local_104 != (char *)0x0);
        }
        local_108 = local_108 + 6;
        free(pcVar6);
      }
    }
  }
  else {
    for (; *local_108 != 0xf; local_108 = local_108 + 6) {
      bVar1 = false;
      auStack_d4[0] = *local_108;
      auStack_d4[1] = local_108[1];
      auStack_d4[2] = local_108[2];
      local_f8 = 3;
      sVar5 = strlen(*(char **)(local_108 + 4));
      pcVar6 = (char *)malloc(sVar5 + 1);
      if (pcVar6 == (char *)0x0) {
        return -0x1b;
      }
      strcpy(pcVar6,*(char **)(local_108 + 4));
      local_104 = strtok(pcVar6,local_74);
      if ((*local_108 == 0xb) || (*local_108 == 0xc)) {
        local_f4 = 0;
        if (local_10[0] == 0xc) {
          if ((local_108[1] == 0) || (local_108[1] == 6)) {
            local_f4 = 4;
          }
          else if (((local_108[1] == 0x12) || (local_108[1] == 0x13)) || (local_108[1] == 0x14)) {
            local_f4 = 0x14;
          }
        }
        if ((int)local_10[0] < 0xc) {
          if (local_108[1] == 0) {
            local_f4 = 3;
          }
          else if (local_108[1] == 5) {
            local_f4 = 0xc;
          }
        }
        pcVar7 = FUN_0040f7f4(piVar4,local_104,(int)auStack_6c,local_f4);
        if (pcVar7 != (char *)0x0) {
          bVar1 = true;
          for (local_f0 = 0; local_f0 < local_f4; local_f0 = local_f0 + 1) {
            auStack_d4[local_f0 + 3] = (ushort)auStack_6c[local_f0];
          }
        }
      }
      else {
        do {
          local_70 = 0;
          pcVar7 = FUN_0040f668(piVar4,local_104,&local_70);
          if (pcVar7 == (char *)0x0) {
            auStack_d4[local_f8] = 0;
          }
          else {
            bVar1 = true;
            auStack_d4[local_f8] = (ushort)local_70;
          }
          local_f8 = local_f8 + 1;
          local_104 = strtok((char *)0x0,local_74);
        } while (local_104 != (char *)0x0);
      }
      free(pcVar6);
      if ((bVar1) &&
         (local_100 = FUN_00445444(param_1,(char *)*param_2,auStack_d4,0x60), local_100 < 0)) {
        puts("wl_phy_pavars: fail to set");
        return local_100;
      }
    }
  }
  return local_100;
}



int FUN_0047970c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  short *psVar2;
  int *piVar3;
  size_t sVar4;
  char *pcVar5;
  char *pcVar6;
  undefined2 uVar7;
  ushort *local_58;
  char *local_54;
  char *local_50;
  int local_4c;
  bool local_48;
  int local_44;
  int local_40;
  ushort local_34;
  ushort local_32;
  undefined2 local_30 [2];
  ulong local_2c;
  char local_18 [4];
  ulong local_14;
  short *local_10 [2];
  
  local_58 = &DAT_004ea0e0;
  local_50 = (char *)0x0;
  local_18[0] = ' ';
  local_18[1] = '\0';
  local_4c = 0;
  local_10[0] = (short *)0x0;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    while (*local_58 != 0xf) {
      local_40 = 0;
      local_34 = *local_58;
      local_32 = local_58[1];
      sVar4 = strlen(*(char **)(local_58 + 2));
      pcVar5 = (char *)malloc(sVar4 + 1);
      if (pcVar5 == (char *)0x0) {
        return -0x1b;
      }
      strcpy(pcVar5,*(char **)(local_58 + 2));
      local_4c = FUN_00445198(param_1,(char *)*param_2,&local_34,8,local_10);
      psVar2 = local_10[0];
      if (local_4c < 0) {
        printf("phy %x band %x err %d\n",(uint)*local_58,(uint)local_58[1],local_4c);
        free(pcVar5);
        return local_4c;
      }
      if (*local_10[0] == 0xf) {
        local_58 = local_58 + 4;
        free(pcVar5);
      }
      else {
        if (local_10[0][1] == 0) {
          printf("cck2gpo=0x%x\n",(uint)(ushort)local_10[0][2]);
          printf("ofdm2gpo=0x%x\n",*(uint *)(psVar2 + 4));
        }
        else if (local_58[1] == 1) {
          printf("ofdm5glpo=0x%x\n",*(uint *)(local_10[0] + 4));
        }
        else if (local_58[1] == 2) {
          printf("ofdm5gpo=0x%x\n",*(uint *)(local_10[0] + 4));
        }
        else if (local_58[1] == 3) {
          printf("ofdm5ghpo=0x%x\n",*(uint *)(local_10[0] + 4));
        }
        local_54 = strtok(pcVar5,local_18);
        do {
          iVar1 = local_40 + 6;
          local_40 = local_40 + 1;
          printf("%s=0x%x\n",local_54,(uint)(ushort)psVar2[iVar1]);
          local_54 = strtok((char *)0x0,local_18);
        } while (local_54 != (char *)0x0);
        local_58 = local_58 + 4;
        free(pcVar5);
      }
    }
  }
  else {
    while (*local_58 != 0xf) {
      local_48 = false;
      local_44 = 0;
      local_34 = *local_58;
      local_32 = local_58[1];
      sVar4 = strlen(*(char **)(local_58 + 2));
      pcVar5 = (char *)malloc(sVar4 + 1);
      if (pcVar5 == (char *)0x0) {
        return -0x1b;
      }
      strcpy(pcVar5,*(char **)(local_58 + 2));
      if (local_58[1] == 0) {
        pcVar6 = FUN_0040f668(piVar3,"cck2gpo",&local_14);
        local_48 = pcVar6 != (char *)0x0;
        if (local_48) {
          local_30[0] = (undefined2)local_14;
        }
        else {
          local_30[0] = 0;
        }
        local_50 = FUN_0040f668(piVar3,"ofdm2gpo",&local_14);
      }
      else if (local_58[1] == 1) {
        local_50 = FUN_0040f668(piVar3,"ofdm5glpo",&local_14);
      }
      else if (local_58[1] == 2) {
        local_50 = FUN_0040f668(piVar3,"ofdm5gpo",&local_14);
      }
      else if (local_58[1] == 3) {
        local_50 = FUN_0040f668(piVar3,"ofdm5ghpo",&local_14);
      }
      if (local_50 == (char *)0x0) {
        local_2c = 0;
      }
      else {
        local_48 = true;
        local_2c = local_14;
      }
      local_54 = strtok(pcVar5,local_18);
      do {
        local_14 = 0;
        local_50 = FUN_0040f668(piVar3,local_54,&local_14);
        if (local_50 == (char *)0x0) {
          uVar7 = 0;
        }
        else {
          local_48 = true;
          uVar7 = (undefined2)local_14;
        }
        local_30[local_44 + 4] = uVar7;
        local_44 = local_44 + 1;
        local_54 = strtok((char *)0x0,local_18);
      } while (local_54 != (char *)0x0);
      if ((local_48) &&
         (local_4c = FUN_00445444(param_1,(char *)*param_2,&local_34,0x1c), local_4c < 0)) {
        puts("wl_phy_povars: fail to set");
        free(pcVar5);
        return local_4c;
      }
      local_58 = local_58 + 4;
      free(pcVar5);
    }
  }
  return local_4c;
}



int FUN_00479d98(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  int local_38;
  bool local_34;
  ulong local_28;
  undefined1 local_24 [2];
  undefined2 local_22;
  undefined2 local_1e;
  undefined2 local_1a;
  undefined2 local_16;
  undefined2 local_12;
  int local_10 [2];
  
  local_10[0] = 0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar5 = FUN_00445198(param_1,(char *)*param_2,local_24,0x14,local_10);
    iVar4 = local_10[0];
    if (iVar5 < 0) {
      puts("wl_phy_rpcalvars: fail to get");
      return iVar5;
    }
    for (local_38 = 0; local_38 < 5; local_38 = local_38 + 1) {
      switch(local_38) {
      case 0:
        printf("rpcal2g=0x%x ",(uint)*(ushort *)(iVar4 + local_38 * 4));
        break;
      case 1:
        printf("rpcal5gb0=0x%x ",(uint)*(ushort *)(iVar4 + local_38 * 4));
        break;
      case 2:
        printf("rpcal5gb1=0x%x ",(uint)*(ushort *)(iVar4 + local_38 * 4));
        break;
      case 3:
        printf("rpcal5gb2=0x%x ",(uint)*(ushort *)(iVar4 + local_38 * 4));
        break;
      case 4:
        printf("rpcal5gb3=0x%x\n",(uint)*(ushort *)(iVar4 + local_38 * 4));
      }
    }
  }
  else {
    memset(local_24,0,0x14);
    pcVar2 = FUN_0040f668(piVar1,"rpcal2g",&local_28);
    if (pcVar2 != (char *)0x0) {
      local_22 = 1;
    }
    pcVar3 = FUN_0040f668(piVar1,"rpcal5gb0",&local_28);
    if (pcVar3 != (char *)0x0) {
      local_1e = 1;
    }
    local_34 = pcVar3 != (char *)0x0 || pcVar2 != (char *)0x0;
    pcVar2 = FUN_0040f668(piVar1,"rpcal5gb1",&local_28);
    if (pcVar2 != (char *)0x0) {
      local_34 = true;
      local_1a = 1;
    }
    pcVar2 = FUN_0040f668(piVar1,"rpcal5gb2",&local_28);
    if (pcVar2 != (char *)0x0) {
      local_34 = true;
      local_16 = 1;
    }
    pcVar2 = FUN_0040f668(piVar1,"rpcal5gb3",&local_28);
    if (pcVar2 != (char *)0x0) {
      local_34 = true;
      local_12 = 1;
    }
    if (!local_34) {
      puts("wl_phy_rpcalvars: fail to found matching rpcalvar name");
      return 0;
    }
    iVar4 = FUN_00445444(param_1,(char *)*param_2,local_24,0x14);
    if (iVar4 < 0) {
      puts("wl_phy_rpcalvars: fail to set");
      return iVar4;
    }
  }
  return 0;
}



int FUN_0047a16c(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  bool local_28;
  int local_24;
  undefined1 local_1c [8];
  byte *local_14;
  ulong local_10 [2];
  
  local_24 = 0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar4 = FUN_00445198(param_1,"fem2g",(void *)0x0,0,&local_14);
    if (iVar4 < 0) {
      puts("wl_phy_fem: fail to get fem2g");
    }
    else {
      printf("tssipos2g=0x%x extpagain2g=0x%x pdetrange2g=0x%x triso2g=0x%x antswctl2g=0x%x\n",
             (uint)*local_14,(uint)local_14[1],(uint)local_14[2],(uint)local_14[3],(uint)local_14[4]
            );
    }
    iVar4 = FUN_00445198(param_1,"fem5g",(void *)0x0,0,&local_14);
    local_24 = -(iVar4 >> 0x1f);
    if (local_24 == 0) {
      printf("tssipos5g=0x%x extpagain5g=0x%x pdetrange5g=0x%x triso5g=0x%x antswctl5g=0x%x\n",
             (uint)*local_14,(uint)local_14[1],(uint)local_14[2],(uint)local_14[3],(uint)local_14[4]
            );
    }
    else {
      puts("wl_phy_fem: fail to get fem5g");
    }
  }
  else {
    memset(local_1c,0,5);
    pcVar2 = FUN_0040f668(piVar1,"tssipos2g",local_10);
    pcVar3 = FUN_0040f668(piVar1,"extpagain2g",local_10);
    local_28 = pcVar3 != (char *)0x0 || pcVar2 != (char *)0x0;
    pcVar2 = FUN_0040f668(piVar1,"pdetrange2g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    pcVar2 = FUN_0040f668(piVar1,"triso2g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    pcVar2 = FUN_0040f668(piVar1,"antswctl2g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    if (local_28) {
      iVar4 = FUN_00445444(param_1,"fem2g",local_1c,5);
      local_24 = -(iVar4 >> 0x1f);
      if (local_24 == 0) {
        puts("fem2g set");
      }
      else {
        puts("wl_phy_fem: fail to set fem2g");
      }
    }
    memset(local_1c,0,5);
    pcVar2 = FUN_0040f668(piVar1,"tssipos5g",local_10);
    pcVar3 = FUN_0040f668(piVar1,"extpagain5g",local_10);
    local_28 = pcVar3 != (char *)0x0 || pcVar2 != (char *)0x0;
    pcVar2 = FUN_0040f668(piVar1,"pdetrange5g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    pcVar2 = FUN_0040f668(piVar1,"triso5g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    pcVar2 = FUN_0040f668(piVar1,"antswctl5g",local_10);
    if (pcVar2 != (char *)0x0) {
      local_28 = true;
    }
    if (local_28) {
      iVar4 = FUN_00445444(param_1,"fem5g",local_1c,5);
      local_24 = -(iVar4 >> 0x1f);
      if (local_24 == 0) {
        puts("fem5g set");
      }
      else {
        puts("wl_phy_fem: fail to set fem5g");
      }
    }
  }
  return local_24;
}



int FUN_0047a66c(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  int iVar3;
  ulong local_18;
  undefined1 local_14 [8];
  byte *local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar3 = FUN_00445198(param_1,"maxpower",(void *)0x0,0,&local_c);
    iVar3 = -(iVar3 >> 0x1f);
    if (iVar3 == 0) {
      printf("maxp2ga0=%x\n",(uint)*local_c);
      printf("maxp2ga1=%x\n",(uint)local_c[1]);
      printf("maxp5ga0=%x\n",(uint)local_c[2]);
      printf("maxp5ga1=%x\n",(uint)local_c[3]);
      printf("maxp5gla0=%x\n",(uint)local_c[4]);
      printf("maxp5gla1=%x\n",(uint)local_c[5]);
      printf("maxp5gha0=%x\n",(uint)local_c[6]);
      printf("maxp5gha1=%x\n",(uint)local_c[7]);
    }
    else {
      puts("wl_phy_maxpower: fail to get maxpower");
    }
  }
  else {
    pcVar2 = FUN_0040f668(piVar1,"maxp2ga0",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp2ga0");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp2ga1",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp2ga1");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5ga0",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5ga0");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5ga1",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5ga1");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5gla0",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5gla0");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5gla1",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5gla1");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5gha0",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5gha0");
    }
    pcVar2 = FUN_0040f668(piVar1,"maxp5gha1",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing maxp5gha1");
    }
    iVar3 = FUN_00445444(param_1,"maxpower",local_14,8);
    iVar3 = -(iVar3 >> 0x1f);
    if (iVar3 != 0) {
      puts("wl_phy_maxpower: fail to set");
    }
  }
  return iVar3;
}



int FUN_0047aab0(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  int iVar3;
  ulong local_18;
  undefined1 local_14 [4];
  byte *local_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar3 = FUN_00445198(param_1,"antgain",(void *)0x0,0,local_10);
    iVar3 = -(iVar3 >> 0x1f);
    if (iVar3 == 0) {
      printf("ag0=%x\n",(uint)*local_10[0]);
      printf("ag1=%x\n",(uint)local_10[0][1]);
    }
    else {
      puts("wl_antgain: fail to get antgain");
    }
  }
  else {
    pcVar2 = FUN_0040f668(piVar1,"ag0",&local_18);
    if (pcVar2 == (char *)0x0) {
      puts("Missing ag0");
      iVar3 = -0x2c;
    }
    else {
      pcVar2 = FUN_0040f668(piVar1,"ag1",&local_18);
      if (pcVar2 == (char *)0x0) {
        puts("Missing ag1");
        iVar3 = -0x2c;
      }
      else {
        iVar3 = FUN_00445444(param_1,"antgain",local_14,2);
        iVar3 = -(iVar3 >> 0x1f);
        if (iVar3 != 0) {
          puts("wl_antgain: fail to set");
        }
      }
    }
  }
  return iVar3;
}



int FUN_0047ac9c(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_14;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtol((char *)*piVar1,local_10,0);
    }
    else {
      uVar3 = strtol((char *)*piVar1,local_10,0);
      local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    if (*local_10[0] == '\0') {
      iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,&local_14,4,PTR_DAT_00551644,0x2000);
      if (iVar2 == 0) {
        if (DAT_00557704 == '\0') {
          local_14 = *(uint *)PTR_DAT_00551644;
        }
        else {
          uVar3 = *(uint *)PTR_DAT_00551644;
          local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        FUN_00402444(local_14);
      }
    }
    else {
      printf("set: error parsing value \"%s\" as an integer\n",(char *)*piVar1);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_0047aea4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  byte local_28;
  int local_18;
  uint local_14;
  char *local_10 [2];
  
  local_18 = 0;
  local_10[0] = (char *)0x0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtol((char *)*piVar2,local_10,0);
    }
    else {
      uVar4 = strtol((char *)*piVar2,local_10,0);
      local_14 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    if (*local_10[0] == '\0') {
      iVar3 = FUN_00445360(param_1,(char *)*param_2,&local_14,4,&local_18);
      iVar1 = local_18;
      if (-1 < iVar3) {
        printf("ESTPWR LUT FOR CORE %d\n",local_14);
        for (local_28 = 0; -1 < (char)local_28; local_28 = local_28 + 1) {
          printf("%d\n",(uint)*(ushort *)(iVar1 + (uint)local_28 * 2));
        }
      }
    }
    else {
      printf("set: error parsing value \"%s\" as an integer\n",(char *)*piVar2);
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



int FUN_0047b090(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  ulong uVar2;
  int iVar3;
  ulong uVar4;
  int *local_res8;
  byte local_21c;
  byte local_21b;
  undefined2 auStack_214 [256];
  int local_14;
  
  local_14 = 0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
    iVar1 = local_14;
    if (-1 < iVar3) {
      for (local_21b = 0; local_21b < 2; local_21b = local_21b + 1) {
        printf("CORE%d\tTSSI\t\tPWR\n",(uint)local_21b);
        for (local_21c = 0; local_21c < *(byte *)(iVar1 + 0x400); local_21c = local_21c + 1) {
          printf("\t%d\t\t%d\n",
                 (uint)*(ushort *)(iVar1 + ((uint)local_21b * 0x80 + (uint)local_21c) * 2),
                 (int)*(short *)(iVar1 + ((uint)local_21b * 0x80 + (uint)local_21c + 0x100) * 2));
        }
      }
    }
  }
  else {
    memset(auStack_214,0,0x200);
    local_21c = 0;
    uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    local_res8 = (int *)(param_3 + 8);
    if (*local_res8 == 0) {
      iVar3 = -0x2c;
    }
    else {
      iVar3 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
      iVar1 = local_14;
      if (-1 < iVar3) {
        memcpy(auStack_214,(void *)(local_14 + 0x200),0x200);
        do {
          if ((char)local_21c < '\0') {
            puts("Entries exceeded max allowed");
            return -0x2c;
          }
          uVar4 = strtoul((char *)*local_res8,(char **)0x0,0);
          auStack_214[(uVar2 & 0xff) * 0x80 + (uint)local_21c] = (short)uVar4;
          local_21c = local_21c + 1;
          local_res8 = local_res8 + 1;
        } while (*local_res8 != 0);
        if (local_21c == *(byte *)(iVar1 + 0x400)) {
          iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_214,0x200);
        }
        else {
          printf("Incorrect Number of Entries. Expected %d, Entered %d\n",
                 (uint)*(byte *)(iVar1 + 0x400),(uint)local_21c);
          iVar3 = -0x2c;
        }
      }
    }
  }
  return iVar3;
}



undefined4 FUN_0047b3ec(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  undefined4 uVar2;
  undefined3 extraout_var;
  ulong uVar3;
  ulong uVar4;
  undefined4 local_34;
  ulong local_30;
  uint local_2c;
  uint local_28;
  undefined1 auStack_23 [15];
  undefined1 local_14;
  char local_13;
  undefined1 local_12;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  memset(&local_34,0,0x24);
  if (*(int *)(param_3 + 4) == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_23);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      uVar2 = 0xffffffd4;
    }
    else if (*(int *)(param_3 + 8) == 0) {
      uVar2 = 0xffffffd4;
    }
    else {
      local_30 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      if (*(int *)(param_3 + 0xc) == 0) {
        uVar2 = 0xffffffd4;
      }
      else {
        local_28 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        if (*(int *)(param_3 + 0x10) == 0) {
          uVar2 = 0xffffffd4;
        }
        else {
          local_2c = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
          if (local_2c == 0) {
            local_2c = 4;
          }
          if (DAT_00557704 == '\0') {
            local_34 = 0x101;
          }
          else {
            local_34 = 0x1010000;
            local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                       local_30 >> 0x18;
            local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                       local_2c >> 0x18;
            local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                       local_28 >> 0x18;
          }
          if (*(int *)(param_3 + 0x14) == 0) {
            uVar2 = 0xffffffd4;
          }
          else {
            uVar3 = strtoul(*(char **)(param_3 + 0x14),local_10,10);
            if (*local_10[0] == ':') {
              local_10[0] = local_10[0] + 1;
              uVar4 = strtoul(local_10[0],local_10,10);
              local_13 = (char)uVar4;
              if (*local_10[0] == ':') {
                local_10[0] = local_10[0] + 1;
                if (local_13 == '\0') {
                  uVar2 = 0xffffffd4;
                }
                else {
                  uVar4 = strtoul(local_10[0],local_10,10);
                  local_12 = (undefined1)uVar4;
                  if (((*local_10[0] == '\0') || (*local_10[0] == '\n')) || (*local_10[0] == ' ')) {
                    local_14 = (char)uVar3;
                    uVar2 = FUN_00445444(param_1,(char *)*param_2,&local_34,0x24);
                  }
                  else {
                    uVar2 = 0xffffffd4;
                  }
                }
              }
              else {
                uVar2 = 0xffffffd4;
              }
            }
            else {
              uVar2 = 0xffffffd4;
            }
          }
        }
      }
    }
  }
  return uVar2;
}



int FUN_0047b8b8(int *param_1,undefined4 *param_2,int param_3)

{
  void *pvVar1;
  int iVar2;
  uint uVar3;
  long lVar4;
  ulong uVar5;
  int *local_res8;
  byte local_7c;
  byte local_7b;
  undefined1 local_74;
  undefined1 local_73;
  undefined2 auStack_6e [3];
  byte abStack_68 [82];
  undefined1 local_16;
  void *local_14;
  
  local_14 = (void *)0x0;
  iVar2 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
  pvVar1 = local_14;
  if (-1 < iVar2) {
    if (*(int *)(param_3 + 4) == 0) {
      for (local_7b = 0; local_7b < 2; local_7b = local_7b + 1) {
        printf("CORE %d\n",(uint)local_7b);
        printf("\tChannel = %d\n",(uint)*(byte *)((int)pvVar1 + 1));
        printf("\tStarting Power = %d\n",(int)*(short *)((int)pvVar1 + (uint)local_7b * 2 + 6));
        printf("\tNum of Entries = %d\n",(uint)*(byte *)((int)pvVar1 + local_7b + 0xc));
        puts("\tTSSI values:");
        for (local_7c = 0; local_7c < *(byte *)((int)pvVar1 + local_7b + 0xc);
            local_7c = local_7c + 1) {
          printf("\t%d\n",(uint)*(byte *)((int)pvVar1 + (uint)local_7c + (uint)local_7b * 0x28 + 0xe
                                         ));
        }
      }
    }
    else {
      memcpy(&local_74,local_14,0x60);
      uVar3 = strtol(*(char **)(param_3 + 4),(char **)0x0,0);
      local_74 = (undefined1)uVar3;
      if (*(int *)(param_3 + 8) == 0) {
        iVar2 = -0x2c;
      }
      else {
        lVar4 = strtol(*(char **)(param_3 + 8),(char **)0x0,0);
        auStack_6e[uVar3 & 0xff] = (short)lVar4;
        if (*(int *)(param_3 + 0xc) == 0) {
          iVar2 = -0x2c;
        }
        else {
          uVar5 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
          abStack_68[uVar3 & 0xff] = (byte)uVar5;
          if (*(int *)(param_3 + 0x10) == 0) {
            iVar2 = -0x2c;
          }
          else {
            uVar5 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
            local_73 = (undefined1)uVar5;
            local_res8 = (int *)(param_3 + 0x14);
            if (*local_res8 == 0) {
              local_16 = 1;
              FUN_00445444(param_1,(char *)*param_2,&local_74,0x60);
              iVar2 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
              pvVar1 = local_14;
              if (-1 < iVar2) {
                printf("CORE %d\n",uVar3 & 0xff);
                printf("\tChannel = %d\n",(uint)*(byte *)((int)pvVar1 + 1));
                printf("Starting Power = %d\n",(int)*(short *)((int)pvVar1 + (uVar3 & 0xff) * 2 + 6)
                      );
                printf("Num of Entries = %d\n",(uint)*(byte *)((int)pvVar1 + (uVar3 & 0xff) + 0xc));
                puts("TSSI values:");
                for (local_7c = 0; local_7c < *(byte *)((int)pvVar1 + (uVar3 & 0xff) + 0xc);
                    local_7c = local_7c + 1) {
                  printf("%d\n",(uint)*(byte *)((int)pvVar1 +
                                               (uint)local_7c + (uVar3 & 0xff) * 0x28 + 0xe));
                }
              }
            }
            else {
              memset(abStack_68 + (uVar3 & 0xff) * 0x28 + 2,0,0x80);
              local_7c = 0;
              do {
                if ((char)local_7c < '\0') {
                  puts("Entries exceeded max allowed");
                  return -1;
                }
                uVar5 = strtoul((char *)*local_res8,(char **)0x0,0);
                abStack_68[(uint)local_7c + (uVar3 & 0xff) * 0x28 + 2] = (byte)uVar5;
                local_7c = local_7c + 1;
                local_res8 = local_res8 + 1;
              } while (*local_res8 != 0);
              if (local_7c == abStack_68[uVar3 & 0xff]) {
                local_16 = 0;
                iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_74,0x60);
              }
              else {
                printf("Incorrect Number of Entries. Expected %d, Entered %d\n",
                       (uint)abStack_68[uVar3 & 0xff],(uint)local_7c);
                iVar2 = -1;
              }
            }
          }
        }
      }
    }
  }
  return iVar2;
}



int FUN_0047bef4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int iVar2;
  long lVar3;
  ulong uVar4;
  int *local_res8;
  byte local_48;
  byte local_47;
  byte local_46;
  byte local_45;
  byte local_3c [8];
  undefined1 auStack_34 [16];
  undefined1 auStack_24 [16];
  int local_14 [2];
  
  local_48 = 0;
  local_14[0] = 0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar2 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,local_14);
    iVar1 = local_14[0];
    if (-1 < iVar2) {
      for (local_47 = 0; local_47 < 8; local_47 = local_47 + 1) {
        if (*(char *)(iVar1 + (uint)local_47) != '\0') {
          printf("Num Antennas on Core %d = %d\n",(uint)local_47,
                 (uint)*(byte *)(iVar1 + (uint)local_47));
          local_48 = *(char *)(iVar1 + (uint)local_47) + local_48;
        }
      }
      puts("Pwr Caps with Cell On:");
      for (local_47 = 0; local_47 < local_48; local_47 = local_47 + 1) {
        printf("\t%d",(int)*(char *)(iVar1 + (uint)local_47 + 8));
      }
      putchar(10);
      puts("Pwr Caps with Cell Off:");
      for (local_47 = 0; local_47 < local_48; local_47 = local_47 + 1) {
        printf("\t%d",(int)*(char *)(iVar1 + (uint)local_47 + 0x18));
      }
      putchar(10);
    }
  }
  else {
    lVar3 = strtol((char *)*local_res8,(char **)0x0,0);
    local_48 = (byte)lVar3;
    local_3c[0] = local_48;
    for (local_47 = 1; local_47 < 8; local_47 = local_47 + 1) {
      local_res8 = local_res8 + 1;
      if (*local_res8 == 0) {
        return -0x2c;
      }
      lVar3 = strtol((char *)*local_res8,(char **)0x0,0);
      local_3c[local_47] = (byte)lVar3;
      local_48 = local_3c[local_47] + local_48;
    }
    local_res8 = local_res8 + 1;
    if (*local_res8 == 0) {
      iVar2 = -0x2c;
    }
    else {
      memset(auStack_34,0x7f,0x10);
      memset(auStack_24,0x7f,0x10);
      local_47 = 0;
      local_46 = 0;
      local_45 = 0;
      do {
        if ((uint)local_48 << 1 <= (uint)local_45) {
          puts("Entries exceeded max allowed");
          return -1;
        }
        if (local_45 < local_48) {
          uVar4 = strtoul((char *)*local_res8,(char **)0x0,0);
          auStack_34[local_47] = (char)uVar4;
          local_47 = local_47 + 1;
        }
        else {
          uVar4 = strtoul((char *)*local_res8,(char **)0x0,0);
          auStack_24[local_46] = (char)uVar4;
          local_46 = local_46 + 1;
        }
        local_45 = local_45 + 1;
        local_res8 = local_res8 + 1;
      } while (*local_res8 != 0);
      if (((uint)local_45 == (uint)local_48 << 1) || (local_45 == local_48)) {
        iVar2 = FUN_00445444(param_1,(char *)*param_2,local_3c,0x28);
        if (iVar2 < 0) {
          puts("Unable to set the txpwrcaps.");
          puts("Check number of antennas for this board.");
          iVar2 = -1;
        }
      }
      else {
        printf("Incorrect Number of Entries. Expected %d/%d, Entered %d\n",(uint)local_48,
               (uint)local_48 << 1,(uint)local_45);
        iVar2 = -1;
      }
    }
  }
  return iVar2;
}



undefined4 FUN_0047c3fc(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined4 uVar4;
  int *local_res8;
  uint local_28;
  ulong local_24;
  ulong local_20;
  ulong local_1c;
  undefined1 auStack_17 [6];
  undefined1 auStack_11 [9];
  
  memset(&local_28,0,0x20);
  iVar2 = strcmp((char *)*param_2,"pkteng_stop");
  if (iVar2 == 0) {
    piVar3 = (int *)(param_3 + 4);
    if (*piVar3 == 0) {
      return 0xffffffd4;
    }
    iVar2 = strcmp((char *)*piVar3,"tx");
    if (iVar2 == 0) {
      local_28 = 2;
    }
    else {
      iVar2 = strcmp((char *)*piVar3,"rx");
      if (iVar2 != 0) {
        return 0xffffffd4;
      }
      local_28 = 8;
    }
  }
  else {
    iVar2 = strcmp((char *)*param_2,"pkteng_start");
    if (iVar2 != 0) {
      printf("Invalid command name %s\n",(char *)*param_2);
      return 0;
    }
    if (*(int *)(param_3 + 4) == 0) {
      return 0xffffffd4;
    }
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_17);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      return 0xffffffd4;
    }
    piVar3 = (int *)(param_3 + 8);
    if (*piVar3 == 0) {
      return 0xffffffd4;
    }
    iVar2 = strcmp((char *)*piVar3,"tx");
    if ((iVar2 == 0) || (iVar2 = strcmp((char *)*piVar3,"txwithack"), iVar2 == 0)) {
      iVar2 = strcmp((char *)*piVar3,"tx");
      if (iVar2 == 0) {
        local_28 = 1;
      }
      else {
        local_28 = 6;
      }
      local_res8 = (int *)(param_3 + 0xc);
      if (*local_res8 == 0) {
        return 0xffffffd4;
      }
      iVar2 = strcmp((char *)*local_res8,"async");
      if (iVar2 == 0) {
        local_28 = local_28 & 0xfffffeff;
      }
      else {
        iVar2 = strcmp((char *)*local_res8,"sync");
        if (iVar2 == 0) {
          local_28 = local_28 | 0x100;
        }
        else {
          local_res8 = (int *)(param_3 + 8);
        }
      }
      if (local_res8[1] == 0) {
        return 0xffffffd4;
      }
      local_24 = strtoul((char *)local_res8[1],(char **)0x0,0);
      if (local_res8[2] == 0) {
        return 0xffffffd4;
      }
      local_1c = strtoul((char *)local_res8[2],(char **)0x0,0);
      if (local_res8[3] == 0) {
        return 0xffffffd4;
      }
      local_20 = strtoul((char *)local_res8[3],(char **)0x0,0);
      if ((local_res8[4] != 0) &&
         (bVar1 = FUN_0041d6ac((char *)local_res8[4],auStack_11),
         CONCAT31(extraout_var_00,bVar1) == 0)) {
        return 0xffffffd4;
      }
    }
    else {
      iVar2 = strcmp((char *)*piVar3,"rx");
      if ((iVar2 != 0) && (iVar2 = strcmp((char *)*piVar3,"rxwithack"), iVar2 != 0)) {
        return 0xffffffd4;
      }
      iVar2 = strcmp((char *)*piVar3,"rx");
      if (iVar2 == 0) {
        local_28 = 4;
      }
      else {
        local_28 = 5;
      }
      piVar3 = (int *)(param_3 + 0xc);
      if (*piVar3 != 0) {
        iVar2 = strcmp((char *)*piVar3,"async");
        if (iVar2 == 0) {
          local_28 = local_28 & 0xfffffeff;
        }
        else {
          iVar2 = strcmp((char *)*piVar3,"sync");
          if (iVar2 == 0) {
            local_28 = local_28 | 0x100;
            if (*(int *)(param_3 + 0x10) == 0) {
              return 0xffffffd4;
            }
            local_20 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
            if (*(int *)(param_3 + 0x14) == 0) {
              return 0xffffffd4;
            }
            local_24 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
          }
        }
      }
    }
  }
  if (DAT_00557704 != '\0') {
    local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
               local_28 >> 0x18;
    local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
               local_24 >> 0x18;
    local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
               local_20 >> 0x18;
    local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
               local_1c >> 0x18;
  }
  uVar4 = FUN_00445444(param_1,"pkteng",&local_28,0x20);
  return uVar4;
}



int FUN_0047cb90(int *param_1,undefined4 *param_2,int *param_3)

{
  byte bVar1;
  char cVar2;
  short sVar4;
  ushort uVar5;
  int iVar6;
  int *local_res8;
  int local_cc;
  byte local_c8;
  byte local_c7;
  undefined4 auStack_b0 [3];
  int local_a4;
  char local_9f;
  char local_9e;
  char *local_1c;
  uint local_14;
  char *local_10 [2];
  char cVar3;
  
  local_c8 = 0;
  for (local_cc = 0; param_3[local_cc] != 0; local_cc = local_cc + 1) {
  }
  local_10[0] = 
  "\tSet the cosolidated TSSI/PWR table: wl txcal_pwr_tssi_tbl <core> <Ps> <N> <Ch> <Tssi_Ps Tssi_Ps+1 .. Tssi_Ps+N-1>\n\t\tPs: Starting Power in 6.3 format\n\t\tN: Number of entries in the table covering the power range (Ps : (Ps+N-1))\n\t\tCh: Channel Number\n\t\tTssi_X: Adjusted TSSI corresponding to Power X\n"
  ;
  if (local_cc != 0) {
    FUN_004cbd80(auStack_b0,"wl_rxiqest",0,0);
    local_res8 = param_3;
    while (iVar6 = FUN_004cbe18(auStack_b0,local_res8), iVar6 != -1) {
      if (iVar6 == 1) {
        return -0x2c;
      }
      local_res8 = local_res8 + local_a4;
      bVar1 = (byte)local_14;
      if (local_9e == 'g') {
        if (local_9f == '\0') {
          fprintf(stderr,
                  "%s: could not parse \"%s\" as an int for gain-correction (0, 1, 2, 3, 4, 7, 8)\n"
                  ,"wl_rxiqest",local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (8 < (int)local_14)) {
          fprintf(stderr,"%s: invalid gain-correction select %d (0,1,2,3,4,7,8)\n","wl_rxiqest",
                  local_14);
          return -2;
        }
        local_10[0] = (char *)((uint)(bVar1 & 0xf) << 0x18 | (uint)local_10[0] & 0xf0ffffff);
      }
      if (local_9e == 'f') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for lpf-hpc override select (0, 1)\n"
                  ,"wl_rxiqest",local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (1 < (int)local_14)) {
          fprintf(stderr,"%s: invalid lpf-hpc override select %d (0,1)\n","wl_rxiqest",local_14);
          return -2;
        }
        local_10[0] = (char *)((uint)(bVar1 & 0xf) << 0x14 | (uint)local_10[0] & 0xff0fffff);
      }
      if (local_9e == 'w') {
        if (local_9f == '\0') {
          fprintf(stderr,
                  "%s: could not parse \"%s\" as an int for dig-lpf override select (0, 1 or 2)\n",
                  "wl_rxiqest",local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (2 < (int)local_14)) {
          fprintf(stderr,"%s: invalid dig-lpf override select %d (0,1,2)\n","wl_rxiqest",local_14);
          return -2;
        }
        local_10[0] = (char *)((uint)(bVar1 & 3) << 0x16 | (uint)local_10[0] & 0xff3fffff);
      }
      if (local_9e == 'r') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for resolution (0, 1)\n","wl_rxiqest"
                  ,local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (1 < (int)local_14)) {
          fprintf(stderr,"%s: invalid resolution select %d (0,1)\n","wl_rxiqest",local_14);
          return -2;
        }
        local_c8 = bVar1 & 0xf;
        local_10[0] = (char *)((uint)local_c8 << 0x10 | (uint)local_10[0] & 0xfff0ffff);
      }
      if (local_9e == 's') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for the sample count\n","wl_rxiqest",
                  local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (0x10 < (int)local_14)) {
          fprintf(stderr,"%s: sample count too large %d(10 <= x <= 16)\n","wl_rxiqest",local_14);
          return -2;
        }
        local_10[0] = (char *)((local_14 & 0xff) << 8 | (uint)local_10[0] & 0xffff00ff);
      }
      if (local_9e == 'a') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for antenna (0, 1, 3)\n","wl_rxiqest"
                  ,local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (3 < (int)local_14)) {
          fprintf(stderr,"%s: invalid antenna select %d\n","wl_rxiqest",local_14);
          return -2;
        }
        local_10[0] = (char *)((uint)local_10[0] & 0xffffff00 | local_14 & 0xff);
      }
      if (local_9e == 'e') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for extra INITgain\n","wl_rxiqest",
                  local_1c);
          return -2;
        }
        if ((((int)local_14 < 0) || (0x18 < (int)local_14)) || ((int)local_14 % 3 != 0)) {
          fprintf(stderr,"%s: Valid extra INITgain = {0, 3, .., 21, 24}\n","wl_rxiqest");
          return -2;
        }
        local_10[0] = (char *)(((int)local_14 / 3) * 0x10000000 | (uint)local_10[0] & 0xfffffff);
      }
      if (local_9e == 'i') {
        if (local_9f == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for init or clipLO mode\n",
                  "wl_rxiqest",local_1c);
          return -2;
        }
        if (((int)local_14 < 0) || (9 < (int)local_14)) {
          fprintf(stderr,"%s: Valid options - 0(default gain), 1(init gain)or 4(clip LO gain). \n",
                  "wl_rxiqest");
          return -2;
        }
        local_10[0] = (char *)((uint)local_10[0] & 0xffffff0f | (local_14 & 0xf) << 4);
      }
    }
  }
  iVar6 = FUN_004ba428(param_1,(char *)*param_2,(uint)local_10[0]);
  if ((-1 < iVar6) && (iVar6 = FUN_004ba35c(param_1,(char *)*param_2,(uint *)local_10), -1 < iVar6))
  {
    if (local_c8 == 1) {
      if ((uint)local_10[0] >> 0x14 == 0) {
        if ((uint)local_10[0] >> 10 == 0) {
          sVar4 = (short)((int)(short)((ushort)local_10[0] & 0x3ff) << 6);
          uVar5 = sVar4 >> 6;
          if ((short)uVar5 < 0) {
            printf("-%d.%ddBm ",(int)((short)-uVar5 >> 2),((ushort)-uVar5 & 3) * 0x19);
          }
          else {
            printf("%d.%ddBm ",(int)(sVar4 >> 8),(uVar5 & 3) * 0x19);
          }
          putchar(10);
        }
        else {
          for (local_c7 = 0; local_c7 < 2; local_c7 = local_c7 + 1) {
            sVar4 = (short)((int)(short)((ushort)((uint)local_10[0] >> ((uint)local_c7 * 10 & 0x1f))
                                        & 0x3ff) << 6);
            uVar5 = sVar4 >> 6;
            if ((short)uVar5 < 0) {
              printf("-%d.%ddBm ",(int)((short)-uVar5 >> 2),((ushort)-uVar5 & 3) * 0x19);
            }
            else {
              printf("%d.%ddBm ",(int)(sVar4 >> 8),(uVar5 & 3) * 0x19);
            }
          }
          putchar(10);
        }
      }
      else {
        for (local_c7 = 0; local_c7 < 3; local_c7 = local_c7 + 1) {
          sVar4 = (short)((int)(short)((ushort)((uint)local_10[0] >> ((uint)local_c7 * 10 & 0x1f)) &
                                      0x3ff) << 6);
          uVar5 = sVar4 >> 6;
          if ((short)uVar5 < 0) {
            printf("-%d.%ddBm ",(int)((short)-uVar5 >> 2),((ushort)-uVar5 & 3) * 0x19);
          }
          else {
            printf("%d.%ddBm ",(int)(sVar4 >> 8),(uVar5 & 3) * 0x19);
          }
        }
        putchar(10);
      }
    }
    else {
      cVar2 = (char)local_10[0];
      cVar3 = (char)((uint)local_10[0] >> 8);
      if ((uint)local_10[0] >> 0x10 == 0) {
        if ((uint)local_10[0] >> 8 == 0) {
          printf("%ddBm\n",(int)cVar2);
        }
        else {
          printf("%ddBm %ddBm\n",(int)cVar2,(int)cVar3);
        }
      }
      else {
        printf("%ddBm %ddBm %ddBm\n",(int)cVar2,(int)cVar3,(int)(char)((uint)local_10[0] >> 0x10));
      }
    }
  }
  return iVar6;
}



int FUN_0047d848(int *param_1)

{
  int iVar1;
  uint local_c;
  
  local_c = 0;
  iVar1 = FUN_004ba35c(param_1,"wowl_status",&local_c);
  if (iVar1 == 0) {
    puts("Status of last wakeup:");
    printf("\tflags:0x%x\n",local_c);
    if ((local_c & 0x10) != 0) {
      puts("\t\tWake-on-Loss-of-Beacons enabled");
    }
    if ((local_c & 1) != 0) {
      puts("\t\tWake-on-Magic frame enabled");
    }
    if ((local_c & 2) != 0) {
      puts("\t\tWake-on-Net pattern enabled");
    }
    if ((local_c & 4) != 0) {
      puts("\t\tWake-on-Deauth enabled");
    }
    if ((local_c & 8) != 0) {
      puts("\t\tRetrograde TSF enabled");
    }
    if ((local_c & 0x20) != 0) {
      puts("\t\tTest-mode enabled");
    }
    putchar(10);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_0047d9bc(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  size_t sVar3;
  void *pvVar4;
  int local_1c;
  uint local_18;
  
  local_1c = 0;
  local_18 = 0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba1f8(param_1,"wowl_wakeind",(char *)&local_1c,8);
    if (-1 < iVar2) {
      if (local_1c != 0) {
        puts("PCI Indication set");
      }
      if (local_18 != 0) {
        puts("MAC Indication set");
        if ((local_18 & 1) != 0) {
          puts("\tMAGIC packet received");
        }
        if ((local_18 & 2) != 0) {
          puts("\tPacket received with Netpattern");
        }
        if ((local_18 & 4) != 0) {
          puts("\tDisassociation/Deauth received");
        }
        if ((local_18 & 8) != 0) {
          puts("\tRetrograde TSF detected");
        }
        if ((local_18 & 0x10) != 0) {
          puts("\tBeacons Lost");
        }
        if ((local_18 & 0x20) != 0) {
          puts("\tTest Mode");
        }
        if ((local_18 & 0x40) != 0) {
          puts("\tPTK Refresh received.");
        }
        if ((local_18 & 0x80) != 0) {
          puts("\tEAP-Identity request received");
        }
        if ((local_18 & 0x400) != 0) {
          puts("\tWake on GTK failure.");
        }
        if ((local_18 & 0x800) != 0) {
          puts("\tExtended Magic Packet received.");
        }
        if ((local_18 & 0x4000) != 0) {
          puts("\tKey Rotation Packet received.");
        }
        if ((local_18 & 0x10000) != 0) {
          puts("\tWake on Scan offload.");
        }
        if ((local_18 & 0x40000) != 0) {
          puts("\tWake on MDNS Conflict.");
        }
        if ((local_18 & 0x80000) != 0) {
          puts("\tWake on MDNS Service.");
        }
        if ((local_18 & 0x100000) != 0) {
          puts("\tWake on TCP Keepalive Data.");
        }
        if ((local_18 & 0x20000) != 0) {
          puts("\tWake on TCP Keepalive Timeout.");
        }
        if ((local_18 & 0x200000) != 0) {
          puts("\tWake on Firmware died in wowl mode.");
        }
        if ((local_18 & 0x800000) != 0) {
          puts("\tWake for MIC countermeasures.");
        }
        if ((local_18 & 0x803) != 0) {
          if ((local_18 & 0x8000) == 0) {
            puts("\t\tUnicast frame received");
          }
          else {
            puts("\t\tBroadcast/Mcast frame received");
          }
        }
      }
      if ((local_1c == 0) && (local_18 == 0)) {
        puts("No wakeup indication set");
      }
      iVar2 = 0;
    }
  }
  else {
    iVar2 = strcmp((char *)*piVar1,"clear");
    if (iVar2 == 0) {
      pvVar4 = (void *)*piVar1;
      sVar3 = strlen((char *)*piVar1);
      iVar2 = FUN_004ba2e4(param_1,"wowl_wakeind",pvVar4,sVar3);
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_0047ddd8(int *param_1,undefined4 param_2,int param_3)

{
  int local_18;
  int local_14;
  byte local_10;
  
  local_18 = -1;
  if ((*(int *)(param_3 + 4) == 0) &&
     (local_18 = FUN_004ba1f8(param_1,"wakeup_reason",(char *)&local_14,8), local_18 == 0)) {
    if ((local_10 == 0) || (4 < local_10)) {
      puts("Unknown wakeup Reason");
    }
    else {
      printf("ID: %d\t",local_14);
      if (local_10 == 1) {
        puts("Reason: LCD_ON");
      }
      else if (local_10 == 2) {
        puts("Reason: LCD_OFF");
      }
      else if (local_10 == 3) {
        puts("Reason: DRC1_WAKE");
      }
      else if (local_10 == 4) {
        puts("Reason: DRC2_WAKE");
      }
    }
  }
  return local_18;
}



undefined4 FUN_0047df60(int *param_1,undefined4 param_2,int param_3)

{
  undefined *__dest;
  bool bVar1;
  ushort uVar2;
  int *piVar3;
  undefined4 uVar4;
  size_t sVar5;
  ushort *puVar6;
  ulong uVar7;
  ushort *puVar8;
  int iVar9;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  uint uVar10;
  char *__src;
  int *local_res8;
  size_t local_60;
  ushort local_5c;
  int local_58;
  undefined1 auStack_2c [32];
  
  __dest = PTR_DAT_00551644;
  local_58 = 0;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    uVar4 = 0xffffffd4;
  }
  else {
    sVar5 = strlen("wowl_pkt");
    strncpy(__dest,"wowl_pkt",sVar5);
    sVar5 = strlen("wowl_pkt");
    __dest[sVar5] = 0;
    sVar5 = strlen("wowl_pkt");
    puVar6 = (ushort *)(__dest + sVar5 + 1);
    local_60 = strlen("wowl_pkt");
    if (DAT_00557704 == '\0') {
      uVar7 = strtoul((char *)*piVar3,(char **)0x0,0);
      uVar2 = (ushort)uVar7;
    }
    else {
      uVar7 = strtoul((char *)*piVar3,(char **)0x0,0);
      uVar2 = (ushort)(uVar7 >> 8) & 0xff00 | (ushort)(byte)(uVar7 >> 0x18);
    }
    *puVar6 = uVar2;
    puVar8 = puVar6 + 1;
    local_res8 = (int *)(param_3 + 8);
    if (*local_res8 == 0) {
      puts("Dest of the packet needs to be provided");
      uVar4 = 0xffffffd4;
    }
    else {
      iVar9 = strcmp((char *)*local_res8,"bcast");
      if (iVar9 == 0) {
        local_58 = 1;
        bVar1 = FUN_0041d6ac("ff:ff:ff:ff:ff:ff",puVar8);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          return 0xffffffd4;
        }
      }
      else {
        iVar9 = strcmp((char *)*local_res8,"ucast");
        if (iVar9 == 0) {
          local_58 = 2;
          local_res8 = (int *)(param_3 + 0xc);
          if (*local_res8 == 0) {
            puts("EA of ucast dest of the packet needs to be provided");
            return 0xffffffd4;
          }
          bVar1 = FUN_0041d6ac((char *)*local_res8,puVar8);
          if (CONCAT31(extraout_var_00,bVar1) == 0) {
            return 0xffffffd4;
          }
          memcpy(auStack_2c,puVar8,6);
        }
        else {
          bVar1 = FUN_0041d6ac((char *)*local_res8,puVar8);
          if (CONCAT31(extraout_var_01,bVar1) == 0) {
            return 0xffffffd4;
          }
        }
      }
      piVar3 = local_res8 + 1;
      if (*piVar3 == 0) {
        puts("type - magic/net needs to be provided");
        uVar4 = 0xffffffd4;
      }
      else {
        iVar9 = strncmp((char *)*piVar3,"magic",5);
        if (iVar9 == 0) {
          local_5c = 1;
        }
        else {
          iVar9 = strncmp((char *)*piVar3,"net",3);
          if (iVar9 == 0) {
            local_5c = 2;
          }
          else {
            iVar9 = strncmp((char *)*piVar3,"eapid",5);
            if (iVar9 != 0) {
              return 0xffffffd4;
            }
            local_5c = 0x80;
          }
        }
        puVar6[4] = local_5c;
        puVar8 = puVar6 + 5;
        if (local_5c == 1) {
          if (uVar2 < 0x66) {
            return 0xfffffffe;
          }
          if (local_58 == 2) {
            memcpy(puVar8,auStack_2c,6);
          }
          else {
            if (local_res8[2] == 0) {
              return 0xffffffd4;
            }
            bVar1 = FUN_0041d6ac((char *)local_res8[2],puVar8);
            if (CONCAT31(extraout_var_02,bVar1) == 0) {
              return 0xffffffd4;
            }
          }
          local_60 = local_60 + 0x11;
        }
        else if (local_5c == 2) {
          piVar3 = local_res8 + 2;
          if (*piVar3 == 0) {
            puts("Starting offset not provided");
            return 0xffffffd4;
          }
          if (DAT_00557704 == '\0') {
            uVar10 = strtoul((char *)*piVar3,(char **)0x0,0);
          }
          else {
            uVar7 = strtoul((char *)*piVar3,(char **)0x0,0);
            uVar10 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18
            ;
          }
          *(uint *)(puVar6 + 7) = uVar10;
          puVar8[0] = 0;
          puVar8[1] = 0;
          if (DAT_00557704 == '\0') {
            uVar4 = 0x1c;
          }
          else {
            uVar4 = 0x1c000000;
          }
          *(undefined4 *)(puVar6 + 9) = uVar4;
          puVar8 = puVar6 + 0x13;
          piVar3 = local_res8 + 3;
          if (*piVar3 == 0) {
            puts("pattern not provided");
            return 0xffffffd4;
          }
          if (DAT_00557704 == '\0') {
            uVar10 = FUN_0043dc20((char *)*piVar3,(int)puVar8);
          }
          else {
            uVar10 = FUN_0043dc20((char *)*piVar3,(int)puVar8);
            uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                     uVar10 >> 0x18;
          }
          *(uint *)(puVar6 + 0xb) = uVar10;
          local_60 = *(int *)(puVar6 + 0xb) + local_60 + 0xb + 0x1c;
          puVar6[0xf] = 0;
          puVar6[0x10] = 0;
          local_res8 = local_res8 + 4;
          if (*local_res8 != 0) {
            if (DAT_00557704 == '\0') {
              uVar10 = FUN_0043dc20((char *)*local_res8,(int)puVar8 + *(int *)(puVar6 + 0xb));
            }
            else {
              uVar10 = FUN_0043dc20((char *)*local_res8,(int)((int)puVar8 + *(int *)(puVar6 + 0xb)))
              ;
              uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                       uVar10 >> 0x18;
            }
            *(uint *)(puVar6 + 0xf) = uVar10;
            local_60 = local_60 + *(int *)(puVar6 + 0xf);
          }
        }
        else {
          local_res8 = local_res8 + 2;
          if (*local_res8 == 0) {
            puts("EAPOL identity string not provided");
            return 0xffffffd4;
          }
          sVar5 = strlen((char *)*local_res8);
          *(char *)puVar8 = (char)sVar5;
          __src = (char *)*local_res8;
          sVar5 = strlen((char *)*local_res8);
          strncpy((char *)((int)puVar6 + 0xb),__src,sVar5);
          sVar5 = strlen((char *)*local_res8);
          local_60 = sVar5 + local_60 + 0xb + 1;
        }
        uVar4 = FUN_004ba050(param_1,0x107,__dest,local_60);
      }
    }
  }
  return uVar4;
}



int FUN_0047e858(int *param_1,undefined4 param_2,int param_3)

{
  undefined *puVar1;
  int *piVar2;
  int iVar3;
  size_t sVar4;
  size_t sVar5;
  char *pcVar6;
  size_t sVar7;
  uint *puVar8;
  uint *puVar9;
  ulong uVar10;
  uint uVar11;
  uint local_48;
  uint local_44;
  uint *local_40;
  size_t local_3c;
  
  puVar1 = PTR_DAT_00551644;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = FUN_004ba1f8(param_1,"wowl_pattern",PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar3) {
      printf("#of patterns :%d\n",*(int *)PTR_DAT_00551644);
      local_40 = (uint *)(puVar1 + 4);
      for (local_48 = 0; local_48 < *(uint *)puVar1; local_48 = local_48 + 1) {
        printf("Pattern %d:\n",local_48 + 1);
        printf("ID         :0x%x\nOffset     :%d\nMasksize   :%d\nMask       :0x",local_40[4],
               local_40[1],*local_40);
        for (local_44 = 0; local_44 < *local_40; local_44 = local_44 + 1) {
          printf("%02x",(uint)*(byte *)((int)local_40 + local_44 + 0x1c));
        }
        printf("\nPatternSize:%d\nPattern    :0x",local_40[3]);
        uVar11 = local_40[2];
        for (local_44 = 0; local_44 < local_40[3]; local_44 = local_44 + 1) {
          printf("%02x",(uint)*(byte *)((int)local_40 + local_44 + uVar11));
        }
        puts("\n");
        local_40 = (uint *)((int)local_40 + *local_40 + local_40[3] + 0x1c);
      }
    }
  }
  else {
    iVar3 = strcmp((char *)*piVar2,"add");
    if (((iVar3 == 0) || (iVar3 = strcmp((char *)*piVar2,"del"), iVar3 == 0)) ||
       (iVar3 = strcmp((char *)*piVar2,"clr"), iVar3 == 0)) {
      sVar4 = strlen("wowl_pattern");
      strncpy(puVar1,"wowl_pattern",sVar4);
      sVar4 = strlen("wowl_pattern");
      puVar1[sVar4] = 0;
      sVar4 = strlen("wowl_pattern");
      sVar5 = strlen("wowl_pattern");
      pcVar6 = (char *)*piVar2;
      sVar7 = strlen(pcVar6);
      strncpy(puVar1 + sVar4 + 1,pcVar6,sVar7);
      sVar7 = strlen(pcVar6);
      local_3c = sVar7 + sVar5 + 2;
      iVar3 = strcmp(pcVar6,"clr");
      if (iVar3 != 0) {
        sVar5 = strlen(pcVar6);
        puVar8 = (uint *)(puVar1 + sVar4 + 1 + sVar5 + 1);
        puVar9 = puVar8 + 7;
        piVar2 = (int *)(param_3 + 8);
        if (*piVar2 == 0) {
          puts("Starting offset not provided");
          return -0x2c;
        }
        if (DAT_00557704 == '\0') {
          uVar11 = strtoul((char *)*piVar2,(char **)0x0,0);
        }
        else {
          uVar10 = strtoul((char *)*piVar2,(char **)0x0,0);
          uVar11 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                   uVar10 >> 0x18;
        }
        puVar8[1] = uVar11;
        if (*(int *)(param_3 + 0xc) == 0) {
          puts("Mask not provided");
          return -0x2c;
        }
        pcVar6 = *(char **)(param_3 + 0xc);
        if (DAT_00557704 == '\0') {
          uVar11 = FUN_0043dc20(pcVar6,(int)puVar9);
        }
        else {
          uVar11 = FUN_0043dc20(pcVar6,(int)puVar9);
          uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                   uVar11 >> 0x18;
        }
        *puVar8 = uVar11;
        if (*puVar8 == 0xffffffff) {
          return -0x2c;
        }
        if (DAT_00557704 == '\0') {
          uVar11 = *puVar8 + 0x1c;
        }
        else {
          uVar11 = *puVar8 + 0x1c;
          uVar11 = uVar11 * 0x1000000 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                   uVar11 >> 0x18;
        }
        puVar8[2] = uVar11;
        if (*(int *)(param_3 + 0x10) == 0) {
          puts("Pattern value not provided");
          return -0x2c;
        }
        pcVar6 = *(char **)(param_3 + 0x10);
        if (DAT_00557704 == '\0') {
          uVar11 = FUN_0043dc20(pcVar6,(int)((int)puVar9 + *puVar8));
        }
        else {
          uVar11 = FUN_0043dc20(pcVar6,(int)((int)puVar9 + *puVar8));
          uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                   uVar11 >> 0x18;
        }
        puVar8[3] = uVar11;
        if (puVar8[3] == 0xffffffff) {
          return -0x2c;
        }
        local_3c = puVar8[3] + *puVar8 + local_3c + 0x1c;
      }
      iVar3 = FUN_004ba050(param_1,0x107,puVar1,local_3c);
    }
    else {
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



int FUN_0047efb0(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  char *pcVar1;
  uint param1;
  int param1_00;
  
  pcVar1 = (char *)*param_3;
  if (param_3[1] == 0) {
    param1 = 0;
  }
  else {
    param1 = atoi((char *)param_3[1]);
  }
  printf("\n--------------------------------");
  printf("\n--------------------------------");
  printf("PHY DEBUG COMMAND with input argument : %d\n",param1);
  printf("\n--------------------------------");
  printf("\n--------------------------------");
  putchar(10);
  param1_00 = FUN_004ba428(param_1,pcVar1,param1);
  if (param1_00 < 0) {
    printf("PHY DEBUG COMMAND error %d\n",param1_00);
  }
  return param1_00;
}



int FUN_0047f0cc(int *param_1,int param_2,int param_3)

{
  undefined *__dest;
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  int local_20;
  
  __dest = PTR_DAT_00551644;
  sVar1 = strlen("wowl_ext_magic");
  strncpy(__dest,"wowl_ext_magic",sVar1);
  sVar1 = strlen("wowl_ext_magic");
  __dest[sVar1] = 0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),__dest,0x2000);
    if (-1 < iVar3) {
      printf("0x");
      for (local_20 = 0; local_20 < 6; local_20 = local_20 + 1) {
        printf("%02x",(uint)(byte)__dest[local_20]);
      }
      putchar(10);
      iVar3 = 0;
    }
  }
  else {
    sVar1 = strlen("wowl_ext_magic");
    sVar2 = strlen("wowl_ext_magic");
    iVar3 = FUN_0043dc20(*(char **)(param_3 + 4),(int)(__dest + sVar1 + 1));
    if (iVar3 == -1) {
      iVar3 = -0x2c;
    }
    else if (iVar3 == 6) {
      iVar3 = FUN_004ba050(param_1,*(int *)(param_2 + 0xc),__dest,sVar2 + 7);
    }
    else {
      puts("Extended magic pattern must be 6-byte length");
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



undefined4 FUN_0047f2ec(int *param_1,undefined4 param_2,int param_3)

{
  undefined *__dest;
  bool bVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  size_t sVar5;
  size_t sVar6;
  undefined3 extraout_var;
  char *local_18;
  
  __dest = PTR_DAT_00551644;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    uVar3 = 0xffffffd4;
  }
  else {
    iVar4 = strncmp((char *)*piVar2,"ptk",3);
    if (iVar4 == 0) {
      local_18 = "auth_ptk_m1";
    }
    else {
      iVar4 = strncmp((char *)*piVar2,"gtk_bad",7);
      if (iVar4 == 0) {
        local_18 = "auth_gtk_bad_m1";
      }
      else {
        iVar4 = strncmp((char *)*piVar2,"gtk",3);
        if (iVar4 != 0) {
          puts("Unknown option");
          return 0xffffffd4;
        }
        local_18 = "auth_gtk_m1";
      }
    }
    if (*(int *)(param_3 + 8) == 0) {
      puts("Mac address missing");
      uVar3 = 0xffffffd4;
    }
    else {
      sVar5 = strlen(local_18);
      strncpy(__dest,local_18,sVar5);
      sVar5 = strlen(local_18);
      __dest[sVar5] = 0;
      sVar5 = strlen(local_18);
      sVar6 = strlen(local_18);
      bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),__dest + sVar5 + 1);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        uVar3 = 0xffffffd4;
      }
      else {
        uVar3 = FUN_004ba050(param_1,0x107,__dest,sVar6 + 7);
      }
    }
  }
  return uVar3;
}



int FUN_0047f518(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  char *pcVar1;
  int iVar2;
  uint local_10;
  uint local_c;
  
  pcVar1 = (char *)*param_3;
  if (param_3[1] == 0) {
    iVar2 = FUN_004ba35c(param_1,pcVar1,&local_c);
    if (-1 < iVar2) {
      if ((local_c & 0xff) == 0) {
        pcVar1 = "Off";
      }
      else {
        pcVar1 = "On";
      }
      puts(pcVar1);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = atoi((char *)param_3[1]);
    local_10 = (uint)(iVar2 != 0);
    local_c = local_10;
    iVar2 = FUN_004ba050(param_1,0xdb,(char *)&local_10,4);
    if (iVar2 < 0) {
      printf("Set frameburst error %d\n",iVar2);
    }
    else {
      iVar2 = FUN_004ba428(param_1,pcVar1,local_c);
      if (iVar2 < 0) {
        printf("Set rifs error %d\n",iVar2);
      }
    }
  }
  return iVar2;
}



int FUN_0047f69c(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  char *pcVar1;
  int *piVar2;
  int iVar3;
  uint local_10 [2];
  
  pcVar1 = (char *)*param_3;
  piVar2 = param_3 + 1;
  if (*piVar2 == 0) {
    iVar3 = FUN_004ba35c(param_1,pcVar1,local_10);
    if (-1 < iVar3) {
      if ((local_10[0] & 0xff) == 0) {
        pcVar1 = "Off";
      }
      else {
        pcVar1 = "On";
      }
      puts(pcVar1);
      iVar3 = 0;
    }
  }
  else {
    iVar3 = strcmp((char *)*piVar2,"-1");
    if ((iVar3 == 0) || (iVar3 = strcmp((char *)*piVar2,"0"), iVar3 == 0)) {
      local_10[0] = atoi((char *)*piVar2);
      iVar3 = FUN_004ba428(param_1,pcVar1,local_10[0]);
      if (iVar3 < 0) {
        printf("Set rifs mode advertisement error %d\n",iVar3);
      }
    }
    else {
      iVar3 = -0x2c;
    }
  }
  return iVar3;
}



int FUN_0047f818(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  undefined1 auVar2 [4];
  undefined1 auVar3 [4];
  undefined1 param2 [4];
  undefined1 param10 [4];
  uint param12;
  uint param14;
  uint param16;
  uint param18;
  uint param20;
  uint param22;
  int iVar4;
  ushort *puVar5;
  ushort uVar6;
  ushort uVar7;
  size_t __size;
  undefined1 *__ptr;
  ulong uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint param23;
  uint uVar20;
  uint uVar21;
  undefined4 *local_res8;
  int local_3e0;
  uint local_3dc;
  uint local_3d8;
  uint local_3d4;
  uint local_3cc;
  uint local_3c4;
  ushort *local_204;
  char *local_200;
  undefined1 auStack_1fc [4];
  uint local_1f8;
  uint local_1f4;
  undefined1 auStack_1f0 [4];
  uint local_1ec;
  uint local_1e8;
  undefined1 auStack_1e4 [4];
  uint local_1e0;
  uint local_1dc;
  uint local_1d8;
  uint local_1d4;
  undefined1 auStack_1d0 [4];
  uint local_1cc;
  undefined1 local_1c8 [4];
  undefined1 local_1c4 [4];
  uint local_1c0;
  uint local_1bc;
  uint local_1b8;
  uint local_1b4;
  uint local_1b0;
  uint local_1ac;
  undefined1 local_1a8 [4];
  undefined1 local_1a4 [4];
  uint local_1a0;
  uint local_19c;
  uint local_198;
  uint local_194;
  uint local_190;
  uint local_18c;
  uint local_184;
  uint local_180;
  uint local_17c;
  uint local_178;
  uint local_174;
  uint local_170;
  uint local_16c;
  uint local_168;
  uint local_164;
  uint local_160;
  uint local_15c;
  uint local_158;
  uint local_154;
  uint local_150;
  uint auStack_b7 [32];
  uint local_37;
  uint local_33;
  uint local_2f;
  
  local_204 = (ushort *)0x0;
  local_res8 = (undefined4 *)(param_3 + 4);
  for (local_3d8 = 0; local_res8[local_3d8] != 0; local_3d8 = local_3d8 + 1) {
  }
  if (local_3d8 < 0x21) {
    __size = (local_3d8 + 1) * 2;
    __ptr = (undefined1 *)malloc(__size);
    if (__ptr == (undefined1 *)0x0) {
      fprintf(stderr,"malloc failed to allocate %d bytes\n",__size);
      local_3e0 = -1;
    }
    else {
      *__ptr = (char)local_3d8;
      __ptr[1] = (char)(local_3d8 >> 8);
      for (local_3dc = 0; local_3dc < local_3d8; local_3dc = local_3dc + 1) {
        uVar8 = strtoul((char *)*local_res8,&local_200,0);
        __ptr[local_3dc * 2 + 2] = (char)uVar8;
        __ptr[local_3dc * 2 + 3] = (char)(uVar8 >> 8);
        if (*local_200 != '\0') {
          fprintf(stderr,"Type \'%s\' (arg %d) not a number?\n",(char *)*local_res8,local_3dc);
          free(__ptr);
          return -1;
        }
        local_res8 = local_res8 + 1;
      }
      local_3e0 = FUN_00445198(param_1,(char *)*param_2,__ptr,__size,&local_204);
      free(__ptr);
      puVar5 = local_204;
      if (-1 < local_3e0) {
        if (DAT_00557704 == '\0') {
          uVar6 = *local_204;
        }
        else {
          uVar6 = *local_204 << 8 | *local_204 >> 8;
        }
        if (uVar6 == 2) {
          if (DAT_00557704 == '\0') {
            uVar6 = *local_204;
          }
          else {
            uVar6 = *local_204 << 8 | *local_204 >> 8;
          }
          if (DAT_00557704 == '\0') {
            uVar7 = local_204[1];
          }
          else {
            uVar7 = local_204[1] << 8 | local_204[1] >> 8;
          }
          printf("Version: %d, Length %d bytes\n",(uint)uVar6,(uint)uVar7);
          if (DAT_00557704 == '\0') {
            uVar6 = puVar5[1];
          }
          else {
            uVar6 = puVar5[1] << 8 | puVar5[1] >> 8;
          }
          local_204 = puVar5 + 2;
          for (local_3d4 = uVar6 - 4; puVar5 = local_204, 3 < local_3d4;
              local_3d4 = local_3d4 - uVar9) {
            if (DAT_00557704 == '\0') {
              uVar6 = *local_204;
              uVar7 = local_204[1];
            }
            else {
              uVar6 = *local_204 << 8 | *local_204 >> 8;
              uVar7 = local_204[1] << 8 | local_204[1] >> 8;
            }
            uVar9 = (uint)uVar7;
            if ((uVar9 < 4) || (local_3d4 < uVar9)) {
              fprintf(stderr,"Bad len %d for tag %d, remaining len %d\n",uVar9,(uint)uVar6,local_3d4
                     );
              local_3e0 = -1;
              break;
            }
            if ((uVar7 & 0xf000) != 0) {
              fprintf(stderr,"Resrved bits in len %d for tag %d, remaining len %d\n",uVar9,
                      (uint)uVar6,local_3d4);
              local_3e0 = -1;
              break;
            }
            switch(uVar6) {
            case 0:
              if (uVar9 < 0xc) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0xc);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1fc,local_204,uVar9);
                uVar17 = local_1f4;
                uVar19 = local_1f8;
                if (DAT_00557704 != '\0') {
                  uVar17 = local_1f4 << 0x18 | (local_1f4 & 0xff00) << 8 |
                           (local_1f4 & 0xff0000) >> 8 | local_1f4 >> 0x18;
                  uVar19 = local_1f8 << 0x18 | (local_1f8 & 0xff00) << 8 |
                           (local_1f8 & 0xff0000) >> 8 | local_1f8 >> 0x18;
                }
                printf("PHY:\n  TX Duration: %u\n  RX Duration: %u\n",uVar19,uVar17);
              }
              break;
            case 1:
              if (uVar9 < 100) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,100);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1d0,local_204,uVar9);
                uVar14 = local_170;
                uVar19 = local_1b0;
                uVar17 = local_1b8;
                uVar15 = local_1c0;
                auVar2 = local_1c8;
                uVar13 = local_1cc;
                auVar3 = local_1c4;
                uVar11 = local_1bc;
                uVar10 = local_1b4;
                uVar12 = local_174;
                if (DAT_00557704 != '\0') {
                  uVar14 = local_170 << 0x18 | (local_170 & 0xff00) << 8 |
                           (local_170 & 0xff0000) >> 8 | local_170 >> 0x18;
                  uVar19 = local_1b0 << 0x18 | (local_1b0 & 0xff00) << 8 |
                           (local_1b0 & 0xff0000) >> 8 | local_1b0 >> 0x18;
                  uVar17 = local_1b8 << 0x18 | (local_1b8 & 0xff00) << 8 |
                           (local_1b8 & 0xff0000) >> 8 | local_1b8 >> 0x18;
                  uVar15 = local_1c0 << 0x18 | (local_1c0 & 0xff00) << 8 |
                           (local_1c0 & 0xff0000) >> 8 | local_1c0 >> 0x18;
                  auVar2 = (undefined1  [4])
                           ((int)local_1c8 << 0x18 | ((uint)local_1c8 & 0xff00) << 8 |
                            ((uint)local_1c8 & 0xff0000) >> 8 | (uint)local_1c8 >> 0x18);
                  uVar13 = local_1cc << 0x18 | (local_1cc & 0xff00) << 8 |
                           (local_1cc & 0xff0000) >> 8 | local_1cc >> 0x18;
                  auVar3 = (undefined1  [4])
                           ((int)local_1c4 << 0x18 | ((uint)local_1c4 & 0xff00) << 8 |
                            ((uint)local_1c4 & 0xff0000) >> 8 | (uint)local_1c4 >> 0x18);
                  uVar11 = local_1bc << 0x18 | (local_1bc & 0xff00) << 8 |
                           (local_1bc & 0xff0000) >> 8 | local_1bc >> 0x18;
                  uVar10 = local_1b4 << 0x18 | (local_1b4 & 0xff00) << 8 |
                           (local_1b4 & 0xff0000) >> 8 | local_1b4 >> 0x18;
                  uVar12 = local_174 << 0x18 | (local_174 & 0xff00) << 8 |
                           (local_174 & 0xff0000) >> 8 | local_174 >> 0x18;
                }
                printf("SCAN:\n  User-Scan:\tCount: %u\tDuration: %u\n  Assoc-Scan:\tCount: %u\tDuration: %u\n  Roam-Scan:\tCount: %u\tDuration: %u\n  PNO-Scan:\tCount: %u\tDuration: %u\n  Other-Scan:\tCount: %u\tDuration: %u\n"
                       ,uVar13,(uint)auVar2,(uint)auVar3,uVar15,uVar11,uVar17,uVar10,uVar19,uVar12,
                       uVar14);
              }
              break;
            case 2:
              if (uVar9 < 0x20) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0x20);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1d0,local_204,uVar9);
                uVar11 = local_1b4;
                uVar19 = local_1bc;
                auVar2 = local_1c4;
                uVar17 = local_1cc;
                auVar3 = local_1c8;
                uVar15 = local_1c0;
                uVar13 = local_1b8;
                if (DAT_00557704 != '\0') {
                  uVar11 = local_1b4 << 0x18 | (local_1b4 & 0xff00) << 8 |
                           (local_1b4 & 0xff0000) >> 8 | local_1b4 >> 0x18;
                  uVar19 = local_1bc << 0x18 | (local_1bc & 0xff00) << 8 |
                           (local_1bc & 0xff0000) >> 8 | local_1bc >> 0x18;
                  auVar2 = (undefined1  [4])
                           ((int)local_1c4 << 0x18 | ((uint)local_1c4 & 0xff00) << 8 |
                            ((uint)local_1c4 & 0xff0000) >> 8 | (uint)local_1c4 >> 0x18);
                  uVar17 = local_1cc << 0x18 | (local_1cc & 0xff00) << 8 |
                           (local_1cc & 0xff0000) >> 8 | local_1cc >> 0x18;
                  auVar3 = (undefined1  [4])
                           ((int)local_1c8 << 0x18 | ((uint)local_1c8 & 0xff00) << 8 |
                            ((uint)local_1c8 & 0xff0000) >> 8 | (uint)local_1c8 >> 0x18);
                  uVar15 = local_1c0 << 0x18 | (local_1c0 & 0xff00) << 8 |
                           (local_1c0 & 0xff0000) >> 8 | local_1c0 >> 0x18;
                  uVar13 = local_1b8 << 0x18 | (local_1b8 & 0xff00) << 8 |
                           (local_1b8 & 0xff0000) >> 8 | local_1b8 >> 0x18;
                }
                printf("HSIC:\n  Suspend count: %u\n  Resume count: %u\n  Disconnect count: %u\n  Reconnect count: %u\n  Active duration: %u\n  Suspend duration: %u\n  Disconnect duration:%u\n"
                       ,uVar17,(uint)auVar3,(uint)auVar2,uVar15,uVar19,uVar13,uVar11);
              }
              break;
            case 3:
              bVar1 = false;
              if (uVar9 < 0x1a5) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0x1a5);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1d0,local_204,uVar9);
                uVar18 = local_33;
                uVar19 = local_37;
                uVar17 = local_1b0;
                uVar15 = local_1b8;
                uVar13 = local_1c0;
                auVar2 = local_1c8;
                uVar11 = local_1cc;
                auVar3 = local_1c4;
                uVar10 = local_1bc;
                uVar12 = local_1b4;
                uVar14 = local_1ac;
                uVar16 = local_2f;
                if (DAT_00557704 != '\0') {
                  uVar18 = local_33 << 0x18 | (local_33 & 0xff00) << 8 | (local_33 & 0xff0000) >> 8
                           | local_33 >> 0x18;
                  uVar19 = local_37 << 0x18 | (local_37 & 0xff00) << 8 | (local_37 & 0xff0000) >> 8
                           | local_37 >> 0x18;
                  uVar17 = local_1b0 << 0x18 | (local_1b0 & 0xff00) << 8 |
                           (local_1b0 & 0xff0000) >> 8 | local_1b0 >> 0x18;
                  uVar15 = local_1b8 << 0x18 | (local_1b8 & 0xff00) << 8 |
                           (local_1b8 & 0xff0000) >> 8 | local_1b8 >> 0x18;
                  uVar13 = local_1c0 << 0x18 | (local_1c0 & 0xff00) << 8 |
                           (local_1c0 & 0xff0000) >> 8 | local_1c0 >> 0x18;
                  auVar2 = (undefined1  [4])
                           ((int)local_1c8 << 0x18 | ((uint)local_1c8 & 0xff00) << 8 |
                            ((uint)local_1c8 & 0xff0000) >> 8 | (uint)local_1c8 >> 0x18);
                  uVar11 = local_1cc << 0x18 | (local_1cc & 0xff00) << 8 |
                           (local_1cc & 0xff0000) >> 8 | local_1cc >> 0x18;
                  auVar3 = (undefined1  [4])
                           ((int)local_1c4 << 0x18 | ((uint)local_1c4 & 0xff00) << 8 |
                            ((uint)local_1c4 & 0xff0000) >> 8 | (uint)local_1c4 >> 0x18);
                  uVar10 = local_1bc << 0x18 | (local_1bc & 0xff00) << 8 |
                           (local_1bc & 0xff0000) >> 8 | local_1bc >> 0x18;
                  uVar12 = local_1b4 << 0x18 | (local_1b4 & 0xff00) << 8 |
                           (local_1b4 & 0xff0000) >> 8 | local_1b4 >> 0x18;
                  uVar14 = local_1ac << 0x18 | (local_1ac & 0xff00) << 8 |
                           (local_1ac & 0xff0000) >> 8 | local_1ac >> 0x18;
                  uVar16 = local_2f << 0x18 | (local_2f & 0xff00) << 8 | (local_2f & 0xff0000) >> 8
                           | local_2f >> 0x18;
                }
                printf("PM WAKE:\n  Current Time: %u\n  HW MACC: 0x%08x\n  SW MACC: 0x%08x\n  PM Dur: %u\n  MPC Dur: %u\n  TSF Drift (Last/Min/Max/Avg/Cnt): %d/%d/%d/%u/%u\n  Frts (end_cnt/dur): %u/%u\n"
                       ,uVar11,(uint)auVar2,(uint)auVar3,uVar13,uVar10,uVar15,uVar12,uVar17,uVar14,
                       uVar19,uVar16,uVar18);
                putchar(10);
                local_3dc = (uint)local_1a8 & 0xff;
                if (local_3dc < 0x1f) {
                  local_3cc = local_3dc;
                  if (local_3dc == 0) {
                    local_3cc = 0x1e;
                  }
                  do {
                    if (0x1d < local_3dc) {
                      local_3dc = 0;
                    }
                    if (DAT_00557704 == '\0') {
                      uVar19 = *(uint *)(local_1c8 + (local_3dc + 4) * 8 + 1);
                      uVar17 = *(uint *)(local_1c4 + (local_3dc + 4) * 8 + 1);
                    }
                    else {
                      uVar19 = *(uint *)(local_1c8 + (local_3dc + 4) * 8 + 1);
                      uVar19 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                               uVar19 >> 0x18;
                      uVar17 = *(uint *)(local_1c4 + (local_3dc + 4) * 8 + 1);
                      uVar17 = uVar17 << 0x18 | (uVar17 & 0xff00) << 8 | (uVar17 & 0xff0000) >> 8 |
                               uVar17 >> 0x18;
                    }
                    if ((uVar19 != 0) || (uVar17 != 0)) {
                      printf("  State: %2d  reason: 0x%04x  time: %u\n",local_3dc,uVar17,uVar19);
                    }
                    local_3dc = local_3dc + 1;
                  } while (local_3dc != local_3cc);
                  putchar(10);
                  for (local_3dc = 0; local_3dc < 0x20; local_3dc = local_3dc + 1) {
                    if (DAT_00557704 == '\0') {
                      uVar19 = *(uint *)(local_1c8 + (local_3dc + 0x44) * 4 + 1);
                    }
                    else {
                      uVar19 = *(uint *)(local_1c8 + (local_3dc + 0x44) * 4 + 1);
                      uVar19 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                               uVar19 >> 0x18;
                    }
                    if (uVar19 == 0) {
                      if (local_3dc != 0) {
                        bVar1 = true;
                      }
                    }
                    else {
                      if (bVar1) {
                        puts("  ---");
                        bVar1 = false;
                      }
                      printf("  Event: %2d Wake-Duration: %u\n",local_3dc,uVar19);
                    }
                  }
                }
                else {
                  fprintf(stderr,"Unexpected idx %d > %d\n",local_3dc,0x1e);
                  local_3e0 = -1;
                }
              }
              break;
            case 4:
              if (uVar9 < 0xc) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0xc);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1f0,local_204,uVar9);
                uVar17 = local_1e8;
                uVar19 = local_1ec;
                if (DAT_00557704 != '\0') {
                  uVar17 = local_1e8 << 0x18 | (local_1e8 & 0xff00) << 8 |
                           (local_1e8 & 0xff0000) >> 8 | local_1e8 >> 0x18;
                  uVar19 = local_1ec << 0x18 | (local_1ec & 0xff00) << 8 |
                           (local_1ec & 0xff0000) >> 8 | local_1ec >> 0x18;
                }
                printf("Connect:\n  Count: %u\n  Duration: %u\n",uVar19,uVar17);
              }
              break;
            case 5:
              if (uVar9 < 0x14) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0x14);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1e4,local_204,uVar9);
                uVar13 = local_1d4;
                uVar19 = local_1dc;
                uVar17 = local_1e0;
                uVar15 = local_1d8;
                if (DAT_00557704 != '\0') {
                  uVar13 = local_1d4 << 0x18 | (local_1d4 & 0xff00) << 8 |
                           (local_1d4 & 0xff0000) >> 8 | local_1d4 >> 0x18;
                  uVar19 = local_1dc << 0x18 | (local_1dc & 0xff00) << 8 |
                           (local_1dc & 0xff0000) >> 8 | local_1dc >> 0x18;
                  uVar17 = local_1e0 << 0x18 | (local_1e0 & 0xff00) << 8 |
                           (local_1e0 & 0xff0000) >> 8 | local_1e0 >> 0x18;
                  uVar15 = local_1d8 << 0x18 | (local_1d8 & 0xff00) << 8 |
                           (local_1d8 & 0xff0000) >> 8 | local_1d8 >> 0x18;
                }
                printf("AWDL:\n  TX Duration: %u\n  RX Duration: %u\n  AW Duration: %u\n  AW-PSCAN Duration: %u\n"
                       ,uVar17,uVar19,uVar15,uVar13);
              }
              break;
            case 6:
              if (uVar9 < 0x84) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0x84);
                local_3e0 = -1;
              }
              else {
                memcpy(auStack_1d0,local_204,uVar9);
                if (DAT_00557704 == '\0') {
                  bVar1 = local_1b0 == 0;
                }
                else {
                  bVar1 = (((local_1b0 & 0xff) == 0 && (local_1b0 & 0xff00) == 0) &&
                          (local_1b0 & 0xff0000) == 0) && local_1b0 >> 0x18 == 0;
                }
                if (bVar1) {
                  puts("link stats are not supported for this pcie core");
                }
                param23 = local_150;
                uVar19 = local_158;
                uVar17 = local_160;
                uVar15 = local_18c;
                uVar13 = local_194;
                uVar11 = local_19c;
                auVar2 = local_1a4;
                uVar10 = local_1ac;
                uVar12 = local_1b4;
                uVar14 = local_1bc;
                auVar3 = local_1c4;
                uVar16 = local_1cc;
                param2 = local_1c8;
                uVar18 = local_1c0;
                uVar20 = local_1b8;
                uVar21 = local_1b0;
                param10 = local_1a8;
                param12 = local_1a0;
                param14 = local_198;
                param16 = local_190;
                param18 = local_164;
                param20 = local_15c;
                param22 = local_154;
                if (DAT_00557704 != '\0') {
                  param23 = local_150 << 0x18 | (local_150 & 0xff00) << 8 |
                            (local_150 & 0xff0000) >> 8 | local_150 >> 0x18;
                  uVar19 = local_158 << 0x18 | (local_158 & 0xff00) << 8 |
                           (local_158 & 0xff0000) >> 8 | local_158 >> 0x18;
                  uVar17 = local_160 << 0x18 | (local_160 & 0xff00) << 8 |
                           (local_160 & 0xff0000) >> 8 | local_160 >> 0x18;
                  uVar15 = local_18c << 0x18 | (local_18c & 0xff00) << 8 |
                           (local_18c & 0xff0000) >> 8 | local_18c >> 0x18;
                  uVar13 = local_194 << 0x18 | (local_194 & 0xff00) << 8 |
                           (local_194 & 0xff0000) >> 8 | local_194 >> 0x18;
                  uVar11 = local_19c << 0x18 | (local_19c & 0xff00) << 8 |
                           (local_19c & 0xff0000) >> 8 | local_19c >> 0x18;
                  auVar2 = (undefined1  [4])
                           ((int)local_1a4 << 0x18 | ((uint)local_1a4 & 0xff00) << 8 |
                            ((uint)local_1a4 & 0xff0000) >> 8 | (uint)local_1a4 >> 0x18);
                  uVar10 = local_1ac << 0x18 | (local_1ac & 0xff00) << 8 |
                           (local_1ac & 0xff0000) >> 8 | local_1ac >> 0x18;
                  uVar12 = local_1b4 << 0x18 | (local_1b4 & 0xff00) << 8 |
                           (local_1b4 & 0xff0000) >> 8 | local_1b4 >> 0x18;
                  uVar14 = local_1bc << 0x18 | (local_1bc & 0xff00) << 8 |
                           (local_1bc & 0xff0000) >> 8 | local_1bc >> 0x18;
                  auVar3 = (undefined1  [4])
                           ((int)local_1c4 << 0x18 | ((uint)local_1c4 & 0xff00) << 8 |
                            ((uint)local_1c4 & 0xff0000) >> 8 | (uint)local_1c4 >> 0x18);
                  uVar16 = local_1cc << 0x18 | (local_1cc & 0xff00) << 8 |
                           (local_1cc & 0xff0000) >> 8 | local_1cc >> 0x18;
                  param2 = (undefined1  [4])
                           ((int)local_1c8 << 0x18 | ((uint)local_1c8 & 0xff00) << 8 |
                            ((uint)local_1c8 & 0xff0000) >> 8 | (uint)local_1c8 >> 0x18);
                  uVar18 = local_1c0 << 0x18 | (local_1c0 & 0xff00) << 8 |
                           (local_1c0 & 0xff0000) >> 8 | local_1c0 >> 0x18;
                  uVar20 = local_1b8 << 0x18 | (local_1b8 & 0xff00) << 8 |
                           (local_1b8 & 0xff0000) >> 8 | local_1b8 >> 0x18;
                  uVar21 = local_1b0 << 0x18 | (local_1b0 & 0xff00) << 8 |
                           (local_1b0 & 0xff0000) >> 8 | local_1b0 >> 0x18;
                  param10 = (undefined1  [4])
                            ((int)local_1a8 << 0x18 | ((uint)local_1a8 & 0xff00) << 8 |
                             ((uint)local_1a8 & 0xff0000) >> 8 | (uint)local_1a8 >> 0x18);
                  param12 = local_1a0 << 0x18 | (local_1a0 & 0xff00) << 8 |
                            (local_1a0 & 0xff0000) >> 8 | local_1a0 >> 0x18;
                  param14 = local_198 << 0x18 | (local_198 & 0xff00) << 8 |
                            (local_198 & 0xff0000) >> 8 | local_198 >> 0x18;
                  param16 = local_190 << 0x18 | (local_190 & 0xff00) << 8 |
                            (local_190 & 0xff0000) >> 8 | local_190 >> 0x18;
                  param18 = local_164 << 0x18 | (local_164 & 0xff00) << 8 |
                            (local_164 & 0xff0000) >> 8 | local_164 >> 0x18;
                  param20 = local_15c << 0x18 | (local_15c & 0xff00) << 8 |
                            (local_15c & 0xff0000) >> 8 | local_15c >> 0x18;
                  param22 = local_154 << 0x18 | (local_154 & 0xff00) << 8 |
                            (local_154 & 0xff0000) >> 8 | local_154 >> 0x18;
                }
                printf("PCIE:\n  D3 Suspend count: %u\n  D0 Resume count: %u\n  PERST# assert count: %u\n  PERST# deassert count: %u\n  Active duration: %u ms\n  D3 Suspend duration: %u ms\n  PERST# duration:%u ms\n  l0 cnt:%u dur:%u usecs\n  l1 cnt:%u dur:%u usecs\n  l1_1 cnt:%u dur:%u usecs\n  l1_2 cnt:%u dur:%u usecs\n  l2 cnt:%u dur:%u usecs\n  deepsleep cnt:%u dur:%u usecs\n  LTR_ACTIVE Count %u Duration: %u ms\n  LTR_SLEEP Count: %u Duration: %u ms\n"
                       ,uVar16,(uint)param2,(uint)auVar3,uVar18,uVar14,uVar20,uVar12,uVar21,uVar10,
                       (uint)param10,(uint)auVar2,param12,uVar11,param14,uVar13,param16,uVar15,
                       param18,uVar17,param20,uVar19,param22,param23);
                uVar14 = local_168;
                uVar19 = local_170;
                uVar17 = local_180;
                uVar15 = local_184;
                uVar13 = local_17c;
                uVar11 = local_178;
                uVar10 = local_174;
                uVar12 = local_16c;
                if (DAT_00557704 != '\0') {
                  uVar14 = local_168 << 0x18 | (local_168 & 0xff00) << 8 |
                           (local_168 & 0xff0000) >> 8 | local_168 >> 0x18;
                  uVar19 = local_170 << 0x18 | (local_170 & 0xff00) << 8 |
                           (local_170 & 0xff0000) >> 8 | local_170 >> 0x18;
                  uVar17 = local_180 << 0x18 | (local_180 & 0xff00) << 8 |
                           (local_180 & 0xff0000) >> 8 | local_180 >> 0x18;
                  uVar15 = local_184 << 0x18 | (local_184 & 0xff00) << 8 |
                           (local_184 & 0xff0000) >> 8 | local_184 >> 0x18;
                  uVar13 = local_17c << 0x18 | (local_17c & 0xff00) << 8 |
                           (local_17c & 0xff0000) >> 8 | local_17c >> 0x18;
                  uVar11 = local_178 << 0x18 | (local_178 & 0xff00) << 8 |
                           (local_178 & 0xff0000) >> 8 | local_178 >> 0x18;
                  uVar10 = local_174 << 0x18 | (local_174 & 0xff00) << 8 |
                           (local_174 & 0xff0000) >> 8 | local_174 >> 0x18;
                  uVar12 = local_16c << 0x18 | (local_16c & 0xff00) << 8 |
                           (local_16c & 0xff0000) >> 8 | local_16c >> 0x18;
                }
                printf("  # of submissions %u - # of h2d doorbell:%u\n  # of completions %u - # of d2h doorbell:%u\n  # of rx_completions %u - # of d2h drbl. for rx_completions %u\n  # of tx_completions %u - # of d2h drbl. for tx_completions %u\n"
                       ,uVar13,uVar15,uVar11,uVar17,uVar10,uVar19,uVar12,uVar14);
                if (local_184 == 0) {
                  printf("  Avg. # of subm./doorbell:0.0, ");
                }
                else {
                  uVar17 = local_184;
                  uVar19 = local_17c;
                  if (DAT_00557704 != '\0') {
                    uVar17 = local_184 << 0x18 | (local_184 & 0xff00) << 8 |
                             (local_184 & 0xff0000) >> 8 | local_184 >> 0x18;
                    uVar19 = local_17c << 0x18 | (local_17c & 0xff00) << 8 |
                             (local_17c & 0xff0000) >> 8 | local_17c >> 0x18;
                  }
                  if (uVar17 == 0) {
                    trap(7);
                  }
                  uVar13 = local_184;
                  uVar15 = local_17c;
                  if (DAT_00557704 != '\0') {
                    uVar13 = local_184 << 0x18 | (local_184 & 0xff00) << 8 |
                             (local_184 & 0xff0000) >> 8 | local_184 >> 0x18;
                    uVar15 = local_17c << 0x18 | (local_17c & 0xff00) << 8 |
                             (local_17c & 0xff0000) >> 8 | local_17c >> 0x18;
                  }
                  if (uVar13 == 0) {
                    trap(7);
                  }
                  uVar11 = local_184;
                  if (DAT_00557704 != '\0') {
                    uVar11 = local_184 << 0x18 | (local_184 & 0xff00) << 8 |
                             (local_184 & 0xff0000) >> 8 | local_184 >> 0x18;
                  }
                  if (uVar11 == 0) {
                    trap(7);
                  }
                  printf("  Avg. # of subm./doorbell:%d.%d, ",uVar19 / uVar17,
                         ((uVar15 % uVar13) * 100) / uVar11);
                }
                if (local_180 == 0) {
                  puts("avg. # completions/MSI:0.0");
                }
                else {
                  uVar17 = local_180;
                  uVar19 = local_178;
                  if (DAT_00557704 != '\0') {
                    uVar17 = local_180 << 0x18 | (local_180 & 0xff00) << 8 |
                             (local_180 & 0xff0000) >> 8 | local_180 >> 0x18;
                    uVar19 = local_178 << 0x18 | (local_178 & 0xff00) << 8 |
                             (local_178 & 0xff0000) >> 8 | local_178 >> 0x18;
                  }
                  if (uVar17 == 0) {
                    trap(7);
                  }
                  uVar13 = local_180;
                  uVar15 = local_178;
                  if (DAT_00557704 != '\0') {
                    uVar13 = local_180 << 0x18 | (local_180 & 0xff00) << 8 |
                             (local_180 & 0xff0000) >> 8 | local_180 >> 0x18;
                    uVar15 = local_178 << 0x18 | (local_178 & 0xff00) << 8 |
                             (local_178 & 0xff0000) >> 8 | local_178 >> 0x18;
                  }
                  if (uVar13 == 0) {
                    trap(7);
                  }
                  uVar11 = local_180;
                  if (DAT_00557704 != '\0') {
                    uVar11 = local_180 << 0x18 | (local_180 & 0xff00) << 8 |
                             (local_180 & 0xff0000) >> 8 | local_180 >> 0x18;
                  }
                  if (uVar11 == 0) {
                    trap(7);
                  }
                  printf("avg. # completions/MSI:%d.%d\n",uVar19 / uVar17,
                         ((uVar15 % uVar13) * 100) / uVar11);
                }
              }
              break;
            case 7:
              bVar1 = false;
              if (uVar9 < 0x40) {
                fprintf(stderr,"Short len for %d: %d < %d\n",(uint)uVar6,uVar9,0x40);
                local_3e0 = -1;
              }
              else {
                if (DAT_00557704 == '\0') {
                  uVar10 = *(uint *)(local_204 + 2);
                  uVar11 = *(uint *)(local_204 + 4);
                  uVar12 = *(uint *)(local_204 + 6);
                  uVar13 = *(uint *)(local_204 + 8);
                  uVar14 = *(uint *)(local_204 + 10);
                  uVar15 = *(uint *)(local_204 + 0xc);
                  uVar16 = *(uint *)(local_204 + 0xe);
                  uVar17 = *(uint *)(local_204 + 0x10);
                  uVar18 = *(uint *)(local_204 + 0x12);
                  uVar19 = *(uint *)(local_204 + 0x18);
                  uVar20 = *(uint *)(local_204 + 0x1e);
                  uVar21 = *(uint *)(local_204 + 0x1c);
                }
                else {
                  uVar19 = *(uint *)(local_204 + 2);
                  uVar10 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 4);
                  uVar11 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 6);
                  uVar12 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 8);
                  uVar13 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 10);
                  uVar14 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 0xc);
                  uVar15 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 0xe);
                  uVar16 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 0x10);
                  uVar17 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 0x12);
                  uVar18 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar19 = *(uint *)(local_204 + 0x18);
                  uVar19 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                           uVar19 >> 0x18;
                  uVar20 = *(uint *)(local_204 + 0x1e);
                  uVar20 = uVar20 << 0x18 | (uVar20 & 0xff00) << 8 | (uVar20 & 0xff0000) >> 8 |
                           uVar20 >> 0x18;
                  uVar21 = *(uint *)(local_204 + 0x1c);
                  uVar21 = uVar21 << 0x18 | (uVar21 & 0xff00) << 8 | (uVar21 & 0xff0000) >> 8 |
                           uVar21 >> 0x18;
                }
                printf("PM WAKE:\n  Current Time: %u\n  HW MACC: 0x%08x\n  SW MACC: 0x%08x\n  PM Dur: %u\n  MPC Dur: %u\n  TSF Drift (Last/Min/Max/Avg/Cnt): %d/%d/%d/%u/%u\n  Frts (end_cnt/dur): %u/%u\n"
                       ,uVar10,uVar11,uVar12,uVar13,uVar14,uVar15,uVar16,uVar17,uVar18,uVar19,uVar20
                       ,uVar21);
                putchar(10);
                local_3dc = (uint)(byte)puVar5[0x1a];
                if (puVar5[0x15] < local_3dc) {
                  fprintf(stderr,"Unexpected idx %d > %d\n",local_3dc,(uint)puVar5[0x15]);
                  local_3e0 = -1;
                }
                else {
                  local_3c4 = local_3dc;
                  if (local_3dc == 0) {
                    local_3c4 = (uint)puVar5[0x15];
                  }
                  do {
                    iVar4 = puVar5[0x14] + 4;
                    if (puVar5[0x15] <= local_3dc) {
                      local_3dc = 0;
                    }
                    if (DAT_00557704 == '\0') {
                      uVar19 = *(uint *)((int)puVar5 + local_3dc * 8 + iVar4);
                      uVar17 = *(uint *)((int)puVar5 + local_3dc * 8 + iVar4 + 4);
                    }
                    else {
                      uVar19 = *(uint *)((int)puVar5 + local_3dc * 8 + iVar4);
                      uVar19 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                               uVar19 >> 0x18;
                      uVar17 = *(uint *)((int)puVar5 + local_3dc * 8 + iVar4 + 4);
                      uVar17 = uVar17 << 0x18 | (uVar17 & 0xff00) << 8 | (uVar17 & 0xff0000) >> 8 |
                               uVar17 >> 0x18;
                    }
                    if ((uVar19 != 0) || (uVar17 != 0)) {
                      printf("  State: %2d  reason: 0x%04x  time: %u\n",local_3dc,uVar17,uVar19);
                    }
                    local_3dc = local_3dc + 1;
                  } while (local_3dc != local_3c4);
                  putchar(10);
                  for (local_3dc = 0; local_3dc < puVar5[0x17]; local_3dc = local_3dc + 1) {
                    if (DAT_00557704 == '\0') {
                      uVar19 = *(uint *)((int)puVar5 + local_3dc * 4 + puVar5[0x16] + 4);
                    }
                    else {
                      uVar19 = *(uint *)((int)puVar5 + local_3dc * 4 + puVar5[0x16] + 4);
                      uVar19 = uVar19 << 0x18 | (uVar19 & 0xff00) << 8 | (uVar19 & 0xff0000) >> 8 |
                               uVar19 >> 0x18;
                    }
                    if (uVar19 == 0) {
                      if (local_3dc != 0) {
                        bVar1 = true;
                      }
                    }
                    else {
                      if (bVar1) {
                        puts("  ---");
                        bVar1 = false;
                      }
                      printf("  Event: %2d Wake-Duration: %u\n",local_3dc,uVar19);
                    }
                  }
                }
              }
              break;
            default:
              printf("Skipping uknown %d-byte tag %d\n",uVar9,(uint)uVar6);
            }
            putchar(10);
            if (local_3e0 != 0) break;
            uVar19 = uVar9 + 3 & 0xfffffffc;
            uVar9 = local_3d4;
            if (uVar19 <= local_3d4) {
              uVar9 = uVar19;
            }
            local_204 = (ushort *)((int)local_204 + uVar9);
          }
          if ((local_3d4 != 0) && (local_3d4 < 4)) {
            fprintf(stderr,"Invalid length remaining %d\n",local_3d4);
            local_3e0 = -1;
          }
        }
        else {
          puts("Power stats version mismatch");
          local_3e0 = -1;
        }
      }
    }
  }
  else {
    fprintf(stderr,"Currently limited to %d types in one query\n",0x20);
    local_3e0 = -1;
  }
  return local_3e0;
}



int FUN_004830c4(int *param_1,int param_2,undefined4 *param_3)

{
  undefined *puVar1;
  int iVar2;
  ulong *puVar3;
  ulong uVar4;
  
  iVar2 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  if (param_3[1] == 0) {
    PTR_DAT_00551644[iVar2 + 1] = 0;
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar2) {
      printf("pfn_alert_thresh %u\n",*(uint *)PTR_DAT_00551644);
      printf("roam_alert_thresh %u\n",*(uint *)(puVar1 + 4));
      iVar2 = 0;
    }
  }
  else {
    puVar3 = (ulong *)(PTR_DAT_00551644 + iVar2 + 1);
    uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar3 = uVar4;
    if (param_3[2] == 0) {
      puts("Incorrect number of arguments");
      iVar2 = -1;
    }
    else {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar3[1] = uVar4;
      if (param_3[3] == 0) {
        iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar2 + 9);
      }
      else {
        puts("extra arguments");
        iVar2 = -1;
      }
    }
  }
  return iVar2;
}



undefined4 FUN_00483314(undefined1 param_1)

{
  DAT_0055970d = param_1;
  return 0;
}



int FUN_0048334c(int *param_1)

{
  int iVar1;
  
  if (DAT_0055970d == '\0') {
    iVar1 = FUN_004ba160(param_1,"seq_start",(void *)0x0,0,PTR_DAT_00551644,0x2000);
  }
  else if (DAT_0055769c == '\0') {
    DAT_0055769c = '\x01';
    __bss_start = 0;
    DAT_00557694 = 0;
    DAT_00557698 = 0;
    iVar1 = 0;
  }
  else {
    puts("calling seq_start() when it\'s already in batching mode");
    FUN_004b9c5c();
    DAT_0055769c = '\0';
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00483430(int *param_1)

{
  char *pcVar1;
  undefined *puVar2;
  uint uVar3;
  void *local_20;
  int local_1c;
  uint local_18;
  undefined4 *local_14;
  
  if (DAT_0055970d == '\0') {
    local_1c = FUN_004ba160(param_1,"seq_stop",(void *)0x0,0,PTR_DAT_00551644,0x2000);
  }
  else if (DAT_0055769c == '\0') {
    puts("calling seq_stop when it\'s already out of batching mode");
    local_1c = -0x2c;
  }
  else {
    DAT_0055769c = '\0';
    local_14 = DAT_00557694;
    if (DAT_00557694 == (undefined4 *)0x0) {
      puts("no command batched");
      local_1c = -0x2c;
    }
    else {
      local_1c = FUN_00445444(param_1,"seq_start",(void *)0x0,0);
      if (local_1c == 0) {
        do {
          puVar2 = PTR_DAT_00551644;
          if (local_14 == (undefined4 *)0x0) {
            local_1c = FUN_00445444(param_1,"seq_stop",(void *)0x0,0);
            if (local_1c != 0) {
              puts("failed to send seq_stop");
            }
            goto LAB_0048374c;
          }
          memset(PTR_DAT_00551644,0,0x2000);
          *(undefined4 *)puVar2 = 0x5f716573;
          pcVar1 = puVar2 + 4;
          pcVar1[0] = 'l';
          pcVar1[1] = 'i';
          pcVar1[2] = 's';
          pcVar1[3] = 't';
          puVar2[8] = '\0';
          local_20 = (void *)((uint)(puVar2 + 0xc) & 0xfffffffc);
          local_18 = (int)local_20 - (int)PTR_DAT_00551644;
          while ((((int)local_18 < 0x1e0 && (local_14 != (undefined4 *)0x0)) &&
                 (uVar3 = local_18 + (local_14[2] + 3 & 0xfffffffc) + 8, (int)uVar3 < 0x1e0))) {
            memcpy(local_20,local_14 + 1,8);
            memcpy((void *)((int)local_20 + 8),(void *)local_14[3],local_14[2]);
            local_20 = (void *)((int)local_20 + 8 + local_14[2] + 3 & 0xfffffffc);
            local_14 = (undefined4 *)*local_14;
            local_18 = uVar3;
          }
          local_1c = FUN_004baca0(param_1,0x107,PTR_DAT_00551644,local_18);
        } while (local_1c == 0);
        puts("failed to send seq_list");
      }
      else {
        puts("failed to send seq_start");
      }
LAB_0048374c:
      FUN_004b9c5c();
    }
  }
  return local_1c;
}



undefined4 FUN_00483770(short *param_1)

{
  undefined4 uVar1;
  
  if (*param_1 < 0) {
    *param_1 = 0x14;
  }
  else if ((*param_1 < 5) || (1000 < *param_1)) {
    printf("passive dwell not in range %d\n",(int)*param_1);
    return 0xffffffff;
  }
  if (param_1[1] < 0) {
    param_1[1] = 10;
  }
  else if ((param_1[1] < 10) || (1000 < param_1[1])) {
    printf("active dwell not in range %d\n",(int)param_1[1]);
    return 0xffffffff;
  }
  if (param_1[2] < 0) {
    param_1[2] = 300;
  }
  else if ((param_1[2] < 10) || (900 < param_1[2])) {
    printf("Width Trigger Scan Interval not in range %d\n",(int)param_1[2]);
    return 0xffffffff;
  }
  if (param_1[5] < 0) {
    param_1[5] = 5;
  }
  else if ((param_1[5] < 5) || (100 < param_1[5])) {
    printf("Width Channel Transition Delay Factor not in range %d\n",(int)param_1[5]);
    return 0xffffffff;
  }
  if (param_1[3] < 0) {
    param_1[3] = 200;
  }
  else if ((param_1[3] < 200) || (10000 < param_1[3])) {
    printf("Passive Total per Channel not in range %d\n",(int)param_1[3]);
    return 0xffffffff;
  }
  if (param_1[4] < 0) {
    param_1[4] = 0x14;
  }
  if ((param_1[4] < 0x14) || (10000 < param_1[4])) {
    printf("Active Total per Channel not in range %d\n",(int)param_1[4]);
    uVar1 = 0xffffffff;
  }
  else {
    if (param_1[6] < 0) {
      param_1[6] = 0x19;
    }
    else if ((param_1[6] < 0) || (100 < param_1[6])) {
      printf("Activity Threshold not in range %d\n",(int)param_1[6]);
      return 0xffffffff;
    }
    uVar1 = 0;
  }
  return uVar1;
}



int FUN_00483ac0(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  ushort uVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  undefined *__dest;
  ulong uVar6;
  size_t local_40;
  int local_3c;
  uint local_18;
  ushort local_14;
  uint *local_10 [2];
  
  local_10[0] = (uint *)0x0;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    puVar1 = local_10[0];
    if (-1 < iVar4) {
      if (DAT_00557704 == '\0') {
        uVar5 = *local_10[0];
        uVar2 = (ushort)local_10[0][1];
      }
      else {
        uVar5 = *local_10[0];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        uVar2 = (ushort)local_10[0][1] << 8 | (ushort)local_10[0][1] >> 8;
      }
      printf("Period (msec) :%d\nLength        :%d\nPacket        :0x",uVar5,(uint)uVar2);
      for (local_3c = 0; local_3c < (int)(uint)(ushort)puVar1[1]; local_3c = local_3c + 1) {
        printf("%02x",(uint)*(byte *)((int)puVar1 + local_3c + 6));
      }
      putchar(10);
    }
  }
  else {
    local_40 = strlen("keep_alive");
    strncpy(PTR_DAT_00551644,"keep_alive",local_40);
    PTR_DAT_00551644[local_40] = 0;
    __dest = PTR_DAT_00551644 + local_40 + 1;
    if (DAT_00557704 == '\0') {
      local_18 = strtoul((char *)*piVar3,(char **)0x0,0);
    }
    else {
      uVar6 = strtoul((char *)*piVar3,(char **)0x0,0);
      local_18 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    if (local_18 == 0) {
      local_14 = 0;
      local_40 = local_40 + 9;
    }
    else {
      piVar3 = (int *)(param_3 + 8);
      if (*piVar3 == 0) {
        local_14 = 0;
        local_40 = local_40 + 7;
      }
      else {
        if (DAT_00557704 == '\0') {
          iVar4 = FUN_0043dc20((char *)*piVar3,(int)(__dest + 6));
          local_14 = (ushort)iVar4;
        }
        else {
          iVar4 = FUN_0043dc20((char *)*piVar3,(int)(__dest + 6));
          local_14 = (ushort)iVar4 << 8 | (ushort)iVar4 >> 8;
        }
        local_40 = local_14 + local_40 + 7;
      }
    }
    memcpy(__dest,&local_18,6);
    iVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_40);
  }
  return iVar4;
}



int FUN_00483ee0(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  int iVar1;
  ushort uVar2;
  char *__s;
  int *piVar3;
  int iVar4;
  ulong uVar5;
  uint uVar6;
  undefined *__dest;
  size_t local_50;
  int local_4c;
  int local_48;
  undefined2 local_1c;
  undefined2 local_1a;
  uint local_18;
  ushort local_14;
  undefined1 local_12;
  int local_10;
  uint local_c;
  
  local_10 = 0;
  memset(&local_1c,0,0xc);
  __s = (char *)*param_3;
  piVar3 = param_3 + 1;
  if (*piVar3 == 0) {
    iVar4 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_c = strtoul((char *)*piVar3,(char **)0x0,0);
    }
    else {
      uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
      local_c = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    piVar3 = param_3 + 2;
    if (*piVar3 == 0) {
      iVar4 = FUN_00445198(param_1,(char *)*param_2,&local_c,4,&local_10);
      iVar1 = local_10;
      if (-1 < iVar4) {
        if (DAT_00557704 == '\0') {
          uVar6 = *(uint *)(local_10 + 4);
          uVar2 = *(ushort *)(local_10 + 8);
        }
        else {
          uVar6 = *(uint *)(local_10 + 4);
          uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
          uVar2 = *(ushort *)(local_10 + 8) << 8 | *(ushort *)(local_10 + 8) >> 8;
        }
        printf("Id            :%d\nPeriod (msec) :%d\nLength        :%d\nPacket        :0x",
               (uint)*(byte *)(local_10 + 10),uVar6,(uint)uVar2);
        for (local_48 = 0; local_48 < (int)(uint)*(ushort *)(iVar1 + 8); local_48 = local_48 + 1) {
          printf("%02x",(uint)*(byte *)(iVar1 + local_48 + 0xb));
        }
        putchar(10);
      }
    }
    else {
      local_50 = strlen(__s);
      strncpy(PTR_DAT_00551644,__s,local_50);
      PTR_DAT_00551644[local_50] = 0;
      __dest = PTR_DAT_00551644 + local_50 + 1;
      if (DAT_00557704 == '\0') {
        local_18 = strtoul((char *)*piVar3,(char **)0x0,0);
      }
      else {
        uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
        local_18 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      if (DAT_00557704 == '\0') {
        local_1c = 1;
        local_1a = 0xb;
      }
      else {
        local_1c = 0x100;
        local_1a = 0xb00;
      }
      local_12 = (undefined1)local_c;
      local_4c = 0;
      local_50 = local_50 + 0xc;
      if ((local_18 != 0) && (param_3[3] != 0)) {
        local_4c = FUN_0043dc20((char *)param_3[3],(int)(__dest + 0xb));
        local_50 = local_50 + local_4c;
      }
      local_14 = (ushort)local_4c;
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 8 | local_14 >> 8;
      }
      memcpy(__dest,&local_1c,0xb);
      iVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_50);
    }
  }
  return iVar4;
}



void FUN_00484454(void)

{
  uint local_10;
  
  puts("Names accepted for base offsets:");
  for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
    printf("\t%s\n",(&PTR_s_START_00555fb4)[local_10 * 2]);
  }
  return;
}



uint FUN_004844e0(char *param_1)

{
  char cVar1;
  int iVar2;
  uint uVar3;
  uint local_20;
  char *local_1c;
  char *local_18;
  
  for (local_20 = 0; local_20 < 0x10; local_20 = local_20 + 1) {
    local_18 = param_1;
    for (local_1c = (&PTR_s_START_00555fb4)[local_20 * 2];
        (*local_18 != '\0' && (cVar1 = *local_1c, iVar2 = toupper((int)*local_18), cVar1 == iVar2));
        local_1c = local_1c + 1) {
      local_18 = local_18 + 1;
    }
    if ((*local_18 == '\0') && (*local_1c == '\0')) break;
  }
  if (local_20 < 0x10) {
    uVar3 = (uint)*(ushort *)(&DAT_00555fb8 + local_20 * 8);
  }
  else {
    uVar3 = 0xffffffff;
  }
  return uVar3;
}



undefined * FUN_00484624(ushort param_1)

{
  uint local_10;
  
  local_10 = 0;
  while( true ) {
    if (0xf < local_10) {
      sprintf(&DAT_00559b18,"%d",(uint)param_1);
      return &DAT_00559b18;
    }
    if (param_1 == *(ushort *)(&DAT_00555fb8 + local_10 * 8)) break;
    local_10 = local_10 + 1;
  }
  return (&PTR_s_START_00555fb4)[local_10 * 2];
}



undefined4 FUN_004846e8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  ulong uVar3;
  uint local_14;
  uint local_10;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    puts("No args provided");
    uVar2 = 0xffffffd4;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_14 = strtoul((char *)*piVar1,(char **)0x0,0);
    }
    else {
      uVar3 = strtoul((char *)*piVar1,(char **)0x0,0);
      local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    piVar1 = (int *)(param_3 + 8);
    if (*piVar1 == 0) {
      puts("Enable/disable value not provided");
      uVar2 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_10 = strtoul((char *)*piVar1,(char **)0x0,0);
      }
      else {
        uVar3 = strtoul((char *)*piVar1,(char **)0x0,0);
        local_10 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      uVar2 = FUN_00445444(param_1,(char *)*param_2,&local_14,8);
    }
  }
  return uVar2;
}



undefined4 FUN_004848d8(int *param_1,undefined4 param_2,int param_3)

{
  byte bVar1;
  ushort uVar2;
  undefined2 uVar3;
  size_t sVar4;
  undefined *__dest;
  int iVar5;
  undefined4 uVar6;
  int *piVar7;
  ulong uVar8;
  uint param1;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int *local_res8;
  size_t local_98;
  ulong local_94;
  undefined *local_8c;
  char *local_88;
  int local_84;
  uint local_2c;
  uint local_28;
  uint local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined2 local_18;
  undefined2 local_16;
  char *local_10;
  char acStack_c [2];
  undefined1 local_a;
  
  sVar4 = strlen("pkt_filter_add");
  strncpy(PTR_DAT_00551644,"pkt_filter_add",sVar4);
  PTR_DAT_00551644[sVar4] = 0;
  local_98 = sVar4 + 1;
  __dest = PTR_DAT_00551644 + sVar4 + 1;
  if ((*(int *)(param_3 + 4) == 0) || (iVar5 = strcmp(*(char **)(param_3 + 4),"-l"), iVar5 != 0)) {
    piVar7 = (int *)(param_3 + 4);
    if (*piVar7 == 0) {
      puts("No args provided");
      uVar6 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_2c = strtoul((char *)*piVar7,&local_10,0);
      }
      else {
        uVar8 = strtoul((char *)*piVar7,&local_10,0);
        local_2c = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18;
      }
      if (*local_10 == '\0') {
        piVar7 = (int *)(param_3 + 8);
        if (*piVar7 == 0) {
          puts("Polarity not provided");
          uVar6 = 0xffffffd4;
        }
        else {
          if (DAT_00557704 == '\0') {
            local_24 = strtoul((char *)*piVar7,&local_10,0);
          }
          else {
            uVar8 = strtoul((char *)*piVar7,&local_10,0);
            local_24 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                       uVar8 >> 0x18;
          }
          if (*local_10 == '\0') {
            local_res8 = (int *)(param_3 + 0xc);
            if (*local_res8 == 0) {
              puts("Filter type not provided");
              uVar6 = 0xffffffd4;
            }
            else {
              if (DAT_00557704 == '\0') {
                local_28 = strtoul((char *)*local_res8,&local_10,0);
              }
              else {
                uVar8 = strtoul((char *)*local_res8,&local_10,0);
                local_28 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                           uVar8 >> 0x18;
              }
              if (DAT_00557704 == '\0') {
                param1 = strtoul((char *)*local_res8,&local_10,0);
              }
              else {
                uVar8 = strtoul((char *)*local_res8,&local_10,0);
                param1 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                         uVar8 >> 0x18;
              }
              if (*local_10 == '\0') {
                if (((param1 == 0) || (param1 == 2)) || (param1 == 4)) {
                  local_28 = param1;
                  if (DAT_00557704 != '\0') {
                    local_28 = param1 << 0x18 | (param1 & 0xff00) << 8 | (param1 & 0xff0000) >> 8 |
                               param1 >> 0x18;
                  }
                  if ((param1 == 0) || (param1 == 1)) {
                    piVar7 = (int *)(param_3 + 0x10);
                    if (*piVar7 == 0) {
                      puts("Offset not provided");
                      return 0xffffffd4;
                    }
                    if (DAT_00557704 == '\0') {
                      local_20 = strtoul((char *)*piVar7,&local_10,0);
                    }
                    else {
                      uVar8 = strtoul((char *)*piVar7,&local_10,0);
                      local_20 = uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 |
                                 uVar8 >> 0x18;
                    }
                    if (*local_10 != '\0') {
                      printf("Invalid number for offset: %s\n",(char *)*piVar7);
                      return 0xffffffd4;
                    }
                    piVar7 = (int *)(param_3 + 0x14);
                    if (*piVar7 == 0) {
                      puts("Bitmask not provided");
                      return 0xffffffd4;
                    }
                    uVar9 = FUN_0043dc20((char *)*piVar7,(int)(__dest + 0x14));
                    if (uVar9 == 0xffffffff) {
                      printf("Rejecting: %s\n",(char *)*piVar7);
                      return 0xffffffd4;
                    }
                    uVar10 = uVar9;
                    if (DAT_00557704 != '\0') {
                      uVar10 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 |
                               uVar9 >> 0x18;
                    }
                    local_res8 = (int *)(param_3 + 0x18);
                    if (*local_res8 == 0) {
                      puts("Pattern not provided");
                      return 0xffffffd4;
                    }
                    uVar9 = FUN_0043dc20((char *)*local_res8,(int)(__dest + uVar9 + 0x14));
                    if (uVar9 == 0xffffffff) {
                      printf("Rejecting: %s\n",(char *)*local_res8);
                      return 0xffffffd4;
                    }
                    uVar11 = uVar9;
                    if (DAT_00557704 != '\0') {
                      uVar11 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 |
                               uVar9 >> 0x18;
                    }
                    if (uVar10 != uVar11) {
                      puts("Mask and pattern not the same size");
                      return 0xffffffd4;
                    }
                    local_98 = uVar9 * 2 + sVar4 + 0x15;
                    local_1c = uVar10;
                    memcpy(__dest,&local_2c,0x14);
                  }
                  if (param1 == 2) {
                    bVar1 = 0;
                    local_8c = __dest + 0x10;
                    while (piVar7 = local_res8 + 1, *piVar7 != 0) {
                      if ((*(ushort *)(__ctype_b + *(char *)*piVar7 * 2) & 8) == 0) {
                        local_10 = strchr((char *)*piVar7,0x3a);
                        if (local_10 == (char *)0x0) {
                          printf("Invalid [base:]offset format: %s\n",(char *)*piVar7);
                          return 0xffffffd4;
                        }
                        *local_10 = '\0';
                        local_94 = FUN_004844e0((char *)*piVar7);
                        if (local_94 == 0xffffffff) {
                          printf("Invalid base %s\n",(char *)*piVar7);
                          FUN_00484454();
                          return 0xffffffd4;
                        }
                        *local_10 = ':';
                      }
                      else {
                        local_94 = strtoul((char *)*piVar7,&local_10,0);
                      }
                      if (*local_10 == ':') {
                        local_1c._2_2_ = (ushort)local_94;
                        if (DAT_00557704 != '\0') {
                          local_1c._2_2_ = local_1c._2_2_ << 8 | local_1c._2_2_ >> 8;
                        }
                        local_94 = strtoul(local_10 + 1,&local_10,0);
                      }
                      else {
                        local_1c._2_2_ = 0;
                      }
                      if (*local_10 != '\0') {
                        printf("Invalid [base:]offset format: %s\n",(char *)*piVar7);
                        return 0xffffffd4;
                      }
                      if (0xffff < (int)local_94) {
                        puts("Offset too large");
                        return 0xffffffd4;
                      }
                      uVar2 = (ushort)local_94;
                      if (DAT_00557704 != '\0') {
                        uVar2 = uVar2 << 8 | uVar2 >> 8;
                      }
                      local_1c = CONCAT22(local_1c._2_2_,uVar2);
                      local_16 = 0;
                      piVar7 = local_res8 + 2;
                      if (*piVar7 == 0) {
                        puts("Bitmask not provided");
                        return 0xffffffd4;
                      }
                      uVar9 = FUN_0043dc20((char *)*piVar7,(int)(local_8c + 8));
                      if (uVar9 == 0xffffffff) {
                        printf("Rejecting: %s\n",(char *)*piVar7);
                        return 0xffffffd4;
                      }
                      if (DAT_00557704 == '\0') {
                        uVar10 = uVar9 & 0xffff;
                      }
                      else {
                        uVar10 = (uint)(ushort)((ushort)uVar9 << 8 | (ushort)uVar9 >> 8);
                      }
                      local_res8 = local_res8 + 3;
                      if (*local_res8 == 0) {
                        puts("Pattern not provided");
                        return 0xffffffd4;
                      }
                      if (*(char *)*local_res8 == '!') {
                        if (DAT_00557704 == '\0') {
                          local_16 = 1;
                        }
                        else {
                          local_16 = 0x100;
                        }
                        *local_res8 = *local_res8 + 1;
                      }
                      if (*(char *)*local_res8 == '\0') {
                        puts("Pattern not provided");
                        return 0xffffffd4;
                      }
                      uVar9 = FUN_0043dc20((char *)*local_res8,(int)(local_8c + uVar9 + 8));
                      if (uVar9 == 0xffffffff) {
                        printf("Rejecting: %s\n",(char *)*local_res8);
                        return 0xffffffd4;
                      }
                      if (DAT_00557704 == '\0') {
                        uVar11 = uVar9 & 0xffff;
                      }
                      else {
                        uVar11 = (uint)(ushort)((ushort)uVar9 << 8 | (ushort)uVar9 >> 8);
                      }
                      if (uVar10 != uVar11) {
                        puts("Mask and pattern not the same size");
                        return 0xffffffd4;
                      }
                      local_18 = (undefined2)uVar10;
                      local_98 = uVar9 * 2 + local_98 + 8;
                      memcpy(local_8c,&local_1c,8);
                      local_8c = local_8c + uVar9 * 2 + 8;
                      bVar1 = bVar1 + 1;
                    }
                    local_98 = local_98 + 0x10;
                    local_20 = CONCAT22((((short)PTR_DAT_00551644 + (short)local_98) - (short)__dest
                                        ) + -0xc,(ushort)bVar1);
                    memcpy(__dest,&local_2c,0x10);
                    local_res8 = piVar7;
                  }
                  if (param1 == 4) {
                    local_88 = (char *)local_res8[1];
                    sVar4 = strlen(local_88);
                    if ((sVar4 & 1) != 0) {
                      printf("Invalid APF program length: %s\n",(char *)local_res8[1]);
                      return 0xffffffd4;
                    }
                    local_84 = 0;
                    for (; *local_88 != '\0'; local_88 = local_88 + 2) {
                      strncpy(acStack_c,local_88,2);
                      local_a = 0;
                      uVar8 = strtoul(acStack_c,(char **)0x0,0x10);
                      *(char *)((int)(__dest + 0xc) + local_84 + 8) = (char)uVar8;
                      local_84 = local_84 + 1;
                    }
                    uVar2 = (ushort)local_84;
                    if (DAT_00557704 != '\0') {
                      uVar2 = uVar2 << 8 | uVar2 >> 8;
                    }
                    *(ushort *)(__dest + 0xe) = uVar2;
                    if (DAT_00557704 == '\0') {
                      uVar3 = 1;
                    }
                    else {
                      uVar3 = 0x100;
                    }
                    *(undefined2 *)(__dest + 0xc) = uVar3;
                    local_98 = *(ushort *)(__dest + 0xe) + local_98 + 0x14;
                    memcpy(__dest,&local_2c,0xc);
                  }
                  uVar6 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_98);
                }
                else {
                  printf("Invalid filter type %d\n",param1);
                  uVar6 = 0xffffffd4;
                }
              }
              else {
                printf("Invalid number for filter type: %s\n",(char *)*local_res8);
                uVar6 = 0xffffffd4;
              }
            }
          }
          else {
            printf("Invalid number for polarity: %s\n",(char *)*piVar7);
            uVar6 = 0xffffffd4;
          }
        }
      }
      else {
        printf("Invalid number for id: %s\n",(char *)*piVar7);
        uVar6 = 0xffffffd4;
      }
    }
  }
  else {
    FUN_00484454();
    uVar6 = 0;
  }
  return uVar6;
}



void FUN_00485a8c(int param_1,uint param_2,char *param_3)

{
  uint local_10;
  
  printf("%sMask        :0x",param_3);
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    printf("%02x",(uint)*(byte *)(param_1 + local_10));
  }
  printf("\n%sPattern     :0x",param_3);
  for (; local_10 < param_2 << 1; local_10 = local_10 + 1) {
    printf("%02x",(uint)*(byte *)(param_1 + local_10));
  }
  puts("\n");
  return;
}



int FUN_00485b98(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  int iVar5;
  ulong uVar6;
  uint uVar7;
  uint *puVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  char *param2;
  ushort uVar12;
  uint uVar13;
  uint *local_90;
  uint local_8c;
  uint local_88;
  int local_80;
  uint *local_7c;
  uint *local_78;
  uint *local_10;
  uint local_c;
  
  local_10 = (uint *)0x0;
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    puts("No args provided");
    iVar5 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_c = strtoul((char *)*piVar4,(char **)0x0,0);
    }
    else {
      uVar6 = strtoul((char *)*piVar4,(char **)0x0,0);
      local_c = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    iVar5 = FUN_00445198(param_1,(char *)*param_2,&local_c,4,&local_10);
    puVar1 = local_10;
    if (-1 < iVar5) {
      printf("Num filters: %d\n\n",*local_10);
      local_90 = puVar1 + 1;
      for (local_8c = 0; local_8c < *puVar1; local_8c = local_8c + 1) {
        if (DAT_00557704 == '\0') {
          uVar7 = local_90[1];
        }
        else {
          uVar7 = local_90[1];
          uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
        }
        if (uVar7 == 4) {
          puVar8 = local_90 + 3;
          local_7c = local_90 + 5;
          if (DAT_00557704 == '\0') {
            uVar2 = *(ushort *)((int)local_90 + 0xe);
            uVar3 = (ushort)*puVar8;
          }
          else {
            uVar2 = *(ushort *)((int)local_90 + 0xe) << 8 | *(ushort *)((int)local_90 + 0xe) >> 8;
            uVar3 = (ushort)*puVar8 << 8 | (ushort)*puVar8 >> 8;
          }
          if (uVar3 != 1) {
            if (DAT_00557704 == '\0') {
              uVar2 = (ushort)*puVar8;
            }
            else {
              uVar2 = (ushort)*puVar8 << 8 | (ushort)*puVar8 >> 8;
            }
            printf("%s: APF: incorrect version, version=%d, expected version=%d\n",
                   "wl_pkt_filter_list",(uint)uVar2,1);
            return -2;
          }
          if (DAT_00557704 == '\0') {
            uVar7 = *local_90;
            uVar9 = local_90[2];
            uVar10 = local_90[1];
          }
          else {
            uVar7 = *local_90;
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
            uVar9 = local_90[2];
            uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
            uVar10 = local_90[1];
            uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                     uVar10 >> 0x18;
          }
          printf("Id          :%d\nNegate      :%d\nType        :%d\nProgram len :%d\n",uVar7,uVar9,
                 uVar10,(uint)uVar2);
          printf("Program     :");
          for (local_88 = 0; (local_7c != (uint *)0x0 && (local_88 < uVar2));
              local_88 = local_88 + 1) {
            printf("%02X",(uint)(byte)*local_7c);
            local_7c = (uint *)((int)local_7c + 1);
          }
          puts("\n");
          local_80 = *(ushort *)((int)local_90 + 0xe) + 8;
        }
        else if (uVar7 == 2) {
          uVar7 = local_90[3];
          local_78 = local_90 + 4;
          if (DAT_00557704 == '\0') {
            uVar9 = *local_90;
            uVar10 = local_90[2];
            uVar11 = local_90[1];
          }
          else {
            uVar9 = *local_90;
            uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
            uVar10 = local_90[2];
            uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                     uVar10 >> 0x18;
            uVar11 = local_90[1];
            uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                     uVar11 >> 0x18;
          }
          printf("Id          :%d\nNegate      :%d\nType        :%d\nList count  :%d\n",uVar9,uVar10
                 ,uVar11,(uint)(byte)uVar7);
          for (local_88 = 1; local_88 <= (byte)uVar7; local_88 = local_88 + 1) {
            printf("%sPattern %d\n","    ",local_88);
            if (DAT_00557704 == '\0') {
              uVar2 = *(ushort *)((int)local_78 + 2);
            }
            else {
              uVar2 = *(ushort *)((int)local_78 + 2) << 8 | *(ushort *)((int)local_78 + 2) >> 8;
            }
            param2 = FUN_00484624(uVar2);
            if (DAT_00557704 == '\0') {
              uVar2 = (ushort)*local_78;
            }
            else {
              uVar2 = (ushort)*local_78 << 8 | (ushort)*local_78 >> 8;
            }
            if (DAT_00557704 == '\0') {
              uVar3 = *(ushort *)((int)local_78 + 6);
            }
            else {
              uVar3 = *(ushort *)((int)local_78 + 6) << 8 | *(ushort *)((int)local_78 + 6) >> 8;
            }
            if (DAT_00557704 == '\0') {
              uVar12 = (ushort)local_78[1];
            }
            else {
              uVar12 = (ushort)local_78[1] << 8 | (ushort)local_78[1] >> 8;
            }
            printf("%sOffset      :%s:%d\n%sMatch flags :%04x\n%sPattern len :%d\n","    ",param2,
                   (uint)uVar2,"    ",(uint)uVar3,"    ",(uint)uVar12);
            if (DAT_00557704 == '\0') {
              uVar2 = (ushort)local_78[1];
            }
            else {
              uVar2 = (ushort)local_78[1] << 8 | (ushort)local_78[1] >> 8;
            }
            FUN_00485a8c((int)(local_78 + 2),(uint)uVar2,&DAT_0051f228);
            if (DAT_00557704 == '\0') {
              uVar2 = (ushort)local_78[1];
            }
            else {
              uVar2 = (ushort)local_78[1] << 8 | (ushort)local_78[1] >> 8;
            }
            local_78 = (uint *)((int)local_78 + (uint)uVar2 * 2 + 8);
          }
          local_80 = (int)local_78 - (int)(local_90 + 3);
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar9 = *local_90;
            uVar10 = local_90[2];
            uVar7 = local_90[1];
            uVar11 = local_90[3];
            uVar13 = local_90[4];
          }
          else {
            uVar7 = *local_90;
            uVar9 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
            uVar7 = local_90[2];
            uVar10 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18
            ;
            uVar7 = local_90[1];
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
            uVar11 = local_90[3];
            uVar11 = uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 |
                     uVar11 >> 0x18;
            uVar13 = local_90[4];
            uVar13 = uVar13 << 0x18 | (uVar13 & 0xff00) << 8 | (uVar13 & 0xff0000) >> 8 |
                     uVar13 >> 0x18;
          }
          printf("Id          :%d\nNegate      :%d\nType        :%d\nOffset      :%d\nPattern len :%d\n"
                 ,uVar9,uVar10,uVar7,uVar11,uVar13);
          if (DAT_00557704 == '\0') {
            uVar7 = local_90[4];
          }
          else {
            uVar7 = local_90[4];
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
          }
          FUN_00485a8c((int)(local_90 + 5),uVar7,&DAT_004e4a88);
          if (DAT_00557704 == '\0') {
            uVar7 = local_90[4];
          }
          else {
            uVar7 = local_90[4];
            uVar7 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
          }
          local_80 = (uVar7 + 4) * 2;
        }
        local_90 = (uint *)((int)local_90 + local_80 + 0xf & 0xfffffffc);
      }
    }
  }
  return iVar5;
}



int FUN_004868bc(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  ulong uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint local_10;
  uint *local_c;
  
  local_c = (uint *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    puts("No args provided");
    iVar2 = -0x2c;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10 = strtoul((char *)*piVar1,(char **)0x0,0);
    }
    else {
      uVar3 = strtoul((char *)*piVar1,(char **)0x0,0);
      local_10 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    iVar2 = FUN_00445198(param_1,(char *)*param_2,&local_10,4,&local_c);
    if (-1 < iVar2) {
      if (DAT_00557704 == '\0') {
        uVar4 = *local_c;
        uVar5 = local_c[2];
        uVar6 = local_c[1];
      }
      else {
        uVar4 = *local_c;
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        uVar5 = local_c[2];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        uVar6 = local_c[1];
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
      }
      printf("Packets matched for filter \'%d\': %d\nTotal packets discarded        : %d\nTotal packet forwarded         : %d\n"
             ,local_10,uVar4,uVar5,uVar6);
    }
  }
  return iVar2;
}



int FUN_00486b60(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  ushort uVar3;
  ushort uVar4;
  int iVar5;
  ulong uVar6;
  size_t __n;
  int *local_res8;
  int local_38;
  ushort local_34;
  byte *local_10;
  char *local_c;
  
  puVar2 = PTR_DAT_00551644;
  local_c = (char *)0x0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    iVar5 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_10);
    if (iVar5 == 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(local_10 + 2);
      }
      else {
        uVar3 = *(ushort *)(local_10 + 2) << 8 | *(ushort *)(local_10 + 2) >> 8;
      }
      if (*local_10 == 0) {
        if (local_10[1] == 0) {
          if (uVar3 < 0x81) {
            printf("Port count %d:\n",(uint)uVar3);
            for (local_38 = 0; local_38 < (int)(uint)uVar3; local_38 = local_38 + 1) {
              if (DAT_00557704 == '\0') {
                uVar4 = *(ushort *)(local_10 + local_38 * 2 + 4);
              }
              else {
                uVar4 = *(ushort *)(local_10 + local_38 * 2 + 4) << 8 |
                        *(ushort *)(local_10 + local_38 * 2 + 4) >> 8;
              }
              printf("%d\n",(uint)uVar4);
            }
            iVar5 = 0;
          }
          else {
            printf("Invalid count %d\n",(uint)uVar3);
            iVar5 = -0x2c;
          }
        }
        else {
          printf("Format error: nonzero reserved element 0x%02x\n",(uint)local_10[1]);
          iVar5 = -0x2c;
        }
      }
      else {
        printf("Unsupported version %d, only support %d\n",(uint)*local_10,0);
        iVar5 = -0x2c;
      }
    }
  }
  else {
    *PTR_DAT_00551644 = 0;
    puVar2[1] = 0;
    local_34 = 0;
    while( true ) {
      if ((*local_res8 == 0) || (0x7f < local_34)) goto LAB_00486f3c;
      uVar6 = strtoul((char *)*local_res8,&local_c,0);
      if ((*local_c != '\0') || (0xffff < uVar6)) break;
      uVar3 = (ushort)uVar6;
      if (DAT_00557704 != '\0') {
        uVar3 = uVar3 << 8 | uVar3 >> 8;
      }
      *(ushort *)(puVar2 + (uint)local_34 * 2 + 4) = uVar3;
      local_34 = local_34 + 1;
      local_res8 = local_res8 + 1;
    }
    iVar5 = strcmp((char *)*local_res8,"none");
    if (iVar5 != 0) {
      printf("Bad port number %s\n",(char *)*local_res8);
      return -0x2c;
    }
    local_res8 = local_res8 + 1;
LAB_00486f3c:
    if (*local_res8 == 0) {
      uVar3 = local_34;
      if (DAT_00557704 != '\0') {
        uVar3 = local_34 << 8 | local_34 >> 8;
      }
      *(ushort *)(puVar2 + 2) = uVar3;
      __n = (local_34 + 2) * 2;
      memmove(PTR_DAT_00551644 + 0x11,PTR_DAT_00551644,__n);
      puVar2 = PTR_DAT_00551644;
      *(undefined4 *)PTR_DAT_00551644 = 0x5f746b70;
      pcVar1 = puVar2 + 4;
      pcVar1[0] = 'f';
      pcVar1[1] = 'i';
      pcVar1[2] = 'l';
      pcVar1[3] = 't';
      pcVar1 = puVar2 + 8;
      pcVar1[0] = 'e';
      pcVar1[1] = 'r';
      pcVar1[2] = '_';
      pcVar1[3] = 'p';
      pcVar1 = puVar2 + 0xc;
      pcVar1[0] = 'o';
      pcVar1[1] = 'r';
      pcVar1[2] = 't';
      pcVar1[3] = 's';
      puVar2[0x10] = '\0';
      iVar5 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0x11);
    }
    else {
      puts("Too many port numbers!");
      iVar5 = -0x2c;
    }
  }
  return iVar5;
}



int FUN_00487090(int *param_1,undefined4 *param_2)

{
  undefined *param0;
  int iVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  uint local_58;
  uint local_54;
  uint local_50;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  ushort local_10;
  ushort local_e;
  void *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar1 == 0) {
    memcpy(&local_58,local_c,0x4c);
    if (DAT_00557704 != '\0') {
      local_54 = local_54 << 0x18 | (local_54 & 0xff00) << 8 | (local_54 & 0xff0000) >> 8 |
                 local_54 >> 0x18;
    }
    iVar1 = sprintf(param0,"%s %u ","aftx",local_54);
    pcVar2 = param0 + iVar1;
    if (DAT_00557704 != '\0') {
      local_58 = local_58 << 0x18 | (local_58 & 0xff00) << 8 | (local_58 & 0xff0000) >> 8 |
                 local_58 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","afrx",local_58);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_50 = local_50 << 0x18 | (local_50 & 0xff00) << 8 | (local_50 & 0xff0000) >> 8 |
                 local_50 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","datatx",local_50);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_4c = local_4c << 0x18 | (local_4c & 0xff00) << 8 | (local_4c & 0xff0000) >> 8 |
                 local_4c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","datarx",local_4c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                 local_48 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","txdrop",local_48);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_44 = local_44 << 0x18 | (local_44 & 0xff00) << 8 | (local_44 & 0xff0000) >> 8 |
                 local_44 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","rxdrop",local_44);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_40 = local_40 << 0x18 | (local_40 & 0xff00) << 8 | (local_40 & 0xff0000) >> 8 |
                 local_40 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","monrx",local_40);
    if (DAT_00557704 != '\0') {
      local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                 local_28 >> 0x18;
    }
    iVar3 = sprintf(pcVar2 + iVar1,"%s %u ","txsupr",local_28);
    pcVar2 = pcVar2 + iVar1 + iVar3;
    *pcVar2 = '\n';
    pcVar2[1] = '\0';
    pcVar2 = pcVar2 + 1;
    if (DAT_00557704 != '\0') {
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","afrxdrop",local_24);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_3c = local_3c << 0x18 | (local_3c & 0xff00) << 8 | (local_3c & 0xff0000) >> 8 |
                 local_3c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","lostmaster",local_3c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                 local_38 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","misalign",local_38);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                 local_30 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aw_dur",local_30);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                 local_34 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aws",local_34);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","rx80211",local_18);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","awdrop",local_20);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","noawchansw",local_1c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                 local_2c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","debug",local_2c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","peeropdrop",local_14);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 == '\0') {
      uVar4 = (uint)local_10;
    }
    else {
      uVar4 = (uint)local_10 << 0x18 | (local_10 & 0xff00) << 8;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","chancal",uVar4);
    if (DAT_00557704 == '\0') {
      uVar4 = (uint)local_e;
    }
    else {
      uVar4 = (uint)local_e << 0x18 | (local_e & 0xff00) << 8;
    }
    iVar3 = sprintf(pcVar2 + iVar1,"%s %u ","nopreawint",uVar4);
    pcVar2 = pcVar2 + iVar1 + iVar3;
    *pcVar2 = '\n';
    pcVar2[1] = '\0';
    pcVar2[1] = '\n';
    pcVar2[2] = '\0';
    fputs(PTR_DAT_00551644,stdout);
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_00487ee0(int *param_1,undefined4 *param_2)

{
  undefined *param0;
  int iVar1;
  char *pcVar2;
  int iVar3;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  void *local_c;
  
  param0 = PTR_DAT_00551644;
  iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (iVar1 == 0) {
    memcpy(&local_38,local_c,0x2c);
    if (DAT_00557704 != '\0') {
      local_38 = local_38 << 0x18 | (local_38 & 0xff00) << 8 | (local_38 & 0xff0000) >> 8 |
                 local_38 >> 0x18;
    }
    iVar1 = sprintf(param0,"%s %u ","aw_proc_in_aw_sched",local_38);
    pcVar2 = param0 + iVar1;
    if (DAT_00557704 != '\0') {
      local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                 local_34 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aw_upd_in_pre_aw_proc",local_34);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                 local_30 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","pre_aw_proc_in_aw_set",local_30);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_2c = local_2c << 0x18 | (local_2c & 0xff00) << 8 | (local_2c & 0xff0000) >> 8 |
                 local_2c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","ignore_pre_aw_proc",local_2c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                 local_28 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","miss_pre_aw_intr",local_28);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_24 = local_24 << 0x18 | (local_24 & 0xff00) << 8 | (local_24 & 0xff0000) >> 8 |
                 local_24 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aw_dur_zero",local_24);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_20 = local_20 << 0x18 | (local_20 & 0xff00) << 8 | (local_20 & 0xff0000) >> 8 |
                 local_20 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aw_sched",local_20);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_1c = local_1c << 0x18 | (local_1c & 0xff00) << 8 | (local_1c & 0xff0000) >> 8 |
                 local_1c >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","aw_proc",local_1c);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","pre_aw_proc",local_18);
    pcVar2 = pcVar2 + iVar1;
    if (DAT_00557704 != '\0') {
      local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                 local_14 >> 0x18;
    }
    iVar1 = sprintf(pcVar2,"%s %u ","not_init",local_14);
    if (DAT_00557704 != '\0') {
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
    }
    iVar3 = sprintf(pcVar2 + iVar1,"%s %u ","null_awdl",local_10);
    pcVar2 = pcVar2 + iVar1 + iVar3;
    *pcVar2 = '\n';
    pcVar2[1] = '\0';
    pcVar2[1] = '\n';
    pcVar2[2] = '\0';
    fputs(PTR_DAT_00551644,stdout);
    iVar1 = 0;
  }
  return iVar1;
}



undefined4 FUN_00488718(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  undefined1 auStack_10 [8];
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("Mac Address not set");
    uVar2 = 0xffffffff;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_10);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      uVar2 = FUN_004ba2e4(param_1,"awdl_wowl_sleeper_addr",auStack_10,6);
    }
  }
  return uVar2;
}



int FUN_004887d4(char *param_1,int param_2,int param_3)

{
  char *pcVar1;
  long lVar2;
  size_t sVar3;
  int local_20;
  char *local_1c;
  char *local_14 [2];
  
  local_14[0] = (char *)0x0;
  if (param_1 == (char *)0x0) {
    local_20 = -1;
  }
  else {
    local_20 = 0;
    local_1c = param_1;
    while (*local_1c != '\0') {
      lVar2 = strtol(local_1c,local_14,0);
      pcVar1 = local_14[0];
      if (local_14[0] == local_1c) {
        fprintf(stderr,"could not parse awseq number starting at substring \"%s\" in list:\n%s\n",
                local_1c,param_1);
        return -1;
      }
      sVar3 = strspn(local_14[0]," ,");
      local_1c = pcVar1 + sVar3;
      if (local_20 == param_3) {
        fprintf(stderr,"too many awseq (more than %d) in awseq list:\n%s\n",param_3,param_1);
        return -1;
      }
      *(short *)(param_2 + local_20 * 2) = (short)lVar2;
      local_20 = local_20 + 1;
    }
  }
  return local_20;
}



undefined4
FUN_0048893c(undefined4 param_1,undefined4 param_2,int param_3,void *param_4,uint *param_5,
            undefined4 param_6,undefined2 *param_7)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  ushort uVar4;
  int *piVar5;
  char *pcVar6;
  size_t sVar7;
  long lVar8;
  int iVar9;
  undefined3 extraout_var;
  char *__s1;
  uint uVar10;
  int *local_res8;
  size_t local_1f0;
  void *local_1ec;
  char *local_1e8;
  char local_1e4;
  undefined4 local_1e0;
  int local_1dc;
  uint local_1d8;
  uint local_1d4;
  char acStack_1b4 [64];
  char *local_174;
  uint auStack_170 [90];
  
  local_174 = (char *)0x0;
  local_1e0 = 0;
  local_1d8 = 0;
  local_1d4 = 0;
  *(undefined4 *)((int)param_4 + 0x24) = 0xffffffff;
  *(undefined1 *)((int)param_4 + 0x28) = 0xff;
  *(undefined1 *)((int)param_4 + 0x29) = 0xff;
  *(undefined1 *)((int)param_4 + 0x2a) = 0;
  *(undefined4 *)((int)param_4 + 0x2c) = 0;
  *(undefined4 *)((int)param_4 + 0x30) = 0;
  memset(auStack_170,0,0x168);
  bVar2 = false;
  local_res8 = (int *)(param_3 + 4);
  do {
    while( true ) {
      __s1 = (char *)*local_res8;
      if (__s1 == (char *)0x0) {
        if ((int)local_1d4 < 0xb) {
          if (DAT_00557704 == '\0') {
            uVar10 = *(uint *)((int)param_4 + 0x2c);
          }
          else {
            uVar10 = *(uint *)((int)param_4 + 0x2c);
            uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                     uVar10 >> 0x18;
          }
          *(uint *)((int)param_4 + 0x2c) = uVar10;
          for (local_1dc = 0; local_1dc < (int)local_1d8; local_1dc = local_1dc + 1) {
            if (DAT_00557704 == '\0') {
              uVar4 = *(ushort *)((int)param_4 + (local_1dc + 0x1c) * 2 + 4);
            }
            else {
              uVar4 = *(ushort *)((int)param_4 + (local_1dc + 0x1c) * 2 + 4);
              uVar4 = uVar4 << 8 | uVar4 >> 8;
            }
            *(ushort *)((int)param_4 + (local_1dc + 0x1c) * 2 + 4) = uVar4;
          }
          uVar10 = local_1d8;
          if (DAT_00557704 != '\0') {
            uVar10 = local_1d8 << 0x18 | (local_1d8 & 0xff00) << 8 | (local_1d8 & 0xff0000) >> 8 |
                     local_1d8 >> 0x18;
          }
          *(uint *)((int)param_4 + 0x30) = uVar10;
          for (local_1dc = 0; local_1dc < (int)local_1d4; local_1dc = local_1dc + 1) {
            if (DAT_00557704 == '\0') {
              uVar10 = auStack_170[local_1dc * 9];
            }
            else {
              uVar10 = auStack_170[local_1dc * 9];
              uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 |
                       uVar10 >> 0x18;
            }
            auStack_170[local_1dc * 9] = uVar10;
          }
          if (local_1d4 == 1) {
            local_1d4 = 0;
            memcpy(param_4,auStack_170,0x24);
          }
          if ((int)local_1d4 < 1) {
            local_1ec = (void *)((int)param_4 + (local_1d8 + 0x1c) * 2 + 4);
          }
          else {
            uVar10 = (local_1d8 + 0x1e) * 2 + 3 & 0xfffffffc;
            if (*param_5 < local_1d4 * 0x24 + uVar10) {
              fwrite("additional ssids exceed params_size\n",1,0x24,stderr);
              return 0xffffffff;
            }
            local_1ec = (void *)((int)param_4 + uVar10);
            memcpy(local_1ec,auStack_170,local_1d4 * 0x24);
            local_1ec = (void *)((int)local_1ec + local_1d4 * 0x24);
          }
          uVar10 = local_1d4;
          if (DAT_00557704 != '\0') {
            uVar10 = local_1d4 << 0x18 | (local_1d4 & 0xff00) << 8 | (local_1d4 & 0xff0000) >> 8 |
                     local_1d4 >> 0x18;
          }
          *(uint *)((int)param_4 + 0x34) = uVar10;
          *param_5 = (int)local_1ec + (local_1d4 * 0x24 - (int)param_4);
        }
        else {
          fprintf(stderr,"ssid count %d exceeds max of %d\n",local_1d4,10);
          local_1e0 = 0xffffffff;
        }
        return local_1e0;
      }
      piVar5 = local_res8 + 1;
      bVar3 = false;
      memset(acStack_1b4,0,0x40);
      local_1e4 = '\0';
      local_1e8 = __s1;
      if (!bVar2) break;
      bVar3 = true;
      local_res8 = piVar5;
LAB_00488c50:
      lVar8 = strtol(local_1e8,&local_174,0);
      cVar1 = *local_174;
      if ((((local_1e4 == 's') || (iVar9 = strcmp(acStack_1b4,"ssid"), iVar9 == 0)) || (bVar3)) &&
         (local_1d4 = FUN_0041ed48(local_1e8,(int)auStack_170,local_1d4,10), (int)local_1d4 < 0)) {
        return 0xffffffff;
      }
      if ((local_1e4 == 'p') || (iVar9 = strcmp(acStack_1b4,"pscan_type"), iVar9 == 0)) {
        iVar9 = strcmp(local_1e8,"host");
        if (iVar9 == 0) {
          *param_7 = 0;
        }
        else {
          iVar9 = strcmp(local_1e8,"fw");
          if (iVar9 == 0) {
            *param_7 = 1;
          }
          else {
            iVar9 = strcmp(local_1e8,"abort");
            if (iVar9 != 0) {
              fprintf(stderr,
                      "pscan_type value should be \"host\", \"fw\", \"abort\", but got \"%s\"\n",
                      local_1e8);
              return 0xffffffff;
            }
            *param_7 = 2;
          }
        }
      }
      if (((local_1e4 == 't') || (iVar9 = strcmp(acStack_1b4,"scan_type"), iVar9 == 0)) &&
         (iVar9 = strcmp(local_1e8,"active"), iVar9 != 0)) {
        iVar9 = strcmp(local_1e8,"passive");
        if (iVar9 != 0) {
          fprintf(stderr,"scan_type value should be \"active\", \"passive\", but got \"%s\"\n",
                  local_1e8);
          return 0xffffffff;
        }
        *(byte *)((int)param_4 + 0x2a) = *(byte *)((int)param_4 + 0x2a) | 1;
      }
      if (((local_1e4 == 'b') || (iVar9 = strcmp(acStack_1b4,"bssid"), iVar9 == 0)) &&
         (bVar3 = FUN_0041d6ac(local_1e8,(void *)((int)param_4 + 0x24)),
         CONCAT31(extraout_var,bVar3) == 0)) {
        fprintf(stderr,"could not parse \"%s\" as an ethernet MAC address\n",local_1e8);
        return 0xffffffff;
      }
      if ((local_1e4 == 'n') || (iVar9 = strcmp(acStack_1b4,"nprobes"), iVar9 == 0)) {
        if (cVar1 != '\0') {
          fprintf(stderr,"could not parse \"%s\" as an int for value nprobes\n",local_1e8);
          return 0xffffffff;
        }
        *(long *)((int)param_4 + 0x2c) = lVar8;
      }
      if ((local_1e4 == 'c') || (iVar9 = strcmp(acStack_1b4,"awseq"), iVar9 == 0)) {
        local_1d8 = FUN_004887d4(local_1e8,(int)param_4 + 0x3c,0x40);
        printf("awseq %d\n",local_1d8);
        if (local_1d8 == 0xffffffff) {
          fwrite("error parsing channel list arg\n",1,0x1f,stderr);
          return 0xffffffff;
        }
      }
      if ((local_1e4 == 'r') || (iVar9 = strcmp(acStack_1b4,"results"), iVar9 == 0)) {
        if (cVar1 != '\0') {
          fprintf(stderr,"could not parse \"%s\" result required or not\n",local_1e8);
          return 0xffffffff;
        }
        *(bool *)param_6 = lVar8 != 0;
      }
    }
    iVar9 = strcmp(__s1,"--");
    if (iVar9 != 0) {
      iVar9 = strncmp(__s1,"--",2);
      if (iVar9 == 0) {
        pcVar6 = strchr(__s1,0x3d);
        if (pcVar6 == (char *)0x0) {
          fprintf(stderr,"wl_awdl_pscan: missing \" = \" in long param \"%s\"\n",__s1);
          return 0xffffffff;
        }
        local_1f0 = (int)pcVar6 - (int)(__s1 + 2);
        if (0x3f < (int)local_1f0) {
          local_1f0 = 0x3f;
        }
        memcpy(acStack_1b4,__s1 + 2,local_1f0);
        local_res8 = piVar5;
        local_1e8 = pcVar6 + 1;
        if (pcVar6[1] == '\0') {
          fprintf(stderr,"wl_awdl_pscan: missing value after \" = \" in long param \"%s\"\n",__s1);
          return 0xffffffff;
        }
      }
      else if (*__s1 == '-') {
        local_1e4 = __s1[1];
        sVar7 = strlen(__s1);
        if (2 < sVar7) {
          fprintf(stderr,"wl_awdl_pscan: only single char options, error on param \"%s\"\n",__s1);
          return 0xffffffff;
        }
        if (*piVar5 == 0) {
          fprintf(stderr,"wl_awdl_pscan: missing value parameter after \"%s\"\n",__s1);
          return 0xffffffff;
        }
        local_res8 = local_res8 + 2;
        local_1e8 = (char *)*piVar5;
      }
      else {
        bVar3 = true;
        local_res8 = piVar5;
      }
      goto LAB_00488c50;
    }
    bVar2 = true;
    local_res8 = piVar5;
  } while( true );
}



int FUN_0048956c(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  undefined4 *__s;
  uint uVar2;
  int iVar3;
  void *__buf;
  ssize_t sVar4;
  int iVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  undefined4 uVar8;
  int local_c0;
  undefined4 *local_bc;
  undefined4 *local_b8;
  undefined4 *local_b4;
  undefined4 *local_b0;
  size_t local_68;
  ushort local_64 [2];
  sockaddr local_60;
  char acStack_4c [16];
  char local_3c [16];
  char local_2c [20];
  undefined1 auStack_18 [8];
  byte local_10;
  
  local_64[0] = 0;
  builtin_strncpy(local_2c,"eth1",5);
  local_2c[5] = 0;
  local_2c[6] = 0;
  local_2c[7] = 0;
  local_2c[8] = 0;
  local_2c[9] = 0;
  local_2c[10] = 0;
  local_2c[0xb] = 0;
  local_2c[0xc] = 0;
  local_2c[0xd] = 0;
  local_2c[0xe] = 0;
  local_2c[0xf] = 0;
  local_2c[0x10] = '\x01';
  local_bc = (undefined4 *)0x0;
  local_b8 = (undefined4 *)0x0;
  local_68 = 0x234;
  __s = (undefined4 *)malloc(0x234);
  if (__s == (undefined4 *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for scan params\n",local_68);
    local_c0 = -1;
  }
  else {
    memset(__s,0,local_68);
    local_c0 = FUN_0048893c(param_1,param_2,param_3,__s + 2,&local_68,local_2c + 0x10,local_64);
    if (local_c0 == 0) {
      if (DAT_00557704 == '\0') {
        uVar8 = 1;
      }
      else {
        uVar8 = 0x1000000;
      }
      *__s = uVar8;
      uVar1 = local_64[0];
      if (DAT_00557704 != '\0') {
        uVar1 = local_64[0] << 8 | local_64[0] >> 8;
      }
      *(ushort *)(__s + 1) = uVar1;
      uVar2 = time((time_t *)0x0);
      srand(uVar2);
      if (DAT_00557704 == '\0') {
        iVar3 = rand();
        uVar1 = (ushort)iVar3;
      }
      else {
        iVar3 = rand();
        uVar1 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      *(ushort *)((int)__s + 6) = uVar1;
      local_68 = local_68 + 8;
      local_c0 = FUN_004ba160(param_1,"awdl_pscan",__s,local_68,PTR_DAT_00551644,0x2000);
      if (local_c0 != 0) {
        printf("awdl_pscan: err = %d\n",local_c0);
      }
      if (((local_2c[0x10] != '\0') && (local_c0 == 0)) && (local_64[0] == 0)) {
        memset(acStack_4c,0,0x20);
        if (param_1 == (int *)0x0) {
          strncpy(acStack_4c,local_2c,0xf);
        }
        else {
          strncpy(acStack_4c,(char *)param_1,0xf);
        }
        memset(auStack_18,0,0x10);
        local_10 = local_10 | 0x20;
        local_c0 = FUN_004ba2e4(param_1,"event_msgs",auStack_18,0x10);
        if (local_c0 == 0) {
          iVar3 = socket(0x11,3,0x6c88);
          if (iVar3 < 0) {
            printf("Cannot create socket %d\n",iVar3);
            local_c0 = -1;
          }
          else {
            local_c0 = ioctl(iVar3,0x8933,acStack_4c);
            if (local_c0 < 0) {
              printf("Cannot get index..... %d\n",local_c0);
            }
            else {
              memset(&local_60,0,0x14);
              local_60.sa_family = 0x11;
              local_60.sa_data[0] = -0x78;
              local_60.sa_data[1] = 'l';
              local_60.sa_data[2] = local_3c[0];
              local_60.sa_data[3] = local_3c[1];
              local_60.sa_data[4] = local_3c[2];
              local_60.sa_data[5] = local_3c[3];
              local_c0 = bind(iVar3,&local_60,0x14);
              if (local_c0 < 0) {
                printf("Cannot bind %d\n",local_c0);
              }
              else {
                __buf = malloc(0x800);
                if (__buf == (void *)0x0) {
                  printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
                  local_c0 = -1;
                }
                else {
                  puts("Waiting for SCAN results through ESCAN");
                  puVar7 = local_bc;
                  puVar6 = local_b8;
LAB_00489aec:
                  while( true ) {
                    do {
                      do {
                        local_b8 = puVar6;
                        local_bc = puVar7;
                        sVar4 = recv(iVar3,__buf,0x800,0);
                        uVar2 = *(uint *)((int)__buf + 0x1c);
                        puVar7 = local_bc;
                        puVar6 = local_b8;
                      } while ((uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                               uVar2 >> 0x18) != 0x45);
                    } while (sVar4 < 1);
                    uVar2 = *(uint *)((int)__buf + 0x20);
                    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                            uVar2 >> 0x18;
                    if (uVar2 != 8) {
                      if (uVar2 == 0) {
                        for (local_b4 = local_bc; local_b4 != (undefined4 *)0x0;
                            local_b4 = (undefined4 *)*local_b4) {
                          FUN_004242c8(local_b4 + 1);
                        }
                      }
                      else {
                        printf("sync_id: %d, status:%d, misc. error/abort\n",
                               (uint)*(ushort *)((int)__buf + 0x50),uVar2);
                      }
                      goto LAB_00489f6c;
                    }
                    if ((0x7f < *(uint *)((int)__buf + 0x58)) &&
                       (*(uint *)((int)__buf + 0x58) < 0x5dd)) break;
                    fprintf(stderr,"Cannot trust bi->length %d, skipping\n",
                            *(int *)((int)__buf + 0x58));
                  }
                  for (local_b4 = local_bc; local_b4 != (undefined4 *)0x0;
                      local_b4 = (undefined4 *)*local_b4) {
                    local_b0 = local_b4 + 1;
                    iVar5 = FUN_00422974((void *)((int)__buf + 0x5c),local_b4 + 3,6);
                    if (((iVar5 == 0) &&
                        (((*(ushort *)((int)__buf + 0x9c) ^ *(ushort *)(local_b4 + 0x13)) & 0xc000)
                         == 0)) &&
                       ((*(char *)((int)__buf + 0x66) == *(char *)((int)local_b4 + 0x16) &&
                        (iVar5 = FUN_00422974((void *)((int)__buf + 0x67),
                                              (void *)((int)local_b4 + 0x17),
                                              (uint)*(byte *)((int)__buf + 0x66)), iVar5 == 0))))
                    break;
                  }
                  if (local_b4 != (undefined4 *)0x0) {
                    if (*(short *)((int)__buf + 0xa2) != 0) {
                      if ((((*(byte *)(local_b0 + 0x18) ^ *(byte *)((int)__buf + 0xb4)) & 4) == 0)
                         && ((*(short *)((int)local_b0 + 0x4e) == 0 ||
                             (*(short *)((int)local_b0 + 0x4e) < *(short *)((int)__buf + 0xa2))))) {
                        *(undefined2 *)((int)local_b0 + 0x4e) = *(undefined2 *)((int)__buf + 0xa2);
                        *(undefined2 *)(local_b0 + 0x1f) = *(undefined2 *)((int)__buf + 0xd0);
                        *(undefined1 *)(local_b0 + 0x14) = *(undefined1 *)((int)__buf + 0xa4);
                      }
                      else if (((*(byte *)((int)__buf + 0xb4) & 4) != 0) &&
                              ((*(byte *)(local_b0 + 0x18) & 4) == 0)) {
                        *(undefined2 *)((int)local_b0 + 0x4e) = *(undefined2 *)((int)__buf + 0xa2);
                        *(undefined2 *)(local_b0 + 0x1f) = *(undefined2 *)((int)__buf + 0xd0);
                        *(undefined1 *)(local_b0 + 0x14) = *(undefined1 *)((int)__buf + 0xa4);
                        *(byte *)(local_b0 + 0x18) = *(byte *)(local_b0 + 0x18) | 4;
                      }
                    }
                    goto LAB_00489aec;
                  }
                  puVar6 = (undefined4 *)malloc(*(int *)((int)__buf + 0x58) + 4);
                  if (puVar6 != (undefined4 *)0x0) {
                    *puVar6 = 0;
                    memcpy(puVar6 + 1,(void *)((int)__buf + 0x54),*(size_t *)((int)__buf + 0x58));
                    puVar7 = puVar6;
                    if (local_b8 != (undefined4 *)0x0) {
                      *local_b8 = puVar6;
                      puVar7 = local_bc;
                    }
                    goto LAB_00489aec;
                  }
                  perror("can\'t allocate memory for bss");
LAB_00489f6c:
                  local_b4 = local_bc;
                  while (local_b4 != (undefined4 *)0x0) {
                    puVar7 = (undefined4 *)*local_b4;
                    free(local_b4);
                    local_b4 = puVar7;
                  }
                  free(__buf);
                }
              }
            }
            close(iVar3);
          }
        }
      }
    }
    else {
      printf("wl_awdl_pscan_prep() failed, err = %d\n",local_c0);
    }
    free(__s);
  }
  return local_c0;
}



int FUN_00489ff4(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  int iVar5;
  size_t __n;
  undefined *__dest;
  ulong uVar6;
  ushort uVar7;
  ushort uVar8;
  undefined1 auStack_34 [6];
  undefined1 local_2e;
  undefined1 local_2d;
  ushort local_2c;
  ushort local_2a;
  ushort local_26;
  ushort local_24;
  int local_10 [2];
  
  local_10[0] = 0;
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    iVar5 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)(local_10[0] + 10);
      }
      else {
        uVar1 = *(ushort *)(local_10[0] + 10) << 8 | *(ushort *)(local_10[0] + 10) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(local_10[0] + 8);
      }
      else {
        uVar2 = *(ushort *)(local_10[0] + 8) << 8 | *(ushort *)(local_10[0] + 8) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(local_10[0] + 0x10);
      }
      else {
        uVar3 = *(ushort *)(local_10[0] + 0x10) << 8 | *(ushort *)(local_10[0] + 0x10) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar7 = *(ushort *)(local_10[0] + 0xe);
      }
      else {
        uVar7 = *(ushort *)(local_10[0] + 0xe) << 8 | *(ushort *)(local_10[0] + 0xe) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar8 = *(ushort *)(local_10[0] + 0xc);
      }
      else {
        uVar8 = *(ushort *)(local_10[0] + 0xc) << 8 | *(ushort *)(local_10[0] + 0xc) >> 8;
      }
      printf("AFPeriod(msec):%d\nAW Period     :%d\nAW Cmn time   :%d\nGuard timr    :%d\nExt period    :%d\nAWDL Flags    :%#04x\nMaster chan   :%d\n"
             ,(uint)uVar1,(uint)uVar2,(uint)uVar3,(uint)*(byte *)(local_10[0] + 7),(uint)uVar7,
             (uint)uVar8,(uint)*(byte *)(local_10[0] + 6));
      putchar(10);
    }
  }
  else {
    __n = strlen("awdl_sync_params");
    strncpy(PTR_DAT_00551644,"awdl_sync_params",__n);
    PTR_DAT_00551644[__n] = 0;
    bzero(auStack_34,0x24);
    __dest = PTR_DAT_00551644 + __n + 1;
    if (DAT_00557704 == '\0') {
      uVar6 = strtoul((char *)*piVar4,(char **)0x0,0);
      local_2a = (ushort)uVar6;
    }
    else {
      uVar6 = strtoul((char *)*piVar4,(char **)0x0,0);
      local_2a = (ushort)uVar6 << 8 | (ushort)uVar6 >> 8;
    }
    if (DAT_00557704 == '\0') {
      uVar6 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      local_2c = (ushort)uVar6;
    }
    else {
      uVar6 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      local_2c = (ushort)uVar6 << 8 | (ushort)uVar6 >> 8;
    }
    if (DAT_00557704 == '\0') {
      uVar6 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
      local_24 = (ushort)uVar6;
    }
    else {
      uVar6 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
      local_24 = (ushort)uVar6 << 8 | (ushort)uVar6 >> 8;
    }
    if (DAT_00557704 == '\0') {
      uVar6 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
      local_2d = (undefined1)uVar6;
    }
    else {
      uVar6 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
      local_2d = (undefined1)(uVar6 >> 8);
    }
    if (DAT_00557704 == '\0') {
      uVar6 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
      local_26 = (ushort)uVar6;
    }
    else {
      uVar6 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
      local_26 = (ushort)uVar6 << 8 | (ushort)uVar6 >> 8;
    }
    uVar6 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
    local_2e = (undefined1)uVar6;
    memcpy(__dest,auStack_34,0x24);
    iVar5 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0x25);
  }
  return iVar5;
}



int FUN_0048a6dc(int *param_1,undefined4 *param_2,int param_3)

{
  byte *pbVar1;
  bool bVar2;
  int *piVar3;
  int iVar4;
  size_t __n;
  undefined *puVar5;
  undefined3 extraout_var;
  int local_28;
  byte *local_c;
  
  local_c = (byte *)0x0;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pbVar1 = local_c;
    if (-1 < iVar4) {
      printf("Dst Addr      :%02x:%02x:%02x:%02x:%02x:%02x \n",(uint)*local_c,(uint)local_c[1],
             (uint)local_c[2],(uint)local_c[3],(uint)local_c[4],(uint)local_c[5]);
      printf("Category and OUI[3]    :0x");
      for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {
        printf("%02x",(uint)pbVar1[local_28 + 6]);
      }
      putchar(10);
    }
  }
  else {
    __n = strlen("awdl_af_hdr");
    strncpy(PTR_DAT_00551644,"awdl_af_hdr",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar5 = PTR_DAT_00551644 + __n + 1;
    if ((*piVar3 == 0) ||
       (bVar2 = FUN_0041d6ac((char *)*piVar3,puVar5), CONCAT31(extraout_var,bVar2) != 0)) {
      if (DAT_00557704 == '\0') {
        FUN_0043dc20(*(char **)(param_3 + 8),(int)(puVar5 + 6));
      }
      else {
        FUN_0043dc20(*(char **)(param_3 + 8),(int)(puVar5 + 6));
      }
      iVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0x25);
    }
    else {
      printf("Problem parsing MAC address \"%s\".\n",(char *)*piVar3);
      iVar4 = -1;
    }
  }
  return iVar4;
}



int FUN_0048a9b0(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  size_t __n;
  undefined4 *puVar2;
  ulong uVar3;
  uint *local_14;
  undefined4 local_10;
  
  local_14 = (uint *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_14);
    if (-1 < iVar1) {
      local_10 = *local_14;
      printf("MinExt:\t%d\nMaxExtMulti:\t%d\nMaxExtUni:\t%d\nMaxExt:\t%d\n",local_10 & 0xff,
             local_10 >> 8 & 0xff,local_10 >> 0x10 & 0xff,local_10 >> 0x18);
    }
  }
  else {
    __n = strlen("awdl_extcounts");
    strncpy(PTR_DAT_00551644,"awdl_extcounts",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar2 = (undefined4 *)(PTR_DAT_00551644 + __n + 1);
    uVar3 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    local_10 = CONCAT31(local_10._1_3_,(char)uVar3);
    if (*(int *)(param_3 + 8) == 0) {
      iVar1 = -2;
    }
    else {
      uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      local_10._0_2_ = CONCAT11((char)uVar3,(undefined1)local_10);
      if (*(int *)(param_3 + 0xc) == 0) {
        iVar1 = -2;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_10._0_3_ = CONCAT12((char)uVar3,(undefined2)local_10);
        if (*(int *)(param_3 + 0x10) == 0) {
          iVar1 = -2;
        }
        else {
          uVar3 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
          local_10 = CONCAT13((char)uVar3,(undefined3)local_10);
          *puVar2 = local_10;
          iVar1 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 5);
        }
      }
    }
  }
  return iVar1;
}



int FUN_0048ac7c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  size_t __n;
  undefined *__dest;
  ulong uVar3;
  char *pcVar4;
  undefined3 extraout_var;
  int *local_res8;
  void *local_1c;
  byte local_18;
  byte local_17;
  ushort local_16;
  byte local_14;
  byte local_13;
  byte local_12;
  byte local_11;
  byte local_10;
  byte local_f;
  ushort local_e;
  
  local_1c = (void *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_1c);
    if (-1 < iVar2) {
      memcpy(&local_18,local_1c,0xc);
      printf("Mode:\t%d\nRole:\t%d\n",(uint)local_18,(uint)local_17);
      printf(" Non-Election Bcasting Period: %d\n Current Bcasting Period: %d\n",(uint)local_16,
             (uint)local_e);
      printf("Master Addr :%02x:%02x:%02x:%02x:%02x:%02x \n",(uint)local_14,(uint)local_13,
             (uint)local_12,(uint)local_11,(uint)local_10,(uint)local_f);
    }
  }
  else {
    __n = strlen("awdl_opmode");
    strncpy(PTR_DAT_00551644,"awdl_opmode",__n);
    PTR_DAT_00551644[__n] = 0;
    bzero(&local_18,0xc);
    __dest = PTR_DAT_00551644 + __n + 1;
    local_res8 = (int *)(param_3 + 8);
    uVar3 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    local_18 = (byte)uVar3;
    if (*local_res8 != 0) {
      pcVar4 = (char *)*local_res8;
      local_res8 = (int *)(param_3 + 0xc);
      uVar3 = strtoul(pcVar4,(char **)0x0,0);
      local_17 = (byte)uVar3;
      if (*local_res8 == 0) {
        local_16 = 1000;
      }
      else {
        pcVar4 = (char *)*local_res8;
        local_res8 = (int *)(param_3 + 0x10);
        uVar3 = strtoul(pcVar4,(char **)0x0,0);
        local_16 = (ushort)uVar3;
      }
    }
    if ((*local_res8 == 0) ||
       (bVar1 = FUN_0041d6ac((char *)*local_res8,&local_14), CONCAT31(extraout_var,bVar1) != 0)) {
      memcpy(__dest,&local_18,0xc);
      iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0xd);
    }
    else {
      printf("Problem parsing MAC address \"%s\".\n",(char *)local_res8[3]);
      iVar2 = -1;
    }
  }
  return iVar2;
}



int FUN_0048afbc(int *param_1,undefined4 *param_2,int param_3)

{
  byte *pbVar1;
  int iVar2;
  size_t __n;
  undefined1 *puVar3;
  ulong uVar4;
  byte *local_c;
  
  local_c = (byte *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pbVar1 = local_c;
    if (-1 < iVar2) {
      printf("Flags\t\t:%d\nID\t\t:%d\nSelf Metric     \t:%d\n",(uint)*local_c,
             (uint)*(ushort *)(local_c + 1),*(int *)(local_c + 3));
      printf("RSSI thresholds:\n    close  sync\t\t:%d\n    master rssi boost\t:%d\n    edge   sync\t\t:%d\n    close range\t\t:%d\n    mid range\t\t:%d\n"
             ,(int)(char)pbVar1[7],(int)(char)pbVar1[8],(int)(char)pbVar1[9],(int)(char)pbVar1[10],
             (int)(char)pbVar1[0xb]);
      printf("Master dwell count:\n    Edge master\t\t:%d\n",(uint)pbVar1[0x1a]);
      printf("Max number of higher masters:\n    close range\t\t:%d\n    mid range  \t\t:%d\nMax tree depth\t\t:%d\n"
             ,(uint)pbVar1[0xc],(uint)pbVar1[0xd],(uint)pbVar1[0xe]);
      puts("Current top master:");
      printf("    addr\t\t: %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)pbVar1[0xf],(uint)pbVar1[0x10],
             (uint)pbVar1[0x11],(uint)pbVar1[0x12],(uint)pbVar1[0x13],(uint)pbVar1[0x14]);
      printf("    self metric    :%d\n",*(int *)(pbVar1 + 0x15));
      printf("Current tree depth:%d\n",(uint)pbVar1[0x19]);
      if (*pbVar1 != 0) {
        printf("\nPrivate election ID :%d\n",*(int *)(pbVar1 + 0x25));
        puts("Current private top master:");
        printf("    addr\t\t: %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)pbVar1[0x1b],(uint)pbVar1[0x1c]
               ,(uint)pbVar1[0x1d],(uint)pbVar1[0x1e],(uint)pbVar1[0x1f],(uint)pbVar1[0x20]);
        printf("    self metric    :%d\n",*(int *)(pbVar1 + 0x21));
        printf("Current private tree depth:%d\n",(uint)pbVar1[0x29]);
      }
    }
  }
  else {
    __n = strlen("awdl_election_tree");
    strncpy(PTR_DAT_00551644,"awdl_election_tree",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar3 = PTR_DAT_00551644 + __n + 1;
    uVar4 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    *puVar3 = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
    puVar3[1] = (char)uVar4;
    puVar3[2] = (char)(uVar4 >> 8);
    uVar4 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
    *(ulong *)(puVar3 + 3) = uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
    puVar3[7] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
    puVar3[8] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
    puVar3[9] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x1c),(char **)0x0,0);
    puVar3[10] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x20),(char **)0x0,0);
    puVar3[0xb] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x24),(char **)0x0,0);
    puVar3[0xc] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x28),(char **)0x0,0);
    puVar3[0xd] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x2c),(char **)0x0,0);
    puVar3[0xe] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x30),(char **)0x0,0);
    puVar3[0x1a] = (char)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x34),(char **)0x0,0);
    *(ulong *)(puVar3 + 0x25) = uVar4;
    iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0x2b);
  }
  return iVar2;
}



int FUN_0048b60c(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  size_t __n;
  uint *puVar4;
  uint local_2c;
  uint *local_10 [2];
  
  local_10[0] = (uint *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    puVar4 = local_10[0];
    if (-1 < iVar2) {
      if (DAT_00557704 == '\0') {
        uVar3 = *local_10[0] & 0xffff;
      }
      else {
        uVar3 = (uint)(ushort)((ushort)*local_10[0] << 8 | (ushort)*local_10[0] >> 8);
      }
      printf("Length\t      :%d\nPacket\t      :0x",uVar3);
      for (local_2c = 0; local_2c < *puVar4; local_2c = local_2c + 1) {
        printf("%02x",(uint)*(byte *)((int)puVar4 + local_2c + 4));
      }
      putchar(10);
    }
  }
  else {
    __n = strlen("awdl_payload");
    strncpy(PTR_DAT_00551644,"awdl_payload",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar4 = (uint *)(PTR_DAT_00551644 + __n + 1);
    if (DAT_00557704 == '\0') {
      uVar3 = FUN_0043dc20((char *)*piVar1,(int)(puVar4 + 1));
      uVar3 = uVar3 & 0xffff;
    }
    else {
      iVar2 = FUN_0043dc20((char *)*piVar1,(int)(puVar4 + 1));
      uVar3 = (uint)(ushort)((ushort)iVar2 << 8 | (ushort)iVar2 >> 8);
    }
    *puVar4 = uVar3;
    iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,*puVar4 + __n + 3);
  }
  return iVar2;
}



int FUN_0048b8b8(int *param_1,undefined4 *param_2,int param_3)

{
  byte *pbVar1;
  ushort uVar2;
  int iVar3;
  size_t __n;
  undefined1 *puVar4;
  ulong uVar5;
  int local_2c;
  byte *local_10 [2];
  
  local_10[0] = (byte *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    pbVar1 = local_10[0];
    if (-1 < iVar3) {
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(local_10[0] + 2);
      }
      else {
        uVar2 = *(ushort *)(local_10[0] + 2) << 8 | *(ushort *)(local_10[0] + 2) >> 8;
      }
      printf("long psf period\t      :%d\nlong psf tx offset\t      :%d\nLength\t      :%d\nPacket\t      :0x"
             ,(uint)*local_10[0],(uint)local_10[0][1],(uint)uVar2);
      for (local_2c = 0; local_2c < (int)(uint)*(ushort *)(pbVar1 + 2); local_2c = local_2c + 1) {
        printf("%02x",(uint)pbVar1[local_2c + 4]);
      }
      putchar(10);
    }
  }
  else {
    __n = strlen("awdl_long_psf");
    strncpy(PTR_DAT_00551644,"awdl_long_psf",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar4 = PTR_DAT_00551644 + __n + 1;
    uVar5 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    *puVar4 = (char)uVar5;
    uVar5 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
    puVar4[1] = (char)uVar5;
    puVar4[2] = 0;
    puVar4[3] = 0;
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        iVar3 = FUN_0043dc20(*(char **)(param_3 + 0xc),(int)(puVar4 + 4));
        uVar2 = (ushort)iVar3;
      }
      else {
        iVar3 = FUN_0043dc20(*(char **)(param_3 + 0xc),(int)(puVar4 + 4));
        uVar2 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
      }
      puVar4[2] = (char)uVar2;
      puVar4[3] = (char)(uVar2 >> 8);
    }
    iVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + *(ushort *)(puVar4 + 2) + 5);
  }
  return iVar3;
}



int FUN_0048bc78(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  int iVar2;
  size_t __n;
  byte *pbVar3;
  ulong uVar4;
  int local_2c;
  byte *local_18 [3];
  
  local_18[0] = (byte *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_18);
    pbVar3 = local_18[0];
    if (-1 < iVar2) {
      printf("Seq Len\t\t:%d\nEncoding\t:%d\nStep count\t:%d\nduplicate\t:%d\nfill channel\t:%d\nChan Sequence   :"
             ,(uint)*local_18[0],(uint)local_18[0][1],(uint)local_18[0][3],(uint)local_18[0][2],
             (uint)*(ushort *)(local_18[0] + 4));
      for (local_2c = 0; local_2c < (int)((*pbVar3 + 1) * (pbVar3[1] + 1)); local_2c = local_2c + 1)
      {
        printf("%02x",(uint)pbVar3[local_2c + 6]);
      }
      putchar(10);
    }
  }
  else {
    __n = strlen("awdl_chan_seq");
    strncpy(PTR_DAT_00551644,"awdl_chan_seq",__n);
    PTR_DAT_00551644[__n] = 0;
    pbVar3 = PTR_DAT_00551644 + __n + 1;
    uVar4 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    pbVar3[1] = (byte)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
    pbVar3[3] = (byte)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
    pbVar3[2] = (byte)uVar4;
    uVar4 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
    pbVar3[4] = (byte)uVar4;
    pbVar3[5] = (byte)(uVar4 >> 8);
    *pbVar3 = 0;
    if (*(int *)(param_3 + 0x14) != 0) {
      bVar1 = *pbVar3;
      iVar2 = FUN_0043dc20(*(char **)(param_3 + 0x14),(int)(pbVar3 + 6));
      *pbVar3 = bVar1 + (char)iVar2;
    }
    bVar1 = *pbVar3;
    if (pbVar3[1] + 1 == 0) {
      trap(7);
    }
    *pbVar3 = (byte)((uint)*pbVar3 / (pbVar3[1] + 1));
    *pbVar3 = *pbVar3 - 1;
    iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + bVar1 + 7);
  }
  return iVar2;
}



int FUN_0048c028(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  uint uVar4;
  undefined3 extraout_var;
  uint local_48;
  char *local_2c;
  uint local_28;
  int local_24;
  uint local_20;
  uint local_1c;
  undefined1 auStack_18 [16];
  
  local_28 = 0;
  iVar2 = FUN_004024e8((int *)(param_3 + 4),"awdl_if",&local_28,&local_24);
  if (iVar2 == 0) {
    piVar3 = (int *)(param_3 + 4) + local_24;
    if (local_24 == 0) {
      local_28 = 0xffffffff;
    }
    if (*piVar3 == 0) {
      if (DAT_00557704 != '\0') {
        local_28 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                   local_28 >> 0x18;
      }
      iVar2 = FUN_004ba0cc(param_1,"awdl_if",&local_28,4,PTR_DAT_00551644,0x2000);
      if (-1 < iVar2) {
        uVar4 = *(uint *)PTR_DAT_00551644;
        if (DAT_00557704 != '\0') {
          uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        if (uVar4 == 0) {
          puts("down");
        }
        else {
          puts("up");
        }
        iVar2 = 0;
      }
    }
    else {
      bzero(&local_20,0x14);
      bVar1 = FUN_0041d6ac((char *)*piVar3,auStack_18);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        iVar2 = -1;
      }
      else {
        piVar3 = piVar3 + 1;
        iVar2 = strcasecmp((char *)*piVar3,"up");
        if (iVar2 == 0) {
          local_48 = 1;
        }
        else {
          iVar2 = strcasecmp((char *)*piVar3,"down");
          if (iVar2 == 0) {
            local_48 = 0;
          }
          else {
            local_48 = strtol((char *)*piVar3,&local_2c,0);
            if (*local_2c != '\0') {
              fwrite("error!\n",1,7,stderr);
              return -1;
            }
          }
        }
        local_20 = local_28;
        if (DAT_00557704 != '\0') {
          local_20 = local_28 << 0x18 | (local_28 & 0xff00) << 8 | (local_28 & 0xff0000) >> 8 |
                     local_28 >> 0x18;
          local_48 = local_48 << 0x18 | (local_48 & 0xff00) << 8 | (local_48 & 0xff0000) >> 8 |
                     local_48 >> 0x18;
        }
        local_1c = local_48;
        iVar2 = FUN_004ba2e4(param_1,"awdl_if",&local_20,0x14);
      }
    }
  }
  return iVar2;
}



undefined4 FUN_0048c440(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  undefined1 auStack_10 [8];
  
  bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_10);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    uVar2 = 0xffffffff;
  }
  else {
    uVar2 = FUN_004ba2e4(param_1,"awdl_mon_bssid",auStack_10,6);
  }
  return uVar2;
}



int FUN_0048c4d0(int *param_1,undefined4 *param_2,int param_3)

{
  uint uVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  ushort uVar6;
  ushort uVar7;
  ushort uVar8;
  uint uVar9;
  uint uVar10;
  uint *local_40;
  uint local_3c;
  int local_38;
  int local_10 [2];
  
  local_38 = 0;
  local_10[0] = 0;
  if ((*(int *)(param_3 + 4) == 0) &&
     (local_38 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10), -1 < local_38)) {
    local_40 = (uint *)(local_10[0] + 4);
    for (local_3c = (uint)*(ushort *)(local_10[0] + 2); 0x3b < local_3c; local_3c = local_3c - 0x3c)
    {
      puts("----------------------------");
      printf("Address    : %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)(byte)local_40[7],
             (uint)*(byte *)((int)local_40 + 0x1d),(uint)*(byte *)((int)local_40 + 0x1e),
             (uint)*(byte *)((int)local_40 + 0x1f),(uint)(byte)local_40[8],
             (uint)*(byte *)((int)local_40 + 0x21));
      printf("Top Master : %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)*(byte *)((int)local_40 + 0x22),
             (uint)*(byte *)((int)local_40 + 0x23),(uint)(byte)local_40[9],
             (uint)*(byte *)((int)local_40 + 0x25),(uint)*(byte *)((int)local_40 + 0x26),
             (uint)*(byte *)((int)local_40 + 0x27));
      if (DAT_00557704 == '\0') {
        uVar1 = *local_40 & 0xffff;
      }
      else {
        uVar1 = (uint)(ushort)((ushort)*local_40 << 8 | (ushort)*local_40 >> 8);
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)((int)local_40 + 0xe);
      }
      else {
        uVar2 = *(ushort *)((int)local_40 + 0xe) << 8 | *(ushort *)((int)local_40 + 0xe) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = (ushort)local_40[1];
      }
      else {
        uVar3 = (ushort)local_40[1] << 8 | (ushort)local_40[1] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar4 = (ushort)local_40[4];
      }
      else {
        uVar4 = (ushort)local_40[4] << 8 | (ushort)local_40[4] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar5 = (ushort)local_40[2];
      }
      else {
        uVar5 = (ushort)local_40[2] << 8 | (ushort)local_40[2] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = *(ushort *)((int)local_40 + 10);
      }
      else {
        uVar6 = *(ushort *)((int)local_40 + 10) << 8 | *(ushort *)((int)local_40 + 10) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar7 = *(ushort *)((int)local_40 + 0x12);
      }
      else {
        uVar7 = *(ushort *)((int)local_40 + 0x12) << 8 | *(ushort *)((int)local_40 + 0x12) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar8 = (ushort)local_40[3];
      }
      else {
        uVar8 = (ushort)local_40[3] << 8 | (ushort)local_40[3] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar9 = local_40[5];
        uVar10 = local_40[6];
      }
      else {
        uVar9 = local_40[5];
        uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
        uVar10 = local_40[6];
        uVar10 = uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 | uVar10 >> 0x18
        ;
      }
      printf("Type/state        : %x\nAF rssi (avg)     : %d\nAF rssi (last)    : %d\nAW period         : %d\nAw counter        : %d\nAW Cmn time       : %d\nTx counter        : %d\nTx delay          : %d\nAw Ext length     : %d\nAction period     : %d\nElection Metrics  : %d\nTop Master Metrics: %d\nDistance From Top : %d\n"
             ,uVar1,(int)*(char *)((int)local_40 + 6),(int)*(char *)((int)local_40 + 7),(uint)uVar2,
             (uint)uVar3,(uint)uVar4,(uint)uVar5,(uint)uVar6,(uint)uVar7,(uint)uVar8,uVar9,uVar10,
             (uint)(byte)local_40[10]);
      if (*(char *)((int)local_40 + 0x29) == '\0') {
        puts("No private election params");
      }
      else {
        printf("Private top Master : %02x:%02x:%02x:%02x:%02x:%02x\n",
               (uint)*(byte *)((int)local_40 + 0x2a),(uint)*(byte *)((int)local_40 + 0x2b),
               (uint)(byte)local_40[0xb],(uint)*(byte *)((int)local_40 + 0x2d),
               (uint)*(byte *)((int)local_40 + 0x2e),(uint)*(byte *)((int)local_40 + 0x2f));
        if (DAT_00557704 == '\0') {
          uVar1 = local_40[0xd];
          uVar9 = local_40[0xc];
        }
        else {
          uVar1 = local_40[0xd];
          uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
          uVar9 = local_40[0xc];
          uVar9 = uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18;
        }
        printf("Private election ID  \t\t\t: %d\nPrivate top master metric  \t\t: %d\nPrivate distance From Top\t\t: %d\n"
               ,uVar1,uVar9,(uint)(byte)local_40[0xe]);
      }
      puts("-----------------------------");
      local_40 = local_40 + 0xf;
    }
  }
  return local_38;
}



int FUN_0048cc30(int *param_1,undefined4 *param_2,int param_3)

{
  ushort *puVar1;
  undefined *puVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  undefined3 extraout_var;
  ulong uVar6;
  size_t local_30;
  int local_2c;
  ushort *local_28;
  uint local_24;
  uint local_20;
  ushort *local_10 [2];
  
  local_10[0] = (ushort *)0x0;
  iVar4 = FUN_0040192c(param_3);
  puVar2 = PTR_DAT_00551644;
  if (iVar4 < 2) {
    local_2c = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if ((-1 < local_2c) && (local_24 = (uint)*local_10[0], local_24 != 0)) {
      local_28 = local_10[0] + 1;
      puts("----------------------------------------------------------------------");
      puts(" Address \t       Flags \t         Chanseq ");
      for (; 0xc < local_24; local_24 = local_24 - (*puVar1 + 0xc)) {
        printf("%02x:%02x:%02x:%02x:%02x:%02x\t",(uint)(byte)*local_28,
               (uint)*(byte *)((int)local_28 + 1),(uint)(byte)local_28[1],
               (uint)*(byte *)((int)local_28 + 3),(uint)(byte)local_28[2],
               (uint)*(byte *)((int)local_28 + 5));
        printf("0x%x\t",*(uint *)(local_28 + 3));
        if (local_28[5] != 0) {
          for (local_20 = 0; local_20 < local_28[5]; local_20 = local_20 + 1) {
            printf("%x ",(uint)*(byte *)((int)local_28 + local_20 + 0xc));
          }
        }
        putchar(10);
        puVar1 = local_28 + 5;
        local_28 = (ushort *)((int)local_28 + *puVar1 + 0xc);
      }
      puts("----------------------------------------------------------------------");
    }
  }
  else {
    *PTR_DAT_00551644 = 0;
    iVar5 = strcmp(*(char **)(param_3 + 4),"add");
    if (iVar5 == 0) {
      puVar2[1] = 0;
    }
    else {
      iVar5 = strcmp(*(char **)(param_3 + 4),"del");
      if (iVar5 != 0) {
        fprintf(stderr,"operation \'%s\' is not supported\n",*(char **)(param_3 + 4));
        return -1;
      }
      puVar2[1] = 1;
    }
    if (iVar4 < 3) {
      fwrite("Peer address is expected\n",1,0x19,stderr);
      local_2c = -1;
    }
    else {
      bVar3 = FUN_0041d6ac(*(char **)(param_3 + 8),puVar2 + 2);
      if (CONCAT31(extraout_var,bVar3) == 0) {
        fwrite("Peer address parse error\n",1,0x19,stderr);
        local_2c = -1;
      }
      else if (iVar4 < 4) {
        fwrite("Peer Operation mode is expected\n",1,0x20,stderr);
        local_2c = -1;
      }
      else {
        uVar6 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        puVar2[8] = (char)uVar6;
        local_30 = 9;
        if (4 < iVar4) {
          iVar4 = FUN_0043dc20(*(char **)(param_3 + 0x10),(int)(puVar2 + 9));
          local_30 = iVar4 + 9;
        }
        local_2c = FUN_004ba2e4(param_1,(char *)*param_2,puVar2,local_30);
      }
    }
  }
  return local_2c;
}



undefined4 FUN_0048d108(int param_1,int param_2,void *param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  ulong uVar2;
  uint uVar3;
  undefined4 local_28;
  
  local_28 = 0;
  bVar1 = FUN_0041d6ac(*(char **)(param_2 + 4),param_3);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    fwrite("Invalid BSSID\n",1,0xe,stderr);
    local_28 = 0xffffffff;
  }
  else if (param_1 < 3) {
    fwrite("Dst mac is expected\n",1,0x14,stderr);
    local_28 = 0xffffffff;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_2 + 8),(void *)((int)param_3 + 6));
    if (CONCAT31(extraout_var_00,bVar1) == 0) {
      fwrite("Invalid dst mac\n",1,0x10,stderr);
      local_28 = 0xffffffff;
    }
    else if (param_1 < 4) {
      fwrite("Channel is expected\n",1,0x14,stderr);
      local_28 = 0xffffffff;
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_2 + 0xc),(char **)0x0,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_2 + 0xc),(char **)0x0,0);
        uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      *(uint *)((int)param_3 + 0xc) = uVar3;
      if (param_1 < 5) {
        fwrite("Dwell time is expected\n",1,0x17,stderr);
        local_28 = 0xffffffff;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar3 = strtoul(*(char **)(param_2 + 0x10),(char **)0x0,0);
        }
        else {
          uVar2 = strtoul(*(char **)(param_2 + 0x10),(char **)0x0,0);
          uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
        }
        *(uint *)((int)param_3 + 0x10) = uVar3;
        if (param_1 < 6) {
          fwrite("Flags are expected\n",1,0x13,stderr);
          local_28 = 0xffffffff;
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar3 = strtoul(*(char **)(param_2 + 0x14),(char **)0x0,0);
          }
          else {
            uVar2 = strtoul(*(char **)(param_2 + 0x14),(char **)0x0,0);
            uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
          }
          *(uint *)((int)param_3 + 0x14) = uVar3;
          if (param_1 < 7) {
            fwrite("Pkt lifetime is expected\n",1,0x19,stderr);
            local_28 = 0xffffffff;
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar3 = strtoul(*(char **)(param_2 + 0x18),(char **)0x0,0);
            }
            else {
              uVar2 = strtoul(*(char **)(param_2 + 0x18),(char **)0x0,0);
              uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                      uVar2 >> 0x18;
            }
            *(uint *)((int)param_3 + 0x18) = uVar3;
            if (param_1 < 8) {
              fwrite("Tx rate is expected\n",1,0x14,stderr);
              local_28 = 0xffffffff;
            }
            else {
              if (DAT_00557704 == '\0') {
                uVar3 = strtoul(*(char **)(param_2 + 0x1c),(char **)0x0,0);
              }
              else {
                uVar2 = strtoul(*(char **)(param_2 + 0x1c),(char **)0x0,0);
                uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                        uVar2 >> 0x18;
              }
              *(uint *)((int)param_3 + 0x1c) = uVar3;
              if (param_1 < 9) {
                fwrite("Max retries count is expected\n",1,0x1e,stderr);
                local_28 = 0xffffffff;
              }
              else {
                if (DAT_00557704 == '\0') {
                  uVar3 = strtoul(*(char **)(param_2 + 0x20),(char **)0x0,0);
                }
                else {
                  uVar2 = strtoul(*(char **)(param_2 + 0x20),(char **)0x0,0);
                  uVar3 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                          uVar2 >> 0x18;
                }
                *(uint *)((int)param_3 + 0x20) = uVar3;
              }
            }
          }
        }
      }
    }
  }
  return local_28;
}



int FUN_0048d7cc(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  size_t __n;
  undefined *puVar2;
  size_t sVar3;
  uint uVar4;
  int local_28;
  
  iVar1 = FUN_0040192c(param_3);
  if (iVar1 < 2) {
    fwrite("GET operation is not supported\n",1,0x1f,stderr);
    local_28 = -1;
  }
  else {
    __n = strlen("awdl_oob_af");
    strncpy(PTR_DAT_00551644,"awdl_oob_af",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar2 = PTR_DAT_00551644 + __n + 1;
    local_28 = FUN_0048d108(iVar1,param_3,puVar2);
    if (local_28 == 0) {
      if (iVar1 < 10) {
        fwrite("Payload is expected\n",1,0x14,stderr);
        local_28 = -1;
      }
      else {
        if (DAT_00557704 == '\0') {
          sVar3 = strlen(*(char **)(param_3 + 0x24));
          uVar4 = sVar3 & 0xffff;
        }
        else {
          sVar3 = strlen(*(char **)(param_3 + 0x24));
          uVar4 = (uint)(ushort)((ushort)sVar3 << 8 | (ushort)sVar3 >> 8);
        }
        puVar2[0x24] = (char)(uVar4 / 2);
        puVar2[0x25] = (char)(uVar4 / 2 >> 8);
        iVar1 = FUN_00459628(*(char **)(param_3 + 0x24),puVar2 + 0x26,
                             (uint)*(ushort *)(puVar2 + 0x24));
        if (iVar1 == 0) {
          local_28 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,
                                  *(ushort *)(puVar2 + 0x24) + __n + 0x27);
        }
        else {
          fwrite("Error parsing payload\n",1,0x16,stderr);
          local_28 = -1;
        }
      }
    }
  }
  return local_28;
}



int FUN_0048dad0(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  int iVar2;
  size_t __n;
  uint *puVar3;
  ulong uVar4;
  uint uVar5;
  size_t sVar6;
  int local_38;
  
  iVar2 = FUN_0040192c(param_3);
  if (iVar2 < 2) {
    fwrite("GET operation is not supported\n",1,0x1f,stderr);
    local_38 = -1;
  }
  else {
    __n = strlen("awdl_oob_af_async");
    strncpy(PTR_DAT_00551644,"awdl_oob_af_async",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar3 = (uint *)(PTR_DAT_00551644 + __n + 1);
    local_38 = FUN_0048d108(iVar2,param_3,(undefined *)((int)puVar3 + 6));
    if (local_38 == 0) {
      if (DAT_00557704 == '\0') {
        uVar5 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
      }
      else {
        uVar4 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        uVar5 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      *(uint *)((int)puVar3 + 0x1a) = uVar5;
      if (iVar2 < 10) {
        fwrite("Tx time is expected\n",1,0x14,stderr);
        local_38 = -1;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar5 = strtoul(*(char **)(param_3 + 0x24),(char **)0x0,0);
        }
        else {
          uVar4 = strtoul(*(char **)(param_3 + 0x24),(char **)0x0,0);
          uVar5 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        }
        *puVar3 = uVar5;
        if (iVar2 < 0xb) {
          fwrite("Pkt tag is expected\n",1,0x14,stderr);
          local_38 = -1;
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar4 = strtoul(*(char **)(param_3 + 0x28),(char **)0x0,0);
            uVar1 = (ushort)uVar4;
          }
          else {
            uVar4 = strtoul(*(char **)(param_3 + 0x28),(char **)0x0,0);
            uVar1 = (ushort)(uVar4 >> 8) & 0xff00 | (ushort)(byte)(uVar4 >> 0x18);
          }
          *(char *)(puVar3 + 1) = (char)uVar1;
          *(char *)((int)puVar3 + 5) = (char)(uVar1 >> 8);
          if (iVar2 < 0xc) {
            fwrite("Payload is expected\n",1,0x14,stderr);
            local_38 = -1;
          }
          else {
            if (DAT_00557704 == '\0') {
              sVar6 = strlen(*(char **)(param_3 + 0x2c));
              uVar5 = sVar6 & 0xffff;
            }
            else {
              sVar6 = strlen(*(char **)(param_3 + 0x2c));
              uVar5 = (uint)(ushort)((ushort)sVar6 << 8 | (ushort)sVar6 >> 8);
            }
            *(char *)((int)puVar3 + 0x2a) = (char)(uVar5 / 2);
            *(char *)((int)puVar3 + 0x2b) = (char)(uVar5 / 2 >> 8);
            iVar2 = FUN_00459628(*(char **)(param_3 + 0x2c),(undefined1 *)(puVar3 + 0xb),
                                 (uint)*(ushort *)((int)puVar3 + 0x2a));
            if (iVar2 == 0) {
              local_38 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,
                                      *(ushort *)((int)puVar3 + 0x2a) + __n + 0x2d);
            }
            else {
              fwrite("Error parsing payload\n",1,0x16,stderr);
              local_38 = -1;
            }
          }
        }
      }
    }
  }
  return local_38;
}



int FUN_0048e080(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  size_t __n;
  uint *puVar2;
  ulong uVar3;
  uint uVar4;
  size_t sVar5;
  int local_30;
  
  iVar1 = FUN_0040192c(param_3);
  if (iVar1 < 2) {
    fwrite("GET operation is not supported\n",1,0x1f,stderr);
    local_30 = -1;
  }
  else {
    __n = strlen("awdl_oob_af_auto");
    strncpy(PTR_DAT_00551644,"awdl_oob_af_auto",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar2 = (uint *)(PTR_DAT_00551644 + __n + 1);
    local_30 = FUN_0048d108(iVar1,param_3,puVar2 + 2);
    if (local_30 == 0) {
      if (iVar1 < 10) {
        fwrite("Tx channel map is expected\n",1,0x1b,stderr);
        local_30 = -1;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar4 = strtoul(*(char **)(param_3 + 0x24),(char **)0x0,0);
        }
        else {
          uVar3 = strtoul(*(char **)(param_3 + 0x24),(char **)0x0,0);
          uVar4 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        *puVar2 = uVar4;
        if (iVar1 < 0xb) {
          fwrite("Tx aws offset is expected\n",1,0x1a,stderr);
          local_30 = -1;
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar4 = strtoul(*(char **)(param_3 + 0x28),(char **)0x0,0);
          }
          else {
            uVar3 = strtoul(*(char **)(param_3 + 0x28),(char **)0x0,0);
            uVar4 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
          }
          puVar2[1] = uVar4;
          if (iVar1 < 0xc) {
            fwrite("Payload is expected\n",1,0x14,stderr);
            local_30 = -1;
          }
          else {
            if (DAT_00557704 == '\0') {
              sVar5 = strlen(*(char **)(param_3 + 0x2c));
              uVar4 = sVar5 & 0xffff;
            }
            else {
              sVar5 = strlen(*(char **)(param_3 + 0x2c));
              uVar4 = (uint)(ushort)((ushort)sVar5 << 8 | (ushort)sVar5 >> 8);
            }
            *(char *)(puVar2 + 0xb) = (char)(uVar4 / 2);
            *(char *)((int)puVar2 + 0x2d) = (char)(uVar4 / 2 >> 8);
            iVar1 = FUN_00459628(*(char **)(param_3 + 0x2c),(undefined1 *)((int)puVar2 + 0x2e),
                                 (uint)(ushort)puVar2[0xb]);
            if (iVar1 == 0) {
              local_30 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,
                                      (ushort)puVar2[0xb] + __n + 0x2f);
            }
            else {
              fwrite("Error parsing payload\n",1,0x16,stderr);
              local_30 = -1;
            }
          }
        }
      }
    }
  }
  return local_30;
}



undefined4 FUN_0048e564(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  undefined4 uVar2;
  ulong local_14;
  ulong local_10;
  
  iVar1 = FUN_0040192c(param_3);
  if (iVar1 < 3) {
    uVar2 = 0xffffffff;
  }
  else {
    local_14 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    local_10 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
    uVar2 = FUN_004ba2e4(param_1,(char *)*param_2,&local_14,8);
  }
  return uVar2;
}



int FUN_0048e630(int *param_1,undefined4 *param_2,int param_3)

{
  ushort *puVar1;
  bool bVar2;
  int iVar3;
  size_t __n;
  undefined *puVar4;
  ulong uVar5;
  undefined3 extraout_var;
  int local_28;
  ushort *local_10 [2];
  
  local_10[0] = (ushort *)0x0;
  iVar3 = FUN_0040192c(param_3);
  if (*(int *)(param_3 + 4) == 0) {
    local_28 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    puVar1 = local_10[0];
    if (-1 < local_28) {
      printf(" flags:           0x%04x \n",(uint)*local_10[0]);
      printf(" sounding count:  %d\n",(uint)(byte)puVar1[1]);
      printf(" allowed mac:     %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)(byte)puVar1[2],
             (uint)*(byte *)((int)puVar1 + 5),(uint)(byte)puVar1[3],(uint)*(byte *)((int)puVar1 + 7)
             ,(uint)(byte)puVar1[4],(uint)*(byte *)((int)puVar1 + 9));
    }
  }
  else if (iVar3 < 4) {
    fwrite("flag, sounding_count, ea expected\n",1,0x22,stderr);
    local_28 = -1;
  }
  else {
    __n = strlen("awdl_ranging_config");
    strncpy(PTR_DAT_00551644,"awdl_ranging_config",__n);
    PTR_DAT_00551644[__n] = 0;
    puVar4 = PTR_DAT_00551644 + __n + 1;
    uVar5 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    *puVar4 = (char)uVar5;
    puVar4[1] = (char)(uVar5 >> 8);
    uVar5 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
    puVar4[2] = (char)uVar5;
    puVar4[3] = 0;
    bVar2 = FUN_0041d6ac(*(char **)(param_3 + 0xc),puVar4 + 4);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      fwrite("awdl ranging config mac addr err\n",1,0x21,stderr);
      local_28 = -1;
    }
    else {
      local_28 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,__n + 0xb);
    }
  }
  return local_28;
}



int FUN_0048e958(int *param_1,undefined4 *param_2,int param_3)

{
  undefined2 uVar1;
  bool bVar2;
  int iVar3;
  size_t __n;
  byte *pbVar4;
  ulong uVar5;
  undefined3 extraout_var;
  int local_30;
  int local_2c;
  uint local_28;
  byte *local_c;
  
  local_c = (byte *)0x0;
  iVar3 = FUN_0040192c(param_3);
  if (*(int *)(param_3 + 4) == 0) {
    local_30 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pbVar4 = local_c;
    if (-1 < local_30) {
      printf(" num peers:       %d \n",(uint)*local_c);
      printf(" num peers done:  %d \n",(uint)pbVar4[1]);
      printf(" num aws:         %d \n",(uint)pbVar4[2]);
      puts("----------------------------------------------------------------------");
      puts(" Address \t      chanspec \t         flags ");
      for (local_28 = 0; local_28 < *pbVar4; local_28 = local_28 + 1) {
        printf(" %02x:%02x:%02x:%02x:%02x:%02x  \t 0x%04x  \t   %d\n",
               (uint)pbVar4[local_28 * 10 + 7],(uint)pbVar4[local_28 * 10 + 8],
               (uint)pbVar4[local_28 * 10 + 9],(uint)pbVar4[local_28 * 10 + 10],
               (uint)pbVar4[local_28 * 10 + 0xb],(uint)pbVar4[local_28 * 10 + 0xc],
               (uint)*(ushort *)(pbVar4 + local_28 * 10 + 3),
               (uint)*(ushort *)(pbVar4 + local_28 * 10 + 5));
      }
    }
  }
  else if (iVar3 % 3 == 2) {
    __n = strlen("awdl_ranging_start");
    strncpy(PTR_DAT_00551644,"awdl_ranging_start",__n);
    PTR_DAT_00551644[__n] = 0;
    pbVar4 = PTR_DAT_00551644 + __n + 1;
    *pbVar4 = (char)((ulonglong)((longlong)iVar3 * 0x55555556) >> 0x20) - (char)(iVar3 >> 0x1f);
    pbVar4[1] = 0;
    iVar3 = param_3 + 8;
    uVar5 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    pbVar4[2] = (byte)uVar5;
    for (local_2c = 0; local_2c < (int)(uint)*pbVar4; local_2c = local_2c + 1) {
      uVar5 = strtoul(*(char **)(iVar3 + local_2c * 0xc),(char **)0x0,0);
      pbVar4[local_2c * 10 + 5] = (byte)uVar5;
      pbVar4[local_2c * 10 + 6] = (byte)(uVar5 >> 8);
      FUN_0043dc20(*(char **)(iVar3 + local_2c * 0xc + 4),(int)(pbVar4 + local_2c * 10 + 3));
      uVar1 = *(undefined2 *)(pbVar4 + local_2c * 10 + 3);
      pbVar4[local_2c * 10 + 3] = (byte)((ushort)uVar1 >> 8);
      pbVar4[local_2c * 10 + 4] = (byte)uVar1;
      bVar2 = FUN_0041d6ac(*(char **)(iVar3 + local_2c * 0xc + 8),pbVar4 + local_2c * 10 + 7);
      if (CONCAT31(extraout_var,bVar2) == 0) {
        fwrite("awdl ranging start mac addr err\n",1,0x20,stderr);
        return -1;
      }
    }
    local_30 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,(*pbVar4 - 1) * 10 + __n + 0xe);
  }
  else {
    fprintf(stderr," param count = %d, should be three params per peer\n",iVar3 + -1);
    local_30 = -1;
  }
  return local_30;
}



int FUN_0048efa4(int *param_1,undefined4 *param_2)

{
  int iVar1;
  int iVar2;
  int local_18;
  int local_c;
  
  local_c = 0;
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  iVar1 = local_c;
  if (-1 < iVar2) {
    printf(" num results:       %d \n",(uint)*(byte *)(local_c + 3));
    printf(" num good results:  %d \n",(uint)*(byte *)(iVar1 + 2));
    puts("-----------------------------------------------------------------------------");
    puts(" Address \t\t chanspec \t sounding_count\t  ts \t dist \t status   ");
    for (local_18 = 0; local_18 < (int)(uint)*(byte *)(iVar1 + 3); local_18 = local_18 + 1) {
      printf(" %02x:%02x:%02x:%02x:%02x:%02x \t",(uint)*(byte *)(iVar1 + local_18 * 0x16 + 6),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 7),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 8),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 9),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 10),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 0xb));
      printf(" %04x \t\t    %d    \t  %d    \t  ",(uint)*(ushort *)(iVar1 + local_18 * 0x16 + 0xc),
             (uint)*(byte *)(iVar1 + local_18 * 0x16 + 5),*(int *)(iVar1 + local_18 * 0x16 + 0xe));
      if (*(int *)(iVar1 + local_18 * 0x16 + 0x12) == -1) {
        printf("-1  \t");
      }
      else {
        printf("%d.%d \t",*(uint *)(iVar1 + local_18 * 0x16 + 0x12) >> 4,
               (*(uint *)(iVar1 + local_18 * 0x16 + 0x12) & 0xf) * 10 >> 4);
      }
      if (*(char *)(iVar1 + local_18 * 0x16 + 4) == '\0') {
        printf(" %s\n","todo");
      }
      else if (*(char *)(iVar1 + local_18 * 0x16 + 4) == '\x01') {
        printf(" %s\n","success");
      }
      else if (*(char *)(iVar1 + local_18 * 0x16 + 4) == '\x02') {
        printf(" %s\n","fail");
      }
      else if (*(char *)(iVar1 + local_18 * 0x16 + 4) == '\x03') {
        printf(" %s\n","timeout");
      }
      else if (*(char *)(iVar1 + local_18 * 0x16 + 4) == '\x04') {
        printf(" %s\n","abort");
      }
    }
  }
  return iVar2;
}



int FUN_0048f548(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  bool bVar2;
  int *piVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined4 *local_res8;
  uint local_90;
  uint local_8c;
  uint local_44 [2];
  undefined1 auStack_3c [4];
  undefined1 auStack_38 [4];
  uint local_34;
  uint local_30;
  char *local_14;
  uint *local_10 [2];
  
  local_90 = 0;
  local_14 = (char *)0x0;
  local_10[0] = (uint *)0x0;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    puVar1 = local_10[0];
    if (-1 < iVar4) {
      if (DAT_00557704 == '\0') {
        uVar5 = *local_10[0];
      }
      else {
        uVar5 = *local_10[0];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Enabled                   : %d\n",uVar5);
      pcVar6 = FUN_0041e064((byte *)(puVar1 + 2));
      printf("Host IP Address           : %s\n",pcVar6);
      pcVar6 = FUN_0041e064((byte *)(puVar1 + 3));
      printf("Host IP Subnet Mask       : %s\n",pcVar6);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[4];
      }
      else {
        uVar5 = puVar1[4];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Downlink Bandwidth        : %d\n",uVar5);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[5];
      }
      else {
        uVar5 = puVar1[5];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Uplink Bandwidth          : %d\n",uVar5);
      putchar(10);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[6];
      }
      else {
        uVar5 = puVar1[6];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[BK]  : %d\n",uVar5);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[7];
      }
      else {
        uVar5 = puVar1[7];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[BE]  : %d\n",uVar5);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[8];
      }
      else {
        uVar5 = puVar1[8];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[VI]  : %d\n",uVar5);
      putchar(10);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[9];
      }
      else {
        uVar5 = puVar1[9];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[BK]  : %d\n",uVar5);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[10];
      }
      else {
        uVar5 = puVar1[10];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[BE]  : %d\n",uVar5);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[0xb];
      }
      else {
        uVar5 = puVar1[0xb];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[VI]  : %d\n",uVar5);
      putchar(10);
      if (DAT_00557704 == '\0') {
        uVar5 = puVar1[1];
      }
      else {
        uVar5 = puVar1[1];
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Flags                     : 0x%04X\n",uVar5);
    }
  }
  else {
    for (; piVar3[local_90] != 0; local_90 = local_90 + 1) {
    }
    if (((local_90 == 1) || (local_90 == 5)) || (local_90 == 6)) {
      memset(local_44,0,0x30);
      if (DAT_00557704 == '\0') {
        local_44[0] = strtol((char *)*piVar3,&local_14,0);
      }
      else {
        uVar5 = strtol((char *)*piVar3,&local_14,0);
        local_44[0] = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                      uVar5 >> 0x18;
      }
      local_res8 = (undefined4 *)(param_3 + 8);
      if (*local_14 == '\0') {
        if (1 < local_90) {
          if (local_44[0] == 0) {
            return -2;
          }
          bVar2 = FUN_0041d840((char *)*local_res8,(int)auStack_3c);
          if (CONCAT31(extraout_var,bVar2) == 0) {
            return -0x2c;
          }
          bVar2 = FUN_0041d840(*(char **)(param_3 + 0xc),(int)auStack_38);
          if (CONCAT31(extraout_var_00,bVar2) == 0) {
            return -0x2c;
          }
          if (DAT_00557704 == '\0') {
            local_34 = strtol(*(char **)(param_3 + 0x10),&local_14,0);
          }
          else {
            uVar5 = strtol(*(char **)(param_3 + 0x10),&local_14,0);
            local_34 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                       uVar5 >> 0x18;
          }
          local_res8 = (undefined4 *)(param_3 + 0x14);
          if (DAT_00557704 == '\0') {
            local_30 = strtol((char *)*local_res8,&local_14,0);
          }
          else {
            uVar5 = strtol((char *)*local_res8,&local_14,0);
            local_30 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                       uVar5 >> 0x18;
          }
          local_res8 = (undefined4 *)(param_3 + 0x18);
          for (local_8c = 0; local_8c < 3; local_8c = local_8c + 1) {
            local_44[local_8c + 6] = 0;
            *(undefined4 *)(auStack_3c + (local_8c + 8) * 4 + -4) = 0;
          }
          if (local_90 == 6) {
            if (DAT_00557704 == '\0') {
              local_44[1] = strtol((char *)*local_res8,&local_14,0);
            }
            else {
              uVar5 = strtol((char *)*local_res8,&local_14,0);
              local_44[1] = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                            uVar5 >> 0x18;
            }
          }
        }
        iVar4 = FUN_00445444(param_1,(char *)*param_2,local_44,0x30);
      }
      else {
        iVar4 = -0x2c;
      }
    }
    else {
      fprintf(stderr,"Too few/many arguments\t(require 1 or 5 or 6 , got %d)\n",local_90);
      iVar4 = -0x2c;
    }
  }
  return iVar4;
}



undefined4 FUN_00490010(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  long lVar3;
  undefined4 *local_res8;
  int local_50;
  undefined4 local_30 [4];
  ushort local_20;
  ushort local_1e;
  ushort local_1c;
  uint local_18;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  puVar1 = (undefined4 *)(param_3 + 4);
  for (local_50 = 0; puVar1[local_50] != 0; local_50 = local_50 + 1) {
  }
  if (local_50 == 4) {
    memset(local_30,0,0x20);
    local_30[0] = 1;
    if (DAT_00557704 == '\0') {
      lVar3 = strtol((char *)*puVar1,local_10,0);
      local_20 = (ushort)lVar3;
    }
    else {
      lVar3 = strtol((char *)*puVar1,local_10,0);
      local_20 = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
    }
    local_res8 = (undefined4 *)(param_3 + 8);
    if (*local_10[0] == '\0') {
      if (DAT_00557704 == '\0') {
        lVar3 = strtol((char *)*local_res8,local_10,0);
        local_1e = (ushort)lVar3;
      }
      else {
        lVar3 = strtol((char *)*local_res8,local_10,0);
        local_1e = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
      }
      local_res8 = (undefined4 *)(param_3 + 0xc);
      if (*local_10[0] == '\0') {
        if (DAT_00557704 == '\0') {
          lVar3 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar3;
        }
        else {
          lVar3 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0x10);
        if (*local_10[0] == '\0') {
          if (DAT_00557704 == '\0') {
            local_18 = strtol((char *)*local_res8,local_10,0);
            local_18 = local_18 & 0xffff;
          }
          else {
            lVar3 = strtol((char *)*local_res8,local_10,0);
            local_18 = (uint)(ushort)((ushort)lVar3 << 8 | (ushort)lVar3 >> 8);
          }
          if (*local_10[0] == '\0') {
            uVar2 = FUN_00445444(param_1,(char *)*param_2,local_30,0x20);
          }
          else {
            uVar2 = 0xffffffd4;
          }
        }
        else {
          uVar2 = 0xffffffd4;
        }
      }
      else {
        uVar2 = 0xffffffd4;
      }
    }
    else {
      uVar2 = 0xffffffd4;
    }
  }
  else {
    fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",4,local_50);
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



undefined4 FUN_00490458(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  long lVar4;
  undefined3 extraout_var;
  undefined4 *local_res8;
  uint local_50;
  undefined4 local_2c;
  undefined1 auStack_28 [12];
  ushort local_1c;
  ushort local_1a;
  ushort local_18;
  ushort local_16;
  uint local_14;
  char *local_c;
  
  local_c = (char *)0x0;
  puVar2 = (undefined4 *)(param_3 + 4);
  for (local_50 = 0; puVar2[local_50] != 0; local_50 = local_50 + 1) {
  }
  if (local_50 < 3) {
    fprintf(stderr,"Too few arguments (require > 3  got %d)\n",local_50);
    uVar3 = 0xffffffd4;
  }
  else {
    memset(&local_2c,0,0x20);
    local_2c = 1;
    if (DAT_00557704 == '\0') {
      lVar4 = strtol((char *)*puVar2,&local_c,0);
      local_16 = (ushort)lVar4;
    }
    else {
      lVar4 = strtol((char *)*puVar2,&local_c,0);
      local_16 = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
    }
    local_res8 = (undefined4 *)(param_3 + 8);
    if (*local_c == '\0') {
      if ((local_16 & 1) == 0) {
        if (local_50 != 5) {
          fprintf(stderr,"Too few/many arguments (require 5 got %d)\n",local_50);
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_1c = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_1c = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0xc);
        if (*local_c != '\0') {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_1a = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_1a = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0x10);
        if (*local_c != '\0') {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_18 = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_18 = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0x14);
        if (*local_c != '\0') {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          local_14 = strtol((char *)*local_res8,&local_c,0);
          local_14 = local_14 & 0xffff;
        }
        else {
          lVar4 = strtol((char *)*local_res8,&local_c,0);
          local_14 = (uint)(ushort)((ushort)lVar4 << 8 | (ushort)lVar4 >> 8);
        }
        if (*local_c != '\0') {
          return 0xffffffd4;
        }
      }
      else {
        if (local_50 != 3) {
          fprintf(stderr,"Too many arguments (require 3 got %d)\n",local_50);
          return 0xffffffd4;
        }
        bVar1 = FUN_0041d6ac((char *)*local_res8,auStack_28);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          local_14 = strtol(*(char **)(param_3 + 0xc),&local_c,0);
          local_14 = local_14 & 0xffff;
        }
        else {
          lVar4 = strtol(*(char **)(param_3 + 0xc),&local_c,0);
          local_14 = (uint)(ushort)((ushort)lVar4 << 8 | (ushort)lVar4 >> 8);
        }
        if (*local_c != '\0') {
          return 0xffffffd4;
        }
      }
      uVar3 = FUN_00445444(param_1,"trf_mgmt_filters_add",&local_2c,0x20);
    }
    else {
      uVar3 = 0xffffffd4;
    }
  }
  return uVar3;
}



undefined4 FUN_00490ae8(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  long lVar3;
  undefined4 *local_res8;
  int local_50;
  undefined4 local_30 [4];
  ushort local_20;
  ushort local_1e;
  ushort local_1c;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  puVar1 = (undefined4 *)(param_3 + 4);
  for (local_50 = 0; puVar1[local_50] != 0; local_50 = local_50 + 1) {
  }
  if (local_50 == 3) {
    memset(local_30,0,0x20);
    local_30[0] = 1;
    if (DAT_00557704 == '\0') {
      lVar3 = strtol((char *)*puVar1,local_10,0);
      local_20 = (ushort)lVar3;
    }
    else {
      lVar3 = strtol((char *)*puVar1,local_10,0);
      local_20 = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
    }
    local_res8 = (undefined4 *)(param_3 + 8);
    if (*local_10[0] == '\0') {
      if (DAT_00557704 == '\0') {
        lVar3 = strtol((char *)*local_res8,local_10,0);
        local_1e = (ushort)lVar3;
      }
      else {
        lVar3 = strtol((char *)*local_res8,local_10,0);
        local_1e = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
      }
      local_res8 = (undefined4 *)(param_3 + 0xc);
      if (*local_10[0] == '\0') {
        if (DAT_00557704 == '\0') {
          lVar3 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar3;
        }
        else {
          lVar3 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar3 << 8 | (ushort)lVar3 >> 8;
        }
        if (*local_10[0] == '\0') {
          uVar2 = FUN_00445444(param_1,(char *)*param_2,local_30,0x20);
        }
        else {
          uVar2 = 0xffffffd4;
        }
      }
      else {
        uVar2 = 0xffffffd4;
      }
    }
    else {
      uVar2 = 0xffffffd4;
    }
  }
  else {
    fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",3,local_50);
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



undefined4 FUN_00490e6c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  long lVar4;
  undefined3 extraout_var;
  undefined4 *local_res8;
  uint local_50;
  undefined4 local_30;
  undefined1 auStack_2c [12];
  ushort local_20;
  ushort local_1e;
  ushort local_1c;
  ushort local_1a;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  puVar2 = (undefined4 *)(param_3 + 4);
  for (local_50 = 0; puVar2[local_50] != 0; local_50 = local_50 + 1) {
  }
  if (local_50 < 2) {
    fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",2,local_50);
    uVar3 = 0xffffffd4;
  }
  else {
    memset(&local_30,0,0x20);
    local_30 = 1;
    if (DAT_00557704 == '\0') {
      lVar4 = strtol((char *)*puVar2,local_10,0);
      local_1a = (ushort)lVar4;
    }
    else {
      lVar4 = strtol((char *)*puVar2,local_10,0);
      local_1a = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
    }
    local_res8 = (undefined4 *)(param_3 + 8);
    if (*local_10[0] == '\0') {
      if ((local_1a & 1) == 0) {
        if (local_50 < 4) {
          fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",4,local_50);
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_20 = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_20 = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0xc);
        if (*local_10[0] != '\0') {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_1e = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_1e = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0x10);
        if (*local_10[0] != '\0') {
          return 0xffffffd4;
        }
        if (DAT_00557704 == '\0') {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar4;
        }
        else {
          lVar4 = strtol((char *)*local_res8,local_10,0);
          local_1c = (ushort)lVar4 << 8 | (ushort)lVar4 >> 8;
        }
        if (*local_10[0] != '\0') {
          return 0xffffffd4;
        }
      }
      else {
        if (local_50 != 2) {
          fprintf(stderr,"Too many arguments (require 2 got %d)\n",local_50);
          return 0xffffffd4;
        }
        bVar1 = FUN_0041d6ac((char *)*local_res8,auStack_2c);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          return 0xffffffd4;
        }
      }
      uVar3 = FUN_00445444(param_1,"trf_mgmt_filters_remove",&local_30,0x20);
    }
    else {
      uVar3 = 0xffffffd4;
    }
  }
  return uVar3;
}



int FUN_0049137c(int *param_1,undefined4 *param_2)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  char *param1;
  uint local_40;
  uint *local_10 [2];
  
  local_10[0] = (uint *)0x0;
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
  puVar1 = local_10[0];
  if (-1 < iVar2) {
    if (DAT_00557704 == '\0') {
      uVar3 = *local_10[0];
    }
    else {
      uVar3 = *local_10[0];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    printf("Number of filters : %d\n",uVar3);
    for (local_40 = 0; local_40 < *puVar1; local_40 = local_40 + 1) {
      if ((*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x16) & 1) == 0) {
        putchar(10);
        printf("Filter #%d\n",local_40);
        if (DAT_00557704 == '\0') {
          uVar3 = (uint)(ushort)puVar1[local_40 * 7 + 4];
        }
        else {
          uVar3 = (uint)(ushort)puVar1[local_40 * 7 + 4] << 0x18 |
                  ((ushort)puVar1[local_40 * 7 + 4] & 0xff00) << 8;
        }
        printf("Dst Port : %d\n",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x12);
        }
        else {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x12);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8;
        }
        printf("Src Port : %d\n",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = (uint)(ushort)puVar1[local_40 * 7 + 5];
        }
        else {
          uVar3 = (uint)(ushort)puVar1[local_40 * 7 + 5] << 0x18 |
                  ((ushort)puVar1[local_40 * 7 + 5] & 0xff00) << 8;
        }
        printf("Protocol : %d\n",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x16);
        }
        else {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x16);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8;
        }
        printf("Flags    : 0x%02x\n",uVar3);
        if (DAT_00557704 == '\0') {
          uVar3 = puVar1[local_40 * 7 + 6];
        }
        else {
          uVar3 = puVar1[local_40 * 7 + 6];
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        printf("Priority : %d\n",uVar3);
      }
      else {
        putchar(10);
        printf("Filter #%d\n",local_40);
        if (DAT_00557704 == '\0') {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x16);
        }
        else {
          uVar3 = (uint)*(ushort *)((int)puVar1 + local_40 * 0x1c + 0x16);
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8;
        }
        printf("Flags    : 0x%02x\n",uVar3);
        param1 = FUN_0041d780((int)(puVar1 + local_40 * 7 + 1));
        printf("Dst EtherAddr    : %s\n",param1);
        if (DAT_00557704 == '\0') {
          uVar3 = puVar1[local_40 * 7 + 6];
        }
        else {
          uVar3 = puVar1[local_40 * 7 + 6];
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        printf("Priority : %d\n",uVar3);
      }
    }
  }
  return iVar2;
}



undefined4 FUN_0049189c(int *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  
  uVar1 = FUN_00445444(param_1,(char *)*param_2,(void *)0x0,0);
  return uVar1;
}



int FUN_00491900(int *param_1,undefined4 *param_2,int param_3)

{
  void *pvVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  undefined4 *local_res8;
  uint local_88;
  int local_84;
  int local_80;
  uint auStack_40 [4];
  uint local_30;
  uint local_2c;
  char *local_10;
  void *local_c;
  
  local_88 = 0;
  local_10 = (char *)0x0;
  local_c = (void *)0x0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    pvVar1 = local_c;
    if (-1 < iVar3) {
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)local_c + 0x10);
      }
      else {
        uVar4 = *(uint *)((int)local_c + 0x10);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Downlink Bandwidth        : %d\n",uVar4);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x14);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x14);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Uplink Bandwidth          : %d\n",uVar4);
      putchar(10);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x18);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x18);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[BK]  : %d\n",uVar4);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x1c);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x1c);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[BE]  : %d\n",uVar4);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x20);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x20);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Tx Bandwidth[VI]  : %d\n",uVar4);
      putchar(10);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x18);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x18);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[BK]  : %d\n",uVar4);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x1c);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x1c);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[BE]  : %d\n",uVar4);
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)((int)pvVar1 + 0x20);
      }
      else {
        uVar4 = *(uint *)((int)pvVar1 + 0x20);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("Minimum Rx Bandwidth[VI]  : %d\n",uVar4);
    }
  }
  else {
    for (; piVar2[local_88] != 0; local_88 = local_88 + 1) {
    }
    if (local_88 < 5) {
      fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",5,local_88);
      iVar3 = -0x2c;
    }
    else {
      iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
      if (-1 < iVar3) {
        memcpy(auStack_40,local_c,0x30);
        if (DAT_00557704 == '\0') {
          local_30 = strtol((char *)*piVar2,&local_10,0);
        }
        else {
          uVar4 = strtol((char *)*piVar2,&local_10,0);
          local_30 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18
          ;
        }
        local_res8 = (undefined4 *)(param_3 + 8);
        if (*local_10 == '\0') {
          if (DAT_00557704 == '\0') {
            local_2c = strtol((char *)*local_res8,&local_10,0);
          }
          else {
            uVar4 = strtol((char *)*local_res8,&local_10,0);
            local_2c = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                       uVar4 >> 0x18;
          }
          local_res8 = (undefined4 *)(param_3 + 0xc);
          if (*local_10 == '\0') {
            local_80 = 0;
            for (local_84 = 0; local_84 < 3; local_84 = local_84 + 1) {
              if (DAT_00557704 == '\0') {
                uVar4 = strtol((char *)*local_res8,&local_10,0);
              }
              else {
                uVar4 = strtol((char *)*local_res8,&local_10,0);
                uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                        uVar4 >> 0x18;
              }
              local_res8 = local_res8 + 1;
              auStack_40[local_84 + 6] = uVar4;
              if (*local_10 != '\0') {
                return -0x2c;
              }
              local_80 = auStack_40[local_84 + 6] + local_80;
            }
            if (local_80 == 100) {
              if (local_88 < 6) {
                for (local_84 = 0; local_84 < 3; local_84 = local_84 + 1) {
                  auStack_40[local_84 + 9] = auStack_40[local_84 + 6];
                }
              }
              else {
                local_80 = 0;
                for (local_84 = 0; local_84 < 3; local_84 = local_84 + 1) {
                  if (DAT_00557704 == '\0') {
                    uVar4 = strtol((char *)*local_res8,&local_10,0);
                  }
                  else {
                    uVar4 = strtol((char *)*local_res8,&local_10,0);
                    uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                            uVar4 >> 0x18;
                  }
                  local_res8 = local_res8 + 1;
                  auStack_40[local_84 + 9] = uVar4;
                  if (*local_10 != '\0') {
                    return -0x2c;
                  }
                  local_80 = auStack_40[local_84 + 9] + local_80;
                }
                if (local_80 != 100) {
                  fprintf(stderr,"Sum of gauranteed rx bandwidth levels must equal 100 (got %d)\n",
                          local_80);
                  return -2;
                }
              }
              iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_40,0x30);
            }
            else {
              fprintf(stderr,"Sum of gauranteed bandwidth levels must equal 100 (got %d)\n",local_80
                     );
              iVar3 = -2;
            }
          }
          else {
            iVar3 = -0x2c;
          }
        }
        else {
          iVar3 = -0x2c;
        }
      }
    }
  }
  return iVar3;
}



int FUN_00492388(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  int local_20;
  uint local_14;
  char *local_10;
  uint *local_c;
  
  local_20 = 0;
  local_10 = (char *)0x0;
  local_c = (uint *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar2) {
      local_14 = *local_c;
      printf("Flags : 0x%04X\n",local_14);
    }
  }
  else {
    for (; piVar1[local_20] != 0; local_20 = local_20 + 1) {
    }
    if (local_20 == 1) {
      if (DAT_00557704 == '\0') {
        local_14 = strtol((char *)*piVar1,&local_10,0);
      }
      else {
        uVar3 = strtol((char *)*piVar1,&local_10,0);
        local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      if (*local_10 == '\0') {
        iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_14,4);
      }
      else {
        iVar2 = -0x2c;
      }
    }
    else {
      fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",1,local_20);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



void FUN_004925c8(int param_1,int param_2)

{
  uint *puVar1;
  uint uVar2;
  int iVar3;
  
  puVar1 = (uint *)(param_1 + param_2 * 0xc);
  printf("Statistics for Tx Queue[%d]\n",param_2);
  putchar(10);
  if (DAT_00557704 == '\0') {
    uVar2 = *puVar1;
  }
  else {
    uVar2 = *puVar1;
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets processed : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = puVar1[1];
  }
  else {
    uVar2 = puVar1[1];
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes processed   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = puVar1[2];
  }
  else {
    uVar2 = puVar1[2];
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets discarded : %d\n",uVar2);
  iVar3 = param_1 + param_2 * 0xc;
  putchar(10);
  printf("Statistics for Rx Queue[%d]\n",param_2);
  putchar(10);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar3 + 0x24);
  }
  else {
    uVar2 = *(uint *)(iVar3 + 0x24);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets processed : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar3 + 0x28);
  }
  else {
    uVar2 = *(uint *)(iVar3 + 0x28);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes processed   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar3 + 0x2c);
  }
  else {
    uVar2 = *(uint *)(iVar3 + 0x2c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets discarded : %d\n",uVar2);
  putchar(10);
  return;
}



int FUN_00492968(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  long lVar3;
  uint uVar4;
  int local_20;
  uint local_1c;
  char *local_10;
  int local_c;
  
  local_20 = 0;
  local_10 = (char *)0x0;
  local_c = 0;
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (-1 < iVar1) {
    piVar2 = (int *)(param_3 + 4);
    if (*piVar2 == 0) {
      for (local_1c = 0; local_1c < 3; local_1c = local_1c + 1) {
        FUN_004925c8(local_c,local_1c);
      }
    }
    else {
      for (; piVar2[local_20] != 0; local_20 = local_20 + 1) {
      }
      if (local_20 == 1) {
        if (DAT_00557704 == '\0') {
          uVar4 = strtol((char *)*piVar2,&local_10,0);
          uVar4 = uVar4 & 0xffff;
        }
        else {
          lVar3 = strtol((char *)*piVar2,&local_10,0);
          uVar4 = (uint)(ushort)((ushort)lVar3 << 8 | (ushort)lVar3 >> 8);
        }
        if (uVar4 < 3) {
          FUN_004925c8(local_c,uVar4);
        }
        else {
          fprintf(stderr,"Index must be < %d)\n",3);
          iVar1 = -2;
        }
      }
      else {
        fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",1,local_20);
        iVar1 = -0x2c;
      }
    }
  }
  return iVar1;
}



undefined4 FUN_00492ba8(int *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  
  uVar1 = FUN_00445444(param_1,(char *)*param_2,(void *)0x0,0);
  return uVar1;
}



void FUN_00492c0c(undefined4 *param_1)

{
  puts("Global shaping info. for Tx Queues");
  putchar(10);
  printf("Maximum bytes/second                      : %d\n",*param_1);
  printf("Maximum bytes/sampling period             : %d\n",param_1[1]);
  printf("Total bytes consumed per second           : %d\n",param_1[2]);
  printf("Total bytes consumed per sampling period  : %d\n",param_1[3]);
  printf("Unused bytes for current sampling period  : %d\n",param_1[4]);
  putchar(10);
  puts("Global shaping info. for Rx Queues");
  putchar(10);
  printf("Maximum bytes/second                      : %d\n",param_1[0x1a]);
  printf("Maximum bytes/sampling period             : %d\n",param_1[0x1b]);
  printf("Total bytes consumed per second           : %d\n",param_1[0x1c]);
  printf("Total bytes consumed per sampling period  : %d\n",param_1[0x1d]);
  printf("Unused bytes for current sampling period  : %d\n",param_1[0x1e]);
  putchar(10);
  return;
}



void FUN_00492dbc(int param_1,int param_2)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = param_1 + param_2 * 0x1c;
  printf("Shaping info. for Tx Queue[%d]\n",param_2);
  putchar(10);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x14);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x14);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Gauranteed bandwidth percentage  : %d%%\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x18);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x18);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Guaranteed bytes/second          : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x1c);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x1c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Guaranteed bytes/sampling period : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x20);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x20);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes produced per second   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x24);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x24);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes consumed per second   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x28);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x28);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets pending             : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x2c);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x2c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes pending               : %d\n",uVar2);
  iVar1 = param_1 + param_2 * 0x1c;
  putchar(10);
  printf("Shaping info. for Rx Queue[%d]\n",param_2);
  putchar(10);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x7c);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x7c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Gauranteed bandwidth percentage  : %d%%\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x80);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x80);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Guaranteed bytes/second          : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x84);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x84);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Guaranteed bytes/sampling period : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x88);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x88);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes produced per second   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x8c);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x8c);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes consumed per second   : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x90);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x90);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. packets pending             : %d\n",uVar2);
  if (DAT_00557704 == '\0') {
    uVar2 = *(uint *)(iVar1 + 0x94);
  }
  else {
    uVar2 = *(uint *)(iVar1 + 0x94);
    uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
  }
  printf("Num. bytes pending               : %d\n",uVar2);
  putchar(10);
  return;
}



int FUN_00493524(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  long lVar3;
  uint uVar4;
  int local_20;
  uint local_1c;
  char *local_10;
  undefined4 *local_c;
  
  local_20 = 0;
  local_10 = (char *)0x0;
  local_c = (undefined4 *)0x0;
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  if (-1 < iVar1) {
    piVar2 = (int *)(param_3 + 4);
    if (*piVar2 == 0) {
      FUN_00492c0c(local_c);
      for (local_1c = 0; local_1c < 3; local_1c = local_1c + 1) {
        FUN_00492dbc((int)local_c,local_1c);
      }
    }
    else {
      for (; piVar2[local_20] != 0; local_20 = local_20 + 1) {
      }
      if (local_20 == 1) {
        if (DAT_00557704 == '\0') {
          uVar4 = strtol((char *)*piVar2,&local_10,0);
          uVar4 = uVar4 & 0xffff;
        }
        else {
          lVar3 = strtol((char *)*piVar2,&local_10,0);
          uVar4 = (uint)(ushort)((ushort)lVar3 << 8 | (ushort)lVar3 >> 8);
        }
        if (uVar4 < 3) {
          FUN_00492c0c(local_c);
          FUN_00492dbc((int)local_c,uVar4);
        }
        else {
          fprintf(stderr,"Index must be < %d)\n",3);
          iVar1 = -2;
        }
      }
      else {
        fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",1,local_20);
        iVar1 = -0x2c;
      }
    }
  }
  return iVar1;
}



int FUN_00493784(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  int iVar5;
  long lVar6;
  ushort uVar7;
  ushort uVar8;
  ushort uVar9;
  ushort uVar10;
  undefined4 *local_res8;
  uint local_50;
  ushort local_20;
  ushort local_1e;
  ushort local_1c;
  ushort local_1a;
  ushort local_18;
  ushort local_16;
  ushort local_14;
  char *local_10;
  ushort *local_c;
  
  local_10 = (char *)0x0;
  local_50 = 0;
  piVar4 = (int *)(param_3 + 4);
  if (*piVar4 == 0) {
    local_c = (ushort *)0x0;
    iVar5 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (-1 < iVar5) {
      if (DAT_00557704 == '\0') {
        uVar1 = *local_c;
      }
      else {
        uVar1 = *local_c << 8 | *local_c >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = local_c[1];
      }
      else {
        uVar2 = local_c[1] << 8 | local_c[1] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = local_c[2];
      }
      else {
        uVar3 = local_c[2] << 8 | local_c[2] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar7 = local_c[3];
      }
      else {
        uVar7 = local_c[3] << 8 | local_c[3] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar8 = local_c[4];
      }
      else {
        uVar8 = local_c[4] << 8 | local_c[4] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar9 = local_c[5];
      }
      else {
        uVar9 = local_c[5] << 8 | local_c[5] >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar10 = local_c[6];
      }
      else {
        uVar10 = local_c[6] << 8 | local_c[6] >> 8;
      }
      printf("%d %d %d %d %d %d %d\n",(uint)uVar1,(uint)uVar2,(uint)uVar3,(uint)uVar7,(uint)uVar8,
             (uint)uVar9,(uint)uVar10);
      iVar5 = 0;
    }
  }
  else {
    for (; piVar4[local_50] != 0; local_50 = local_50 + 1) {
    }
    memset(&local_20,0,0xe);
    if (local_50 < 7) {
      fprintf(stderr,"Too few/many arguments (require %d, got %d)\n",7,local_50);
      iVar5 = -0x2c;
    }
    else {
      if (DAT_00557704 == '\0') {
        lVar6 = strtol((char *)*piVar4,&local_10,0);
        local_20 = (ushort)lVar6;
      }
      else {
        lVar6 = strtol((char *)*piVar4,&local_10,0);
        local_20 = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
      }
      local_res8 = (undefined4 *)(param_3 + 8);
      if (*local_10 == '\0') {
        if (DAT_00557704 == '\0') {
          lVar6 = strtol((char *)*local_res8,&local_10,0);
          local_1e = (ushort)lVar6;
        }
        else {
          lVar6 = strtol((char *)*local_res8,&local_10,0);
          local_1e = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
        }
        local_res8 = (undefined4 *)(param_3 + 0xc);
        if (*local_10 == '\0') {
          if (DAT_00557704 == '\0') {
            lVar6 = strtol((char *)*local_res8,&local_10,0);
            local_1c = (ushort)lVar6;
          }
          else {
            lVar6 = strtol((char *)*local_res8,&local_10,0);
            local_1c = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
          }
          local_res8 = (undefined4 *)(param_3 + 0x10);
          if (*local_10 == '\0') {
            if (DAT_00557704 == '\0') {
              lVar6 = strtol((char *)*local_res8,&local_10,0);
              local_1a = (ushort)lVar6;
            }
            else {
              lVar6 = strtol((char *)*local_res8,&local_10,0);
              local_1a = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
            }
            local_res8 = (undefined4 *)(param_3 + 0x14);
            if (*local_10 == '\0') {
              if (DAT_00557704 == '\0') {
                lVar6 = strtol((char *)*local_res8,&local_10,0);
                local_18 = (ushort)lVar6;
              }
              else {
                lVar6 = strtol((char *)*local_res8,&local_10,0);
                local_18 = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
              }
              local_res8 = (undefined4 *)(param_3 + 0x18);
              if (*local_10 == '\0') {
                if (DAT_00557704 == '\0') {
                  lVar6 = strtol((char *)*local_res8,&local_10,0);
                  local_16 = (ushort)lVar6;
                }
                else {
                  lVar6 = strtol((char *)*local_res8,&local_10,0);
                  local_16 = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
                }
                local_res8 = (undefined4 *)(param_3 + 0x1c);
                if (*local_10 == '\0') {
                  if (DAT_00557704 == '\0') {
                    lVar6 = strtol((char *)*local_res8,&local_10,0);
                    local_14 = (ushort)lVar6;
                  }
                  else {
                    lVar6 = strtol((char *)*local_res8,&local_10,0);
                    local_14 = (ushort)lVar6 << 8 | (ushort)lVar6 >> 8;
                  }
                  if (*local_10 == '\0') {
                    iVar5 = FUN_00483770((short *)&local_20);
                    if (iVar5 == 0) {
                      iVar5 = FUN_00445444(param_1,(char *)*param_2,&local_20,0xe);
                    }
                    else {
                      iVar5 = -0x1d;
                    }
                  }
                  else {
                    iVar5 = -0x2c;
                  }
                }
                else {
                  iVar5 = -0x2c;
                }
              }
              else {
                iVar5 = -0x2c;
              }
            }
            else {
              iVar5 = -0x2c;
            }
          }
          else {
            iVar5 = -0x2c;
          }
        }
        else {
          iVar5 = -0x2c;
        }
      }
      else {
        iVar5 = -0x2c;
      }
    }
  }
  return iVar5;
}



int FUN_00494138(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  size_t sVar1;
  int iVar2;
  void *pvVar3;
  char *pcVar4;
  
  pcVar4 = (char *)*param_2;
  pvVar3 = (void *)*param_3;
  sVar1 = strlen((char *)*param_3);
  iVar2 = FUN_004ba2e4(param_1,pcVar4,pvVar3,sVar1);
  if (iVar2 < 0) {
    printf("Error finding the remote server  %s\n",(char *)*param_3);
  }
  return iVar2;
}



undefined4 FUN_004941f4(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  int iVar2;
  ulong uVar3;
  uint param1;
  undefined4 uVar4;
  size_t sVar5;
  int *local_res8;
  int local_120;
  byte local_11c;
  byte local_108;
  byte local_107;
  undefined1 auStack_106 [254];
  
  local_120 = 0;
  local_11c = 0;
  local_res8 = (int *)(param_3 + 4);
  memset(&local_108,0,3);
  do {
    while( true ) {
      if (*local_res8 == 0) {
        if (local_11c == 0) {
          uVar4 = 0xfffffffe;
        }
        else {
          if (local_107 == 0) {
            sVar5 = 3;
          }
          else {
            sVar5 = local_107 + 2;
          }
          uVar4 = FUN_00445444(param_1,(char *)*param_2,&local_108,sVar5);
        }
        return uVar4;
      }
      iVar2 = strncmp((char *)*local_res8,"-i",2);
      if ((iVar2 != 0) || ((local_11c & 1) != 0)) break;
      if (local_res8[1] == 0) {
        return 0xffffffd4;
      }
      iVar2 = atoi((char *)local_res8[1]);
      if ((iVar2 != 0) && (iVar2 != 1)) {
        return 0xfffffffe;
      }
      if (iVar2 == 0) {
        bVar1 = 0;
      }
      else {
        bVar1 = 2;
      }
      local_108 = local_108 | bVar1;
      local_11c = local_11c | 1;
LAB_00494644:
      local_res8 = local_res8 + 2;
    }
    iVar2 = strncmp((char *)*local_res8,"-w",2);
    if ((iVar2 == 0) && ((local_11c & 2) == 0)) {
      if (local_res8[1] == 0) {
        return 0xffffffd4;
      }
      iVar2 = atoi((char *)local_res8[1]);
      if ((iVar2 != 0) && (iVar2 != 1)) {
        return 0xfffffffe;
      }
      if (iVar2 == 0) {
        bVar1 = 0;
      }
      else {
        bVar1 = 4;
      }
      local_108 = local_108 | bVar1;
      local_11c = local_11c | 2;
      goto LAB_00494644;
    }
    iVar2 = strncmp((char *)*local_res8,"-c",2);
    if ((iVar2 != 0) || ((local_11c & 4) != 0)) {
      return 0xffffffd4;
    }
    while ((local_res8 = local_res8 + 1, *local_res8 != 0 &&
           ((*(ushort *)(__ctype_b + (uint)*(byte *)*local_res8 * 2) & 8) != 0))) {
      if (DAT_00557704 == '\0') {
        param1 = strtoul((char *)*local_res8,(char **)0x0,0);
      }
      else {
        uVar3 = strtoul((char *)*local_res8,(char **)0x0,0);
        param1 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      if ((param1 == 0) || (0xe < (int)param1)) {
        printf("Invalid channel %d\n",param1);
        return 0xfffffffe;
      }
      auStack_106[local_120] = (char)param1;
      local_120 = local_120 + 1;
      if (0xe < local_120) {
        puts("Too many channels (max 14)");
        return 0xfffffffe;
      }
    }
    if (local_120 == 0) {
      puts("With option \'-c\' specified, a channel list is required");
      return 0xfffffffe;
    }
    local_107 = (byte)local_120;
    local_11c = local_11c | 4;
  } while( true );
}



int FUN_004946e0(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  char *pcVar1;
  uint param1;
  size_t __n;
  uint local_4c;
  uint local_34;
  uint local_30;
  undefined1 auStack_2c [32];
  char *local_c;
  
  memset(&local_34,0,0x28);
  pcVar1 = (char *)*param_3;
  for (local_4c = 0; (param_3 + 1)[local_4c] != 0; local_4c = local_4c + 1) {
  }
  if (local_4c == 0) {
    param1 = 0xffffffd4;
  }
  else {
    local_34 = strtol((char *)param_3[1],&local_c,0);
    if ((*local_c == '\0') && ((int)local_34 < 0x10)) {
      if (local_4c < 3) {
        if (local_4c == 2) {
          __n = strlen((char *)param_3[2]);
          if (0x20 < __n) {
            puts("ssid too long");
            return -2;
          }
          memcpy(auStack_2c,(void *)param_3[2],__n);
          local_30 = __n;
        }
        if (local_4c == 1) {
          if (DAT_00557704 != '\0') {
            local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                       local_34 >> 0x18;
          }
          param1 = FUN_004ba0cc(param_1,pcVar1,&local_34,0x28,PTR_DAT_00551644,0x100);
          if ((int)param1 < 0) {
            printf("get returned error 0x%x\n",param1);
          }
          else {
            FUN_0041e248((int)PTR_DAT_00551644,0x24);
          }
        }
        else {
          if (DAT_00557704 != '\0') {
            local_34 = local_34 << 0x18 | (local_34 & 0xff00) << 8 | (local_34 & 0xff0000) >> 8 |
                       local_34 >> 0x18;
            local_30 = local_30 << 0x18 | (local_30 & 0xff00) << 8 | (local_30 & 0xff0000) >> 8 |
                       local_30 >> 0x18;
          }
          param1 = FUN_004ba2e4(param_1,pcVar1,&local_34,0x28);
          if ((int)param1 < 0) {
            printf("set returned error 0x%x\n",param1);
          }
        }
      }
      else {
        param1 = 0xffffffd4;
      }
    }
    else {
      param1 = 0xffffffd4;
    }
  }
  return param1;
}



void FUN_00494a88(int param_1)

{
  int iVar1;
  int local_10;
  
  printf("MCS SET : [ ");
  for (local_10 = 0; local_10 < 0x80; local_10 = local_10 + 1) {
    iVar1 = local_10;
    if (local_10 < 0) {
      iVar1 = local_10 + 7;
    }
    if (((int)(uint)*(byte *)(param_1 + (iVar1 >> 3)) >> (local_10 % 8 & 0x1fU) & 1U) != 0) {
      printf("%d ",local_10);
    }
  }
  puts("]");
  return;
}



void FUN_00494b5c(int param_1)

{
  int local_10;
  uint local_c;
  
  for (local_10 = 0; (local_10 < 8 && (*(short *)(param_1 + local_10 * 2) != 0));
      local_10 = local_10 + 1) {
    if (local_10 == 0) {
      printf("VHT SET : ");
    }
    else {
      printf("        : ");
    }
    for (local_c = 0; (int)local_c < 10; local_c = local_c + 1) {
      if (((int)(uint)*(ushort *)(param_1 + local_10 * 2) >> (local_c & 0x1f) & 1U) != 0) {
        printf("%dx%d ",local_c,local_10 + 1);
      }
    }
    putchar(10);
  }
  return;
}



void FUN_00494c8c(int param_1,char *param_2)

{
  int iVar1;
  int local_10;
  
  printf("%s MCS : [ ",param_2);
  for (local_10 = 0; local_10 < 0x20; local_10 = local_10 + 1) {
    iVar1 = local_10;
    if (local_10 < 0) {
      iVar1 = local_10 + 7;
    }
    if (((int)(uint)*(byte *)(param_1 + (iVar1 >> 3)) >> (local_10 % 8 & 0x1fU) & 1U) != 0) {
      printf("%d ",local_10);
    }
  }
  puts("]");
  return;
}



void FUN_00494d68(int param_1,char *param_2)

{
  int local_10;
  uint local_c;
  
  for (local_10 = 0; (local_10 < 4 && (*(short *)(param_1 + local_10 * 2) != 0));
      local_10 = local_10 + 1) {
    if (local_10 == 0) {
      printf("%s VHT : ",param_2);
    }
    else {
      printf("        : ");
    }
    for (local_c = 0; (int)local_c < 10; local_c = local_c + 1) {
      if (((int)(uint)*(ushort *)(param_1 + local_10 * 2) >> (local_c & 0x1f) & 1U) != 0) {
        printf("%dx%d ",local_c,local_10 + 1);
      }
    }
    putchar(10);
  }
  return;
}



int FUN_00494ea0(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  
  iVar1 = FUN_00444b10(param_1,param_2,param_3);
  if (-1 < iVar1) {
    FUN_00494a88((int)PTR_DAT_00551644);
  }
  return iVar1;
}



int FUN_00494f1c(int *param_1,undefined4 param_2,int *param_3)

{
  int iVar1;
  
  iVar1 = FUN_00444b10(param_1,param_2,param_3);
  if (-1 < iVar1) {
    FUN_00494a88((int)PTR_DAT_00551644);
  }
  return iVar1;
}



int FUN_00494f98(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  int iVar3;
  uint uVar4;
  undefined4 *local_res8;
  int local_12c;
  int local_128;
  int local_124;
  undefined1 auStack_114 [256];
  uint local_14;
  uint *local_10;
  char *pcStack_c;
  
  bVar1 = true;
  local_12c = 0;
  local_10 = (uint *)0x0;
  for (local_128 = 0; *(int *)(param_3 + local_128 * 4) != 0; local_128 = local_128 + 1) {
  }
  if (4 < local_128) {
    return -0x2c;
  }
  local_res8 = (undefined4 *)(param_3 + 4);
  local_124 = 1;
  if (local_128 == 1) {
    local_14 = 0xffffffff;
    memcpy(auStack_114,&local_14,4);
  }
  else {
    if ((*(ushort *)(__ctype_b + (uint)*(byte *)*local_res8 * 2) & 8) != 0) {
      bVar1 = false;
      if (DAT_00557704 == '\0') {
        local_14 = strtoul((char *)*local_res8,&pcStack_c,0);
      }
      else {
        uVar2 = strtoul((char *)*local_res8,&pcStack_c,0);
        local_14 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      if ((local_14 != 0) && (local_14 != 1)) {
        fwrite("wl mimo_ss_stf: bad stf mode.\n",1,0x1e,stderr);
        return -2;
      }
      memcpy(auStack_114,&local_14,4);
      local_12c = 4;
      local_res8 = (undefined4 *)(param_3 + 8);
      local_124 = 2;
    }
    if (local_124 == local_128) {
      local_14 = 0xffffffff;
      memcpy(auStack_114 + local_12c,&local_14,4);
    }
    else {
      iVar3 = strncmp((char *)*local_res8,"-b",2);
      if (iVar3 == 0) {
        if (local_124 + 1 == local_128) {
          return -2;
        }
        iVar3 = strcmp((char *)local_res8[1],"a");
        if (iVar3 == 0) {
          local_14 = 1;
        }
        else {
          iVar3 = strcmp((char *)local_res8[1],"b");
          if (iVar3 != 0) {
            fwrite("wl mimo_ss_stf: wrong -b option, \"-b a\" or \"-b b\"\n",1,0x32,stderr);
            return -0x2c;
          }
          local_14 = 0;
        }
        if (local_124 + 2 < local_128) {
          return -2;
        }
        memcpy(auStack_114 + local_12c,&local_14,4);
      }
    }
  }
  if (bVar1) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,auStack_114,0x100,&local_10);
    if (-1 < iVar3) {
      if (DAT_00557704 == '\0') {
        uVar4 = *local_10;
      }
      else {
        uVar4 = *local_10;
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      printf("0x%x\n",uVar4);
    }
  }
  else {
    iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_114,0x100);
  }
  return iVar3;
}



int FUN_0049548c(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  undefined *puVar2;
  int iVar3;
  ulong uVar4;
  int local_40;
  uint local_3c;
  int local_38;
  int local_34;
  int *local_30;
  char *pcStack_1c;
  uint local_18;
  uint local_14;
  undefined4 local_10 [2];
  
  local_10[0] = 0;
  for (local_40 = 0; *(int *)(param_3 + local_40 * 4) != 0; local_40 = local_40 + 1) {
  }
  if (local_40 < 4) {
    if (local_40 == 1) {
      local_3c = 0;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_3c = strtoul(*(char **)(param_3 + 4),&pcStack_1c,0);
      }
      else {
        uVar4 = strtoul(*(char **)(param_3 + 4),&pcStack_1c,0);
        local_3c = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      if ((local_3c != 0) && (local_3c != 1)) {
        return -2;
      }
    }
    local_18 = local_3c;
    if (local_40 == 3) {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul(*(char **)(param_3 + 8),&pcStack_1c,0);
      }
      else {
        uVar4 = strtoul(*(char **)(param_3 + 8),&pcStack_1c,0);
        local_14 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
    }
    else {
      local_14 = 0x20;
    }
    iVar3 = FUN_00445198(param_1,(char *)*param_2,&local_18,8,local_10);
    puVar2 = PTR_DAT_00551644;
    if (-1 < iVar3) {
      printf("get external log records: %d\n",*(int *)(PTR_DAT_00551644 + 4));
      if (*(int *)(puVar2 + 4) == 0) {
        iVar3 = 0;
      }
      else if (*(short *)puVar2 == 0x100) {
        local_30 = (int *)(puVar2 + 8);
        puts("Seq:\tTime(ms) Log");
        for (local_38 = 0; local_38 < *(int *)(puVar2 + 4); local_38 = local_38 + 1) {
          printf("%d:\t%d\t ",(uint)*(byte *)((int)local_30 + 10),*local_30);
          for (local_34 = 0;
              (local_34 < 0x1e &&
              (*(short *)((int)local_30 + 6) != *(short *)(&DAT_005514c0 + local_34 * 0xc)));
              local_34 = local_34 + 1) {
          }
          if (local_34 == 0x1e) {
            printf("fmt string not found for id %d\n",(uint)*(ushort *)((int)local_30 + 6));
            uVar1 = *(ushort *)(puVar2 + 2);
          }
          else {
            switch((&DAT_005514c4)[local_34 * 0xc]) {
            case 0:
              printf("%s",(&PTR_s_Driver_is_Up_005514c8)[local_34 * 3]);
              break;
            case 1:
              printf((&PTR_s_Driver_is_Up_005514c8)[local_34 * 3],local_30 + 4);
              break;
            case 2:
              printf((&PTR_s_Driver_is_Up_005514c8)[local_34 * 3],local_30[3]);
              break;
            case 3:
              printf((&PTR_s_Driver_is_Up_005514c8)[local_34 * 3],local_30[3],local_30 + 4);
              break;
            case 4:
              printf((&PTR_s_Driver_is_Up_005514c8)[local_34 * 3],local_30 + 4,local_30[3]);
            }
            uVar1 = *(ushort *)(puVar2 + 2);
          }
          local_30 = (int *)((int)local_30 + (uint)uVar1);
        }
        iVar3 = 0;
      }
      else {
        printf("version mismatch: version = 0x%x, expected 0x%0x\n",(uint)*(ushort *)puVar2,0x100);
        iVar3 = 0;
      }
    }
  }
  else {
    iVar3 = -0x2c;
  }
  return iVar3;
}



int FUN_00495a60(int *param_1,undefined4 *param_2,int *param_3)

{
  int iVar1;
  ulong uVar2;
  int local_28;
  char *pcStack_18;
  undefined1 auStack_14 [4];
  ushort local_10;
  undefined1 local_e;
  undefined1 local_d;
  
  for (local_28 = 0; param_3[local_28] != 0; local_28 = local_28 + 1) {
  }
  if (local_28 == 1) {
    iVar1 = FUN_00444b10(param_1,param_2,param_3);
    if (-1 < iVar1) {
      printf("max_number=%d, module=%x, level=%d, flag=%d, version=0x%04x\n",
             *(int *)PTR_DAT_00551644,(uint)*(ushort *)(PTR_DAT_00551644 + 4),
             (uint)(byte)PTR_DAT_00551644[6],(uint)(byte)PTR_DAT_00551644[7],
             (uint)*(ushort *)(PTR_DAT_00551644 + 8));
    }
  }
  else if (local_28 == 4) {
    if (DAT_00557704 == '\0') {
      uVar2 = strtoul((char *)param_3[1],&pcStack_18,0);
      local_10 = (ushort)uVar2;
    }
    else {
      uVar2 = strtoul((char *)param_3[1],&pcStack_18,0);
      local_10 = (ushort)uVar2 << 8 | (ushort)uVar2 >> 8;
    }
    uVar2 = strtoul((char *)param_3[2],&pcStack_18,0);
    local_e = (undefined1)uVar2;
    uVar2 = strtoul((char *)param_3[3],&pcStack_18,0);
    local_d = (undefined1)uVar2;
    iVar1 = FUN_00445444(param_1,(char *)*param_2,auStack_14,0xc);
  }
  else {
    fwrite("illegal command!\n",1,0x11,stderr);
    iVar1 = -0x2c;
  }
  return iVar1;
}



int FUN_00495cd0(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  int local_20;
  int local_1c;
  int *local_18;
  undefined4 local_c;
  
  local_c = 0;
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if (local_20 < 2) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar2) {
      printf("get external assert logs: %d\n",*(int *)(PTR_DAT_00551644 + 4));
      if (*(int *)(puVar1 + 4) == 0) {
        iVar2 = 0;
      }
      else if (*(short *)puVar1 == 0x100) {
        local_18 = (int *)(puVar1 + 8);
        puts("id: \ttime(ms) \tstring");
        for (local_1c = 0; local_1c < *(int *)(puVar1 + 4); local_1c = local_1c + 1) {
          printf("%d: \t%d \t%s",local_1c,*local_18,(char *)((int)local_18 + 5));
          local_18 = (int *)((int)local_18 + (uint)*(ushort *)(puVar1 + 2));
        }
        iVar2 = 0;
      }
      else {
        printf("Version mismatch: version = 0x%x, expected 0x%x\n",(uint)*(ushort *)puVar1,0x100);
        iVar2 = 0;
      }
    }
  }
  else {
    iVar2 = -0x2c;
  }
  return iVar2;
}



char * FUN_00495eb8(int param_1,int param_2,int param_3)

{
  char *pcVar1;
  
  if (param_1 < param_2) {
    pcVar1 = "Low";
  }
  else if ((param_1 < param_2) || (param_3 <= param_1)) {
    if (param_1 < param_3) {
      pcVar1 = (char *)0x0;
    }
    else {
      pcVar1 = "High";
    }
  }
  else {
    pcVar1 = "Medium";
  }
  return pcVar1;
}



// WARNING: Removing unreachable block (ram,0x004961d8)
// WARNING: Removing unreachable block (ram,0x004961e4)

int FUN_00495f68(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  ushort *puVar4;
  ushort uVar5;
  ulong uVar6;
  char *pcVar7;
  void *pvVar8;
  uint *puVar9;
  int iVar10;
  char *pcVar11;
  char *pcVar12;
  int iVar13;
  uint uVar14;
  undefined4 *puVar15;
  uint param7;
  uint param10;
  undefined4 *local_res8;
  ulong local_120;
  ulong local_11c;
  int local_118;
  ulong local_114;
  int local_110;
  ulong local_10c;
  int local_104;
  uint local_100;
  int local_fc;
  ushort local_c8;
  ushort local_c6;
  int aiStack_b0 [38];
  ushort *local_18;
  uint local_14;
  ushort local_10 [4];
  
  local_18 = (ushort *)0x0;
  local_110 = 0;
  bVar1 = false;
  bVar2 = true;
  bVar3 = false;
  local_104 = 0;
  local_c6 = 10;
  local_10c = 0xff;
  local_res8 = (undefined4 *)(param_3 + 4);
  while( true ) {
    pcVar7 = (char *)*local_res8;
    puVar15 = local_res8 + 1;
    if (pcVar7 == (char *)0x0) break;
    iVar13 = strcasecmp(pcVar7,"-n");
    if (iVar13 == 0) {
      bVar2 = false;
      local_res8 = puVar15;
    }
    else {
      iVar13 = strcasecmp(pcVar7,"-i");
      if (iVar13 == 0) {
        bVar1 = true;
        local_res8 = puVar15;
      }
      else {
        iVar13 = strcasecmp(pcVar7,"-curband");
        if (iVar13 == 0) {
          bVar3 = true;
          local_res8 = puVar15;
        }
        else {
          pcVar11 = (char *)*puVar15;
          local_res8 = local_res8 + 2;
          if (pcVar11 == (char *)0x0) {
            printf("Need value following %s\n",pcVar7);
            return -0x2c;
          }
          iVar13 = strcasecmp(pcVar7,"-c");
          if (iVar13 == 0) {
            local_10c = strtoul(pcVar11,(char **)0x0,0);
          }
          iVar13 = strcasecmp(pcVar7,"-cs");
          if ((iVar13 == 0) && (local_10[0] = FUN_004c0638(pcVar11), local_10[0] != 0)) {
            local_10c = FUN_004c13a4(local_10[0]);
          }
          iVar13 = strcasecmp(pcVar7,"-s");
          if (iVar13 == 0) {
            uVar6 = strtoul(pcVar11,(char **)0x0,0);
            local_c6 = (ushort)uVar6;
            if ((local_c6 == 0) || (0x3c < local_c6)) {
              printf("%d: Num of seconds must be <= %d\n",uVar6 & 0xffff,0x3c);
              return -0x2c;
            }
          }
        }
      }
    }
  }
  if (local_10c == 0) {
    local_120 = 1;
    local_11c = 0xe0;
  }
  else {
    if (local_10c == 0xff) {
      local_110 = FUN_004ba35c(param_1,"chanspec",&local_14);
      if (local_110 < 0) {
        puts("CCA: Can\'t get currrent chanspec");
        return local_110;
      }
      uVar5 = FUN_00402eb0(local_14);
      local_10c = FUN_004c13a4(uVar5);
      printf("Using channel %d\n",local_10c);
    }
    local_11c = local_10c;
    local_120 = local_10c;
  }
  for (local_114 = local_120; (int)local_114 <= (int)local_11c; local_114 = local_114 + 1) {
    if ((int)local_114 < 0xf) {
      local_c8 = 0;
    }
    else {
      local_c8 = 0xc000;
    }
    local_c8 = (ushort)local_114 | 0x1000 | local_c8;
    local_c8 = FUN_00402c2c(local_c8);
    local_110 = FUN_00445198(param_1,(char *)*param_2,&local_c8,0x18,&local_18);
    puVar4 = local_18;
    if (local_110 < 0) {
      return local_110;
    }
    uVar5 = FUN_00402de8(*local_18);
    *puVar4 = uVar5;
    if ((*puVar4 != 0) && (puVar4[1] != 0)) {
      if (0x3c < puVar4[1]) {
        printf("Bogus num of seconds returned %d\n",(uint)puVar4[1]);
        return -1;
      }
      pvVar8 = malloc(0x18);
      aiStack_b0[local_104] = (int)pvVar8;
      if (aiStack_b0[local_104] == 0) {
        puts("unable to allocate memory");
        return -0x1b;
      }
      FUN_004cc2d0(puVar4,(undefined2 *)aiStack_b0[local_104],'\x01');
      if (*(short *)(aiStack_b0[local_104] + 2) != 0) {
        local_104 = local_104 + 1;
      }
      if (bVar1) {
        if (local_114 == local_120) {
          puts("chan dur      ibss           obss           interf       time");
        }
        for (local_118 = 0; local_118 < (int)(uint)puVar4[1]; local_118 = local_118 + 1) {
          puVar9 = (uint *)(puVar4 + local_118 * 10 + 2);
          if (*puVar9 != 0) {
            uVar14 = (uint)(*(int *)(puVar4 + local_118 * 10 + 4) * 100) / *puVar9;
            if (*puVar9 == 0) {
              trap(7);
            }
            param7 = (uint)(*(int *)(puVar4 + local_118 * 10 + 6) * 100) / *puVar9;
            if (*puVar9 == 0) {
              trap(7);
            }
            param10 = (uint)(*(int *)(puVar4 + local_118 * 10 + 8) * 100) / *puVar9;
            if (*puVar9 == 0) {
              trap(7);
            }
            pcVar7 = FUN_00495eb8(uVar14,0xf,0x19);
            pcVar11 = FUN_00495eb8(param7,0xc,0x19);
            pcVar12 = FUN_00495eb8(param10,5,10);
            printf("%-3u %4d %4u %2d%% %-6s %4u %2d%% %-6s %4u %2d%% %-6s %d\n",*puVar4 & 0xff,
                   *puVar9,*(uint *)(puVar4 + local_118 * 10 + 4),uVar14,pcVar7,
                   *(uint *)(puVar4 + local_118 * 10 + 6),param7,pcVar11,
                   *(uint *)(puVar4 + local_118 * 10 + 8),param10,pcVar12,
                   *(int *)(puVar4 + local_118 * 10 + 10));
          }
        }
      }
    }
  }
  puts("Summaries:");
  puts("chan dur      ibss           obss             interf     num seconds");
  for (local_fc = 0; local_fc < local_104; local_fc = local_fc + 1) {
    iVar13 = *(int *)(aiStack_b0[local_fc] + 0xc);
    iVar10 = *(int *)(aiStack_b0[local_fc] + 0x10);
    pcVar7 = FUN_00495eb8(*(int *)(aiStack_b0[local_fc] + 8),0xf,0x19);
    pcVar11 = FUN_00495eb8(iVar13,0xc,0x19);
    pcVar12 = FUN_00495eb8(iVar10,5,10);
    if (*(short *)(aiStack_b0[local_fc] + 2) != 0) {
      printf("%-3u %4d %4s %2d%% %-6s %4s %2d%% %-6s %4s %2d%% %-6s %d\n",
             *(ushort *)aiStack_b0[local_fc] & 0xff,*(int *)(aiStack_b0[local_fc] + 4),"",
             *(int *)(aiStack_b0[local_fc] + 8),pcVar7,"",*(int *)(aiStack_b0[local_fc] + 0xc),
             pcVar11,"",*(int *)(aiStack_b0[local_fc] + 0x10),pcVar12,
             (uint)*(ushort *)(aiStack_b0[local_fc] + 2));
    }
  }
  if (!bVar2) {
    return local_110;
  }
  iVar13 = FUN_004ba35c(param_1,"chanspec",&local_14);
  if (iVar13 < 0) {
    puts("CCA: Can\'t get currrent chanspec");
    return iVar13;
  }
  uVar5 = FUN_00402eb0(local_14);
  local_100 = 0;
  if (bVar3) {
    if ((uVar5 & 0xc000) == 0xc000) {
      local_100 = 2;
    }
    if ((uVar5 & 0xc000) == 0) {
      local_100 = local_100 | 1;
    }
  }
  iVar13 = FUN_004cc774((int)aiStack_b0,local_104,local_100,local_10);
  if (iVar13 != 0) {
    printf("Cannot find a good channel due to: %s\n",(&PTR_s_No_error_00556034)[iVar13]);
    return -1;
  }
  uVar14 = FUN_004c13a4(local_10[0]);
  printf("Recommended channel: %d\n",uVar14);
  return 0;
}



int FUN_00496a60(int *param_1,undefined4 *param_2)

{
  int iVar1;
  char *param4;
  char *param1;
  uint *local_34;
  undefined4 auStack_30 [10];
  
  local_34 = (uint *)0x0;
  memcpy(auStack_30,&PTR_DAT_00521314,0x28);
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_34);
  if (-1 < iVar1) {
    if ((*local_34 & 4) == 0) {
      if ((*local_34 & 1) == 0) {
        param1 = "is not";
      }
      else {
        param1 = "is";
      }
      if ((*local_34 & 2) == 0) {
        param4 = "non-home";
      }
      else {
        param4 = "home";
      }
      printf("Interference %s detected. last interference at timestamp %d: source is %s on %s channel\n"
             ,param1,local_34[2],(char *)auStack_30[local_34[1]],param4);
    }
    else {
      puts("Feature is stopped due to noisy environment");
    }
  }
  return iVar1;
}



int FUN_00496bbc(int *param_1,undefined4 *param_2)

{
  int iVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  uint param3;
  char *param2;
  uint param1;
  int local_40;
  int local_2c;
  char *local_28 [4];
  undefined *local_18;
  
  local_2c = 0;
  local_28[0] = "None";
  local_28[1] = "IOCTL";
  local_28[2] = "CHANIM";
  local_28[3] = "TIMER";
  local_18 = &DAT_0052135c;
  iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_2c);
  iVar1 = local_2c;
  if (-1 < iVar3) {
    if (*(char *)(local_2c + 200) == '\0') {
      puts("There is no ACS recorded");
    }
    else {
      printf("current timestamp: %u (ms)\n",*(uint *)(local_2c + 0xcc));
      puts("Timestamp(ms)  ACS Trigger  Selected Channel  Glitch Count  CCA Count");
      for (local_40 = 0; local_40 < (int)(uint)*(byte *)(iVar1 + 200); local_40 = local_40 + 1) {
        iVar4 = iVar1 + (uint)(byte)(((char)local_40 - *(char *)(iVar1 + 200)) + 10) * 0x14;
        uVar2 = FUN_00402de8(*(ushort *)(iVar4 + 2));
        *(ushort *)(iVar4 + 2) = uVar2;
        param1 = *(uint *)(iVar4 + 0x10);
        param2 = local_28[*(byte *)(iVar4 + 1)];
        param3 = FUN_004c13a4(*(ushort *)(iVar4 + 2));
        printf("%10u \t%s \t%10d \t%12d \t%8d\n",param1,param2,param3,*(int *)(iVar4 + 8),
               (uint)*(byte *)(iVar4 + 0xc));
      }
    }
  }
  return iVar3;
}



int FUN_00496de4(int *param_1,undefined4 *param_2)

{
  ushort uVar1;
  int iVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  int local_80;
  undefined4 local_40 [2];
  undefined4 local_38;
  uint *local_10 [2];
  
  if (DAT_00557704 == '\0') {
    local_40[0] = 0x30;
    local_38 = 1;
  }
  else {
    local_40[0] = 0x30000000;
    local_38 = 0x1000000;
  }
  iVar2 = FUN_00445198(param_1,(char *)*param_2,local_40,0x30,local_10);
  if (iVar2 < 0) {
    printf("failed to get chanim results");
  }
  else {
    if (DAT_00557704 == '\0') {
      uVar3 = *local_10[0];
    }
    else {
      uVar3 = *local_10[0];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *local_10[0] = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = local_10[0][1];
    }
    else {
      uVar3 = local_10[0][1];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    local_10[0][1] = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = local_10[0][2];
    }
    else {
      uVar3 = local_10[0][2];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    local_10[0][2] = uVar3;
    printf("version: %d \n",local_10[0][1]);
    if (*local_10[0] == 0) {
      local_10[0][1] = 0;
      local_10[0][2] = 0;
    }
    else if (local_10[0][1] != 2) {
      printf("Sorry, your driver has wl_chanim_stats version %d but this program supports only version %d.\n"
             ,local_10[0][1],2);
      *local_10[0] = 0;
      local_10[0][2] = 0;
    }
    puVar4 = local_10[0] + 3;
    if (DAT_00557704 == '\0') {
      uVar3 = *puVar4;
    }
    else {
      uVar3 = *puVar4;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    *puVar4 = uVar3;
    if (DAT_00557704 == '\0') {
      uVar3 = local_10[0][4];
    }
    else {
      uVar3 = local_10[0][4];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    local_10[0][4] = uVar3;
    if (DAT_00557704 == '\0') {
      uVar1 = *(ushort *)((int)local_10[0] + 0x1e);
    }
    else {
      uVar1 = *(ushort *)((int)local_10[0] + 0x1e) << 8 | *(ushort *)((int)local_10[0] + 0x1e) >> 8;
    }
    *(ushort *)((int)local_10[0] + 0x1e) = uVar1;
    if (DAT_00557704 == '\0') {
      uVar3 = local_10[0][8];
    }
    else {
      uVar3 = local_10[0][8];
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    local_10[0][8] = uVar3;
    puts(
        "chanspec tx   inbss   obss   nocat   nopkt   doze     txop     goodtx  badtx   glitch   badplcp  knoise  idle  timestamp"
        );
    printf("0x%4x\t",(uint)*(ushort *)((int)local_10[0] + 0x1e));
    for (local_80 = 0; local_80 < 9; local_80 = local_80 + 1) {
      printf("%d\t",(uint)*(byte *)((int)puVar4 + local_80 + 8));
    }
    if (DAT_00557704 == '\0') {
      uVar3 = *puVar4;
      uVar5 = local_10[0][4];
    }
    else {
      uVar3 = *puVar4;
      uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      uVar5 = local_10[0][4];
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    if (DAT_00557704 == '\0') {
      uVar6 = local_10[0][8];
    }
    else {
      uVar6 = local_10[0][8];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("%d\t%d\t%d\t%d\t%d",uVar3,uVar5,(int)*(char *)((int)local_10[0] + 0x1d),
           (uint)(byte)local_10[0][0xb],uVar6);
    putchar(10);
  }
  return iVar2;
}



int FUN_004974a0(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  long lVar3;
  int local_1c;
  ushort local_18;
  byte local_16;
  byte local_15;
  byte local_14;
  char *apcStack_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_18,6);
    if (-1 < iVar2) {
      printf("Txdelay params: ratio[%d] cnt[%d] period[%d] tune[%d]\n",(uint)local_18,(uint)local_16
             ,(uint)local_15,(uint)local_14);
    }
  }
  else {
    for (local_1c = 0; piVar1[local_1c] != 0; local_1c = local_1c + 1) {
    }
    if (local_1c == 4) {
      lVar3 = strtol((char *)*piVar1,apcStack_10,0);
      local_18 = (ushort)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 8),apcStack_10,0);
      local_16 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0xc),apcStack_10,0);
      local_15 = (byte)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 0x10),apcStack_10,0);
      local_14 = (byte)lVar3;
      iVar2 = FUN_004ba2e4(param_1,(char *)*param_2,&local_18,6);
    }
    else {
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



int FUN_004976e0(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  long lVar2;
  int local_20;
  int local_1c;
  ushort local_18;
  byte local_16;
  byte local_15;
  byte local_14;
  byte local_13;
  char *local_10 [2];
  
  local_10[0] = (char *)0x0;
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    local_20 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_18,6);
    if (-1 < local_20) {
      if (local_18 == 1) {
        printf("Intference params: period[%x] cnt[%x] txfail_thresh[%x] tcptxfail_thresh[%x]\n",
               (uint)local_16,(uint)local_15,(uint)local_14,(uint)local_13);
      }
      else {
        printf("Interference params structure version (%d) is not the version (%d) supported by this tool"
               ,1,(uint)local_18);
        local_20 = -0x2c;
      }
    }
  }
  else {
    local_20 = -0x2c;
    for (local_1c = 0; piVar1[local_1c] != 0; local_1c = local_1c + 1) {
    }
    if (local_1c == 4) {
      lVar2 = strtol((char *)*piVar1,local_10,0);
      local_16 = (byte)lVar2;
      if (*local_10[0] == '\0') {
        lVar2 = strtol(*(char **)(param_3 + 8),local_10,0);
        local_15 = (byte)lVar2;
        if (*local_10[0] == '\0') {
          lVar2 = strtol(*(char **)(param_3 + 0xc),local_10,0);
          local_14 = (byte)lVar2;
          if (*local_10[0] == '\0') {
            lVar2 = strtol(*(char **)(param_3 + 0x10),local_10,0);
            local_13 = (byte)lVar2;
            if (*local_10[0] == '\0') {
              local_18 = 1;
              local_20 = FUN_004ba2e4(param_1,(char *)*param_2,&local_18,6);
            }
          }
        }
      }
    }
  }
  return local_20;
}



undefined4 FUN_00497994(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  undefined4 uVar3;
  char local_14 [2];
  ushort local_12;
  undefined2 local_10;
  char *pcStack_c;
  
  iVar1 = FUN_0040192c(param_3 + 4);
  if (iVar1 < 1) {
    return 0xffffffd4;
  }
  lVar2 = strtol(*(char **)(param_3 + 4),&pcStack_c,0);
  local_14[0] = (char)lVar2;
  if (local_14[0] == '\x01') {
    if (iVar1 != 3) {
      return 0xffffffd4;
    }
    local_12 = FUN_004c0638(*(char **)(param_3 + 8));
    if (local_12 == 0) {
      fprintf(stderr,"error parsing chanspec arg \"%s\"\n",*(char **)(param_3 + 8));
      return 0xfffffffe;
    }
    local_12 = FUN_00402c2c(local_12);
    if (local_12 == 0xff) {
      return 0xffffffd4;
    }
    lVar2 = strtol(*(char **)(param_3 + 0xc),&pcStack_c,0);
    local_10 = (undefined2)lVar2;
  }
  uVar3 = FUN_00445444(param_1,(char *)*param_2,local_14,6);
  return uVar3;
}



int FUN_00497b30(int *param_1,undefined4 *param_2,int param_3)

{
  undefined2 uVar1;
  ushort uVar2;
  int iVar3;
  size_t __size;
  undefined1 *__s;
  uint __seed;
  undefined4 uVar4;
  size_t local_30;
  int local_2c;
  int local_28;
  uint local_10 [2];
  
  local_30 = 0;
  local_2c = 0;
  local_10[0] = 0;
  local_28 = 0;
  if (*(int *)(param_3 + 4) != 0) {
    local_2c = 4;
    iVar3 = toupper((int)**(char **)(param_3 + 4));
    if (iVar3 == 0x45) {
      local_2c = 0xcc;
    }
    else if (iVar3 == 0x53) {
      local_2c = 0xc4;
    }
  }
  if (local_2c == 0) {
    fwrite("wrong syntax, need \'S\' or \'E\'\n",1,0x1e,stderr);
    local_28 = -2;
  }
  else {
    __size = local_2c + 0x168;
    __s = (undefined1 *)malloc(__size);
    if (__s == (undefined1 *)0x0) {
      fprintf(stderr,"Error allocating %d bytes for scan params\n",__size);
      local_28 = -0x1b;
    }
    else {
      memset(__s,0,__size);
      iVar3 = toupper((int)**(char **)(param_3 + 4));
      if (iVar3 == 0x45) {
        local_10[0] = local_2c + 0x118;
        *__s = 0x45;
        if (DAT_00557704 == '\0') {
          uVar4 = 1;
        }
        else {
          uVar4 = 0x1000000;
        }
        *(undefined4 *)(__s + 4) = uVar4;
        if (DAT_00557704 == '\0') {
          uVar1 = 1;
        }
        else {
          uVar1 = 0x100;
        }
        *(undefined2 *)(__s + 8) = uVar1;
        __seed = time((time_t *)0x0);
        srand(__seed);
        if (DAT_00557704 == '\0') {
          iVar3 = rand();
          uVar2 = (ushort)iVar3;
        }
        else {
          iVar3 = rand();
          uVar2 = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
        }
        *(ushort *)(__s + 10) = uVar2;
        local_28 = FUN_0041eee4(param_1,param_2,param_3 + 4,__s + 0xc,local_10);
        if (local_28 == 0) {
          local_30 = local_10[0] + 0x50;
        }
      }
      else if (iVar3 == 0x53) {
        local_10[0] = local_2c + 0x164;
        *__s = 0x53;
        local_28 = FUN_0041eee4(param_1,param_2,param_3 + 4,__s + 4,local_10);
        if (local_28 == 0) {
          local_30 = local_10[0] + 4;
        }
      }
      if (local_28 == 0) {
        local_28 = FUN_004ba160(param_1,(char *)*param_2,__s,local_30,PTR_DAT_00551644,0x2000);
      }
      free(__s);
    }
  }
  return local_28;
}



undefined4 FUN_00497f48(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined4 uVar3;
  undefined3 extraout_var;
  int iVar4;
  undefined1 auStack_14 [6];
  char local_e;
  ushort local_c;
  
  iVar2 = FUN_0040192c(param_3 + 4);
  if (iVar2 < 2) {
    uVar3 = 0xffffffd4;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      uVar3 = 0xffffffd4;
    }
    else {
      iVar4 = strcasecmp(*(char **)(param_3 + 8),"go");
      if (iVar4 == 0) {
        local_e = '\x01';
      }
      else {
        iVar4 = strcasecmp(*(char **)(param_3 + 8),"client");
        if (iVar4 == 0) {
          local_e = '\0';
        }
        else {
          iVar4 = strcasecmp(*(char **)(param_3 + 8),"dyngo");
          if (iVar4 != 0) {
            return 0xffffffd4;
          }
          local_e = '\x02';
        }
      }
      if ((local_e == '\x01') || (local_e == '\x02')) {
        if (iVar2 < 3) {
          local_c = 0;
        }
        else {
          local_c = FUN_004c0638(*(char **)(param_3 + 0xc));
          if (local_c == 0) {
            fprintf(stderr,"error parsing chanspec arg \"%s\"\n",*(char **)(param_3 + 0xc));
            return 0xfffffffe;
          }
          local_c = FUN_00402c2c(local_c);
          if (local_c == 0xff) {
            return 0xfffffffe;
          }
        }
      }
      uVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_14,10);
    }
  }
  return uVar3;
}



undefined4 FUN_0049817c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined4 uVar3;
  undefined3 extraout_var;
  undefined1 auStack_14 [12];
  
  iVar2 = FUN_0040192c(param_3 + 4);
  if (iVar2 == 1) {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      uVar3 = 0xffffffd4;
    }
    else {
      uVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_14,6);
    }
  }
  else {
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



int FUN_0049823c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  undefined3 extraout_var;
  undefined1 auStack_20 [6];
  undefined1 local_1a;
  undefined2 local_18;
  uint local_14;
  int local_10 [2];
  
  local_14 = 0;
  local_10[0] = 0;
  iVar2 = FUN_004024e8((int *)(param_3 + 4),*param_2,&local_14,local_10);
  if (iVar2 == 0) {
    piVar3 = (int *)(param_3 + 4) + local_10[0];
    if (local_10[0] == 0) {
      local_14 = 0xffffffff;
    }
    iVar2 = FUN_0040192c((int)piVar3);
    if (iVar2 < 2) {
      iVar2 = -0x2c;
    }
    else {
      bVar1 = FUN_0041d6ac((char *)*piVar3,auStack_20);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        iVar2 = -0x2c;
      }
      else {
        iVar2 = strcasecmp((char *)piVar3[1],"go");
        if (iVar2 == 0) {
          local_1a = 1;
        }
        else {
          iVar2 = strcasecmp((char *)piVar3[1],"client");
          if (iVar2 != 0) {
            return -0x2c;
          }
          local_1a = 0;
        }
        local_18 = 0;
        if (local_14 == 0xffffffff) {
          iVar2 = FUN_00445444(param_1,(char *)*param_2,auStack_20,10);
        }
        else {
          iVar2 = FUN_00445758(param_1,(char *)*param_2,local_14,auStack_20,10,PTR_DAT_00551644,
                               0x2000);
        }
      }
    }
  }
  return iVar2;
}



int FUN_00498440(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined3 extraout_var;
  uint uVar3;
  undefined1 auStack_14 [8];
  uint *local_c;
  
  iVar2 = FUN_0040192c(param_3 + 4);
  if (iVar2 == 1) {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_00445198(param_1,(char *)*param_2,auStack_14,6,&local_c);
      if (-1 < iVar2) {
        if (DAT_00557704 == '\0') {
          uVar3 = *local_c;
        }
        else {
          uVar3 = *local_c;
          uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        }
        printf("%u %s\n",uVar3,(char *)(local_c + 1));
      }
    }
  }
  else {
    iVar2 = -0x2c;
  }
  return iVar2;
}



int FUN_004985a0(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  long lVar2;
  char local_18;
  undefined1 local_17;
  char *pcStack_14;
  byte *local_10 [2];
  
  iVar1 = FUN_0040192c(param_3 + 4);
  if (iVar1 < 1) {
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (iVar1 == 0) {
      printf("ops: %u ctw: %u\n",(uint)*local_10[0],(uint)local_10[0][1]);
      iVar1 = 0;
    }
    else {
      fprintf(stderr,"%s: error %d\n",(char *)*param_2,iVar1);
    }
  }
  else {
    lVar2 = strtol(*(char **)(param_3 + 4),&pcStack_14,0);
    local_18 = (char)lVar2;
    if (local_18 == '\0') {
      local_17 = 0;
    }
    else {
      if (iVar1 != 2) {
        return -0x2c;
      }
      lVar2 = strtol(*(char **)(param_3 + 8),&pcStack_14,0);
      local_17 = (undefined1)lVar2;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_18,2);
  }
  return iVar1;
}



int FUN_00498750(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  size_t sVar3;
  byte *pbVar4;
  long lVar5;
  uint uVar6;
  ulong uVar7;
  undefined4 *local_res8;
  uint local_50;
  byte *local_4c;
  int local_48;
  int local_44;
  char *apcStack_18 [3];
  
  strcpy(PTR_DAT_00551644,(char *)*param_2);
  iVar2 = FUN_0040192c(param_3 + 4);
  if (iVar2 < 2) {
    iVar2 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (iVar2 != 0) {
      fprintf(stderr,"%s: error %d\n",(char *)*param_2,iVar2);
      return iVar2;
    }
    local_44 = 0;
    while ((local_44 < 0x10 && (*(int *)(puVar1 + local_44 * 0x10 + 0x10) != 0))) {
      printf("start: %u interval: %u duration: %u count: %u\n",
             *(uint *)(puVar1 + local_44 * 0x10 + 4),*(uint *)(puVar1 + local_44 * 0x10 + 8),
             *(uint *)(puVar1 + local_44 * 0x10 + 0xc),*(uint *)(puVar1 + local_44 * 0x10 + 0x10));
      local_44 = local_44 + 1;
    }
    return 0;
  }
  sVar3 = strlen(PTR_DAT_00551644);
  pbVar4 = PTR_DAT_00551644 + sVar3 + 1;
  lVar5 = strtol(*(char **)(param_3 + 4),apcStack_18,0);
  *pbVar4 = (byte)lVar5;
  lVar5 = strtol(*(char **)(param_3 + 8),apcStack_18,0);
  pbVar4[1] = (byte)lVar5;
  local_res8 = (undefined4 *)(param_3 + 0xc);
  local_50 = iVar2 - 2;
  if (pbVar4[1] == 0xff) {
    local_4c = pbVar4 + (4 - (int)PTR_DAT_00551644);
  }
  else {
    if (*pbVar4 < 2) {
      if ((int)local_50 < 1) {
        return -0x2c;
      }
      lVar5 = strtol((char *)*local_res8,apcStack_18,0);
      pbVar4[2] = (byte)lVar5;
      local_res8 = (undefined4 *)(param_3 + 0x10);
      local_50 = iVar2 - 3;
    }
    local_4c = pbVar4 + (4 - (int)PTR_DAT_00551644);
    if (*pbVar4 == 0) {
      if (pbVar4[2] == 1) {
        if (local_50 == 1) {
          if (DAT_00557704 == '\0') {
            uVar6 = strtol((char *)*local_res8,apcStack_18,0);
          }
          else {
            uVar6 = strtol((char *)*local_res8,apcStack_18,0);
            uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
          }
          *(uint *)(pbVar4 + 0xc) = uVar6;
          *(int *)(pbVar4 + 4) = 100 - *(int *)(pbVar4 + 0xc);
        }
        else {
          if (local_50 != 2) {
            fprintf(stderr,"Usage: wl p2p_noa 0 %d 1 <start-pct> <duration-pct>\n",(uint)pbVar4[1]);
            return -0x2c;
          }
          if (DAT_00557704 == '\0') {
            uVar6 = strtol((char *)*local_res8,apcStack_18,0);
          }
          else {
            uVar6 = strtol((char *)*local_res8,apcStack_18,0);
            uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
          }
          *(uint *)(pbVar4 + 4) = uVar6;
          if (DAT_00557704 == '\0') {
            uVar6 = strtol((char *)local_res8[1],apcStack_18,0);
          }
          else {
            uVar6 = strtol((char *)local_res8[1],apcStack_18,0);
            uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
          }
          *(uint *)(pbVar4 + 0xc) = uVar6;
        }
        local_4c = local_4c + 0x10;
        goto LAB_004991ac;
      }
      if (((int)local_50 < 4) || ((local_50 & 3) != 0)) {
        fprintf(stderr,"Usage: wl p2p_noa 0 %d 0 <start> <interval> <duration> <count> ...\n",
                (uint)pbVar4[1]);
        return -0x2c;
      }
    }
    else if (local_50 != 4) {
      fprintf(stderr,"Usage: wl p2p_noa 1 %d <start> <interval> <duration> <count> ...\n",
              (uint)pbVar4[1]);
      return -0x2c;
    }
    for (local_48 = 0; local_48 < (int)local_50; local_48 = local_48 + 4) {
      iVar2 = local_48;
      if (local_48 < 0) {
        iVar2 = local_48 + 3;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = strtoul((char *)local_res8[local_48],apcStack_18,0);
      }
      else {
        uVar7 = strtoul((char *)local_res8[local_48],apcStack_18,0);
        uVar6 = uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18;
      }
      *(uint *)(pbVar4 + (iVar2 >> 2) * 0x10 + 4) = uVar6;
      iVar2 = local_48;
      if (local_48 < 0) {
        iVar2 = local_48 + 3;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = strtol((char *)local_res8[local_48 + 1],apcStack_18,0);
      }
      else {
        uVar6 = strtol((char *)local_res8[local_48 + 1],apcStack_18,0);
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
      }
      *(uint *)(pbVar4 + (iVar2 >> 2) * 0x10 + 8) = uVar6;
      iVar2 = local_48;
      if (local_48 < 0) {
        iVar2 = local_48 + 3;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = strtol((char *)local_res8[local_48 + 2],apcStack_18,0);
      }
      else {
        uVar6 = strtol((char *)local_res8[local_48 + 2],apcStack_18,0);
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
      }
      *(uint *)(pbVar4 + (iVar2 >> 2) * 0x10 + 0xc) = uVar6;
      iVar2 = local_48;
      if (local_48 < 0) {
        iVar2 = local_48 + 3;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = strtol((char *)local_res8[local_48 + 3],apcStack_18,0);
      }
      else {
        uVar6 = strtol((char *)local_res8[local_48 + 3],apcStack_18,0);
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
      }
      *(uint *)(pbVar4 + (iVar2 >> 2) * 0x10 + 0x10) = uVar6;
      local_4c = local_4c + 0x10;
    }
  }
LAB_004991ac:
  iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,(size_t)local_4c);
  return iVar2;
}



undefined4 FUN_004991e8(int *param_1,undefined4 *param_2,int param_3)

{
  undefined4 *puVar1;
  int iVar2;
  undefined4 uVar3;
  size_t sVar4;
  ulong uVar5;
  char *pcStack_10;
  uint local_c;
  
  puVar1 = (undefined4 *)(param_3 + 4);
  iVar2 = FUN_0040192c((int)puVar1);
  if (iVar2 == 2) {
    strcpy(PTR_DAT_00551644,(char *)*param_2);
    sVar4 = strlen(PTR_DAT_00551644);
    if (DAT_00557704 == '\0') {
      local_c = strtoul((char *)*puVar1,&pcStack_10,0);
    }
    else {
      uVar5 = strtoul((char *)*puVar1,&pcStack_10,0);
      local_c = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    memcpy(PTR_DAT_00551644 + sVar4 + 1,&local_c,4);
    if (DAT_00557704 == '\0') {
      local_c = strtoul(*(char **)(param_3 + 8),&pcStack_10,0);
    }
    else {
      uVar5 = strtoul(*(char **)(param_3 + 8),&pcStack_10,0);
      local_c = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    memcpy(PTR_DAT_00551644 + sVar4 + 5,&local_c,4);
    uVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,sVar4 + 9);
  }
  else {
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



int FUN_00499450(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint param1;
  ulong local_18;
  ulong local_14;
  undefined1 local_10;
  int *local_c;
  
  local_c = (int *)0x0;
  memset(&local_18,0,0xc);
  if (*(int *)(param_3 + 4) == 0) {
    puts("Usage: ledbh [led#] [behavior#]");
    iVar1 = -0x2c;
  }
  else {
    local_18 = strtoul(*(char **)(param_3 + 4),(char **)0x0,10);
    if (local_18 < 4) {
      if (*(int *)(param_3 + 8) == 0) {
        iVar1 = FUN_00445198(param_1,(char *)*param_2,&local_18,0xc,&local_c);
        if (iVar1 < 0) {
          puts("wl_ledbh: fail to get");
        }
        printf("led %d behavior %d\n",*local_c,local_c[1]);
      }
      else {
        param1 = FUN_00445198(param_1,(char *)*param_2,&local_18,0xc,&local_c);
        if ((int)param1 < 0) {
          printf("wl_ledbh: fail to get. code %x\n",param1);
        }
        local_14 = strtoul(*(char **)(param_3 + 8),(char **)0x0,10);
        local_10 = (undefined1)local_c[2];
        iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_18,0xc);
        if (iVar1 < 0) {
          puts("wl_ledbh: fail to set");
        }
      }
    }
    else {
      puts("only 4 led supported");
      iVar1 = -2;
    }
  }
  return iVar1;
}



int FUN_00499688(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  ulong uVar3;
  uint uVar4;
  char *param2;
  int local_30;
  uint local_1c;
  uint local_18;
  uint *local_14;
  char *apcStack_10 [2];
  
  local_14 = (uint *)0x0;
  for (local_30 = 0; *(int *)(param_3 + local_30 * 4) != 0; local_30 = local_30 + 1) {
  }
  if ((local_30 < 4) && (1 < local_30)) {
    if (DAT_00557704 == '\0') {
      local_1c = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
    }
    else {
      uVar3 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
      local_1c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    if ((int)local_1c < 4) {
      if (local_30 == 2) {
        iVar2 = FUN_00445198(param_1,(char *)*param_2,&local_1c,4,&local_14);
        if (-1 < iVar2) {
          if (DAT_00557704 == '\0') {
            bVar1 = *local_14 != 0;
          }
          else {
            uVar4 = *local_14;
            bVar1 = (((uVar4 & 0xff) != 0 || (uVar4 & 0xff00) != 0) || (uVar4 & 0xff0000) != 0) ||
                    uVar4 >> 0x18 != 0;
          }
          if (bVar1) {
            param2 = "TRUE";
          }
          else {
            param2 = "FALSE";
          }
          printf("led%d, blink_sync is %s\n",local_1c,param2);
        }
      }
      else if (local_30 == 3) {
        if (DAT_00557704 == '\0') {
          local_18 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
        }
        else {
          uVar3 = strtoul(*(char **)(param_3 + 8),apcStack_10,0);
          local_18 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18
          ;
        }
        iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_1c,8);
      }
      else {
        fwrite("illegal command!\n",1,0x11,stderr);
        iVar2 = -0x2c;
      }
    }
    else {
      puts("only 4 led supported");
      iVar2 = -2;
    }
  }
  else {
    iVar2 = -0x2c;
  }
  return iVar2;
}



undefined4 FUN_00499a14(uint param_1,uint param_2,int param_3)

{
  undefined4 uVar1;
  int local_10;
  uint local_c;
  
  local_c = 0;
  if ((param_1 == 0) && (param_2 == 0)) {
    uVar1 = 1;
  }
  else {
    for (local_10 = 0; *(uint *)(param_3 + local_10 * 8) < 0x20; local_10 = local_10 + 1) {
      local_c = local_c | 1 << (*(uint *)(param_3 + local_10 * 8) & 0x1f);
    }
    if ((param_1 & ~local_c) == 0) {
      local_c = 0;
      if (param_2 != 0) {
        for (; *(int *)(param_3 + local_10 * 8) != 0; local_10 = local_10 + 1) {
          local_c = local_c | 1 << (*(int *)(param_3 + local_10 * 8) - 0x20U & 0x1f);
        }
        if ((param_2 & ~local_c) != 0) {
          return 0;
        }
      }
      uVar1 = 1;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}



int FUN_00499b90(int *param_1,undefined4 param_2,int param_3)

{
  uint param1;
  bool bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  size_t sVar5;
  char *__nptr;
  int iVar6;
  int *local_res8;
  int local_a0;
  uint local_9c;
  uint local_98;
  uint local_90;
  uint local_8c;
  uint local_88;
  uint local_84;
  char *local_80;
  char *local_58;
  uint *local_54;
  undefined1 local_50;
  undefined1 local_4f;
  undefined1 local_4e;
  undefined1 local_4d;
  byte local_4c;
  char acStack_48 [32];
  char local_28 [32];
  
  local_9c = 0;
  local_90 = 0;
  local_8c = 0;
  local_88 = 0;
  local_84 = 0;
  local_58 = (char *)0x0;
  local_54 = (uint *)0x0;
  local_28[0] = '0';
  local_28[1] = 'x';
  local_28[2] = '\0';
  local_28[3] = '\0';
  local_28[4] = '\0';
  local_28[5] = '\0';
  local_28[6] = '\0';
  local_28[7] = '\0';
  local_28[8] = '\0';
  local_28[9] = '\0';
  local_28[10] = '\0';
  local_28[0xb] = '\0';
  local_28[0xc] = '\0';
  local_28[0xd] = '\0';
  local_28[0xe] = '\0';
  local_28[0xf] = '\0';
  local_28[0x10] = '\0';
  local_28[0x11] = '\0';
  local_28[0x12] = '\0';
  local_28[0x13] = '\0';
  local_28[0x14] = '\0';
  local_28[0x15] = '\0';
  local_28[0x16] = '\0';
  local_28[0x17] = '\0';
  local_28[0x18] = '\0';
  local_28[0x19] = '\0';
  local_28[0x1a] = '\0';
  local_28[0x1b] = '\0';
  local_28[0x1c] = '\0';
  local_28[0x1d] = '\0';
  local_28[0x1e] = '\0';
  local_28[0x1f] = '\0';
  iVar3 = FUN_0044527c(param_1,"rrm",&local_50,5,&local_54);
  if (-1 < iVar3) {
    uVar2 = local_54[1];
    uVar4 = (uint)(byte)uVar2;
    param1 = *local_54;
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      if (uVar4 == 0) {
        printf("0x%x ",param1);
      }
      else {
        printf("0x%x%08x",uVar4,param1);
      }
      for (local_a0 = 0; *(uint *)(&DAT_0055604c + local_a0 * 8) < 0x20; local_a0 = local_a0 + 1) {
        if ((1 << (*(uint *)(&DAT_0055604c + local_a0 * 8) & 0x1f) & param1) != 0) {
          printf(" %s",(&PTR_s_Link_Measurement_00556050)[local_a0 * 2]);
        }
      }
      for (; *(uint *)(&DAT_0055604c + local_a0 * 8) != 0; local_a0 = local_a0 + 1) {
        if ((1 << (*(uint *)(&DAT_0055604c + local_a0 * 8) & 0x1f) & uVar4) != 0) {
          printf(" %s",(&PTR_s_Link_Measurement_00556050)[local_a0 * 2]);
        }
      }
      putchar(10);
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_80 = (char *)*local_res8;
        bVar1 = false;
        if ((*local_80 == '+') || (*local_80 == '-')) {
          local_80 = local_80 + 1;
        }
        else {
          local_90 = 0xffffffff;
          local_8c = 0xffffffff;
        }
        local_98 = strtoul(local_80,&local_58,0);
        if (local_98 == 0xffffffff) {
          if ((*local_80 == '0') && (local_80[1] == 'x')) {
            sVar5 = strlen(local_80);
            __nptr = strncpy(acStack_48,local_80,sVar5 - 8);
            local_9c = strtoul(__nptr,&local_58,0);
            *local_58 = '\0';
            sVar5 = strlen(acStack_48);
            local_80 = strcat(local_28,local_80 + sVar5);
            local_98 = strtoul(local_80,&local_58,0);
            if (local_9c == 0xffffffff) {
              fwrite("Invalid entry for RM Capabilities\n",1,0x22,stderr);
              local_9c = 0;
              local_98 = 0;
            }
          }
          else {
            fwrite("Msg bits >32 take only numerical input in hex\n",1,0x2e,stderr);
            local_98 = 0;
          }
        }
        iVar3 = FUN_00499a14(local_98,local_9c,0x55604c);
        if (iVar3 == 0) {
LAB_0049a2ec:
          fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45,
                 stderr);
          fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
          for (local_a0 = 0; *(uint *)(&DAT_0055604c + local_a0 * 8) < 0x20; local_a0 = local_a0 + 1
              ) {
            fprintf(stderr,"\n0x%04x %s",1 << (*(uint *)(&DAT_0055604c + local_a0 * 8) & 0x1f),
                    (&PTR_s_Link_Measurement_00556050)[local_a0 * 2]);
          }
          for (; *(int *)(&DAT_0055604c + local_a0 * 8) != 0; local_a0 = local_a0 + 1) {
            fprintf(stderr,"\n0x%x00000000 %s",
                    1 << (*(int *)(&DAT_0055604c + local_a0 * 8) - 0x20U & 0x1f),
                    (&PTR_s_Link_Measurement_00556050)[local_a0 * 2]);
          }
          fputc(10,stderr);
          return 0;
        }
        if (*local_58 != '\0') {
          for (local_a0 = 0; uVar4 = *(uint *)(&DAT_0055604c + local_a0 * 8), uVar4 < 0x20;
              local_a0 = local_a0 + 1) {
            iVar3 = strcasecmp((&PTR_s_Link_Measurement_00556050)[local_a0 * 2],local_80);
            if (iVar3 == 0) {
              bVar1 = true;
              break;
            }
          }
          if (bVar1) {
            local_98 = 1 << (uVar4 & 0x1f);
          }
          else {
            while ((iVar3 = *(int *)(&DAT_0055604c + local_a0 * 8), iVar3 != 0 &&
                   (iVar6 = strcasecmp((&PTR_s_Link_Measurement_00556050)[local_a0 * 2],local_80),
                   iVar6 != 0))) {
              local_a0 = local_a0 + 1;
            }
            if (iVar3 == 0) {
              local_9c = 0;
            }
            else {
              local_9c = 1 << (iVar3 - 0x20U & 0x1f);
            }
          }
          if ((local_98 == 0) && (local_9c == 0)) goto LAB_0049a2ec;
        }
        if (*(char *)*local_res8 == '-') {
          local_90 = local_90 | local_98;
          if (!bVar1) {
            local_8c = local_8c | local_9c;
          }
        }
        else {
          local_88 = local_88 | local_98;
          if (!bVar1) {
            local_84 = local_84 | local_9c;
          }
        }
      }
      local_88 = param1 & ~local_90 | local_88;
      local_4c = (byte)uVar2 & ~(byte)local_8c | (byte)local_84;
      local_50 = (undefined1)local_88;
      local_4f = (undefined1)(local_88 >> 8);
      local_4e = (undefined1)(local_88 >> 0x10);
      local_4d = (undefined1)(local_88 >> 0x18);
      iVar3 = FUN_00445444(param_1,"rrm",&local_50,5);
    }
  }
  return iVar3;
}



undefined4 FUN_0049a46c(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  ulong uVar3;
  undefined3 extraout_var_00;
  undefined1 auStack_20 [6];
  undefined1 auStack_1a [6];
  ushort local_14;
  ushort local_12;
  undefined1 local_10;
  ushort local_e;
  
  memset(auStack_20,0,0x14);
  if ((*(int *)(param_3 + 4) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_20), CONCAT31(extraout_var,bVar1) != 0))
  {
    if (*(int *)(param_3 + 8) != 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
        local_14 = (ushort)uVar3;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
        local_14 = (ushort)(uVar3 >> 8) & 0xff00 | (ushort)(byte)(uVar3 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)uVar3;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)(uVar3 >> 8) & 0xff00 | (ushort)(byte)(uVar3 >> 0x18);
      }
    }
    if ((*(int *)(param_3 + 0x10) == 0) ||
       (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x10),auStack_1a),
       CONCAT31(extraout_var_00,bVar1) != 0)) {
      if (*(int *)(param_3 + 0x14) != 0) {
        if (DAT_00557704 == '\0') {
          uVar3 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
          local_10 = (undefined1)uVar3;
        }
        else {
          uVar3 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
          local_10 = (undefined1)(uVar3 >> 0x18);
        }
      }
      if (*(int *)(param_3 + 0x18) != 0) {
        if (DAT_00557704 == '\0') {
          uVar3 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
          local_e = (ushort)uVar3;
        }
        else {
          uVar3 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
          local_e = (ushort)(uVar3 >> 8) & 0xff00 | (ushort)(byte)(uVar3 >> 0x18);
        }
      }
      uVar2 = FUN_004ba2e4(param_1,"rrm_stat_req",auStack_20,0x14);
    }
    else {
      puts("wl_rrm_stat_req parsing peer failed");
      uVar2 = 0xffffffd4;
    }
  }
  else {
    puts("wl_rrm_stat_req parsing da failed");
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



int FUN_0049a870(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  ushort uVar3;
  undefined3 extraout_var;
  uint uVar4;
  int local_70;
  uint local_6c;
  undefined1 auStack_58 [2];
  undefined1 auStack_56 [78];
  
  local_70 = -0x2c;
  if (*(int *)(param_3 + 4) == 0) {
    local_70 = -1;
  }
  else {
    bVar2 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_56);
    if (CONCAT31(extraout_var,bVar2) != 0) {
      memset(PTR_DAT_00551644,0,0x600);
      local_70 = FUN_004ba0cc(param_1,(char *)*param_2,auStack_58,0x50,PTR_DAT_00551644,0x600);
      puVar1 = PTR_DAT_00551644;
      if (local_70 < 0) {
        fprintf(stderr,"ERROR: cmd:%s\n",(char *)*param_2);
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar3 = *(ushort *)PTR_DAT_00551644;
        }
        else {
          uVar3 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
        }
        *(ushort *)PTR_DAT_00551644 = uVar3;
        if (*(short *)puVar1 == 0) {
          if (DAT_00557704 == '\0') {
            uVar4 = *(uint *)(puVar1 + 8);
            uVar3 = *(ushort *)(puVar1 + 0xc);
          }
          else {
            uVar4 = *(uint *)(puVar1 + 8);
            uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
            uVar3 = *(ushort *)(puVar1 + 0xc) << 8 | *(ushort *)(puVar1 + 0xc) >> 8;
          }
          printf("ver:%d timestamp:%u flag:%d len:%d\n",(uint)*(ushort *)puVar1,uVar4,(uint)uVar3,
                 (uint)*(ushort *)(puVar1 + 0xe));
          for (local_6c = 0; (int)local_6c < (int)(uint)*(ushort *)(puVar1 + 0xe);
              local_6c = local_6c + 1) {
            if ((local_6c & 7) == 0) {
              printf("\n[%d]:",local_6c);
            }
            printf("[0x%02x][%d] ",(uint)(byte)puVar1[local_6c + 0x10],
                   (int)(char)puVar1[local_6c + 0x10]);
          }
          putchar(10);
        }
        else {
          fprintf(stderr,"ERROR: Mismatch ver[%d] Driver ver[%d]\n",0,(uint)*(ushort *)puVar1);
        }
      }
    }
  }
  return local_70;
}



undefined4 FUN_0049abe8(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  undefined3 extraout_var;
  undefined4 uVar3;
  undefined3 extraout_var_00;
  undefined1 auStack_1c [6];
  undefined1 local_16;
  undefined1 local_15;
  ushort local_14;
  ushort local_12;
  undefined1 auStack_10 [6];
  ushort local_a;
  
  memset(auStack_1c,0,0x14);
  if (*(int *)(param_3 + 4) != 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)uVar2;
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)(uVar2 >> 0x18);
    }
  }
  if ((*(int *)(param_3 + 8) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),auStack_1c), CONCAT31(extraout_var,bVar1) != 0))
  {
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x10) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x14) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)(uVar2 >> 0x18);
      }
    }
    if ((*(int *)(param_3 + 0x18) == 0) ||
       (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 0x18),auStack_10),
       CONCAT31(extraout_var_00,bVar1) != 0)) {
      if (*(int *)(param_3 + 0x1c) != 0) {
        if (DAT_00557704 == '\0') {
          uVar2 = strtoul(*(char **)(param_3 + 0x1c),(char **)0x0,0);
          local_a = (ushort)uVar2;
        }
        else {
          uVar2 = strtoul(*(char **)(param_3 + 0x1c),(char **)0x0,0);
          local_a = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
        }
      }
      uVar3 = FUN_004ba2e4(param_1,"rrm_frame_req",auStack_1c,0x14);
    }
    else {
      puts("wl_rrm_frame_req parsing ta failed");
      uVar3 = 0xffffffd4;
    }
  }
  else {
    puts("wl_rrm_frame_req parsing da failed");
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



undefined4 FUN_0049b0a0(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  undefined3 extraout_var;
  undefined4 uVar3;
  undefined1 auStack_1c [6];
  undefined1 local_16;
  undefined1 local_15;
  ushort local_14;
  ushort local_12;
  ushort local_10;
  
  memset(auStack_1c,0,0xe);
  if (*(int *)(param_3 + 4) != 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)uVar2;
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)(uVar2 >> 0x18);
    }
  }
  if ((*(int *)(param_3 + 8) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),auStack_1c), CONCAT31(extraout_var,bVar1) != 0))
  {
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x10) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x14) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x18) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
        local_10 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
        local_10 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    uVar3 = FUN_004ba2e4(param_1,"rrm_chload_req",auStack_1c,0xe);
  }
  else {
    puts("wl_rrm_chload_req parsing da failed");
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



undefined4 FUN_0049b4fc(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  undefined3 extraout_var;
  undefined4 uVar3;
  undefined1 auStack_1c [6];
  undefined1 local_16;
  undefined1 local_15;
  ushort local_14;
  ushort local_12;
  ushort local_10;
  
  puts("wl_rrm_noise_req");
  memset(auStack_1c,0,0xe);
  if (*(int *)(param_3 + 4) != 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)uVar2;
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_16 = (undefined1)(uVar2 >> 0x18);
    }
  }
  if ((*(int *)(param_3 + 8) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),auStack_1c), CONCAT31(extraout_var,bVar1) != 0))
  {
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_12 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x10) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_14 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x14) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_15 = (undefined1)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x18) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
        local_10 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x18),(char **)0x0,0);
        local_10 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    uVar3 = FUN_004ba2e4(param_1,"rrm_noise_req",auStack_1c,0xe);
  }
  else {
    puts("wl_rrm_noise_req parsing da failed");
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



undefined4 FUN_0049b968(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  ulong uVar2;
  undefined3 extraout_var;
  undefined4 uVar3;
  size_t __n;
  byte local_90;
  byte local_6c [4];
  uint local_68;
  uint local_64;
  undefined1 auStack_60 [6];
  ushort local_5a;
  undefined1 auStack_58 [36];
  ushort local_34;
  size_t local_30;
  undefined1 auStack_2c [36];
  
  local_90 = 0;
  memset(local_6c,0,0x3c);
  if (*(int *)(param_3 + 4) != 0) {
    if (DAT_00557704 == '\0') {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_90 = (byte)uVar2;
    }
    else {
      uVar2 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
      local_90 = (byte)(uVar2 >> 0x18);
    }
    local_6c[0] = local_90;
    if (2 < local_90) {
      puts("wl_rrm_bcn_req parsing bcn mode failed");
      return 0xfffffffe;
    }
  }
  if ((*(int *)(param_3 + 8) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),auStack_60), CONCAT31(extraout_var,bVar1) != 0))
  {
    if (*(int *)(param_3 + 0xc) != 0) {
      if (DAT_00557704 == '\0') {
        local_68 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_68 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
    }
    if (*(int *)(param_3 + 0x10) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_5a = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_5a = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    if (*(int *)(param_3 + 0x14) != 0) {
      if (DAT_00557704 == '\0') {
        local_64 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_64 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
    }
    printf("wl_rrm_bcn_req:bcn mode: %d, duration: %d, chan: %d\n",(uint)local_90,local_68,local_64)
    ;
    if (*(int *)(param_3 + 0x18) != 0) {
      __n = strlen(*(char **)(param_3 + 0x18));
      if (0x20 < __n) {
        puts("ssid too long");
        return 0xfffffffe;
      }
      memset(&local_30,0,0x24);
      memcpy(auStack_2c,*(void **)(param_3 + 0x18),__n);
      local_30 = __n;
      memcpy(auStack_58,&local_30,0x24);
    }
    if (*(int *)(param_3 + 0x1c) != 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = strtoul(*(char **)(param_3 + 0x1c),(char **)0x0,0);
        local_34 = (ushort)uVar2;
      }
      else {
        uVar2 = strtoul(*(char **)(param_3 + 0x1c),(char **)0x0,0);
        local_34 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
      }
    }
    uVar3 = FUN_004ba2e4(param_1,"rrm_bcn_req",local_6c,0x3c);
  }
  else {
    puts("wl_rrm_bcn_req parsing da failed");
    uVar3 = 0xffffffd4;
  }
  return uVar3;
}



undefined4 FUN_0049bed4(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  undefined1 auStack_10 [8];
  
  if ((*(int *)(param_3 + 4) == 0) ||
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_10), CONCAT31(extraout_var,bVar1) != 0))
  {
    uVar2 = FUN_004ba2e4(param_1,"rrm_lm_req",auStack_10,6);
  }
  else {
    puts("wl_rrm_lm_req parsing arg1 failed");
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



undefined4 FUN_0049bf94(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int *piVar3;
  size_t __n;
  undefined4 uVar4;
  size_t local_38;
  size_t local_2c;
  undefined1 auStack_28 [32];
  
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f6d7272;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 'n';
  pcVar1[1] = 'b';
  pcVar1[2] = 'r';
  pcVar1[3] = '_';
  pcVar1 = puVar2 + 8;
  pcVar1[0] = 'r';
  pcVar1[1] = 'e';
  pcVar1[2] = 'q';
  pcVar1[3] = '\0';
  local_38 = 0xc;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 != 0) {
    __n = strlen((char *)*piVar3);
    if (0x20 < __n) {
      puts("ssid too long");
      return 0xfffffffe;
    }
    memset(&local_2c,0,0x24);
    memcpy(auStack_28,(void *)*piVar3,__n);
    local_2c = __n;
    memcpy(PTR_DAT_00551644 + 0xc,&local_2c,0x24);
    local_38 = 0x30;
  }
  uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_38);
  return uVar4;
}



int FUN_0049c108(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int iVar3;
  int local_28;
  undefined *local_24;
  ushort local_10 [4];
  
  memset(PTR_DAT_00551644,0,0x2000);
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f6d7272;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 'n';
  pcVar1[1] = 'b';
  pcVar1[2] = 'r';
  pcVar1[3] = '_';
  pcVar1 = puVar2 + 8;
  pcVar1[0] = 'l';
  pcVar1[1] = 'i';
  pcVar1[2] = 's';
  pcVar1[3] = 't';
  puVar2[0xc] = '\0';
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0xd);
    if ((-1 < iVar3) && (local_10[0] = *(ushort *)PTR_DAT_00551644, local_10[0] != 0)) {
      memset(PTR_DAT_00551644,0,0x2000);
      puVar2 = PTR_DAT_00551644;
      *(undefined4 *)PTR_DAT_00551644 = 0x5f6d7272;
      pcVar1 = puVar2 + 4;
      pcVar1[0] = 'n';
      pcVar1[1] = 'b';
      pcVar1[2] = 'r';
      pcVar1[3] = '_';
      pcVar1 = puVar2 + 8;
      pcVar1[0] = 'l';
      pcVar1[1] = 'i';
      pcVar1[2] = 's';
      pcVar1[3] = 't';
      puVar2[0xc] = '\0';
      memcpy(PTR_DAT_00551644 + 0xd,local_10,2);
      puts("RRM Neighbor Report List:");
      iVar3 = FUN_004b9f94(param_1,0x106,PTR_DAT_00551644,0x2000);
      if (-1 < iVar3) {
        local_24 = PTR_DAT_00551644;
        for (local_28 = 0; local_28 < (int)(uint)local_10[0]; local_28 = local_28 + 1) {
          printf("AP %2d: ",local_28 + 1);
          printf("bssid %02x:%02x:%02x:%02x:%02x:%02x ",(uint)(byte)local_24[2],
                 (uint)(byte)local_24[3],(uint)(byte)local_24[4],(uint)(byte)local_24[5],
                 (uint)(byte)local_24[6],(uint)(byte)local_24[7]);
          printf("bssid_info %08x ",*(uint *)(local_24 + 8));
          printf("reg %2d channel %3d phytype %d\n",(uint)(byte)local_24[0xc],
                 (uint)(byte)local_24[0xd],(uint)(byte)local_24[0xe]);
          local_24 = local_24 + 0xf;
        }
      }
    }
  }
  else {
    iVar3 = -0x2c;
  }
  return iVar3;
}



undefined4 FUN_0049c484(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 uVar2;
  undefined3 extraout_var;
  undefined1 auStack_10 [8];
  
  if (*(int *)(param_3 + 4) == 0) {
    puts("no bssid specified");
    uVar2 = 0xffffffd4;
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_10);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      puts("Incorrect bssid format");
      uVar2 = 0xffffffff;
    }
    else {
      uVar2 = FUN_004ba2e4(param_1,"rrm_nbr_del_nbr",auStack_10,6);
    }
  }
  return uVar2;
}



undefined4 FUN_0049c564(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  undefined4 uVar2;
  undefined3 extraout_var;
  ulong uVar3;
  int local_38;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 auStack_1a [6];
  uint local_14;
  undefined1 local_10;
  undefined1 local_f;
  undefined1 local_e;
  
  memset(&local_1c,0,0x10);
  for (local_38 = 0; *(int *)(param_3 + local_38 * 4) != 0; local_38 = local_38 + 1) {
  }
  if (local_38 == 6) {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_1a);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      puts("wl_rrm_nbr_add_nbr parsing bssid failed");
      uVar2 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
        local_14 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_10 = (undefined1)uVar3;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        local_10 = (undefined1)(uVar3 >> 0x18);
      }
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_f = (undefined1)uVar3;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
        local_f = (undefined1)(uVar3 >> 0x18);
      }
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_e = (undefined1)uVar3;
      }
      else {
        uVar3 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
        local_e = (undefined1)(uVar3 >> 0x18);
      }
      local_1c = 0x34;
      local_1b = 0xd;
      uVar2 = FUN_004ba2e4(param_1,"rrm_nbr_add_nbr",&local_1c,0xf);
    }
  }
  else {
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



int FUN_0049c904(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  int local_20;
  uint local_14;
  char *local_10 [2];
  
  iVar1 = FUN_004ba35c(param_1,(char *)*param_2,&local_14);
  if (-1 < iVar1) {
    piVar2 = (int *)(param_3 + 4);
    if (*piVar2 == 0) {
      printf("0x%x:",local_14);
      for (local_20 = 0; *(int *)(&DAT_0055611c + local_20 * 8) != 0; local_20 = local_20 + 1) {
        if ((*(uint *)(&DAT_0055611c + local_20 * 8) & local_14) != 0) {
          printf("  %s",(&PTR_s_BSS_Transition_00556120)[local_20 * 2]);
        }
      }
      putchar(10);
      iVar1 = 0;
    }
    else {
      local_10[0] = (char *)*piVar2;
      if ((*local_10[0] == '+') || (*local_10[0] == '-')) {
        local_10[0] = local_10[0] + 1;
      }
      if ((*local_10[0] == '\0') || (uVar3 = strtoul(local_10[0],local_10,0), *local_10[0] != '\0'))
      {
        fwrite("WNM mask is a bitfield from the following set. Use + or - prefix to combine with current value:\n"
               ,1,0x60,stderr);
        for (local_20 = 0; *(int *)(&DAT_0055611c + local_20 * 8) != 0; local_20 = local_20 + 1) {
          fprintf(stderr," 0x%04x %s\n",*(uint *)(&DAT_0055611c + local_20 * 8),
                  (&PTR_s_BSS_Transition_00556120)[local_20 * 2]);
        }
        iVar1 = 0;
      }
      else {
        if (*(char *)*piVar2 == '+') {
          uVar3 = local_14 | uVar3;
        }
        else if (*(char *)*piVar2 == '-') {
          uVar3 = ~uVar3 & local_14;
        }
        local_14 = uVar3;
        iVar1 = FUN_004ba428(param_1,(char *)*param_2,local_14);
      }
    }
  }
  return iVar1;
}



undefined4 FUN_0049cc24(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int *piVar3;
  size_t __n;
  undefined4 uVar4;
  size_t local_38;
  size_t local_2c;
  undefined1 auStack_28 [32];
  
  puVar2 = PTR_DAT_00551644;
  *(undefined4 *)PTR_DAT_00551644 = 0x5f6d6e77;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 'b';
  pcVar1[1] = 's';
  pcVar1[2] = 's';
  pcVar1[3] = 't';
  pcVar1 = puVar2 + 8;
  pcVar1[0] = 'r';
  pcVar1[1] = 'a';
  pcVar1[2] = 'n';
  pcVar1[3] = 's';
  pcVar1 = puVar2 + 0xc;
  pcVar1[0] = '_';
  pcVar1[1] = 'q';
  pcVar1[2] = 'u';
  pcVar1[3] = 'e';
  puVar2[0x10] = 'r';
  puVar2[0x11] = 'y';
  puVar2[0x12] = '\0';
  local_38 = 0x13;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 != 0) {
    __n = strlen((char *)*piVar3);
    if (0x20 < __n) {
      puts("ssid too long");
      return 0xffffffff;
    }
    memset(&local_2c,0,0x24);
    memcpy(auStack_28,(void *)*piVar3,__n);
    local_2c = __n;
    memcpy(PTR_DAT_00551644 + 0x13,&local_2c,0x24);
    local_38 = 0x37;
  }
  uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,local_38);
  return uVar4;
}



undefined4 FUN_0049cdc4(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  undefined2 uVar1;
  bool bVar2;
  int iVar3;
  undefined4 uVar4;
  ulong uVar5;
  byte *__s;
  int *piVar6;
  size_t sVar7;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined *puVar8;
  
  iVar3 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  if (param_3[1] == 0) {
    printf("TCLAS Frame Classifier: %s not provided\n","user priority");
    uVar4 = 0xffffffff;
  }
  else {
    puVar8 = PTR_DAT_00551644 + iVar3 + 1;
    uVar5 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar8 = (char)uVar5;
    __s = PTR_DAT_00551644 + iVar3 + 2;
    memset(__s,0,0x2c);
    if (param_3[2] == 0) {
      printf("TCLAS Frame Classifier: %s not provided\n","type");
      uVar4 = 0xffffffff;
    }
    else {
      uVar5 = strtoul((char *)param_3[2],(char **)0x0,0);
      *__s = (byte)uVar5;
      if (param_3[3] == 0) {
        printf("TCLAS Frame Classifier: %s not provided\n","mask");
        uVar4 = 0xffffffff;
      }
      else {
        uVar5 = strtoul((char *)param_3[3],(char **)0x0,0);
        __s[1] = (byte)uVar5;
        if (*__s == 0) {
          piVar6 = param_3 + 4;
          if (*piVar6 == 0) {
            printf("TCLAS Frame Classifier: %s not provided\n","src mac");
            uVar4 = 0xffffffff;
          }
          else {
            sVar7 = strlen((char *)*piVar6);
            if (sVar7 < 2) {
              memset(__s + 2,0,6);
            }
            else {
              bVar2 = FUN_0041d6ac((char *)*piVar6,__s + 2);
              if (CONCAT31(extraout_var,bVar2) == 0) {
                puts(" ERROR: no valid src ether addr provided");
                return 0xffffffff;
              }
            }
            piVar6 = param_3 + 5;
            if (*piVar6 == 0) {
              printf("TCLAS Frame Classifier: %s not provided\n","dst mac");
              uVar4 = 0xffffffff;
            }
            else {
              sVar7 = strlen((char *)*piVar6);
              if (sVar7 < 2) {
                memset(__s + 8,0,6);
              }
              else {
                bVar2 = FUN_0041d6ac((char *)*piVar6,__s + 8);
                if (CONCAT31(extraout_var_00,bVar2) == 0) {
                  puts(" ERROR: no valid dst ether addr provided");
                  return 0xffffffff;
                }
              }
              if (param_3[6] == 0) {
                printf("TCLAS Frame Classifier: %s not provided\n","ether type");
                uVar4 = 0xffffffff;
              }
              else {
                uVar5 = strtoul((char *)param_3[6],(char **)0x0,0);
                __s[0xe] = (byte)(uVar5 >> 8);
                __s[0xf] = (byte)uVar5;
                uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar3 + 0x12);
              }
            }
          }
        }
        else if ((*__s == 1) || (*__s == 4)) {
          if (param_3[4] == 0) {
            printf("TCLAS Frame Classifier: %s not provided\n","ip version");
            uVar4 = 0xffffffff;
          }
          else {
            uVar5 = strtoul((char *)param_3[4],(char **)0x0,0);
            if ((char)uVar5 == '\x06') {
              __s[2] = 6;
              if (param_3[5] == 0) {
                printf("TCLAS Frame Classifier: %s not provided\n","ipv6 source ip");
                uVar4 = 0xffffffff;
              }
              else {
                bVar2 = FUN_0041dbbc((char *)param_3[5],(int)(__s + 3));
                if (CONCAT31(extraout_var_01,bVar2) == 0) {
                  puts("incorrect ipv6 source ip format");
                  uVar4 = 0xffffffff;
                }
                else if (param_3[6] == 0) {
                  printf("TCLAS Frame Classifier: %s not provided\n","ipv6 dest ip");
                  uVar4 = 0xffffffff;
                }
                else {
                  bVar2 = FUN_0041dbbc((char *)param_3[6],(int)(__s + 0x13));
                  if (CONCAT31(extraout_var_02,bVar2) == 0) {
                    puts("incorrect ipv6 dest ip format");
                    uVar4 = 0xffffffff;
                  }
                  else if (param_3[7] == 0) {
                    printf("TCLAS Frame Classifier: %s not provided\n","ipv6 source port");
                    uVar4 = 0xffffffff;
                  }
                  else {
                    uVar5 = strtoul((char *)param_3[7],(char **)0x0,0);
                    __s[0x23] = (byte)(uVar5 >> 8);
                    __s[0x24] = (byte)uVar5;
                    if (param_3[8] == 0) {
                      printf("TCLAS Frame Classifier: %s not provided\n","ipv6 dest port");
                      uVar4 = 0xffffffff;
                    }
                    else {
                      uVar5 = strtoul((char *)param_3[8],(char **)0x0,0);
                      __s[0x25] = (byte)(uVar5 >> 8);
                      __s[0x26] = (byte)uVar5;
                      if (param_3[9] == 0) {
                        printf("TCLAS Frame Classifier: %s not provided\n","ipv6 dscp");
                        uVar4 = 0xffffffff;
                      }
                      else {
                        uVar5 = strtoul((char *)param_3[9],(char **)0x0,0);
                        __s[0x27] = (byte)uVar5;
                        if (param_3[10] == 0) {
                          printf("TCLAS Frame Classifier: %s not provided\n","ipv6 next header");
                          uVar4 = 0xffffffff;
                        }
                        else {
                          uVar5 = strtoul((char *)param_3[10],(char **)0x0,0);
                          __s[0x28] = (byte)uVar5;
                          if (param_3[0xb] == 0) {
                            printf("TCLAS Frame Classifier: %s not provided\n","ipv6 flow label");
                            uVar4 = 0xffffffff;
                          }
                          else {
                            uVar5 = strtoul((char *)param_3[0xb],(char **)0x0,0);
                            __s[0x2b] = (byte)(uVar5 >> 0x10);
                            __s[0x2a] = (byte)(uVar5 >> 8);
                            __s[0x29] = (byte)uVar5;
                            uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar3 + 0x2e);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            else if ((char)uVar5 == '\x04') {
              __s[2] = 4;
              if (param_3[5] == 0) {
                printf("TCLAS Frame Classifier: %s not provided\n","ipv4 source ip");
                uVar4 = 0xffffffff;
              }
              else {
                bVar2 = FUN_0041d840((char *)param_3[5],(int)(__s + 3));
                if (CONCAT31(extraout_var_03,bVar2) == 0) {
                  puts("incorrect source ip format");
                  uVar4 = 0xffffffff;
                }
                else if (param_3[6] == 0) {
                  printf("TCLAS Frame Classifier: %s not provided\n","ipv4 dest ip");
                  uVar4 = 0xffffffff;
                }
                else {
                  bVar2 = FUN_0041d840((char *)param_3[6],(int)(__s + 7));
                  if (CONCAT31(extraout_var_04,bVar2) == 0) {
                    puts("incorrect dest ip format");
                    uVar4 = 0xffffffff;
                  }
                  else if (param_3[7] == 0) {
                    printf("TCLAS Frame Classifier: %s not provided\n","ipv4 source port");
                    uVar4 = 0xffffffff;
                  }
                  else {
                    uVar5 = strtoul((char *)param_3[7],(char **)0x0,0);
                    __s[0xb] = (byte)uVar5;
                    __s[0xc] = (byte)(uVar5 >> 8);
                    uVar1 = *(undefined2 *)(__s + 0xb);
                    __s[0xb] = (byte)((ushort)uVar1 >> 8);
                    __s[0xc] = (byte)uVar1;
                    if (param_3[8] == 0) {
                      printf("TCLAS Frame Classifier: %s not provided\n","ipv4 dest port");
                      uVar4 = 0xffffffff;
                    }
                    else {
                      uVar5 = strtoul((char *)param_3[8],(char **)0x0,0);
                      __s[0xd] = (byte)uVar5;
                      __s[0xe] = (byte)(uVar5 >> 8);
                      uVar1 = *(undefined2 *)(__s + 0xd);
                      __s[0xd] = (byte)((ushort)uVar1 >> 8);
                      __s[0xe] = (byte)uVar1;
                      if (param_3[9] == 0) {
                        printf("TCLAS Frame Classifier: %s not provided\n","ipv4 dscp");
                        uVar4 = 0xffffffff;
                      }
                      else {
                        uVar5 = strtoul((char *)param_3[9],(char **)0x0,0);
                        __s[0xf] = (byte)uVar5;
                        if (param_3[10] == 0) {
                          printf("TCLAS Frame Classifier: %s not provided\n","ipv4 protocol");
                          uVar4 = 0xffffffff;
                        }
                        else {
                          uVar5 = strtoul((char *)param_3[10],(char **)0x0,0);
                          __s[0x10] = (byte)uVar5;
                          uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar3 + 0x14);
                        }
                      }
                    }
                  }
                }
              }
            }
            else {
              uVar4 = 0xffffffff;
            }
          }
        }
        else {
          printf("Unsupported frame classifier type 0x%2x\n",(uint)*__s);
          uVar4 = 0xffffffff;
        }
      }
    }
  }
  return uVar4;
}



undefined4 FUN_0049db68(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  undefined4 uVar4;
  undefined *puVar5;
  
  iVar1 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  iVar2 = iVar1 + 1;
  PTR_DAT_00551644[iVar2] = 0;
  PTR_DAT_00551644[iVar1 + 2] = 0;
  if (param_3[1] != 0) {
    PTR_DAT_00551644[iVar2] = 1;
    puVar5 = PTR_DAT_00551644 + iVar1 + 2;
    uVar3 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar5 = (char)uVar3;
    if (param_3[2] != 0) {
      PTR_DAT_00551644[iVar2] = 2;
      puVar5 = PTR_DAT_00551644 + iVar1 + 3;
      uVar3 = strtoul((char *)param_3[2],(char **)0x0,0);
      *puVar5 = (char)uVar3;
      if (param_3[3] != 0) {
        puts("Too much args provided");
        return 0xffffffff;
      }
    }
  }
  uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar1 + 3);
  return uVar4;
}



void FUN_0049dd54(byte *param_1)

{
  byte *pbVar1;
  char *pcVar2;
  uchar uVar3;
  
  pbVar1 = param_1 + 2;
  printf("up %d  type %d  mask 0x%x  ",(uint)*param_1,(uint)*pbVar1,(uint)param_1[3]);
  if (*pbVar1 == 0) {
    printf("(Eth: ");
    if ((param_1[3] & 1) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041d780((int)(param_1 + 4));
    printf("%cSA %s  ",uVar3,pcVar2);
    if ((param_1[3] & 2) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041d780((int)(param_1 + 10));
    printf("%cDA %s  ",uVar3,pcVar2);
    if ((param_1[3] & 4) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%ctype 0x%04x",uVar3,
           (uint)(ushort)(*(ushort *)(param_1 + 0x10) << 8 | *(ushort *)(param_1 + 0x10) >> 8));
    puts(")");
  }
  else if ((*pbVar1 == 1) || ((*pbVar1 == 4 && (param_1[4] == 4)))) {
    printf("(IPv4: ");
    if ((param_1[3] & 1) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cver %d  ",uVar3,(uint)param_1[4]);
    if ((param_1[3] & 2) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041e064(param_1 + 5);
    printf("%csip %s  ",uVar3,pcVar2);
    if ((param_1[3] & 4) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041e064(param_1 + 9);
    printf("%cdip %s  ",uVar3,pcVar2);
    if ((param_1[3] & 8) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%csp %d  ",uVar3,
           (uint)(ushort)(*(ushort *)(param_1 + 0xd) << 8 | *(ushort *)(param_1 + 0xd) >> 8));
    if ((param_1[3] & 0x10) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cdp %d  ",uVar3,
           (uint)(ushort)(*(ushort *)(param_1 + 0xf) << 8 | *(ushort *)(param_1 + 0xf) >> 8));
    if ((param_1[3] & 0x20) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cdscp 0x%x  ",uVar3,(uint)param_1[0x11]);
    if ((param_1[3] & 0x40) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cprot %d",uVar3,(uint)param_1[0x12]);
    puts(")");
  }
  else if ((*pbVar1 == 4) && (param_1[4] == 6)) {
    printf("(IPv6: ");
    if ((param_1[3] & 1) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cver %d  ",uVar3,(uint)param_1[4]);
    if ((param_1[3] & 2) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041dd00((int)(param_1 + 5));
    printf("%csip %s  ",uVar3,pcVar2);
    if ((param_1[3] & 4) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    pcVar2 = FUN_0041dd00((int)(param_1 + 0x15));
    printf("%cdip %s  ",uVar3,pcVar2);
    if ((param_1[3] & 8) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%csp %d  ",uVar3,
           (uint)(ushort)(*(ushort *)(param_1 + 0x25) << 8 | *(ushort *)(param_1 + 0x25) >> 8));
    if ((param_1[3] & 0x10) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cdp %d  ",uVar3,
           (uint)(ushort)(*(ushort *)(param_1 + 0x27) << 8 | *(ushort *)(param_1 + 0x27) >> 8));
    if ((param_1[3] & 0x20) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cdscp 0x%x  ",uVar3,(uint)param_1[0x29]);
    if ((param_1[3] & 0x40) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cprot %d",uVar3,(uint)param_1[0x2a]);
    if ((param_1[3] & 0x40) == 0) {
      uVar3 = '-';
    }
    else {
      uVar3 = '+';
    }
    printf("%cfl %d",uVar3,
           (uint)param_1[0x2d] << 0x10 | (uint)param_1[0x2c] << 8 | (uint)param_1[0x2b]);
    puts(")");
  }
  else {
    puts("(type unsupported)");
  }
  return;
}



int FUN_0049e534(uint *param_1)

{
  uint local_18;
  uint *local_14;
  int local_10;
  
  local_14 = param_1 + 1;
  local_10 = 0;
  for (local_18 = 0; local_18 < *param_1; local_18 = local_18 + 1) {
    printf("tclas idx %d: ",local_18);
    FUN_0049dd54((byte *)local_14);
    local_10 = (uint)*(byte *)((int)local_14 + 1) + local_10 + 2;
    local_14 = (uint *)((int)local_14 + *(byte *)((int)local_14 + 1) + 2);
  }
  return local_10;
}



int FUN_0049e600(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint *local_10 [2];
  
  local_10[0] = (uint *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (iVar1 == 0) {
      if (*local_10[0] == 0) {
        puts("No tclas frame classifier parameter entry");
      }
      else {
        FUN_0049e534(local_10[0]);
      }
    }
  }
  else {
    puts("Too much args provided");
    iVar1 = -1;
  }
  return iVar1;
}



undefined4 FUN_0049e6ec(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  undefined *puVar2;
  undefined4 uVar3;
  ulong uVar4;
  ulong uVar5;
  ulong uVar6;
  ulong uVar7;
  int local_18;
  
  puVar2 = PTR_DAT_00551644;
  for (local_18 = 0; *(int *)(param_3 + local_18 * 4) != 0; local_18 = local_18 + 1) {
  }
  *(undefined4 *)PTR_DAT_00551644 = 0x5f6d6e77;
  pcVar1 = puVar2 + 4;
  pcVar1[0] = 't';
  pcVar1[1] = 'f';
  pcVar1[2] = 's';
  pcVar1[3] = 'r';
  pcVar1 = puVar2 + 8;
  pcVar1[0] = 'e';
  pcVar1[1] = 'q';
  pcVar1[2] = '_';
  pcVar1[3] = 'a';
  puVar2[0xc] = 'd';
  puVar2[0xd] = 'd';
  puVar2[0xe] = '\0';
  if ((local_18 == 5) && (*(int *)(param_3 + 4) != 0)) {
    uVar4 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    if (*(int *)(param_3 + 8) == 0) {
      puts("Incorrect args provided");
      uVar3 = 0xffffffff;
    }
    else {
      uVar5 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      if (*(int *)(param_3 + 0xc) == 0) {
        puts("Incorrect args provided");
        uVar3 = 0xffffffff;
      }
      else {
        uVar6 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        if (*(int *)(param_3 + 0x10) == 0) {
          puts("Incorrect args provided");
          uVar3 = 0xffffffff;
        }
        else {
          uVar7 = strtoul(*(char **)(param_3 + 0x10),(char **)0x0,0);
          if ((((char)uVar4 == '\0') || (3 < (byte)uVar5)) || (1 < (byte)uVar6)) {
            puts("Input args not in range");
            uVar3 = 0xffffffff;
          }
          else {
            PTR_DAT_00551644[0xf] = (char)uVar4;
            PTR_DAT_00551644[0x10] = (byte)uVar5;
            PTR_DAT_00551644[0x11] = (byte)uVar6;
            PTR_DAT_00551644[0x12] = uVar7 != 0;
            uVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,0x13);
          }
        }
      }
    }
  }
  else {
    puts("Incorrect args provided");
    uVar3 = 0xffffffff;
  }
  return uVar3;
}



undefined4 FUN_0049ea64(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined1 *puVar2;
  undefined4 uVar3;
  ulong uVar4;
  
  iVar1 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  puVar2 = PTR_DAT_00551644 + iVar1 + 1;
  puVar2[1] = 0;
  puVar2[2] = 0;
  if (param_3[1] == 0) {
    puts("Missing <send> argument");
    uVar3 = 0xffffffff;
  }
  else {
    uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar2 = (char)uVar4;
    if (param_3[2] != 0) {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar2[1] = (char)uVar4;
      if (param_3[3] != 0) {
        uVar4 = strtoul((char *)param_3[3],(char **)0x0,0);
        puVar2[2] = (char)uVar4;
        if (param_3[4] != 0) {
          puts("extra argument");
          return 0xffffffff;
        }
      }
    }
    uVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar1 + 4);
  }
  return uVar3;
}



int FUN_0049ec50(int *param_1,int param_2,undefined4 *param_3)

{
  byte *pbVar1;
  byte bVar2;
  undefined *puVar3;
  byte *pbVar4;
  int iVar5;
  uint uVar6;
  byte *pbVar7;
  char *param1;
  byte *local_20;
  
  puVar3 = PTR_DAT_00551644;
  local_20 = PTR_DAT_00551644 + 4;
  strcpy(PTR_DAT_00551644,(char *)*param_3);
  iVar5 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
  if (-1 < iVar5) {
    if (DAT_00557704 == '\0') {
      uVar6 = *(uint *)puVar3;
    }
    else {
      uVar6 = *(uint *)puVar3;
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    *(uint *)puVar3 = uVar6;
    while (pbVar4 = local_20, iVar5 = *(int *)puVar3, *(int *)puVar3 = iVar5 + -1, iVar5 != 0) {
      printf("DMS desc UserID %d:\n",(uint)*local_20);
      printf("\tstatus:%d   token:%d   DMS ID:%d   TCLAS proc:%d\n",(uint)local_20[1],
             (uint)local_20[2],(uint)local_20[3],(uint)local_20[4]);
      pbVar7 = local_20 + 7;
      pbVar1 = local_20 + 5;
      local_20 = pbVar7;
      if (*pbVar1 != 0) {
        puts("\tRegistered STA:");
        while (pbVar4[5] != 0) {
          param1 = FUN_0041d780((int)local_20);
          printf("\t\t- %s\n",param1);
          local_20 = local_20 + 6;
          pbVar4[5] = pbVar4[5] - 6;
        }
      }
      puts("\tTCLAS:");
      while (pbVar4[6] != 0) {
        printf("\t\t- ");
        FUN_0049dd54(local_20);
        bVar2 = local_20[1];
        pbVar4[6] = (pbVar4[6] - local_20[1]) - 2;
        local_20 = local_20 + bVar2 + 2;
      }
    }
    iVar5 = 0;
  }
  return iVar5;
}



undefined4 FUN_0049ef18(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined1 *puVar2;
  undefined4 uVar3;
  ulong uVar4;
  
  iVar1 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  puVar2 = PTR_DAT_00551644 + iVar1 + 1;
  puVar2[1] = 0;
  if (param_3[1] == 0) {
    puts("Missing <del> argument");
    uVar3 = 0xffffffff;
  }
  else {
    uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar2 = (char)uVar4;
    if (param_3[2] != 0) {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar2[1] = (char)uVar4;
      if (param_3[3] != 0) {
        puts("extra argument");
        return 0xffffffff;
      }
    }
    uVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar1 + 3);
  }
  return uVar3;
}



undefined4 FUN_0049f0ac(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined1 *puVar2;
  undefined4 uVar3;
  ulong uVar4;
  
  iVar1 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  puVar2 = PTR_DAT_00551644 + iVar1 + 1;
  puVar2[2] = 0;
  if (param_3[1] == 0) {
    puts("Missing <service> argument");
    uVar3 = 0xffffffff;
  }
  else {
    uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar2 = (char)uVar4;
    if (param_3[2] == 0) {
      puts("Missing <del> argument");
      uVar3 = 0xffffffff;
    }
    else {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar2[1] = (char)uVar4;
      if (param_3[3] != 0) {
        uVar4 = strtoul((char *)param_3[3],(char **)0x0,0);
        puVar2[2] = (char)uVar4;
        if (param_3[4] != 0) {
          puts("extra argument");
          return 0xffffffff;
        }
      }
      uVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar1 + 4);
    }
  }
  return uVar3;
}



int FUN_0049f2a0(int *param_1,int param_2,undefined4 *param_3)

{
  undefined *puVar1;
  int iVar2;
  undefined2 *puVar3;
  ulong uVar4;
  int *piVar5;
  
  puVar1 = PTR_DAT_00551644;
  piVar5 = param_3 + 1;
  iVar2 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  if (*piVar5 == 0) {
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
    if (-1 < iVar2) {
      printf("TIMBC offset: %d, tsf_present: %d, fix_interval: %d, rate_override: %d\n",
             (int)*(short *)PTR_DAT_00551644,(uint)(byte)PTR_DAT_00551644[6],
             (uint)*(ushort *)(PTR_DAT_00551644 + 2),(uint)*(ushort *)(PTR_DAT_00551644 + 4));
      iVar2 = 0;
    }
  }
  else if ((*(ushort *)(__ctype_b + *(char *)*piVar5 * 2) & 8) == 0) {
    iVar2 = -1;
  }
  else {
    puVar3 = (undefined2 *)(puVar1 + iVar2 + 1);
    uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
    *puVar3 = (short)uVar4;
    *(undefined1 *)(puVar3 + 3) = 1;
    puVar3[1] = 0;
    puVar3[2] = 0;
    if (param_3[2] != 0) {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      *(char *)(puVar3 + 3) = (char)uVar4;
      if (param_3[3] != 0) {
        uVar4 = strtoul((char *)param_3[3],(char **)0x0,0);
        puVar3[1] = (short)uVar4;
        if (param_3[4] != 0) {
          uVar4 = strtoul((char *)param_3[4],(char **)0x0,0);
          puVar3[2] = (short)uVar4;
        }
      }
    }
    iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar2 + 9);
  }
  return iVar2;
}



undefined4 FUN_0049f550(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  ushort uVar1;
  int iVar2;
  undefined1 *puVar3;
  undefined4 uVar4;
  ulong uVar5;
  int *piVar6;
  int iVar7;
  
  iVar2 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  puVar3 = PTR_DAT_00551644 + iVar2 + 1;
  puVar3[1] = 0;
  *(undefined2 *)(puVar3 + 2) = 0;
  *(undefined2 *)(puVar3 + 4) = 0;
  if (param_3[1] == 0) {
    puts("Missing <interval> argument");
    uVar4 = 0xffffffff;
  }
  else {
    uVar5 = strtoul((char *)param_3[1],(char **)0x0,0);
    *puVar3 = (char)uVar5;
    if (param_3[2] != 0) {
      uVar5 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar3[1] = (char)uVar5;
      piVar6 = param_3 + 3;
      if (*piVar6 != 0) {
        if (DAT_00557704 == '\0') {
          iVar7 = FUN_0041584c((char *)*piVar6);
          uVar1 = (ushort)iVar7;
        }
        else {
          iVar7 = FUN_0041584c((char *)*piVar6);
          uVar1 = (ushort)iVar7 << 8 | (ushort)iVar7 >> 8;
        }
        *(ushort *)(puVar3 + 2) = uVar1;
        piVar6 = param_3 + 4;
        if (*piVar6 != 0) {
          if (DAT_00557704 == '\0') {
            iVar7 = FUN_0041584c((char *)*piVar6);
            uVar1 = (ushort)iVar7;
          }
          else {
            iVar7 = FUN_0041584c((char *)*piVar6);
            uVar1 = (ushort)iVar7 << 8 | (ushort)iVar7 >> 8;
          }
          *(ushort *)(puVar3 + 4) = uVar1;
          if (param_3[5] != 0) {
            puts("Too many arguments");
            return 0xffffffff;
          }
        }
      }
    }
    uVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar2 + 7);
  }
  return uVar4;
}



int FUN_0049f834(int *param_1,int param_2,undefined4 *param_3)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  undefined *puVar4;
  int iVar5;
  char *param5;
  char *param6;
  char acStack_40 [16];
  char acStack_30 [20];
  
  puVar4 = PTR_DAT_00551644;
  strcpy(PTR_DAT_00551644,(char *)*param_3);
  iVar5 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
  if (-1 < iVar5) {
    bVar1 = *puVar4;
    bVar2 = puVar4[1];
    bVar3 = puVar4[2];
    iVar5 = *(int *)(puVar4 + 4);
    param5 = FUN_004158d8(acStack_40,(uint)*(ushort *)(puVar4 + 8));
    param6 = FUN_004158d8(acStack_30,(uint)*(ushort *)(puVar4 + 10));
    printf("TIM BC current status: %d  status_ap: %d\n  interval: %d   offset: %d\n  high rate: %s   low rate: %s\n"
           ,(uint)bVar1,(uint)bVar2,(uint)bVar3,iVar5,param5,param6);
    iVar5 = 0;
  }
  return iVar5;
}



int FUN_0049f994(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint param1;
  uint local_18;
  ulong local_14;
  char *local_10 [2];
  
  local_18 = 0;
  local_14 = 0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba35c(param_1,(char *)*param_2,&local_18);
    if (-1 < iVar1) {
      param1 = local_18;
      if (DAT_00557704 != '\0') {
        param1 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                 local_18 >> 0x18;
      }
      printf("BSS Max Idle Period: %d\n",param1);
      iVar1 = 0;
    }
  }
  else {
    local_18 = strtoul(*(char **)(param_3 + 4),local_10,0);
    if (*local_10[0] == '\0') {
      if ((*(int *)(param_3 + 8) == 0) ||
         (local_14 = strtoul(*(char **)(param_3 + 8),local_10,0), *local_10[0] == '\0')) {
        iVar1 = FUN_00445444(param_1,(char *)*param_2,&local_18,8);
      }
      else {
        iVar1 = -0x2c;
      }
    }
    else {
      iVar1 = -0x2c;
    }
  }
  return iVar1;
}



undefined4 FUN_0049fb94(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined4 uVar2;
  ulong uVar3;
  undefined2 local_14;
  undefined2 local_12;
  undefined1 local_10;
  undefined1 local_f;
  
  iVar1 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  if (param_3[1] == 0) {
    fprintf(stderr,"%s: error: reqmode missing\n","wl_wnm_bsstrans_req");
    uVar2 = 0xffffffff;
  }
  else {
    uVar3 = strtoul((char *)param_3[1],(char **)0x0,0);
    local_10 = (undefined1)uVar3;
    if (param_3[2] == 0) {
      fprintf(stderr,"%s: error: tbtt missing\n","wl_wnm_bsstrans_req");
      uVar2 = 0xffffffff;
    }
    else {
      uVar3 = strtoul((char *)param_3[2],(char **)0x0,0);
      if (((int)uVar3 < 0x10000) && (-1 < (int)uVar3)) {
        local_14 = (undefined2)uVar3;
        if (param_3[3] == 0) {
          fprintf(stderr,"%s: error: dur missing\n","wl_wnm_bsstrans_req");
          uVar2 = 0xffffffff;
        }
        else {
          uVar3 = strtoul((char *)param_3[3],(char **)0x0,0);
          if (((int)uVar3 < 0x10000) && (-1 < (int)uVar3)) {
            local_12 = (undefined2)uVar3;
            if (param_3[4] == 0) {
              local_f = 1;
            }
            else {
              uVar3 = strtoul((char *)param_3[4],(char **)0x0,0);
              local_f = (undefined1)uVar3;
            }
            memcpy(PTR_DAT_00551644 + iVar1 + 1,&local_14,6);
            uVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar1 + 7);
          }
          else {
            fprintf(stderr,"%s: error: dur out of range(%d)\n","wl_wnm_bsstrans_req",uVar3);
            uVar2 = 0xffffffff;
          }
        }
      }
      else {
        fprintf(stderr,"%s: error: tbtt out of range(%d)\n","wl_wnm_bsstrans_req",uVar3);
        uVar2 = 0xffffffff;
      }
    }
  }
  return uVar2;
}



int FUN_0049feb4(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  long lVar3;
  int local_1c;
  ushort local_18;
  byte local_16;
  ushort local_14;
  char *apcStack_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_18,6);
    if (-1 < iVar2) {
      puts("Keepalives_max_idle parameters -");
      printf("num_of_keepalives_per_bss_max_idle\t\t= %d\nmkeep_alive_index\t= %d\nmax_interval\t= %d\n"
             ,(uint)local_18,(uint)local_16,(uint)local_14);
    }
  }
  else {
    for (local_1c = 0; piVar1[local_1c] != 0; local_1c = local_1c + 1) {
    }
    if ((local_1c < 2) || (3 < local_1c)) {
      iVar2 = -1;
    }
    else {
      lVar3 = strtol((char *)*piVar1,apcStack_10,0);
      local_18 = (ushort)lVar3;
      lVar3 = strtol(*(char **)(param_3 + 8),apcStack_10,0);
      local_16 = (byte)lVar3;
      if (local_1c == 3) {
        lVar3 = strtol(*(char **)(param_3 + 0xc),apcStack_10,0);
        local_14 = (ushort)lVar3;
      }
      else {
        local_14 = 0;
      }
      iVar2 = FUN_004ba2e4(param_1,(char *)*param_2,&local_18,6);
    }
  }
  return iVar2;
}



int FUN_004a00b0(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint local_18;
  uint local_14;
  char *local_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba1f8(param_1,"tsf",(char *)&local_18,8);
    if (iVar2 == 0) {
      if (DAT_00557704 != '\0') {
        local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                   local_14 >> 0x18;
        local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                   local_18 >> 0x18;
      }
      printf("0x%08X 0x%08X\n",local_14,local_18);
    }
  }
  else if (*(int *)(param_3 + 8) == 0) {
    iVar2 = -0x2c;
  }
  else {
    local_14 = strtoul((char *)*piVar1,local_10,0);
    if (*local_10[0] == '\0') {
      local_18 = strtoul(*(char **)(param_3 + 8),local_10,0);
      if (*local_10[0] == '\0') {
        if (DAT_00557704 != '\0') {
          local_18 = local_18 << 0x18 | (local_18 & 0xff00) << 8 | (local_18 & 0xff0000) >> 8 |
                     local_18 >> 0x18;
          local_14 = local_14 << 0x18 | (local_14 & 0xff00) << 8 | (local_14 & 0xff0000) >> 8 |
                     local_14 >> 0x18;
        }
        iVar2 = FUN_004ba2e4(param_1,"tsf",&local_18,8);
      }
      else {
        fprintf(stderr,"%s: %s: error parsing \"%s\" as an integer\n",DAT_00557690,"tsf",
                *(char **)(param_3 + 8));
        iVar2 = -0x2c;
      }
    }
    else {
      fprintf(stderr,"%s: %s: error parsing \"%s\" as an integer\n",DAT_00557690,"tsf",
              (char *)*piVar1);
      iVar2 = -0x2c;
    }
  }
  return iVar2;
}



undefined4 FUN_004a0438(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_20;
  
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if ((1 < local_20) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      uVar1 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      uVar1 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
    *(uint *)PTR_DAT_00551644 = uVar1;
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp",PTR_DAT_00551644,0x100);
  return uVar2;
}



int FUN_004a0598(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  int local_20;
  int local_1c;
  uint local_10 [2];
  
  local_10[0] = 0;
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if ((local_20 < 2) || (*(int *)(param_3 + 4) == 0)) {
    local_1c = FUN_004ba35c(param_1,"mfp_sha256",local_10);
    if (local_1c == 0) {
      printf("%d\n",local_10[0]);
    }
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10[0] = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_10[0] = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
    *(uint *)PTR_DAT_00551644 = local_10[0];
    local_1c = FUN_004ba2e4(param_1,"mfp_sha256",PTR_DAT_00551644,0x100);
  }
  return local_1c;
}



undefined4 FUN_004a0740(int *param_1,undefined4 param_2,int param_3)

{
  undefined1 uVar1;
  ushort uVar2;
  uint *__s;
  undefined4 uVar3;
  uint uVar4;
  int iVar5;
  int local_20;
  
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  __s = (uint *)malloc(0x10);
  if (__s == (uint *)0x0) {
    puts("unable to allocate frame ");
    uVar3 = 0xffffffe5;
  }
  else {
    memset(__s,0,0x10);
    if ((1 < local_20) && (*(int *)(param_3 + 4) != 0)) {
      if (DAT_00557704 == '\0') {
        uVar4 = atoi(*(char **)(param_3 + 4));
      }
      else {
        uVar4 = atoi(*(char **)(param_3 + 4));
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      *__s = uVar4;
    }
    if ((2 < local_20) && (*(int *)(param_3 + 8) != 0)) {
      if (DAT_00557704 == '\0') {
        iVar5 = atoi(*(char **)(param_3 + 8));
        uVar1 = (undefined1)iVar5;
      }
      else {
        iVar5 = atoi(*(char **)(param_3 + 8));
        uVar1 = (undefined1)((uint)iVar5 >> 0x18);
      }
      *(undefined1 *)(__s + 1) = uVar1;
    }
    if ((3 < local_20) && (*(int *)(param_3 + 0xc) != 0)) {
      if (DAT_00557704 == '\0') {
        iVar5 = atoi(*(char **)(param_3 + 0xc));
        uVar2 = (ushort)iVar5;
      }
      else {
        iVar5 = atoi(*(char **)(param_3 + 0xc));
        uVar2 = (ushort)((uint)iVar5 >> 8) & 0xff00 | (ushort)(byte)((uint)iVar5 >> 0x18);
      }
      *(ushort *)((int)__s + 6) = uVar2;
    }
    uVar3 = FUN_00445444(param_1,"mfp_sa_query",__s,0x10);
    free(__s);
  }
  return uVar3;
}



undefined4 FUN_004a0a48(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_108;
  uint local_104;
  
  memset(&local_108,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_108 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_108 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  if ((2 < local_120) && (*(int *)(param_3 + 8) != 0)) {
    if (DAT_00557704 == '\0') {
      local_104 = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 8));
      local_104 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_disassoc",&local_108,0x100);
  return uVar2;
}



undefined4 FUN_004a0c6c(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_108;
  uint local_104;
  
  memset(&local_108,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_108 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_108 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  if ((2 < local_120) && (*(int *)(param_3 + 8) != 0)) {
    if (DAT_00557704 == '\0') {
      local_104 = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 8));
      local_104 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_deauth",&local_108,0x100);
  return uVar2;
}



undefined4 FUN_004a0e90(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_108;
  uint local_104;
  
  memset(&local_108,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_108 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_108 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  if ((2 < local_120) && (*(int *)(param_3 + 8) != 0)) {
    if (DAT_00557704 == '\0') {
      local_104 = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 8));
      local_104 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_assoc",&local_108,0x100);
  return uVar2;
}



undefined4 FUN_004a10b4(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_108;
  uint local_104;
  
  memset(&local_108,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_108 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_108 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  if ((2 < local_120) && (*(int *)(param_3 + 8) != 0)) {
    if (DAT_00557704 == '\0') {
      local_104 = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 8));
      local_104 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_auth",&local_108,0x100);
  return uVar2;
}



undefined4 FUN_004a12d8(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_108;
  uint local_104;
  
  memset(&local_108,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_108 = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_108 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  if ((2 < local_120) && (*(int *)(param_3 + 8) != 0)) {
    if (DAT_00557704 == '\0') {
      local_104 = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 8));
      local_104 = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_reassoc",&local_108,0x100);
  return uVar2;
}



undefined4 FUN_004a14fc(int *param_1,undefined4 param_2,int param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int local_120;
  uint local_10c [65];
  
  memset(local_10c,0,0x100);
  for (local_120 = 0; *(int *)(param_3 + local_120 * 4) != 0; local_120 = local_120 + 1) {
  }
  if ((1 < local_120) && (*(int *)(param_3 + 4) != 0)) {
    if (DAT_00557704 == '\0') {
      local_10c[0] = atoi(*(char **)(param_3 + 4));
    }
    else {
      uVar1 = atoi(*(char **)(param_3 + 4));
      local_10c[0] = uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18
      ;
    }
  }
  uVar2 = FUN_004ba2e4(param_1,"mfp_bip_test",local_10c,0x100);
  return uVar2;
}



undefined4 FUN_004a1664(int *param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  int local_20;
  undefined1 local_10 [4];
  uint local_c;
  
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if (local_20 == 3) {
    memset(local_10,0,8);
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_10[0] = (undefined1)iVar2;
    if (DAT_00557704 == '\0') {
      local_c = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar3 = atoi(*(char **)(param_3 + 8));
      local_c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    uVar1 = FUN_004ba2e4(param_1,"event_log_set_init",local_10,8);
  }
  else {
    uVar1 = 0xffffffd4;
  }
  return uVar1;
}



undefined4 FUN_004a17d8(int *param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  uint uVar3;
  int local_20;
  undefined1 local_10 [4];
  uint local_c;
  
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if (local_20 == 3) {
    memset(local_10,0,8);
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_10[0] = (undefined1)iVar2;
    if (DAT_00557704 == '\0') {
      local_c = atoi(*(char **)(param_3 + 8));
    }
    else {
      uVar3 = atoi(*(char **)(param_3 + 8));
      local_c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    uVar1 = FUN_004ba2e4(param_1,"event_log_set_expand",local_10,8);
  }
  else {
    uVar1 = 0xffffffd4;
  }
  return uVar1;
}



undefined4 FUN_004a194c(int *param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  int local_20;
  undefined1 local_14 [12];
  
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if (local_20 == 2) {
    memset(local_14,0,8);
    iVar2 = atoi(*(char **)(param_3 + 4));
    local_14[0] = (undefined1)iVar2;
    uVar1 = FUN_004ba2e4(param_1,"event_log_set_shrink",local_14,8);
  }
  else {
    uVar1 = 0xffffffd4;
  }
  return uVar1;
}



undefined4 FUN_004a1a38(int *param_1,undefined4 param_2,int param_3)

{
  byte bVar1;
  undefined4 uVar2;
  int iVar3;
  int *local_res8;
  int local_20;
  ushort local_c;
  undefined1 local_a;
  byte local_9;
  
  bVar1 = 0;
  for (local_20 = 0; *(int *)(param_3 + local_20 * 4) != 0; local_20 = local_20 + 1) {
  }
  if (local_20 < 4) {
    uVar2 = 0xffffffd4;
  }
  else {
    memset(&local_c,0,4);
    if (DAT_00557704 == '\0') {
      iVar3 = atoi(*(char **)(param_3 + 4));
      local_c = (ushort)iVar3;
    }
    else {
      iVar3 = atoi(*(char **)(param_3 + 4));
      local_c = (ushort)iVar3 << 8 | (ushort)iVar3 >> 8;
    }
    local_res8 = (int *)(param_3 + 8);
    iVar3 = atoi((char *)*local_res8);
    local_a = (undefined1)iVar3;
    for (local_res8 = (int *)(param_3 + 0xc); *local_res8 != 0; local_res8 = local_res8 + 1) {
      iVar3 = strcmp((char *)*local_res8,"LOG");
      if (iVar3 == 0) {
        bVar1 = bVar1 | 0x80;
      }
      else {
        iVar3 = strcmp((char *)*local_res8,"PRINT");
        if (iVar3 == 0) {
          bVar1 = bVar1 | 0x40;
        }
        else {
          iVar3 = strcmp((char *)*local_res8,"NONE");
          if (iVar3 != 0) {
            return 0xffffffd4;
          }
        }
      }
    }
    local_9 = bVar1;
    uVar2 = FUN_004ba2e4(param_1,"event_log_tag_control",&local_c,8);
  }
  return uVar2;
}



int FUN_004a1c9c(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  int iVar2;
  uint uVar3;
  uint local_18;
  
  for (local_18 = 0; *(int *)(param_3 + 4 + local_18 * 4) != 0; local_18 = local_18 + 1) {
  }
  if (local_18 < 2) {
    iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (iVar2 == 0) {
      printf("Ver:%d ",(uint)*(ushort *)PTR_DAT_00551644);
      printf("len:%d\n",(uint)*(ushort *)(puVar1 + 2));
      if (*(ushort *)(puVar1 + 2) < 0x21) {
        uVar3 = (uint)*(ushort *)(puVar1 + 2);
      }
      else {
        uVar3 = 0x20;
      }
      FUN_004be9f4("First 32 bytes of data",(int)(puVar1 + 4),uVar3);
      iVar2 = 0;
    }
  }
  else {
    fwrite("Usage: bus:wakeup_data\n",1,0x17,stderr);
    iVar2 = -1;
  }
  return iVar2;
}



int FUN_004a1e70(int *param_1,undefined4 param_2,int param_3)

{
  char *param1;
  char *param1_00;
  int local_18;
  
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("Require dongle image filename \n",1,0x1f,stderr);
    local_18 = -1;
  }
  else {
    param1 = *(char **)(param_3 + 4);
    if (DAT_00557700 != 0) {
      printf("dongle image file is %s\n",param1);
    }
    if (*(int *)(param_3 + 8) == 0) {
      fwrite("vars filename missing, assuming no var file\n",1,0x2c,stderr);
      local_18 = -1;
    }
    else {
      param1_00 = *(char **)(param_3 + 8);
      if (DAT_00557700 != 0) {
        printf("dongle var file is %s\n",param1_00);
      }
      local_18 = FUN_004a200c(param_1,param1,"download");
      printf("ret = %d\n",local_18);
      if (local_18 == 0) {
        local_18 = FUN_004a200c(param_1,param1_00,"nvdownload");
      }
    }
  }
  return local_18;
}



int FUN_004a200c(int *param_1,char *param_2,char *param_3)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  size_t sVar4;
  undefined *puVar5;
  void *local_c8;
  int local_c4;
  void *local_c0;
  size_t local_bc;
  FILE *local_b8;
  size_t local_a8;
  uint local_a4;
  stat sStack_a0;
  
  local_c8 = (void *)0x0;
  local_a8 = 0;
  local_a4 = 0;
  local_b8 = fopen(param_2,"rb");
  if (local_b8 == (FILE *)0x0) {
    perror(param_2);
    local_c4 = -1;
  }
  else {
    iVar1 = stat(param_2,&sStack_a0);
    if (iVar1 == 0) {
      if (sStack_a0.st_blocks < 1) {
        local_c4 = -1;
      }
      else {
        local_c8 = malloc(sStack_a0.st_blocks + 4);
        if (local_c8 == (void *)0x0) {
          printf("dhd_rwl_download: Unable to allowcate %d bytes!\n",local_a8);
          local_c4 = -1;
        }
        else {
          sVar4 = fread(local_c8,1,sStack_a0.st_blocks,local_b8);
          fclose(local_b8);
          local_b8 = (FILE *)0x0;
          if ((int)sVar4 < sStack_a0.st_blocks) {
            printf("dhd_rwl_download: Short read in %s!\n",param_2);
            local_c4 = -1;
          }
          else {
            printf("Starting %s, total file length is %d\n",param_3,sStack_a0.st_blocks);
            iVar1 = FUN_004ba428(param_1,param_3,1);
            if (iVar1 == 0) {
              local_a8 = sStack_a0.st_blocks;
              local_c0 = local_c8;
              for (local_bc = sStack_a0.st_blocks; 0 < (int)local_bc; local_bc = local_bc - local_a8
                  ) {
                putchar(0x2e);
                puVar5 = PTR_DAT_00551644;
                memset(PTR_DAT_00551644,0,0x2000);
                *(undefined4 *)puVar5 = 0x626d656d;
                pcVar3 = puVar5 + 4;
                pcVar3[0] = 'y';
                pcVar3[1] = 't';
                pcVar3[2] = 'e';
                pcVar3[3] = 's';
                puVar5[8] = '\0';
                memcpy(puVar5 + 9,&local_a4,4);
                if ((int)local_bc < 0x1e0) {
                  local_a8 = local_bc;
                }
                else {
                  local_a8 = 0x1e0;
                }
                memcpy(puVar5 + 0xd,&local_a8,4);
                puVar5 = puVar5 + 0x11;
                memcpy(puVar5,local_c0,local_a8);
                sVar4 = local_a8;
                if (DAT_00557700 != 0) {
                  printf("sending %d bytes block: \n",
                         (int)(puVar5 + (local_a8 - (int)PTR_DAT_00551644)));
                }
                local_c4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,
                                        (size_t)(puVar5 + (sVar4 - (int)PTR_DAT_00551644)));
                if (local_c4 != 0) {
                  fprintf(stderr,"%s: error %d on writing %d membytes at 0x%08x\n","wl_set()",
                          local_c4,local_a8,local_a4);
                  goto LAB_004a2490;
                }
                local_a4 = local_a4 + local_a8;
                local_c0 = (void *)((int)local_c0 + local_a8);
              }
              putchar(10);
              local_c4 = FUN_004ba428(param_1,param_3,0);
              if (local_c4 != 0) {
                fwrite("dhd_rwl_download: failed to take dongle out of download mode\n",1,0x3d,
                       stderr);
              }
            }
            else {
              fwrite("dhd_rwl_download: failed to put dongle to download mode\n",1,0x38,stderr);
              local_c4 = -1;
            }
          }
        }
      }
    }
    else {
      piVar2 = __errno_location();
      pcVar3 = strerror(*piVar2);
      printf("dhd_rwl_download: %s: %s\n",param_2,pcVar3);
      local_c4 = -1;
    }
  }
LAB_004a2490:
  if (local_c8 != (void *)0x0) {
    free(local_c8);
  }
  if (local_b8 != (FILE *)0x0) {
    fclose(local_b8);
  }
  return local_c4;
}



int FUN_004a24dc(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  size_t sVar2;
  int iVar3;
  void *pvVar4;
  int local_18;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    fwrite("Error: Missing require chip ID<4325,  4329, 43291, 4330a1, 4330 or hsic>\n",1,0x49,
           stderr);
    local_18 = -0x2c;
  }
  else {
    iVar3 = strcmp((char *)*piVar1,"4325");
    if ((((iVar3 == 0) || (iVar3 = strcmp((char *)*piVar1,"4329"), iVar3 == 0)) ||
        (iVar3 = strcmp((char *)*piVar1,"43291"), iVar3 == 0)) ||
       (((iVar3 = strcmp((char *)*piVar1,"4330"), iVar3 == 0 ||
         (iVar3 = strcmp((char *)*piVar1,"4330a1"), iVar3 == 0)) ||
        (iVar3 = strcmp((char *)*piVar1,"hsic"), iVar3 == 0)))) {
      pvVar4 = (void *)*piVar1;
      sVar2 = strlen((char *)*piVar1);
      local_18 = FUN_004ba160(param_1,"init",pvVar4,sVar2 + 1,PTR_DAT_00551644,0x2000);
      if (local_18 == 0) {
        local_18 = 0;
      }
      else {
        fprintf(stderr,"Error: %s: failed to initialize the dongle \n","dhd_init()");
      }
    }
    else {
      fprintf(stderr,"Error: Unsupported chip ID %s\n",(char *)*piVar1);
      local_18 = -2;
    }
  }
  if (local_18 == 0) {
    iVar3 = strcmp((char *)*piVar1,"4325");
    if (iVar3 == 0) {
      fwrite("4325 is the selected chip id\n",1,0x1d,stdout);
      PTR_DAT_0055616c = &DAT_00522814;
    }
    else {
      iVar3 = strcmp((char *)*piVar1,"4329");
      if (iVar3 == 0) {
        fwrite("4329 is the selected chip id\n",1,0x1d,stdout);
        PTR_DAT_0055616c = &DAT_0052281c;
      }
      else {
        iVar3 = strcmp((char *)*piVar1,"43291");
        if (iVar3 == 0) {
          fwrite("43291 is the selected chip id\n",1,0x1e,stdout);
          PTR_DAT_0055616c = s_43291_00522824;
        }
        else {
          iVar3 = strcmp((char *)*piVar1,"4330");
          if (iVar3 == 0) {
            fwrite("4330b0 is the selected chip id\n",1,0x1f,stdout);
            PTR_DAT_0055616c = s_4330b0_00522920;
          }
          else {
            iVar3 = strcmp((char *)*piVar1,"4330a1");
            if (iVar3 == 0) {
              fwrite("4330a1 is the selected chip id\n",1,0x1f,stdout);
              PTR_DAT_0055616c = s_4330a1_00522834;
            }
            else {
              iVar3 = strcmp((char *)*piVar1,"hsic");
              if (iVar3 == 0) {
                fwrite("hsic interface is selected\n",1,0x1b,stdout);
                PTR_DAT_0055616c = &DAT_0052283c;
              }
              else {
                PTR_DAT_0055616c = &DAT_005142c8;
              }
            }
          }
        }
      }
    }
  }
  return local_18;
}



int FUN_004a2970(int *param_1,undefined4 param_2,int param_3)

{
  char *pcVar1;
  __blkcnt_t param2;
  int iVar2;
  char *pcVar3;
  char *param1;
  size_t sVar4;
  uint uVar5;
  int param1_00;
  undefined *puVar6;
  int local_22bc;
  size_t local_22b8;
  FILE *local_22b4;
  undefined1 *local_22b0;
  uint local_2290;
  uint local_228c;
  stat sStack_2288;
  size_t local_21f0;
  undefined1 auStack_21ec [480];
  undefined1 auStack_200c [8196];
  
  local_2290 = 0;
  local_22b4 = (FILE *)0x0;
  iVar2 = strcmp(PTR_DAT_0055616c,"none");
  if (iVar2 == 0) {
    fwrite("chip init must be called before firmware download. \n",1,0x34,stderr);
    iVar2 = -0x2c;
  }
  else {
    iVar2 = strcmp(PTR_DAT_0055616c,"4325");
    if (iVar2 == 0) {
      fwrite("using 4325 ram_info\n",1,0x14,stdout);
      local_22bc = 0x60000;
    }
    else {
      iVar2 = strcmp(PTR_DAT_0055616c,"4329");
      if (iVar2 == 0) {
        fwrite("using 4329 ram_info\n",1,0x14,stdout);
        local_22bc = 0x48000;
      }
      else {
        iVar2 = strcmp(PTR_DAT_0055616c,"43291");
        if (iVar2 == 0) {
          fwrite("using 43291 ram_info\n",1,0x15,stdout);
          local_22bc = 0x60000;
        }
        else {
          iVar2 = strcmp(PTR_DAT_0055616c,"4330b0");
          if (iVar2 == 0) {
            fwrite("using 4330 b0 ram_info\n",1,0x17,stdout);
            local_22bc = 0x48000;
          }
          else {
            iVar2 = strcmp(PTR_DAT_0055616c,"4330a1");
            if (iVar2 == 0) {
              fwrite("using 4330a1 ram_info\n",1,0x16,stdout);
              local_22bc = 0x3c000;
            }
            else {
              iVar2 = strcmp(PTR_DAT_0055616c,"hsic");
              if (iVar2 != 0) {
                fwrite("Error: unknown chip\n",1,0x14,stderr);
                iVar2 = -0x2c;
                goto LAB_004a359c;
              }
              fwrite("using hsic interface\n",1,0x15,stdout);
            }
          }
        }
      }
    }
    if (*(int *)(param_3 + 4) == 0) {
      fwrite("Require dongle image filename \n",1,0x1f,stderr);
      iVar2 = -0x2c;
    }
    else {
      pcVar3 = *(char **)(param_3 + 4);
      if (DAT_00557700 != 0) {
        printf("dongle image file is %s\n",pcVar3);
      }
      if (*(int *)(param_3 + 8) == 0) {
        fwrite("vars filename missing, assuming no var file\n",1,0x2c,stderr);
        iVar2 = -0x2c;
      }
      else {
        param1 = *(char **)(param_3 + 8);
        if (DAT_00557700 != 0) {
          printf("dongle var file is %s\n",param1);
        }
        iVar2 = strcmp(PTR_DAT_0055616c,"hsic");
        if (iVar2 == 0) {
          iVar2 = FUN_004a3be4(param_1,pcVar3,param1);
          return iVar2;
        }
        local_22b4 = fopen(pcVar3,"rb");
        if (local_22b4 == (FILE *)0x0) {
          perror(pcVar3);
          iVar2 = -2;
        }
        else {
          iVar2 = stat(pcVar3,&sStack_2288);
          param2 = sStack_2288.st_blocks;
          if (iVar2 == 0) {
            if (DAT_00557700 != 0) {
              printf("%s file_size=%d\n",pcVar3,sStack_2288.st_blocks);
            }
            iVar2 = FUN_004ba428(param_1,"download",1);
            if (iVar2 == 0) {
              memset(auStack_21ec,0,0x1e0);
              printf("downloading %s, file_size=%d\n",pcVar3,param2);
              while (local_21f0 = fread(auStack_21ec,1,0x1e0,local_22b4), local_21f0 != 0) {
                if (((int)local_21f0 < 0x1e0) && (iVar2 = feof(local_22b4), iVar2 == 0)) {
                  fprintf(stderr,"%s: error reading file %s\n","fread()",pcVar3);
                  iVar2 = -1;
                  goto LAB_004a359c;
                }
                puVar6 = PTR_DAT_00551644;
                memset(PTR_DAT_00551644,0,0x2000);
                *(undefined4 *)puVar6 = 0x626d656d;
                pcVar1 = puVar6 + 4;
                pcVar1[0] = 'y';
                pcVar1[1] = 't';
                pcVar1[2] = 'e';
                pcVar1[3] = 's';
                puVar6[8] = '\0';
                memcpy(puVar6 + 9,&local_2290,4);
                memcpy(puVar6 + 0xd,&local_21f0,4);
                memcpy(puVar6 + 0x11,auStack_21ec,local_21f0);
                iVar2 = FUN_004baca0(param_1,0x107,PTR_DAT_00551644,
                                     (uint)(puVar6 + 0x11 + (local_21f0 - (int)PTR_DAT_00551644)));
                if (iVar2 != 0) {
                  fprintf(stderr,"%s: error %d on writing %d membytes at 0x%08x\n","wl_set()",iVar2,
                          local_21f0,local_2290);
                  goto LAB_004a359c;
                }
                local_2290 = local_2290 + local_21f0;
                memset(auStack_21ec,0,0x1e0);
              }
              iVar2 = feof(local_22b4);
              if (iVar2 == 0) {
                fprintf(stderr,"%s: error reading file %s\n","feof()",pcVar3);
                iVar2 = -1;
              }
              else {
                fclose(local_22b4);
                if (param1 != (char *)0x0) {
                  local_22b4 = fopen(param1,"rb");
                  if (local_22b4 == (FILE *)0x0) {
                    perror(param1);
                    iVar2 = -2;
                    goto LAB_004a359c;
                  }
                  iVar2 = stat(param1,&sStack_2288);
                  if (iVar2 != 0) {
                    perror(param1);
                    iVar2 = -1;
                    goto LAB_004a359c;
                  }
                  printf("downloading %s, file_size=%d\n",param1,sStack_2288.st_blocks);
                  memset(auStack_200c,0,0x2000);
                  sVar4 = fread(auStack_200c,1,sStack_2288.st_blocks,local_22b4);
                  if (sVar4 != sStack_2288.st_blocks) {
                    perror(pcVar3);
                    iVar2 = -1;
                    goto LAB_004a359c;
                  }
                  fclose(local_22b4);
                  local_22b4 = (FILE *)0x0;
                  uVar5 = FUN_004bf368(auStack_200c,sStack_2288.st_blocks);
                  auStack_200c[uVar5] = 0;
                  iVar2 = uVar5 + 4;
                  if ((int)(uVar5 + 4) < 0) {
                    iVar2 = uVar5 + 7;
                  }
                  param1_00 = (iVar2 >> 2) * 4;
                  local_2290 = (local_22bc + (iVar2 >> 2) * -4) - 4;
                  if (DAT_00557700 != 0) {
                    printf("var_size=%d, start=0x%0X\n",param1_00,local_2290);
                  }
                  iVar2 = param1_00;
                  if (param1_00 < 0) {
                    iVar2 = param1_00 + 3;
                  }
                  local_228c = ~(iVar2 >> 2) << 0x10 | iVar2 >> 2 & 0xffffU;
                  if (DAT_00557700 != 0) {
                    printf("last4bytes=0x%0X\n",local_228c);
                  }
                  memcpy(auStack_200c + param1_00,&local_228c,4);
                  local_22b0 = auStack_200c;
                  for (local_22b8 = param1_00 + 4; puVar6 = PTR_DAT_00551644, 0 < (int)local_22b8;
                      local_22b8 = local_22b8 - local_21f0) {
                    memset(PTR_DAT_00551644,0,0x2000);
                    *(undefined4 *)puVar6 = 0x626d656d;
                    pcVar3 = puVar6 + 4;
                    pcVar3[0] = 'y';
                    pcVar3[1] = 't';
                    pcVar3[2] = 'e';
                    pcVar3[3] = 's';
                    puVar6[8] = '\0';
                    memcpy(puVar6 + 9,&local_2290,4);
                    if ((int)local_22b8 < 0x1e0) {
                      local_21f0 = local_22b8;
                    }
                    else {
                      local_21f0 = 0x1e0;
                    }
                    memcpy(puVar6 + 0xd,&local_21f0,4);
                    puVar6 = puVar6 + 0x11;
                    memcpy(puVar6,local_22b0,local_21f0);
                    sVar4 = local_21f0;
                    if (DAT_00557700 != 0) {
                      printf("sending %d bytes block:\n",
                             (int)(puVar6 + (local_21f0 - (int)PTR_DAT_00551644)));
                    }
                    iVar2 = FUN_004baca0(param_1,0x107,PTR_DAT_00551644,
                                         (uint)(puVar6 + (sVar4 - (int)PTR_DAT_00551644)));
                    if (iVar2 != 0) {
                      fprintf(stderr,"%s: error %d on writing %d membytes at 0x%08x\n","wl_set()",
                              iVar2,local_21f0,local_2290);
                      goto LAB_004a359c;
                    }
                    local_2290 = local_2290 + local_21f0;
                    local_22b0 = local_22b0 + local_21f0;
                  }
                }
                local_22b4 = (FILE *)0x0;
                iVar2 = FUN_004ba428(param_1,"download",0);
                if (iVar2 != 0) {
                  fprintf(stderr,"%s: failed to take dongle out of download mode\n",
                          "dhd_iovar_setint()");
                }
              }
            }
            else {
              fprintf(stderr,"%s: failed to put dongle in download mode\n","dhd_iovar_setint()");
            }
          }
          else {
            perror(pcVar3);
            iVar2 = -1;
          }
        }
      }
    }
  }
LAB_004a359c:
  if (local_22b4 != (FILE *)0x0) {
    fclose(local_22b4);
  }
  return iVar2;
}



int FUN_004a35d0(int *param_1,undefined4 param_2,int param_3)

{
  char *param1;
  char *param1_00;
  int local_18;
  
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("Require dongle image filename \n",1,0x1f,stderr);
    local_18 = -1;
  }
  else {
    param1 = *(char **)(param_3 + 4);
    if (DAT_00557700 != 0) {
      printf("dongle image file is %s\n",param1);
    }
    if (*(int *)(param_3 + 8) == 0) {
      fwrite("vars filename missing, assuming no var file\n",1,0x2c,stderr);
      local_18 = -1;
    }
    else {
      param1_00 = *(char **)(param_3 + 8);
      if (DAT_00557700 != 0) {
        printf("dongle var file is %s\n",param1_00);
      }
      local_18 = FUN_004a3be4(param_1,param1,param1_00);
    }
  }
  return local_18;
}



// WARNING: Removing unreachable block (ram,0x004a3bbc)

int FUN_004a372c(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  char *__filename;
  FILE *__s;
  size_t __n;
  size_t sVar2;
  uint local_30;
  uint local_2c;
  uint local_28;
  int local_20;
  void *local_14;
  uint local_10;
  size_t local_c;
  
  local_30 = 0;
  local_20 = 0;
  iVar1 = strcmp(PTR_DAT_0055616c,"none");
  if (iVar1 == 0) {
    fwrite("chip init must be called before firmware download. \n",1,0x34,stderr);
    local_20 = -0x2c;
  }
  else {
    iVar1 = strcmp(PTR_DAT_0055616c,"4325");
    if (iVar1 == 0) {
      fwrite("using 4325 ram_info\n",1,0x14,stdout);
      local_28 = 0x60000;
    }
    else {
      iVar1 = strcmp(PTR_DAT_0055616c,"4329");
      if (iVar1 == 0) {
        fwrite("using 4329 ram_info\n",1,0x14,stdout);
        local_28 = 0x48000;
      }
      else {
        iVar1 = strcmp(PTR_DAT_0055616c,"43291");
        if (iVar1 == 0) {
          fwrite("using 43291 ram_info\n",1,0x15,stdout);
          local_28 = 0x60000;
        }
        else {
          iVar1 = strcmp(PTR_DAT_0055616c,"4330b0");
          if (iVar1 == 0) {
            fwrite("using 4330 b0 ram_info\n",1,0x17,stdout);
            local_28 = 0x48000;
          }
          else {
            iVar1 = strcmp(PTR_DAT_0055616c,"4330a1");
            if (iVar1 != 0) {
              fwrite("Error: unknown chip\n",1,0x14,stderr);
              return -0x2c;
            }
            fwrite("using 4330 a1 ram_info\n",1,0x17,stdout);
            local_28 = 0x3c000;
          }
        }
      }
    }
    if (DAT_00557700 != 0) {
      printf("argv=%s\n",*(char **)(param_3 + 4));
    }
    __filename = *(char **)(param_3 + 4);
    if (__filename == (char *)0x0) {
      fwrite("filename required\n",1,0x12,stderr);
      local_20 = -2;
    }
    else {
      __s = fopen(__filename,"wb");
      if (__s == (FILE *)0x0) {
        perror(__filename);
        local_20 = -2;
      }
      else {
        for (local_2c = local_28; local_2c != 0; local_2c = local_2c - __n) {
          __n = 0x1e0;
          if (local_2c < 0x1e1) {
            __n = local_2c;
          }
          local_10 = local_30;
          local_c = __n;
          local_20 = FUN_004ba0cc(param_1,"membytes",&local_10,8,(char *)&local_14,0x1e0);
          if (local_20 != 0) {
            fprintf(stderr,"dhd_upload(): failed reading %d membytes from 0x%08x\n",__n,local_30);
            break;
          }
          sVar2 = fwrite(local_14,1,__n,__s);
          if (sVar2 != __n) {
            fprintf(stderr,"dhd_upload(): error writing to file %s\n",__filename);
            local_20 = -1;
            break;
          }
          local_30 = local_30 + __n;
        }
        fclose(__s);
      }
    }
  }
  return local_20;
}



int FUN_004a3be4(int *param_1,char *param_2,char *param_3)

{
  char *pcVar1;
  undefined *puVar2;
  int local_28;
  void *local_24;
  void **local_20;
  void *local_14;
  void **local_10;
  uint local_c;
  
  local_14 = (void *)0x0;
  local_10 = (void **)0x0;
  local_c = 0;
  local_20 = &local_14;
  FUN_004a3f5c(param_2,param_3,local_20);
  if ((int)local_20 < 1) {
    local_28 = -1;
  }
  else {
    printf("Starting download, total file length is %d\n",(int)local_20);
    local_28 = FUN_004ba428(param_1,"download",1);
    if (local_28 == 0) {
      local_24 = local_14;
      local_10 = local_20;
      for (; 0 < (int)local_20; local_20 = (void **)((int)local_20 - (int)local_10)) {
        putchar(0x2e);
        puVar2 = PTR_DAT_00551644;
        memset(PTR_DAT_00551644,0,0x2000);
        *(undefined4 *)puVar2 = 0x626d656d;
        pcVar1 = puVar2 + 4;
        pcVar1[0] = 'y';
        pcVar1[1] = 't';
        pcVar1[2] = 'e';
        pcVar1[3] = 's';
        puVar2[8] = '\0';
        memcpy(puVar2 + 9,&local_c,4);
        if ((int)local_20 < 0x1e0) {
          local_10 = local_20;
        }
        else {
          local_10 = (void **)0x1e0;
        }
        memcpy(puVar2 + 0xd,&local_10,4);
        puVar2 = puVar2 + 0x11;
        memcpy(puVar2,local_24,(size_t)local_10);
        puVar2 = puVar2 + (int)local_10;
        if (DAT_00557700 != 0) {
          printf("sending %d bytes block: \n",(int)puVar2 - (int)PTR_DAT_00551644);
        }
        local_28 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,(int)puVar2 - (int)PTR_DAT_00551644);
        if (local_28 != 0) {
          fprintf(stderr,"%s: error %d on writing %d membytes at 0x%08x\n","wl_set()",local_28,
                  (int)local_10,local_c);
          goto LAB_004a3f24;
        }
        local_c = local_c + (int)local_10;
        local_24 = (void *)((int)local_24 + (int)local_10);
      }
      putchar(10);
      local_28 = FUN_004ba428(param_1,"download",0);
      if (local_28 != 0) {
        fwrite("dhd_hsic_download: failed to take dongle out of download mode\n",1,0x3e,stderr);
      }
    }
    else {
      fwrite("dhd_hsic_download: failed to put dongle to download mode\n",1,0x39,stderr);
    }
  }
LAB_004a3f24:
  if (local_14 != (void *)0x0) {
    free(local_14);
  }
  return local_28;
}



uint FUN_004a3f5c(char *param_1,char *param_2,undefined4 *param_3)

{
  __blkcnt_t __n;
  int iVar1;
  int *piVar2;
  char *pcVar3;
  size_t sVar4;
  FILE *local_d0;
  FILE *local_cc;
  int *local_c8;
  uint local_c4;
  uint local_c0;
  uint uVar5;
  stat sStack_a0;
  
  local_cc = (FILE *)0x0;
  local_c8 = (int *)0x0;
  local_d0 = fopen(param_1,"rb");
  if (local_d0 == (FILE *)0x0) {
    perror(param_1);
    uVar5 = 0xfffffffe;
  }
  else {
    iVar1 = stat(param_1,&sStack_a0);
    __n = sStack_a0.st_blocks;
    if (iVar1 == 0) {
      if (sStack_a0.st_blocks < 0xa00001) {
        local_cc = fopen(param_2,"rb");
        if (local_cc == (FILE *)0x0) {
          perror(param_2);
          uVar5 = 0xfffffffe;
        }
        else {
          iVar1 = stat(param_2,&sStack_a0);
          if (iVar1 == 0) {
            if (sStack_a0.st_blocks < 0x100001) {
              local_c8 = (int *)malloc(__n + sStack_a0.st_blocks + 4);
              if (local_c8 == (int *)0x0) {
                printf("ReadFiles: Unable to allowcate %d bytes!\n",__n + sStack_a0.st_blocks);
                uVar5 = 0xffffffe5;
              }
              else {
                sVar4 = fread(local_c8,1,__n,local_d0);
                fclose(local_d0);
                local_d0 = (FILE *)0x0;
                if ((int)sVar4 < __n) {
                  printf("ReadFiles: Short read in %s!\n",param_1);
                  uVar5 = 0xffffffff;
                }
                else {
                  iVar1 = FUN_004a454c(local_c8);
                  if (iVar1 < 1) {
                    printf("ReadFiles: Failed input file check %s!\n",param_1);
                    uVar5 = 0xffffffff;
                  }
                  else if (__n < iVar1) {
                    printf("ReadFiles: actual_len %d is greater than fwlen %d\n",iVar1,__n);
                    uVar5 = 0xffffffff;
                  }
                  else {
                    sVar4 = fread((void *)((int)local_c8 + iVar1),1,sStack_a0.st_blocks,local_cc);
                    fclose(local_cc);
                    local_cc = (FILE *)0x0;
                    if ((int)sVar4 < sStack_a0.st_blocks) {
                      printf("ReadFiles: Short read in %s!\n",param_2);
                      uVar5 = 0xffffffff;
                    }
                    else {
                      local_c4 = FUN_004bf368((undefined1 *)((int)local_c8 + iVar1),
                                              sStack_a0.st_blocks);
                      if ((int)(iVar1 + local_c4 + 4) < 0xb00001) {
                        if ((local_c4 & 3) != 0) {
                          uVar5 = 4 - (int)local_c4 % 4;
                          for (local_c0 = 0; local_c0 < uVar5; local_c0 = local_c0 + 1) {
                            *(undefined1 *)((int)local_c8 + iVar1 + local_c4 + local_c0) = 0;
                          }
                          local_c4 = local_c4 + uVar5;
                        }
                        local_c8[1] = iVar1 + local_c4;
                        local_c8[6] = local_c4;
                        uVar5 = FUN_004be058((uint *)(local_c8 + 3),(byte *)0x10,0xffffffff);
                        local_c8[2] = uVar5;
                        for (local_c0 = 0x1c; local_c0 < iVar1 + local_c4; local_c0 = local_c0 + 1)
                        {
                          uVar5 = FUN_004be058((uint *)((int)local_c8 + local_c0),(byte *)0x1,
                                               local_c8[2]);
                          local_c8[2] = uVar5;
                        }
                        local_c8[2] = local_c8[2];
                        *param_3 = local_c8;
                        return 0xffffffff;
                      }
                      puts("ReadFiles: actual_len + nvlen + 4 is greater than 11M");
                      uVar5 = 0xffffffff;
                    }
                  }
                }
              }
            }
            else {
              printf("ReadFile: %s nvram file too large\n",param_2);
              uVar5 = 0xffffffff;
            }
          }
          else {
            piVar2 = __errno_location();
            pcVar3 = strerror(*piVar2);
            printf("ReadFiles: %s: %s\n",param_2,pcVar3);
            uVar5 = 0xffffffff;
          }
        }
      }
      else {
        printf("ReadFile: %s firmware file too large\n",param_1);
        uVar5 = 0xffffffff;
      }
    }
    else {
      piVar2 = __errno_location();
      pcVar3 = strerror(*piVar2);
      printf("ReadFile: %s: %s\n",param_1,pcVar3);
      uVar5 = 0xffffffff;
    }
  }
  if (local_c8 != (int *)0x0) {
    free(local_c8);
  }
  if (local_d0 != (FILE *)0x0) {
    fclose(local_d0);
  }
  if (local_cc != (FILE *)0x0) {
    fclose(local_cc);
  }
  return uVar5;
}



int FUN_004a454c(int *param_1)

{
  int iVar1;
  
  if (*param_1 == 0x30524448) {
    if ((param_1[3] & 0x20U) == 0) {
      iVar1 = -1;
    }
    else {
      iVar1 = param_1[4] + 0x1c;
    }
  }
  else {
    printf("check_file: Error: trx bad hdr %x!\n",*param_1);
    iVar1 = -1;
  }
  return iVar1;
}



int FUN_004a45fc(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  int *local_res8;
  int local_30;
  int *local_20;
  int local_1c [5];
  
  local_20 = (int *)0x0;
  local_1c[0] = -1;
  local_1c[1] = 0xffffffff;
  local_1c[2] = 0xffffffff;
  local_1c[3] = 0xffffffff;
  local_1c[4] = 0xffffffff;
  if (*(int *)(param_3 + 4) == 0) {
    bVar1 = true;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,local_1c,0x14,&local_20);
    piVar2 = local_20;
    if (-1 < iVar3) {
      for (local_30 = 1; local_30 < 5; local_30 = local_30 + 1) {
        if (local_20[local_30 + -1] != local_20[local_30]) {
          bVar1 = false;
        }
      }
      if (bVar1) {
        printf("%2d\n",*local_20);
      }
      else {
        printf("2.4GHz       : %2d\n",*local_20);
        printf("5GHz (lower) : %2d\n",piVar2[1]);
        printf("5GHz (middle): %2d\n",piVar2[2]);
        printf("5GHz (high)  : %2d\n",piVar2[3]);
        printf("5GHz (upper) : %2d\n",piVar2[4]);
      }
      iVar3 = 0;
    }
  }
  else {
    local_1c[0] = atoi(*(char **)(param_3 + 4));
    local_res8 = (int *)(param_3 + 8);
    if (*local_res8 == 0) {
      for (local_30 = 1; local_30 < 5; local_30 = local_30 + 1) {
        local_1c[local_30] = local_1c[0];
      }
    }
    else {
      for (local_30 = 1; local_30 < 5; local_30 = local_30 + 1) {
        iVar3 = atoi((char *)*local_res8);
        local_1c[local_30] = iVar3;
        local_res8 = local_res8 + 1;
        if ((*local_res8 == 0) && (local_30 < 4)) {
          puts("error: missing arguments");
          return -0x2c;
        }
      }
    }
    iVar3 = FUN_00445444(param_1,(char *)*param_2,local_1c,0x14);
  }
  return iVar3;
}



int FUN_004a4958(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int iVar2;
  char *param1;
  int local_48;
  int local_3c;
  int local_38;
  int local_34;
  
  local_3c = 0;
  memset(&local_38,0,0x30);
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,(char *)*param_2,&local_38,0x30,&local_3c);
    iVar1 = local_3c;
    if (-1 < iVar2) {
      for (local_48 = 0; local_48 < 0xc; local_48 = local_48 + 1) {
        if ((*(uint *)(iVar1 + local_48 * 4) & 0x80) == 0) {
          param1 = "CCK ";
        }
        else {
          param1 = "OFDM";
        }
        printf("%s: %2d\n",param1,*(uint *)(iVar1 + local_48 * 4) & 0x7f);
      }
      iVar2 = 0;
    }
  }
  else {
    local_38 = atoi(*(char **)(param_3 + 4));
    local_34 = atoi(*(char **)(param_3 + 8));
    iVar2 = FUN_00445444(param_1,(char *)*param_2,&local_38,0x30);
  }
  return iVar2;
}



int FUN_004a4b24(int *param_1,undefined4 *param_2)

{
  int iVar1;
  int local_20;
  int *local_1c;
  int *local_10 [2];
  
  iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
  if (-1 < iVar1) {
    local_1c = local_10[0] + 1;
    printf("%-8s %8s %8s %8s %8s %8s\n","Name","SZ","Max","Curr","HiWater","Failed");
    for (local_20 = 0; local_20 < *local_10[0]; local_20 = local_20 + 1) {
      printf("%-8s %8d %8d %8d %8d %8d\n",(char *)local_1c,local_1c[2],
             (uint)*(ushort *)(local_1c + 3),(uint)*(ushort *)((int)local_1c + 0xe),
             (uint)*(ushort *)(local_1c + 4),(uint)*(ushort *)((int)local_1c + 0x12));
      local_1c = local_1c + 5;
    }
    iVar1 = 0;
  }
  return iVar1;
}



int FUN_004a4c98(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  byte bVar1;
  undefined1 uVar2;
  byte bVar3;
  char cVar4;
  int iVar5;
  uint uVar6;
  size_t sVar7;
  undefined1 *__ptr;
  undefined4 *local_res8;
  int local_38;
  byte *local_34;
  byte local_30;
  byte local_2f;
  byte *local_24;
  uint local_20;
  int local_1c;
  undefined4 local_18;
  undefined1 auStack_14 [4];
  undefined1 local_10;
  
  local_20 = 0;
  local_1c = 0;
  local_38 = FUN_004024e8(param_3 + 1,*param_3,&local_20,&local_1c);
  if (local_38 == 0) {
    if (local_1c == 0) {
      local_20 = 0xffffffff;
      local_res8 = param_3;
    }
    else {
      local_res8 = param_3 + local_1c;
    }
    if (local_res8[1] == 0) {
      fwrite("missing parameter type\n",1,0x17,stderr);
      local_38 = -0x2c;
    }
    else {
      iVar5 = atoi((char *)local_res8[1]);
      uVar2 = (undefined1)iVar5;
      if (local_res8[2] == 0) {
        local_24 = PTR_DAT_00551644;
        local_10 = uVar2;
        if (local_20 == 0xffffffff) {
          local_38 = FUN_00445198(param_1,(char *)*param_2,auStack_14,5,&local_24);
        }
        else {
          local_38 = FUN_004457f4(param_1,(char *)*param_2,local_20,auStack_14,5,PTR_DAT_00551644,
                                  0x2000);
        }
        if (local_38 == 0) {
          local_34 = local_24;
          bVar3 = local_24[1] + 2;
          printf("%s len %d\n",(char *)*param_2,(uint)bVar3);
          printf("%s Data:\n",(char *)*param_2);
          local_30 = 0;
          while (local_30 < bVar3) {
            local_2f = 0;
            for (; (local_2f < 0x10 && (local_30 < bVar3)); local_30 = local_30 + 1) {
              bVar1 = *local_34;
              local_34 = local_34 + 1;
              printf("%02x",(uint)bVar1);
              local_2f = local_2f + 1;
            }
            putchar(10);
          }
        }
        else {
          fprintf(stderr,"Error %d getting IOVar\n",local_38);
        }
      }
      else {
        uVar6 = atoi((char *)local_res8[2]);
        cVar4 = (char)uVar6;
        if (cVar4 != '\0') {
          if (local_res8[3] == 0) {
            fprintf(stderr,"Data bytes should be specified for IE of length %d\n",uVar6 & 0xff);
            return -0x2c;
          }
          sVar7 = strlen((char *)local_res8[3]);
          if ((int)sVar7 < (int)((uVar6 & 0xff) << 1)) {
            fwrite("Please specify all the data bytes for this IE\n",1,0x2e,stderr);
            return -2;
          }
        }
        if ((cVar4 == '\0') && (local_res8[3] != 0)) {
          fprintf(stderr,"Ignoring data bytes for IE of length %d\n",uVar6 & 0xff);
        }
        bVar3 = cVar4 + 0xe;
        __ptr = (undefined1 *)malloc((uint)bVar3);
        if (__ptr == (undefined1 *)0x0) {
          fwrite("memory alloc failure\n",1,0x15,stderr);
          local_38 = -0x1b;
        }
        else {
          *__ptr = 0x61;
          __ptr[1] = 100;
          __ptr[2] = 100;
          __ptr[3] = 0;
          if (DAT_00557704 == '\0') {
            local_18 = 1;
          }
          else {
            local_18 = 0x1000000;
          }
          memcpy(__ptr + 4,&local_18,4);
          __ptr[0xc] = uVar2;
          __ptr[0xd] = cVar4;
          if ((cVar4 == '\0') ||
             (local_38 = FUN_00459628((char *)local_res8[3],__ptr + 0xe,uVar6 & 0xff), local_38 == 0
             )) {
            if (local_20 == 0xffffffff) {
              local_38 = FUN_00445444(param_1,(char *)*param_2,__ptr,(uint)bVar3);
            }
            else {
              local_38 = FUN_00445758(param_1,(char *)*param_2,local_20,__ptr,(uint)bVar3,
                                      PTR_DAT_00551644,0x2000);
            }
            free(__ptr);
          }
          else {
            free(__ptr);
            fwrite("Error parsing data arg\n",1,0x17,stderr);
          }
        }
      }
    }
  }
  return local_38;
}



int FUN_004a52e0(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  char cVar2;
  int iVar3;
  uint uVar4;
  size_t sVar5;
  char *__ptr;
  byte *local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (iVar3 == 0) {
      bVar1 = *local_10[0];
      (local_10[0] + 1)[bVar1] = 0;
      printf("%s URL len %d\n",(char *)*param_2,(uint)bVar1);
      printf("%s URL: %s\n",(char *)*param_2,(char *)(local_10[0] + 1));
      return 0;
    }
    fprintf(stderr,"Error %d getting IOVar\n",iVar3);
    return iVar3;
  }
  uVar4 = atoi(*(char **)(param_3 + 4));
  cVar2 = (char)uVar4;
  if (cVar2 != '\0') {
    if (*(int *)(param_3 + 8) == 0) {
      fprintf(stderr,"URL string should be specified for URL length %d\n",uVar4 & 0xff);
      return -2;
    }
    sVar5 = strlen(*(char **)(param_3 + 8));
    if (sVar5 != (uVar4 & 0xff)) {
      fwrite("length is not matching to string\n",1,0x21,stderr);
      return -2;
    }
  }
  if ((cVar2 == '\0') && (*(int *)(param_3 + 8) != 0)) {
    fprintf(stderr,"Ignoring data bytes for length %d\n",uVar4 & 0xff);
  }
  __ptr = (char *)malloc((uint)(byte)(cVar2 + 1U));
  if (__ptr == (char *)0x0) {
    fwrite("memory alloc failure\n",1,0x15,stderr);
    iVar3 = -0x1b;
  }
  else {
    *__ptr = cVar2;
    if (cVar2 != '\0') {
      memcpy(__ptr + 1,*(void **)(param_3 + 8),uVar4 & 0xff);
    }
    iVar3 = FUN_00445444(param_1,(char *)*param_2,__ptr,(uint)(byte)(cVar2 + 1U));
    free(__ptr);
  }
  return iVar3;
}



int FUN_004a55f0(int *param_1,undefined4 *param_2,int param_3)

{
  byte *pbVar1;
  bool bVar2;
  undefined3 extraout_var;
  int iVar3;
  char *pcVar4;
  undefined1 *local_30;
  int local_2c;
  int local_28;
  undefined1 auStack_1c [4];
  undefined1 auStack_18 [12];
  byte *local_c;
  
  for (local_28 = 0; *(int *)(param_3 + local_28 * 4) != 0; local_28 = local_28 + 1) {
  }
  if (local_28 == 4) {
    local_30 = auStack_18;
    for (local_2c = 1; local_2c < 4; local_2c = local_2c + 1) {
      bVar2 = FUN_0041d840(*(char **)(param_3 + local_2c * 4),(int)auStack_1c);
      if (CONCAT31(extraout_var,bVar2) == 0) {
        return -0x2c;
      }
      memcpy(local_30,auStack_1c,4);
      local_30 = local_30 + 4;
    }
    iVar3 = FUN_00445444(param_1,(char *)*param_2,auStack_18,0xc);
  }
  else {
    local_c = (byte *)0x0;
    iVar3 = FUN_00445198(param_1,(char *)*param_2,auStack_18,0xc,&local_c);
    pbVar1 = local_c;
    if (-1 < iVar3) {
      pcVar4 = FUN_0041e064(local_c);
      printf("ip: %s ",pcVar4);
      pcVar4 = FUN_0041e064(pbVar1 + 4);
      printf("netmask: %s ",pcVar4);
      pcVar4 = FUN_0041e064(pbVar1 + 8);
      printf("gw: %s\n",pcVar4);
      iVar3 = 0;
    }
  }
  return iVar3;
}



int FUN_004a57f8(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  ulong uVar5;
  ushort uVar6;
  ushort uVar7;
  ushort uVar8;
  ushort uVar9;
  ushort uVar10;
  ushort uVar11;
  ushort uVar12;
  ushort uVar13;
  ushort uVar14;
  ushort uVar15;
  ushort uVar16;
  ushort uVar17;
  uint local_68;
  int local_64;
  char *local_34;
  ushort auStack_30 [16];
  
  local_34 = (char *)0x0;
  for (local_68 = 0; *(int *)(param_3 + 4 + local_68 * 4) != 0; local_68 = local_68 + 1) {
  }
  memset(auStack_30,0,0x1e);
  if (local_68 == 0) {
    iVar4 = FUN_004ba0cc(param_1,"wci2_config",auStack_30,0x1e,PTR_DAT_00551644,0x100);
    if (iVar4 == 0) {
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar1 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2);
      }
      else {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 | *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4);
      }
      else {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4) << 8 | *(ushort *)(PTR_DAT_00551644 + 4) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = *(ushort *)(PTR_DAT_00551644 + 6);
      }
      else {
        uVar6 = *(ushort *)(PTR_DAT_00551644 + 6) << 8 | *(ushort *)(PTR_DAT_00551644 + 6) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar7 = *(ushort *)(PTR_DAT_00551644 + 8);
      }
      else {
        uVar7 = *(ushort *)(PTR_DAT_00551644 + 8) << 8 | *(ushort *)(PTR_DAT_00551644 + 8) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar8 = *(ushort *)(PTR_DAT_00551644 + 10);
      }
      else {
        uVar8 = *(ushort *)(PTR_DAT_00551644 + 10) << 8 | *(ushort *)(PTR_DAT_00551644 + 10) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar9 = *(ushort *)(PTR_DAT_00551644 + 0xc);
      }
      else {
        uVar9 = *(ushort *)(PTR_DAT_00551644 + 0xc) << 8 | *(ushort *)(PTR_DAT_00551644 + 0xc) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar10 = *(ushort *)(PTR_DAT_00551644 + 0xe);
      }
      else {
        uVar10 = *(ushort *)(PTR_DAT_00551644 + 0xe) << 8 | *(ushort *)(PTR_DAT_00551644 + 0xe) >> 8
        ;
      }
      if (DAT_00557704 == '\0') {
        uVar11 = *(ushort *)(PTR_DAT_00551644 + 0x10);
      }
      else {
        uVar11 = *(ushort *)(PTR_DAT_00551644 + 0x10) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x10) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar12 = *(ushort *)(PTR_DAT_00551644 + 0x12);
      }
      else {
        uVar12 = *(ushort *)(PTR_DAT_00551644 + 0x12) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x12) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar13 = *(ushort *)(PTR_DAT_00551644 + 0x14);
      }
      else {
        uVar13 = *(ushort *)(PTR_DAT_00551644 + 0x14) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x14) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar14 = *(ushort *)(PTR_DAT_00551644 + 0x16);
      }
      else {
        uVar14 = *(ushort *)(PTR_DAT_00551644 + 0x16) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x16) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar15 = *(ushort *)(PTR_DAT_00551644 + 0x18);
      }
      else {
        uVar15 = *(ushort *)(PTR_DAT_00551644 + 0x18) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x18) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar16 = *(ushort *)(PTR_DAT_00551644 + 0x1a);
      }
      else {
        uVar16 = *(ushort *)(PTR_DAT_00551644 + 0x1a) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x1a) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar17 = *(ushort *)(PTR_DAT_00551644 + 0x1c);
      }
      else {
        uVar17 = *(ushort *)(PTR_DAT_00551644 + 0x1c) << 8 |
                 *(ushort *)(PTR_DAT_00551644 + 0x1c) >> 8;
      }
      printf("rxassert_off %d rxassert_jit %d rxdeassert_off %d rxdeassert_jit %d txassert_off %d txassert_jit %d txdeassert_off %d txdeassert_jit %d patassert_off %d patassert_jit %d inactassert_off %d inactassert_jit %d scanfreqassert_off %d scanfreqassert_jit %d priassert_off_req %d\n"
             ,(uint)uVar1,(uint)uVar2,(uint)uVar3,(uint)uVar6,(uint)uVar7,(uint)uVar8,(uint)uVar9,
             (uint)uVar10,(uint)uVar11,(uint)uVar12,(uint)uVar13,(uint)uVar14,(uint)uVar15,
             (uint)uVar16,(uint)uVar17);
      iVar4 = 0;
    }
  }
  else if (local_68 < 0xf) {
LAB_004a6060:
    iVar4 = -0x2c;
  }
  else {
    for (local_64 = 0; local_64 < 0xf; local_64 = local_64 + 1) {
      uVar5 = strtoul(*(char **)(param_3 + 4 + local_64 * 4),&local_34,0);
      if (*local_34 != '\0') goto LAB_004a6060;
      uVar1 = (ushort)uVar5;
      if (DAT_00557704 != '\0') {
        uVar1 = uVar1 << 8 | uVar1 >> 8;
      }
      auStack_30[local_64] = uVar1;
    }
    iVar4 = FUN_004ba160(param_1,"wci2_config",auStack_30,0x1e,PTR_DAT_00551644,0x100);
  }
  return iVar4;
}



int FUN_004a6084(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  ulong uVar5;
  ushort uVar6;
  uint local_38;
  int local_34;
  char *local_18;
  ushort auStack_14 [4];
  undefined1 local_c;
  undefined1 local_b;
  
  local_18 = (char *)0x0;
  iVar4 = param_3 + 4;
  for (local_38 = 0; *(int *)(iVar4 + local_38 * 4) != 0; local_38 = local_38 + 1) {
  }
  memset(auStack_14,0,10);
  if (local_38 == 0) {
    iVar4 = FUN_004ba0cc(param_1,"mws_params",auStack_14,10,PTR_DAT_00551644,0x100);
    if (iVar4 == 0) {
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar1 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2);
      }
      else {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 | *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4);
      }
      else {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4) << 8 | *(ushort *)(PTR_DAT_00551644 + 4) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar6 = *(ushort *)(PTR_DAT_00551644 + 6);
      }
      else {
        uVar6 = *(ushort *)(PTR_DAT_00551644 + 6) << 8 | *(ushort *)(PTR_DAT_00551644 + 6) >> 8;
      }
      printf("rx_center_freq %d tx_center_freq %d  rx_channel_bw %d tx_channel_bw %d channel_en %d channel_type %d\n"
             ,(uint)uVar1,(uint)uVar2,(uint)uVar3,(uint)uVar6,(int)(char)PTR_DAT_00551644[8],
             (int)(char)PTR_DAT_00551644[9]);
      iVar4 = 0;
    }
  }
  else {
    if (5 < local_38) {
      for (local_34 = 0; local_34 < 4; local_34 = local_34 + 1) {
        uVar5 = strtoul(*(char **)(iVar4 + local_34 * 4),&local_18,0);
        if (*local_18 != '\0') goto LAB_004a6528;
        uVar1 = (ushort)uVar5;
        if (DAT_00557704 != '\0') {
          uVar1 = uVar1 << 8 | uVar1 >> 8;
        }
        auStack_14[local_34] = uVar1;
      }
      uVar5 = strtoul(*(char **)(iVar4 + local_34 * 4),&local_18,0);
      if (*local_18 == '\0') {
        local_c = (undefined1)uVar5;
        uVar5 = strtoul(*(char **)(iVar4 + (local_34 + 1) * 4),&local_18,0);
        if (*local_18 == '\0') {
          local_b = (undefined1)uVar5;
          iVar4 = FUN_004ba160(param_1,"mws_params",auStack_14,10,PTR_DAT_00551644,0x100);
          return iVar4;
        }
      }
    }
LAB_004a6528:
    iVar4 = -0x2c;
  }
  return iVar4;
}



int FUN_004a6544(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int iVar4;
  ulong uVar5;
  uint local_30;
  int local_2c;
  char *local_14;
  ushort auStack_10 [4];
  
  local_14 = (char *)0x0;
  for (local_30 = 0; *(int *)(param_3 + 4 + local_30 * 4) != 0; local_30 = local_30 + 1) {
  }
  memset(auStack_10,0,6);
  if (local_30 == 0) {
    iVar4 = FUN_004ba0cc(param_1,"mws_debug_msg",auStack_10,6,PTR_DAT_00551644,0x100);
    if (iVar4 == 0) {
      if (DAT_00557704 == '\0') {
        uVar1 = *(ushort *)PTR_DAT_00551644;
      }
      else {
        uVar1 = *(ushort *)PTR_DAT_00551644 << 8 | *(ushort *)PTR_DAT_00551644 >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2);
      }
      else {
        uVar2 = *(ushort *)(PTR_DAT_00551644 + 2) << 8 | *(ushort *)(PTR_DAT_00551644 + 2) >> 8;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4);
      }
      else {
        uVar3 = *(ushort *)(PTR_DAT_00551644 + 4) << 8 | *(ushort *)(PTR_DAT_00551644 + 4) >> 8;
      }
      printf("Message %d Interval %d  Repeats %d \n",(uint)uVar1,(uint)uVar2,(uint)uVar3);
      iVar4 = 0;
    }
  }
  else {
    if (2 < local_30) {
      for (local_2c = 0; local_2c < 3; local_2c = local_2c + 1) {
        uVar5 = strtoul(*(char **)(param_3 + 4 + local_2c * 4),&local_14,0);
        if (*local_14 != '\0') goto LAB_004a68d0;
        uVar1 = (ushort)uVar5;
        if (DAT_00557704 != '\0') {
          uVar1 = uVar1 << 8 | uVar1 >> 8;
        }
        auStack_10[local_2c] = uVar1;
      }
      if ((0x13 < auStack_10[1]) && (auStack_10[1] < 0x7d01)) {
        iVar4 = FUN_004ba160(param_1,"mws_debug_msg",auStack_10,6,PTR_DAT_00551644,0x100);
        return iVar4;
      }
    }
LAB_004a68d0:
    iVar4 = -0x2c;
  }
  return iVar4;
}



int FUN_004a68ec(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  ulong uVar2;
  char *local_40;
  char *local_2c;
  char local_28 [2];
  undefined2 local_26;
  undefined2 local_24;
  undefined2 local_22;
  undefined2 local_20;
  undefined2 local_1e;
  ulong local_1c;
  ulong local_18;
  ulong local_14;
  byte *local_10 [2];
  
  local_2c = (char *)0x0;
  iVar1 = FUN_0040192c(param_3 + 4);
  if (iVar1 == 0) {
    iVar1 = FUN_00445360(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*local_10[0] == 0) {
      local_40 = "DISABLED";
    }
    else if (*local_10[0] == 1) {
      local_40 = "OR";
    }
    else if (*local_10[0] == 2) {
      local_40 = "AND";
    }
    else {
      local_40 = "ERROR";
    }
    printf("logic: %d (%s)\n",(uint)*local_10[0],local_40);
    if (*local_10[0] != 0) {
      printf("low_ms: %d\n",(uint)*(ushort *)(local_10[0] + 2));
      printf("high_ms: %d\n",(uint)*(ushort *)(local_10[0] + 4));
      printf("rx_pkts_threshold: %d\n",(uint)*(ushort *)(local_10[0] + 6));
      printf("tx_pkts_threshold: %d\n",(uint)*(ushort *)(local_10[0] + 8));
      printf("txrx_pkts_threshold: %d\n",(uint)*(ushort *)(local_10[0] + 10));
      printf("rx_bytes_threshold: %d\n",*(int *)(local_10[0] + 0xc));
      printf("tx_bytes_threshold: %d\n",*(int *)(local_10[0] + 0x10));
      printf("txrx_bytes_threshold: %d\n",*(int *)(local_10[0] + 0x14));
    }
    return 0;
  }
  memset(local_28,0,0x18);
  uVar2 = strtoul(*(char **)(param_3 + 4),&local_2c,0);
  if (*local_2c == '\0') {
    if (((uVar2 == 0) || (uVar2 == 1)) || (uVar2 == 2)) {
      local_28[0] = (char)uVar2;
      if (local_28[0] == '\0') {
LAB_004a6ebc:
        iVar1 = FUN_00445444(param_1,(char *)*param_2,local_28,0x18);
        return iVar1;
      }
      if ((8 < iVar1) && (uVar2 = strtoul(*(char **)(param_3 + 8),&local_2c,0), *local_2c == '\0'))
      {
        local_26 = (undefined2)uVar2;
        uVar2 = strtoul(*(char **)(param_3 + 0xc),&local_2c,0);
        if (*local_2c == '\0') {
          local_24 = (undefined2)uVar2;
          uVar2 = strtoul(*(char **)(param_3 + 0x10),&local_2c,0);
          if (*local_2c == '\0') {
            local_22 = (undefined2)uVar2;
            uVar2 = strtoul(*(char **)(param_3 + 0x14),&local_2c,0);
            if (*local_2c == '\0') {
              local_20 = (undefined2)uVar2;
              uVar2 = strtoul(*(char **)(param_3 + 0x18),&local_2c,0);
              if (*local_2c == '\0') {
                local_1e = (undefined2)uVar2;
                uVar2 = strtoul(*(char **)(param_3 + 0x1c),&local_2c,0);
                if (((*local_2c == '\0') &&
                    (local_1c = uVar2, uVar2 = strtoul(*(char **)(param_3 + 0x20),&local_2c,0),
                    *local_2c == '\0')) &&
                   ((local_18 = uVar2, uVar2 = strtoul(*(char **)(param_3 + 0x24),&local_2c,0),
                    *local_2c == '\0' && (local_14 = uVar2, iVar1 == 9)))) goto LAB_004a6ebc;
              }
            }
          }
        }
      }
    }
    else {
      printf("Invalid logic value %u\n",uVar2);
    }
  }
  printf("Usage: %s [logic] [<low_ms> <high_ms> <rxP> <txP> <txrxP> <rxB> <txB> <txrxB>\n",
         DAT_00557690);
  puts("Parameters:");
  puts("logic   : 0=disable, 1=OR, 2=AND all non-zero switching thresholds.");
  puts("low_ms  : Low pm2_sleep_ret value.");
  puts("high_ms : High pm2_sleep_ret value.");
  puts("rxP     : Switching threshold in # of rx packets.");
  puts("          eg. Switch from the low to high FRTS value if rxP or");
  puts("          more packets are received in a PM2 radio wake period.");
  puts("          0 means ignore this threshold.");
  puts("txP     : Switching threshold in # of tx packets.");
  puts("txrxP   : Switching threshold in # of combined tx+rx packets.");
  puts("rxB     : Switching threshold in # of rx bytes.");
  puts("txB     : Switching threshold in # of tx bytes.");
  puts("txrxB   : Switching threshold in # of combined tx+rx bytes.");
  return -1;
}



int FUN_004a706c(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int *piVar2;
  char *param1;
  int iVar3;
  undefined3 extraout_var;
  int local_18;
  char local_14 [12];
  
  local_18 = 0;
  memset(local_14,0,0xc);
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    local_18 = FUN_004ba1f8(param_1,(char *)*param_2,local_14,0xc);
    if (local_18 == 0) {
      param1 = FUN_0041d780((int)(local_14 + 4));
      printf("%s \n",param1);
    }
  }
  else {
    iVar3 = strcasecmp((char *)*piVar2,"add");
    if (iVar3 == 0) {
      local_14[0] = '\x01';
      local_14[1] = '\0';
      local_14[2] = '\0';
      local_14[3] = '\0';
    }
    else {
      iVar3 = strcasecmp((char *)*piVar2,"del");
      if (iVar3 == 0) {
        local_14[0] = '\0';
        local_14[1] = '\0';
        local_14[2] = '\0';
        local_14[3] = '\0';
      }
      else {
        printf("error: unknown operation option%s\n",(char *)*piVar2);
        local_18 = -1;
      }
    }
    if (local_18 == 0) {
      if ((*(int *)(param_3 + 8) == 0) ||
         (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 8),local_14 + 4),
         CONCAT31(extraout_var,bVar1) == 0)) {
        puts(" ERROR: no valid ether addr provided");
        local_18 = -1;
      }
      else {
        local_18 = FUN_004ba2e4(param_1,(char *)*param_2,local_14,0xc);
      }
    }
  }
  return local_18;
}



int FUN_004a7260(int *param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  int *local_res8;
  int local_38;
  ulong local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  char *local_24;
  uint local_10;
  char *local_c;
  
  local_30 = 0;
  local_10 = 0;
  local_2c = 0;
  local_28 = 0;
  iVar1 = FUN_004ba35c(param_1,"monitor_promisc_level",&local_10);
  iVar1 = -(iVar1 >> 0x1f);
  if (iVar1 == 0) {
    if (DAT_00557704 != '\0') {
      local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                 local_10 >> 0x18;
    }
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      printf("0x%x ",local_10);
      for (local_38 = 0; uVar2 = *(uint *)(&DAT_00556170 + local_38 * 8), uVar2 != 0;
          local_38 = local_38 + 1) {
        if (((local_10 & uVar2) != 0) && (uVar2 != local_30)) {
          printf(" %s",(&PTR_s_promisc_00556174)[local_38 * 2]);
        }
        local_30 = uVar2;
      }
      putchar(10);
      iVar1 = 0;
    }
    else {
      for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
        local_24 = (char *)*local_res8;
        if ((*local_24 == '+') || (*local_24 == '-')) {
          local_24 = local_24 + 1;
        }
        else {
          local_28 = 0xffffffff;
        }
        local_34 = strtoul(local_24,&local_c,0);
        if (local_34 == 0xffffffff) {
          fwrite("Bits >32 are not supported on this driver version\n",1,0x32,stderr);
          local_34 = 1;
        }
        if (*local_c != '\0') {
          local_38 = 0;
          while ((local_34 = *(ulong *)(&DAT_00556170 + local_38 * 8), local_34 != 0 &&
                 (iVar1 = strcasecmp((&PTR_s_promisc_00556174)[local_38 * 2],local_24), iVar1 != 0))
                ) {
            if (local_34 == 0) {
              fwrite("msg values may be a list of numbers or names from the following set.\n",1,0x45
                     ,stderr);
              fwrite("Use a + or - prefix to make an incremental change.",1,0x32,stderr);
              for (local_38 = 0; uVar2 = *(uint *)(&DAT_00556170 + local_38 * 8), uVar2 != 0;
                  local_38 = local_38 + 1) {
                if (uVar2 == local_30) {
                  fprintf(stderr,", %s",(&PTR_s_promisc_00556174)[local_38 * 2]);
                }
                else {
                  fprintf(stderr,"\n0x%04x %s",uVar2,(&PTR_s_promisc_00556174)[local_38 * 2]);
                }
                local_30 = uVar2;
              }
              fputc(10,stderr);
              return 0;
            }
            local_38 = local_38 + 1;
          }
        }
        if (*(char *)*local_res8 == '-') {
          local_28 = local_28 | local_34;
        }
        else {
          local_2c = local_2c | local_34;
        }
      }
      local_10 = ~local_28 & local_10 | local_2c;
      if (DAT_00557704 != '\0') {
        local_10 = local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
                   local_10 >> 0x18;
      }
      iVar1 = FUN_004ba428(param_1,"monitor_promisc_level",local_10);
    }
  }
  return iVar1;
}



int FUN_004a77bc(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  undefined3 extraout_var;
  size_t sVar3;
  int iVar4;
  int *piVar5;
  ulong uVar6;
  char *pcVar7;
  int *local_res8;
  int local_24;
  uint local_20;
  char *local_1c;
  
  puVar1 = PTR_DAT_00551644;
  PTR_DAT_00551644[0x14] = 0;
  *(undefined2 *)(puVar1 + 6) = 1;
  local_res8 = (int *)(param_3 + 4);
  if ((((*local_res8 == 0) ||
       (bVar2 = FUN_0041d6ac((char *)*local_res8,puVar1), CONCAT31(extraout_var,bVar2) == 0)) ||
      (sVar3 = strlen((char *)*local_res8), sVar3 != 0x11)) || (*(char *)(*local_res8 + 2) != ':'))
  {
    local_24 = 0;
    local_20 = 0x1fe8;
    *(undefined4 *)puVar1 = 0xffffffff;
    *(undefined2 *)(puVar1 + 4) = 0xffff;
    for (; (*local_res8 != 0 && (local_20 != 0)); local_20 = local_20 - 1) {
      local_1c = (char *)*local_res8;
      for (; (*local_1c != '\0' && (1 < local_20)); local_20 = local_20 - 1) {
        puVar1[local_24 + 0x14] = *local_1c;
        local_24 = local_24 + 1;
        local_1c = local_1c + 1;
      }
      puVar1[local_24 + 0x14] = 0;
      local_24 = local_24 + 1;
      local_res8 = local_res8 + 1;
    }
    puVar1[local_24 + 0x14] = 0;
    iVar4 = FUN_004ba0cc(param_1,(char *)*param_2,puVar1,local_24 + 0x18,puVar1,0x2000);
    if ((-1 < iVar4) && (puVar1[0x14] != '\0')) {
      fputs(puVar1 + 0x14,stdout);
    }
  }
  else {
    piVar5 = (int *)(param_3 + 8);
    if (*piVar5 == 0) {
      *(undefined4 *)(puVar1 + 8) = 0;
      *(undefined4 *)(puVar1 + 0xc) = 0;
      iVar4 = FUN_004ba0cc(param_1,(char *)*param_2,puVar1,0x18,puVar1,0x2000);
      if (-1 < iVar4) {
        printf("%02x:%02x:%02x:%02x:%02x:%02x sch: %s (%u) / prio: %u\n",(uint)(byte)*puVar1,
               (uint)(byte)puVar1[1],(uint)(byte)puVar1[2],(uint)(byte)puVar1[3],
               (uint)(byte)puVar1[4],(uint)(byte)puVar1[5],puVar1 + 0x14,*(uint *)(puVar1 + 8),
               *(uint *)(puVar1 + 0xc));
      }
    }
    else {
      strncpy(puVar1 + 0x14,(char *)*piVar5,0x1fe8);
      if ((*(char *)*piVar5 < '0') || ('9' < *(char *)*piVar5)) {
        *(undefined4 *)(puVar1 + 8) = 0xffffffff;
      }
      else {
        uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
        *(ulong *)(puVar1 + 8) = uVar6;
      }
      piVar5 = (int *)(param_3 + 0xc);
      if ((*piVar5 == 0) || (*(char *)*piVar5 == '-')) {
        *(undefined4 *)(puVar1 + 0xc) = 0;
      }
      else {
        uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
        *(ulong *)(puVar1 + 0xc) = uVar6;
      }
      piVar5 = (int *)(param_3 + 0x10);
      if ((*piVar5 == 0) || (*(char *)*piVar5 == '-')) {
        *(undefined4 *)(puVar1 + 0x10) = 0;
      }
      else {
        uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
        *(ulong *)(puVar1 + 0x10) = uVar6;
      }
      pcVar7 = (char *)*param_2;
      sVar3 = strlen(puVar1 + 0x14);
      iVar4 = FUN_004ba160(param_1,pcVar7,puVar1,sVar3 + 0x18,puVar1,0x2000);
    }
  }
  return iVar4;
}



int FUN_004a7cec(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  undefined3 extraout_var;
  int iVar3;
  char *param2;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int local_48;
  undefined2 local_14;
  undefined1 auStack_12 [6];
  ushort *local_c;
  
  memset(&local_14,0,8);
  local_14 = 0;
  if ((*(int *)(param_3 + 4) != 0) &&
     (bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),auStack_12), CONCAT31(extraout_var,bVar1) == 0))
  {
    puts(" ERROR: no valid ether addr provided");
    return -1;
  }
  iVar3 = FUN_00445360(param_1,(char *)*param_2,&local_14,8,&local_c);
  if (iVar3 < 0) {
    return iVar3;
  }
  if (DAT_00557704 == '\0') {
    if (*local_c != 0) goto LAB_004a7f24;
  }
  else if ((*local_c & 0xff) != 0 || *local_c >> 8 != 0) goto LAB_004a7f24;
  if (DAT_00557704 == '\0') {
    uVar2 = local_c[1];
  }
  else {
    uVar2 = local_c[1] << 8 | local_c[1] >> 8;
  }
  if (uVar2 == 0x2c) {
    if (DAT_00557704 == '\0') {
      uVar4 = *(uint *)(local_c + 2);
    }
    else {
      uVar4 = *(uint *)(local_c + 2);
      uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
    }
    if (0x600 < uVar4 * 0x2c + 8) {
      puts("ERROR : peer list received exceed the buffer size\r");
    }
    local_48 = 0;
    while( true ) {
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)(local_c + 2);
      }
      else {
        uVar4 = *(uint *)(local_c + 2);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      if ((int)uVar4 <= local_48) break;
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)(local_c + local_48 * 0x16 + 0xe);
      }
      else {
        uVar4 = *(uint *)(local_c + local_48 * 0x16 + 0xe);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      *(uint *)(local_c + local_48 * 0x16 + 0xe) = uVar4;
      param2 = FUN_0041d780((int)(local_c + local_48 * 0x16 + 5));
      if (DAT_00557704 == '\0') {
        uVar4 = *(uint *)(local_c + local_48 * 0x16 + 10);
        uVar5 = *(uint *)(local_c + local_48 * 0x16 + 0xc);
        uVar6 = *(uint *)(local_c + local_48 * 0x16 + 0x18);
      }
      else {
        uVar4 = *(uint *)(local_c + local_48 * 0x16 + 10);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        uVar5 = *(uint *)(local_c + local_48 * 0x16 + 0xc);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
        uVar6 = *(uint *)(local_c + local_48 * 0x16 + 0x18);
        uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
      }
      printf("PEER%d: MAC: %s: RSSI %d TxRate %d kbps RxRate %d kbps age : %ds\r\n",local_48,param2,
             *(int *)(local_c + local_48 * 0x16 + 8),uVar4,uVar5,uVar6);
      printf("\t rateset ");
      FUN_004226f4((int)(local_c + local_48 * 0x16 + 0x10),
                   *(uint *)(local_c + local_48 * 0x16 + 0xe));
      puts("\r");
      local_48 = local_48 + 1;
    }
    return 0;
  }
LAB_004a7f24:
  if (DAT_00557704 == '\0') {
    uVar2 = *local_c;
  }
  else {
    uVar2 = *local_c << 8 | *local_c >> 8;
  }
  printf("BSS peer info version/structure size mismatch driver %d firmware %d \r\n",0,(uint)uVar2);
  return -1;
}



int FUN_004a8418(int *param_1,undefined4 *param_2,int param_3)

{
  int local_20;
  short local_1c [2];
  ulong local_18;
  ulong local_14;
  ulong local_10;
  
  local_20 = -1;
  if (*(int *)(param_3 + 4) == 0) {
    memset(local_1c,0,0x10);
    local_20 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)local_1c,0x10);
    if ((-1 < local_20) &&
       (printf("AIBSS TXFAIL config beacon timeout duration: %d \r\nMax consecutive Tx failure before TXFAIL event:%d \r\n"
               ,local_18,local_14), local_1c[0] == 1)) {
      printf("Max ATIM failures before TXFAIL event: %d \r\n",local_10);
    }
  }
  else {
    local_18 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    if (*(int *)(param_3 + 8) == 0) {
      puts("Incorrect number of arguments");
    }
    else {
      local_14 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      if (*(int *)(param_3 + 0xc) == 0) {
        puts("Incorrect number of arguments");
      }
      else {
        local_10 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        if (*(int *)(param_3 + 0x10) == 0) {
          local_1c[0] = 1;
          local_1c[1] = 0x10;
          local_20 = FUN_004ba2e4(param_1,(char *)*param_2,local_1c,0x10);
        }
        else {
          puts("wrong extra arguments");
        }
      }
    }
  }
  return local_20;
}



int FUN_004a8650(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  undefined4 *puVar2;
  ulong uVar3;
  int *piVar4;
  char local_14 [2];
  ushort local_12;
  byte local_10;
  ushort local_e;
  
  if (*(int *)(param_3 + 4) != 0) {
    puVar2 = (undefined4 *)(param_3 + 4);
    memset(local_14,0,8);
    iVar1 = strcasecmp((char *)*puVar2,"off");
    if (iVar1 == 0) {
      local_14[0] = '\0';
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul((char *)*puVar2,(char **)0x0,0);
        local_12 = (ushort)uVar3;
      }
      else {
        uVar3 = strtoul((char *)*puVar2,(char **)0x0,0);
        local_12 = (ushort)uVar3 << 8 | (ushort)uVar3 >> 8;
      }
      if (*(int *)(param_3 + 8) == 0) {
        puts("wl_bssload_static: channel utilization not provided");
        return -1;
      }
      uVar3 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      local_10 = (byte)uVar3;
      piVar4 = (int *)(param_3 + 0xc);
      if (*piVar4 == 0) {
        puts("wl_bssload_static: avail admission capacity not provided");
        return -1;
      }
      if (DAT_00557704 == '\0') {
        uVar3 = strtoul((char *)*piVar4,(char **)0x0,0);
        local_e = (ushort)uVar3;
      }
      else {
        uVar3 = strtoul((char *)*piVar4,(char **)0x0,0);
        local_e = (ushort)uVar3 << 8 | (ushort)uVar3 >> 8;
      }
      local_14[0] = '\x01';
    }
    iVar1 = FUN_004ba2e4(param_1,(char *)*param_2,local_14,8);
    return iVar1;
  }
  iVar1 = FUN_004ba1f8(param_1,(char *)*param_2,local_14,8);
  if (iVar1 < 0) {
    return iVar1;
  }
  if (local_14[0] == '\0') {
    return iVar1;
  }
  if (DAT_00557704 != '\0') {
    local_12 = local_12 << 8 | local_12 >> 8;
  }
  printf("station count: %d\n",(uint)local_12);
  printf("channel utilization: %d\n",(uint)local_10);
  if (DAT_00557704 != '\0') {
    local_e = local_e << 8 | local_e >> 8;
  }
  printf("avail admission capacity: %d\n",(uint)local_e);
  return iVar1;
}



int FUN_004a89f0(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  char *pcVar3;
  uint *local_18;
  uint local_14 [3];
  
  if (*(int *)(param_3 + 4) == 0) {
    local_18 = (uint *)0x0;
    iVar1 = FUN_0044527c(param_1,(char *)*param_2,(void *)0x0,0,&local_18);
    if (iVar1 < 0) {
      return iVar1;
    }
    if (DAT_00557704 == '\0') {
      uVar2 = *local_18;
    }
    else {
      uVar2 = *local_18;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    *local_18 = uVar2;
    if (DAT_00557704 == '\0') {
      uVar2 = local_18[1];
    }
    else {
      uVar2 = local_18[1];
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    local_18[1] = uVar2;
    if (*local_18 == 0xffffffff) {
      if (local_18[1] == 0) {
        pcVar3 = "disabled";
      }
      else {
        pcVar3 = "enabled";
      }
      printf("AUTO (%s)\n",pcVar3);
    }
    else {
      printf("%d\n",*local_18);
    }
  }
  else {
    pcVar3 = *(char **)(param_3 + 4);
    iVar1 = strcasecmp(pcVar3,"auto");
    if ((iVar1 == 0) || (iVar1 = atoi(pcVar3), iVar1 == -1)) {
      local_14[0] = 0xffffffff;
    }
    else {
      iVar1 = strcasecmp(pcVar3,"on");
      if (((iVar1 == 0) || (iVar1 = strcasecmp(pcVar3,"enable"), iVar1 == 0)) ||
         (iVar1 = atoi(pcVar3), iVar1 == 1)) {
        local_14[0] = 1;
      }
      else {
        iVar1 = strcasecmp(pcVar3,"off");
        if (((iVar1 != 0) && (iVar1 = strcasecmp(pcVar3,"disable"), iVar1 != 0)) &&
           (iVar1 = atoi(pcVar3), iVar1 != 0)) {
          return -1;
        }
        local_14[0] = 0;
      }
    }
    if (DAT_00557704 != '\0') {
      local_14[0] = local_14[0] << 0x18 | (local_14[0] & 0xff00) << 8 |
                    (local_14[0] & 0xff0000) >> 8 | local_14[0] >> 0x18;
    }
    FUN_00445444(param_1,(char *)*param_2,local_14,8);
  }
  return 0;
}



int FUN_004a8d9c(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  undefined4 local_10;
  uint local_c;
  
  if (*(int *)(param_3 + 4) == 0) {
    local_10 = 1;
    iVar1 = FUN_004ba0cc(param_1,(char *)*param_2,&local_10,8,PTR_DAT_00551644,0x2000);
    if (-1 < iVar1) {
      fputs(PTR_DAT_00551644 + 8,stdout);
    }
  }
  else {
    iVar1 = strcasecmp(*(char **)(param_3 + 4),"-d");
    if (iVar1 == 0) {
      if (DAT_00557704 == '\0') {
        uVar2 = atoi(*(char **)(param_3 + 8));
      }
      else {
        uVar2 = atoi(*(char **)(param_3 + 8));
        uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      if ((int)uVar2 < 1) {
        puts("Incorrect value for Time specified");
        iVar1 = 0;
      }
      else {
        local_10 = 0;
        local_c = uVar2;
        iVar1 = FUN_004ba0cc(param_1,(char *)*param_2,&local_10,8,PTR_DAT_00551644,0x2000);
        if (-1 < iVar1) {
          printf("Measure Time: %d ms\n",uVar2);
        }
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



int FUN_004a8fe4(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,PTR_DAT_00551644,0x2000);
    if (-1 < iVar1) {
      fputs(PTR_DAT_00551644,stdout);
    }
  }
  else {
    iVar1 = -0x17;
  }
  return iVar1;
}



int FUN_004a90bc(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  char *pcVar3;
  int iVar4;
  uint uVar5;
  uint local_40;
  int local_3c;
  char *local_38;
  undefined1 auStack_28 [2];
  undefined2 local_26;
  char acStack_1c [20];
  
  puVar1 = PTR_DAT_00551644;
  memset(PTR_DAT_00551644,0,0x88);
  memset(auStack_28,0,0xc);
  local_26 = 1;
  local_3c = FUN_004ba0cc(param_1,(char *)*param_2,auStack_28,0xc,puVar1,0x88);
  if (-1 < local_3c) {
    if (*(int *)(param_3 + 4) == 0) {
      if ((*(short *)(puVar1 + 2) == 1) && (*(int *)(puVar1 + 4) != 0)) {
        puts("DFS Preferred channel list:: ");
        for (local_40 = 0; local_40 < *(uint *)(puVar1 + 4); local_40 = local_40 + 1) {
          uVar2 = FUN_00402eb0((uint)*(ushort *)(puVar1 + local_40 * 2 + 8));
          pcVar3 = FUN_004c02bc(uVar2,acStack_1c);
          if (pcVar3 == (char *)0x0) {
            printf("(0x%x) ",(uint)uVar2);
          }
          else {
            printf("%s(0x%x) ",acStack_1c,(uint)uVar2);
          }
        }
        putchar(10);
      }
      else {
        uVar2 = FUN_00402eb0((uint)*(ushort *)puVar1);
        if ((uVar2 == 0) || (pcVar3 = FUN_004c02bc(uVar2,acStack_1c), pcVar3 == (char *)0x0)) {
          printf("DFS Preferred Channel:: 0x%x\n",(uint)uVar2);
        }
        else {
          printf("DFS Preferred Channel:: %s (0x%x)\n",acStack_1c,(uint)uVar2);
        }
      }
    }
    else {
      iVar4 = strcmp(*(char **)(param_3 + 4),"-l");
      if (iVar4 == 0) {
        if (*(int *)(param_3 + 8) == 0) {
          puts("Please provide channel list");
          local_3c = -0x2c;
        }
        else if (*(short *)(puVar1 + 2) == 1) {
          local_38 = strtok(*(char **)(param_3 + 8),", ");
          while (local_38 != (char *)0x0) {
            if ((*local_38 != '+') && (*local_38 != '-')) {
              puts("channel should be prefixed with +/-");
              return -0x2c;
            }
            uVar2 = FUN_004c0638(local_38 + 1);
            if (uVar2 == 0) {
              puts("Invalid channel specified");
              return -0x2c;
            }
            if ((uVar2 & 0xc000) != 0xc000) {
              puts("Invalid channel specified");
              return -0x2c;
            }
            *(undefined2 *)puVar1 = 0;
            if (*local_38 == '+') {
              for (local_40 = 0; local_40 < *(uint *)(puVar1 + 4); local_40 = local_40 + 1) {
                if (uVar2 == *(ushort *)(puVar1 + local_40 * 2 + 8)) {
                  printf("Ignoring chanspec 0x%x\n",(uint)uVar2);
                  goto LAB_004a964c;
                }
              }
              uVar5 = FUN_00402d10(uVar2);
              iVar4 = *(int *)(puVar1 + 4);
              *(short *)(puVar1 + iVar4 * 2 + 8) = (short)uVar5;
              *(int *)(puVar1 + 4) = iVar4 + 1;
            }
            else if (*local_38 == '-') {
              for (local_40 = 0; local_40 < *(uint *)(puVar1 + 4); local_40 = local_40 + 1) {
                if (uVar2 == *(ushort *)(puVar1 + local_40 * 2 + 8)) {
                  *(int *)(puVar1 + 4) = *(int *)(puVar1 + 4) + -1;
                  break;
                }
              }
              for (; local_40 < *(uint *)(puVar1 + 4); local_40 = local_40 + 1) {
                *(undefined2 *)(puVar1 + local_40 * 2 + 8) =
                     *(undefined2 *)(puVar1 + (local_40 + 1) * 2 + 8);
              }
            }
LAB_004a964c:
            local_38 = strtok((char *)0x0,", ");
          }
          if (*(uint *)(puVar1 + 4) < 0x41) {
            *(undefined2 *)(puVar1 + 2) = 1;
            local_3c = FUN_004ba2e4(param_1,(char *)*param_2,puVar1,(*(int *)(puVar1 + 4) + 4) * 2);
          }
          else {
            printf("Maximum %d channels supported\n",0x40);
            local_3c = -0x2c;
          }
        }
        else {
          puts("List Configuration is not supported in this version of driver");
        }
      }
      else {
        if (*(short *)(puVar1 + 2) == 1) {
          *(undefined2 *)puVar1 = 0;
          *(undefined4 *)(puVar1 + 4) = 0;
          local_3c = FUN_004ba2e4(param_1,(char *)*param_2,puVar1,(*(int *)(puVar1 + 4) + 4) * 2);
        }
        iVar4 = strcmp(*(char **)(param_3 + 4),"0");
        if (iVar4 != 0) {
          local_3c = FUN_0041c9d8(param_1,param_2,param_3);
        }
      }
    }
  }
  return local_3c;
}



int FUN_004a97b8(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  ulong *__s;
  char *pcVar4;
  int iVar5;
  ulong uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  size_t __n;
  uint local_38;
  int local_34;
  char *local_1c;
  undefined4 local_18;
  undefined4 local_14;
  char local_10;
  char local_f;
  
  iVar2 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  piVar3 = param_3 + 1;
  __s = (ulong *)malloc(0x284);
  if (__s == (ulong *)0x0) {
    fprintf(stderr,"Error allocating %d bytes for route table\n",0x284);
    local_34 = -0x1b;
  }
  else {
    memset(__s,0,0x284);
    if (*piVar3 == 0) {
      local_34 = FUN_004ba1f8(param_1,PTR_DAT_00551644,(char *)__s,0x284);
      if (local_34 == 0) {
        if (*__s == 0) {
          puts("No entries present");
        }
        else {
          for (local_38 = 0; local_38 < *__s; local_38 = local_38 + 1) {
            printf("entry%d",local_38);
            pcVar4 = FUN_0041e064((byte *)((int)__s + local_38 * 10 + 4));
            printf("\t%s",pcVar4);
            pcVar4 = FUN_0041d780((int)((int)__s + local_38 * 10 + 8));
            printf("\t%s\n",pcVar4);
          }
        }
      }
    }
    else {
      iVar5 = FUN_0040192c((int)piVar3);
      if (((iVar5 < 1) || (uVar6 = strtoul((char *)*piVar3,&local_1c,0), *local_1c != '\0')) ||
         (iVar5 != uVar6 * 2 + 1)) {
LAB_004a9bec:
        fwrite("wrong command format\n",1,0x15,stderr);
        if (__s != (ulong *)0x0) {
          free(__s);
        }
        return 0;
      }
      *__s = uVar6;
      for (local_38 = 0; local_38 < uVar6; local_38 = local_38 + 1) {
        bVar1 = FUN_0041d840((char *)param_3[local_38 * 2 + 2],(int)&local_18);
        if ((CONCAT31(extraout_var,bVar1) == 0) ||
           (bVar1 = FUN_0041d6ac((char *)param_3[local_38 * 2 + 3],&local_14),
           CONCAT31(extraout_var_00,bVar1) == 0)) goto LAB_004a9bec;
        *(undefined4 *)((int)__s + local_38 * 10 + 4) = local_18;
        *(undefined4 *)((int)__s + local_38 * 10 + 8) = local_14;
        *(char *)((int)__s + local_38 * 10 + 0xc) = local_10;
        *(char *)((int)__s + local_38 * 10 + 0xd) = local_f;
      }
      __n = uVar6 * 10 + 4;
      memcpy(PTR_DAT_00551644 + iVar2 + 1,__s,__n);
      local_34 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar2 + 1 + __n);
    }
    free(__s);
  }
  return local_34;
}



int FUN_004a9c44(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  char *__s;
  undefined3 extraout_var;
  char acStack_14 [12];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_004b9f94(param_1,0x119,acStack_14,6);
    if (-1 < iVar2) {
      __s = FUN_0041d780((int)acStack_14);
      puts(__s);
    }
  }
  else {
    bVar1 = FUN_0041d6ac(*(char **)(param_3 + 4),acStack_14);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      iVar2 = -0x2c;
    }
    else {
      iVar2 = FUN_004ba050(param_1,0x11a,acStack_14,6);
    }
  }
  return iVar2;
}



undefined4 FUN_004a9d48(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  ulong uVar3;
  int iVar4;
  uint uVar5;
  undefined1 auStack_118 [256];
  uint local_18;
  uint *local_14;
  char *apcStack_10 [2];
  
  bVar2 = true;
  local_14 = (uint *)0x0;
  if (*(int *)(param_3 + 4) != 0) {
    bVar2 = false;
    if (DAT_00557704 == '\0') {
      local_18 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
    }
    else {
      uVar3 = strtoul(*(char **)(param_3 + 4),apcStack_10,0);
      local_18 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    iVar4 = FUN_00445198(param_1,(char *)*param_2,auStack_118,0x100,&local_14);
    if (iVar4 < 0) {
      return 0xffffffff;
    }
    bVar1 = local_18 != 0;
    local_18 = *local_14 & 0xfffffffe;
    if (bVar1) {
      local_18 = *local_14 & 0xfffffffe | 1;
    }
    memcpy(auStack_118,&local_18,4);
  }
  if (bVar2) {
    iVar4 = FUN_00445198(param_1,(char *)*param_2,auStack_118,0x100,&local_14);
    if (iVar4 < 0) {
      return 0xffffffff;
    }
    if (DAT_00557704 == '\0') {
      uVar5 = *local_14;
    }
    else {
      uVar5 = *local_14;
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    printf("0x%x\n",uVar5);
  }
  else {
    FUN_00445444(param_1,(char *)*param_2,auStack_118,0x100);
  }
  return 0;
}



int FUN_004a9fd4(int *param_1,int param_2,undefined4 *param_3)

{
  undefined *puVar1;
  int iVar2;
  undefined2 *puVar3;
  ulong uVar4;
  
  iVar2 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  if (param_3[1] == 0) {
    PTR_DAT_00551644[iVar2 + 1] = 0;
    iVar2 = FUN_004b9f94(param_1,*(int *)(param_2 + 8),PTR_DAT_00551644,0x2000);
    puVar1 = PTR_DAT_00551644;
    if (-1 < iVar2) {
      printf("period %u\n",(uint)*(ushort *)(PTR_DAT_00551644 + 2));
      printf("scans allowed per period %u\n",(uint)*(ushort *)(puVar1 + 4));
      iVar2 = 0;
    }
  }
  else {
    puVar3 = (undefined2 *)(PTR_DAT_00551644 + iVar2 + 1);
    *puVar3 = 1;
    uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
    puVar3[1] = (short)uVar4;
    if (param_3[2] == 0) {
      puts("Incorrect number of arguments");
      iVar2 = -1;
    }
    else {
      uVar4 = strtoul((char *)param_3[2],(char **)0x0,0);
      puVar3[2] = (short)uVar4;
      if (param_3[3] == 0) {
        iVar2 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar2 + 7);
      }
      else {
        puts("extra arguments");
        iVar2 = -1;
      }
    }
  }
  return iVar2;
}



int FUN_004aa210(int *param_1,undefined4 *param_2,int param_3)

{
  int *local_res8;
  int iVar1;
  short *local_bc;
  undefined4 auStack_ac [3];
  int local_a0;
  char local_9b;
  char local_9a;
  char *local_18;
  undefined4 local_10;
  ushort *local_c;
  
  iVar1 = 0;
  local_bc = (short *)0x0;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    local_c = (ushort *)0x0;
    iVar1 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    if (iVar1 < 0) {
      fwrite("Failed to get stats.\n",1,0x15,stderr);
      return iVar1;
    }
    if (*(int *)(local_c + 2) != 0) {
      if (*local_c == 0) {
        trap(7);
      }
      fprintf(stdout,
              "Seconds test run %d\nNo of dma completed %d\nBytes transfered per dma %d\nBus throughput: %d mbps\n"
              ,(uint)*local_c,*(int *)(local_c + 2),(uint)local_c[1],
              ((*(int *)(local_c + 2) * (uint)local_c[1]) / (uint)*local_c << 3) >> 0x14);
    }
  }
  if (*local_res8 != 0) {
    local_bc = (short *)malloc(8);
    if (local_bc == (short *)0x0) {
      fwrite("Failed to allocate buffer.\n",1,0x1b,stderr);
      return iVar1;
    }
    memset(local_bc,0,8);
    FUN_004cbd80(auStack_ac,"wl_pcie_bus_throughput_params",0,0);
    while (iVar1 = FUN_004cbe18(auStack_ac,local_res8), iVar1 != -1) {
      if (iVar1 == 1) {
        iVar1 = -0x2c;
        goto LAB_004aa5d0;
      }
      local_res8 = local_res8 + local_a0;
      if (local_9a == 'n') {
        if (local_9b == '\0') {
          fprintf(stderr,"%s: could not parse \"%s\" as an int for max_dma_descriptors \n",
                  "wl_pcie_bus_throughput_params",local_18);
          iVar1 = -2;
          goto LAB_004aa5d0;
        }
        *(char *)local_bc = (char)local_10;
        *(char *)((int)local_bc + 1) = (char)((uint)local_10 >> 8);
      }
    }
    if (*local_bc == 0) {
      *(undefined1 *)local_bc = 0x40;
      *(undefined1 *)((int)local_bc + 1) = 0;
    }
    iVar1 = FUN_00445444(param_1,(char *)*param_2,local_bc,8);
    iVar1 = -(iVar1 >> 0x1f);
    if (iVar1 != 0) {
      fprintf(stderr,"failed to trigger measurement %d\n",iVar1);
    }
  }
LAB_004aa5d0:
  if (local_bc != (short *)0x0) {
    free(local_bc);
  }
  return iVar1;
}



int FUN_004aa604(int *param_1,undefined4 *param_2,int param_3)

{
  byte bVar1;
  bool bVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined3 extraout_var;
  char *param3;
  undefined2 local_28 [2];
  uint local_24;
  undefined1 auStack_20 [8];
  int local_18 [2];
  
  memset(local_28,0,0x10);
  local_28[0] = 0;
  puVar3 = (undefined4 *)(param_3 + 4);
  iVar4 = FUN_0040192c((int)puVar3);
  if (iVar4 < 1) {
    iVar4 = -0x2c;
  }
  else {
    iVar4 = strcasecmp((char *)*puVar3,"ap");
    if (iVar4 == 0) {
      local_24 = local_24 | 1;
    }
    else {
      iVar4 = strcasecmp((char *)*puVar3,"sta");
      if (iVar4 != 0) {
        return -0x2c;
      }
    }
    if ((*(int *)(param_3 + 8) != 0) &&
       (bVar2 = FUN_0041d6ac(*(char **)(param_3 + 8),auStack_20), CONCAT31(extraout_var,bVar2) != 0)
       ) {
      local_24 = local_24 | 2;
    }
    iVar4 = FUN_00445198(param_1,(char *)*param_2,local_28,0x10,local_18);
    if (iVar4 < 0) {
      printf("%s(): wlu_var_getbuf failed %d \r\n","wl_interface_create_action",iVar4);
    }
    else {
      bVar1 = *(byte *)(local_18[0] + 0x18);
      param3 = FUN_0041d780(local_18[0] + 2);
      printf("ifname: %s bsscfgidx: %d mac_addr %s\r\n",(char *)(local_18[0] + 8),(uint)bVar1,param3
            );
    }
  }
  return iVar4;
}



int FUN_004aa814(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint local_14;
  int local_10 [2];
  
  local_14 = 0;
  iVar1 = FUN_004024e8((int *)(param_3 + 4),"interface_remove",&local_14,local_10);
  if (iVar1 == 0) {
    if (local_10[0] == 0) {
      iVar1 = FUN_00445444(param_1,(char *)*param_2,(void *)0x0,0);
    }
    else {
      iVar1 = FUN_00445980(param_1,"interface_remove",local_14,(void *)0x0,0);
    }
  }
  return iVar1;
}



int FUN_004aa910(int *param_1,undefined4 *param_2,undefined4 *param_3)

{
  bool bVar1;
  undefined *puVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  undefined2 *puVar7;
  long lVar8;
  int *piVar9;
  char *pcVar10;
  size_t sVar11;
  int *local_res8;
  int local_40;
  undefined2 *local_3c;
  int local_34;
  
  iVar4 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_3);
  iVar5 = iVar4 + 1;
  if (param_3[1] == 0) {
    puts("Mode is required ");
    iVar4 = -1;
  }
  else {
    uVar6 = atoi((char *)param_3[1]);
    if (uVar6 < 2) {
      if (uVar6 == 0) {
        local_res8 = param_3 + 2;
        if (*local_res8 == 0) {
          PTR_DAT_00551644[iVar5] = 0;
          iVar4 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
          puVar2 = PTR_DAT_00551644;
          if (-1 < iVar4) {
            puts("cck rssi-2g:");
            for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[local_40 * 2 + 4]);
            }
            putchar(10);
            puts("cck rssi-5g:");
            for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[local_40 * 2 + 5]);
            }
            putchar(10);
            puts("ofdm rssi-2g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 4) * 2 + 4]);
            }
            putchar(10);
            puts("ofdm rssi-5g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 4) * 2 + 5]);
            }
            putchar(10);
            puts("phy_n 1x1 rssi-2g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0xc) * 2 + 4]);
            }
            putchar(10);
            puts("phy_n 1x1 rssi-5g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0xc) * 2 + 5]);
            }
            putchar(10);
            puts("phy_n 2x2 rssi-2g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x14) * 2 + 4]);
            }
            putchar(10);
            puts("phy_n 2x2 rssi-5g:");
            for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x14) * 2 + 5]);
            }
            putchar(10);
            puts("phy_ac 1x1 rssi-2g:");
            for (local_40 = 0; local_40 < 10; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x2c) * 2 + 4]);
            }
            putchar(10);
            puts("phy_ac 1x1 rssi-5g:");
            for (local_40 = 0; local_40 < 10; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x2c) * 2 + 5]);
            }
            putchar(10);
            puts("phy_ac 2x2 rssi-2g:");
            for (local_40 = 0; local_40 < 10; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x36) * 2 + 4]);
            }
            putchar(10);
            puts("phy_ac 2x2 rssi-5g:");
            for (local_40 = 0; local_40 < 10; local_40 = local_40 + 1) {
              printf("%d, ",(int)(char)puVar2[(local_40 + 0x36) * 2 + 5]);
            }
            putchar(10);
            iVar4 = 0;
          }
        }
        else {
          sVar3 = 0;
          puVar7 = (undefined2 *)(PTR_DAT_00551644 + iVar5);
          local_3c = puVar7 + 2;
          *puVar7 = 1;
          for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
            lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
            *(char *)local_3c = (char)lVar8;
            local_3c = (undefined2 *)((int)local_3c + 1);
            sVar3 = sVar3 + 1;
          }
          puVar7[1] = sVar3 + 4;
          iVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar4 + 0xad);
        }
      }
      else {
        piVar9 = param_3 + 2;
        if (*piVar9 != 0) {
          iVar4 = strcmp((char *)*piVar9,"cck");
          if (iVar4 == 0) {
            local_34 = 0;
          }
          else {
            iVar4 = strcmp((char *)*piVar9,"ofdm");
            if (iVar4 == 0) {
              local_34 = 1;
            }
            else {
              iVar4 = strcmp((char *)*piVar9,"11n");
              if (iVar4 == 0) {
                local_34 = 2;
              }
              else {
                iVar4 = strcmp((char *)*piVar9,"11ac");
                if (iVar4 != 0) {
                  puts("Wrong phy-type: only cck/ofdm/11n/11ac supported");
                  return -1;
                }
                local_34 = 3;
              }
            }
          }
          piVar9 = param_3 + 3;
          if (*piVar9 != 0) {
            iVar4 = strcmp((char *)*piVar9,"2g");
            if (iVar4 == 0) {
              bVar1 = false;
            }
            else {
              iVar4 = strcmp((char *)*piVar9,"5g");
              if (iVar4 != 0) {
                puts("Wrong band-type: only \'2g\' and \'5g\' are supported");
                return -1;
              }
              if (local_34 == 0) {
                puts("cck not allowed on 5g");
                return -1;
              }
              bVar1 = true;
            }
            if (param_3[4] != 0) {
              uVar6 = atoi((char *)param_3[4]);
              if ((uVar6 == 0) || (4 < uVar6)) {
                puts("Wrong number of streams: Only 1 to 4 supported");
                return -1;
              }
              if (((local_34 == 0) || (local_34 == 1)) && (1 < uVar6)) {
                puts("Only 1 stream allowed for CCK/OFDM");
                return -1;
              }
              PTR_DAT_00551644[iVar5] = 0;
              iVar4 = FUN_004b9f94(param_1,param_2[2],PTR_DAT_00551644,0x2000);
              puVar2 = PTR_DAT_00551644;
              if (iVar4 < 0) {
                return iVar4;
              }
              local_res8 = param_3 + 5;
              if (*local_res8 == 0) {
                if (local_34 == 1) {
                  if (bVar1) {
                    pcVar10 = "5";
                  }
                  else {
                    pcVar10 = "2";
                  }
                  printf("ofdm rssi-%sg:\n",pcVar10);
                  for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
                    if (bVar1) {
                      printf("%d, ",(int)(char)puVar2[(local_40 + 4) * 2 + 5]);
                    }
                    else {
                      printf("%d, ",(int)(char)puVar2[(local_40 + 4) * 2 + 4]);
                    }
                  }
                  putchar(10);
                }
                else if (local_34 == 0) {
                  puts("cck rssi-2g:");
                  for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
                    printf("%d, ",(int)(char)puVar2[local_40 * 2 + 4]);
                  }
                  putchar(10);
                }
                else if (local_34 == 2) {
                  if (bVar1) {
                    pcVar10 = "5";
                  }
                  else {
                    pcVar10 = "2";
                  }
                  printf("11N streams:%dx%d rssi-%sg:\n",uVar6,uVar6,pcVar10);
                  for (local_40 = 0; local_40 < 8; local_40 = local_40 + 1) {
                    if (bVar1) {
                      printf("%d, ",(int)(char)puVar2[((uVar6 - 1) * 8 + local_40 + 0xc) * 2 + 5]);
                    }
                    else {
                      printf("%d, ",(int)(char)puVar2[((uVar6 - 1) * 8 + local_40 + 0xc) * 2 + 4]);
                    }
                  }
                  putchar(10);
                }
                else if (local_34 == 3) {
                  if (bVar1) {
                    pcVar10 = "5";
                  }
                  else {
                    pcVar10 = "2";
                  }
                  printf("11AC streams:%dx%d rssi-%sg:\n",uVar6,uVar6,pcVar10);
                  for (local_40 = 0; local_40 < 10; local_40 = local_40 + 1) {
                    if (bVar1) {
                      printf("%d, ",(int)(char)puVar2[((uVar6 - 1) * 10 + local_40 + 0x2c) * 2 + 5])
                      ;
                    }
                    else {
                      printf("%d, ",(int)(char)puVar2[((uVar6 - 1) * 10 + local_40 + 0x2c) * 2 + 4])
                      ;
                    }
                  }
                  putchar(10);
                }
                return 0;
              }
              sVar11 = strlen((char *)*param_2);
              memmove(PTR_DAT_00551644 + sVar11 + 1,PTR_DAT_00551644,0xac);
              iVar4 = sprintf(PTR_DAT_00551644,"%s",(char *)*param_2);
              PTR_DAT_00551644[iVar4 + 1] = 0;
              puVar7 = (undefined2 *)(PTR_DAT_00551644 + iVar4 + 1);
              if (local_34 == 1) {
                local_40 = 0;
                for (; (local_40 < 8 && (*local_res8 != 0)); local_res8 = local_res8 + 1) {
                  if (bVar1) {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)((int)puVar7 + (local_40 + 4) * 2 + 5) = (char)lVar8;
                  }
                  else {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)(puVar7 + local_40 + 6) = (char)lVar8;
                  }
                  local_40 = local_40 + 1;
                }
              }
              else if (local_34 == 0) {
                local_40 = 0;
                for (; (local_40 < 4 && (*local_res8 != 0)); local_res8 = local_res8 + 1) {
                  lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                  *(char *)(puVar7 + local_40 + 2) = (char)lVar8;
                  local_40 = local_40 + 1;
                }
              }
              else if (local_34 == 2) {
                local_40 = 0;
                for (; (local_40 < 8 && (*local_res8 != 0)); local_res8 = local_res8 + 1) {
                  if (bVar1) {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)((int)puVar7 + ((uVar6 - 1) * 8 + local_40 + 0xc) * 2 + 5) =
                         (char)lVar8;
                  }
                  else {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)(puVar7 + (uVar6 - 1) * 8 + local_40 + 0xe) = (char)lVar8;
                  }
                  local_40 = local_40 + 1;
                }
              }
              else if (local_34 == 3) {
                local_40 = 0;
                for (; (local_40 < 10 && (*local_res8 != 0)); local_res8 = local_res8 + 1) {
                  if (bVar1) {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)((int)puVar7 + ((uVar6 - 1) * 10 + local_40 + 0x2c) * 2 + 5) =
                         (char)lVar8;
                  }
                  else {
                    lVar8 = strtol((char *)*local_res8,(char **)0x0,0);
                    *(char *)(puVar7 + (uVar6 - 1) * 10 + local_40 + 0x2e) = (char)lVar8;
                  }
                  local_40 = local_40 + 1;
                }
              }
              *puVar7 = 1;
              puVar7[1] = 0xac;
              iVar4 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,iVar4 + 0xad);
              return iVar4;
            }
          }
        }
        puts("Insufficient params for mode 1");
        iVar4 = -1;
      }
    }
    else {
      puts("Mode can only be 0 or 1");
      iVar4 = -1;
    }
  }
  return iVar4;
}



char * FUN_004abc38(byte *param_1,char *param_2)

{
  snprintf(param_2,0x32,"Interface:%s,Baud Rate:%d",(&PTR_s_UART0_00551634)[*param_1],
           *(int *)(param_1 + 1));
  return param_2;
}



ulong FUN_004abcc4(char *param_1)

{
  ulong uVar1;
  
  uVar1 = strtoul(param_1,(char **)0x0,10);
  return uVar1;
}



int FUN_004abd10(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  bool bVar2;
  ulong uVar3;
  int iVar4;
  uint uVar5;
  int *local_res8;
  int local_1d4;
  uint local_1bc;
  undefined1 local_1b8;
  undefined4 auStack_bc [3];
  int local_b0;
  char local_ab;
  char local_aa;
  char *local_28;
  undefined4 local_20;
  uint local_1c;
  byte local_18;
  byte local_14 [12];
  
  bVar1 = false;
  bVar2 = false;
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    if ((int)param_2[2] < 0) {
      return -1;
    }
    local_1c = local_1c & 0xffffff00;
LAB_004ac0e4:
    local_14[1] = 0;
    local_14[2] = 0;
    local_14[3] = 0;
    local_14[4] = 0;
    local_14[0] = (byte)local_1c;
    local_1d4 = FUN_004ba0cc(param_1,(char *)*param_2,local_14,5,(char *)&local_1bc,0x100);
    if (-1 < local_1d4) {
      local_1c = local_1bc;
      local_18 = local_1b8;
      FUN_004abc38((byte *)&local_1c,PTR_DAT_00551644);
      puts(PTR_DAT_00551644);
      local_1d4 = 0;
    }
  }
  else {
    uVar3 = FUN_004abcc4((char *)*local_res8);
    if (uVar3 == 0) {
      FUN_004cbd80(auStack_bc,"wl_uartparams",0,0);
      while( true ) {
        iVar4 = FUN_004cbe18(auStack_bc,local_res8);
        if (iVar4 == -1) break;
        if (iVar4 == 1) {
          return -1;
        }
        local_res8 = local_res8 + local_b0;
        if (local_aa == 'i') {
          if (local_ab == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int for the uart interface \n",
                    "wl_uartparams",local_28);
            return -1;
          }
          local_1c = CONCAT31(local_1c._1_3_,(char)local_20);
          bVar1 = true;
        }
        if (local_aa == 'b') {
          if (local_ab == '\0') {
            fprintf(stderr,"%s: could not parse \"%s\" as an int forbaud rate\n","wl_uartparams",
                    local_28);
            return -1;
          }
          local_1c._1_3_ = (uint3)local_20;
          local_18 = (byte)((uint)local_20 >> 0x18);
          bVar2 = true;
        }
      }
      if ((bVar1) && (!bVar2)) goto LAB_004ac0e4;
      if (!bVar1) {
        bVar1 = true;
        local_1c = (uint)local_1c._1_3_ << 8;
      }
      if ((bVar1) && (bVar2)) {
        if (DAT_00557704 == '\0') {
          uVar5 = CONCAT13(local_18,local_1c._1_3_);
        }
        else {
          uVar5 = CONCAT13(local_18,local_1c._1_3_) << 0x18 | (local_1c._1_3_ & 0xff00) << 8 |
                  (local_1c._1_3_ & 0xff0000) >> 8 | (uint)local_18;
        }
        local_1c._1_3_ = (uint3)uVar5;
        local_18 = (byte)(uVar5 >> 0x18);
        local_1d4 = FUN_004ba2e4(param_1,(char *)*param_2,&local_1c,5);
      }
      else {
        fprintf(stderr,"%s: you need to set a Baud Rate, \'-b <5|2>\'\n","wl_uartparams");
        local_1d4 = -1;
      }
    }
    else {
      if (DAT_00557704 != '\0') {
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      local_1c = uVar3 << 8;
      local_18 = (byte)(uVar3 >> 0x18);
      local_1d4 = FUN_004ba2e4(param_1,(char *)*param_2,&local_1c,5);
    }
    if (local_1d4 == 0) {
      printf("Uart Parameters set.Baudrate:%d\t Interface:%d\n",CONCAT13(local_18,local_1c._1_3_),
             local_1c & 0xff);
    }
  }
  return local_1d4;
}



int FUN_004ac1a0(int *param_1,undefined4 param_2,int param_3)

{
  int param2;
  uint local_10;
  uint local_c;
  
  memset(&local_10,0,8);
  if (*(int *)(param_3 + 4) == 0) {
    param2 = FUN_004ba1f8(param_1,"hostclksync",(char *)&local_10,8);
    if (param2 == 0) {
      printf("0x%08X 0x%08X\n",
             local_c << 0x18 | (local_c & 0xff00) << 8 | (local_c & 0xff0000) >> 8 | local_c >> 0x18
             ,local_10 << 0x18 | (local_10 & 0xff00) << 8 | (local_10 & 0xff0000) >> 8 |
              local_10 >> 0x18);
    }
    else {
      fprintf(stderr,"wl_host_clk_sync: Error %d\n",param2);
    }
  }
  else {
    param2 = -2;
  }
  return param2;
}



int FUN_004ac314(int *param_1,undefined4 *param_2,int param_3)

{
  char *__s;
  int local_10;
  
  local_10 = 0;
  if ((int)param_2[2] < 0) {
    local_10 = -1;
  }
  else {
    __s = (char *)malloc(0x1fc00);
    if (__s == (char *)0x0) {
      fprintf(stderr,"Failed to allocate dump buffer of %d bytes\n",0x1fc00);
      local_10 = -0x1b;
    }
    else {
      memset(__s,0,0x1fc00);
      if (*(int *)(param_3 + 4) == 0) {
        local_10 = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,__s,0x1fc00);
        if (local_10 == 0) {
          fputs(__s,stdout);
        }
      }
      free(__s);
    }
  }
  return local_10;
}



int FUN_004ac458(int *param_1)

{
  int param2;
  
  param2 = FUN_004ba428(param_1,"hostclksync_cap",0);
  if (param2 != 0) {
    fprintf(stderr,"wl_host_clk_sync: Set Error %d\n",param2);
  }
  return param2;
}



void FUN_004ac4fc(uint param_1,uint *param_2,uint *param_3,int param_4)

{
  if (param_4 == 0) {
    *param_3 = *param_3 | param_1;
  }
  else {
    *param_2 = *param_2 | param_1;
  }
  return;
}



int FUN_004ac570(int *param_1,undefined4 param_2,int param_3)

{
  int *piVar1;
  undefined4 *__ptr;
  int iVar2;
  char *pcVar3;
  ulong local_14;
  int *local_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_00445198(param_1,"dyn_bwsw_params",(void *)0x0,0,local_10);
    iVar2 = -(iVar2 >> 0x1f);
    if (iVar2 == 0) {
      printf("Version=%d\n",*local_10[0]);
      printf("actvcfm=%d\n",(uint)*(byte *)(local_10[0] + 3));
      printf("noactcfm=%d\n",(uint)*(byte *)((int)local_10[0] + 0xd));
      printf("noactincr=%d\n",(uint)*(byte *)((int)local_10[0] + 0xe));
      printf("psense=%d\n",(uint)*(ushort *)((int)local_10[0] + 0xf));
      printf("rxcrsthresh=%d\n",(uint)*(byte *)((int)local_10[0] + 0x11));
      printf("secdurlim=%d\n",(uint)*(byte *)((int)local_10[0] + 0x12));
      printf("txopthresh=%d\n",(uint)*(byte *)((int)local_10[0] + 0x13));
    }
    else {
      puts("wl_dyn_bwsw_params: fail to get params");
    }
  }
  else {
    __ptr = (undefined4 *)malloc(0x14);
    if (__ptr == (undefined4 *)0x0) {
      puts("memory alloc failure");
      iVar2 = -0x1b;
    }
    else {
      __ptr[2] = 0;
      __ptr[1] = 0;
      *__ptr = 1;
      pcVar3 = FUN_0040f668(piVar1,"dflt_desense",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(1,__ptr + 1,__ptr + 2,local_14);
        *(char *)(__ptr + 3) = (char)local_14;
      }
      pcVar3 = FUN_0040f668(piVar1,"noactcfm",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(2,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0xd) = (char)local_14;
      }
      pcVar3 = FUN_0040f668(piVar1,"noactincr",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(4,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0xe) = (char)local_14;
      }
      pcVar3 = FUN_0040f668(piVar1,"psense",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(8,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0xf) = (char)local_14;
        *(char *)(__ptr + 4) = (char)(local_14 >> 8);
      }
      pcVar3 = FUN_0040f668(piVar1,"rxcrsthresh",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(0x10,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0x11) = (char)local_14;
      }
      pcVar3 = FUN_0040f668(piVar1,"secdurlim",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(0x20,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0x12) = (char)local_14;
      }
      pcVar3 = FUN_0040f668(piVar1,"txopthresh",&local_14);
      if (pcVar3 != (char *)0x0) {
        FUN_004ac4fc(0x40,__ptr + 1,__ptr + 2,local_14);
        *(char *)((int)__ptr + 0x13) = (char)local_14;
      }
      iVar2 = FUN_00445444(param_1,"dyn_bwsw_params",__ptr,0x14);
      iVar2 = -(iVar2 >> 0x1f);
      if (iVar2 != 0) {
        printf("wl_dyn_bwsw_params: fail to set %d\n",iVar2);
      }
      free(__ptr);
    }
  }
  return iVar2;
}



int FUN_004acaa8(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    iVar2 = FUN_004ba0cc(param_1,(char *)*param_2,(void *)0x0,0,PTR_DAT_00551644,0x2000);
    if (-1 < iVar2) {
      fputs(PTR_DAT_00551644,stdout);
    }
  }
  else {
    if (DAT_00557704 == '\0') {
      local_c = atoi((char *)*piVar1);
    }
    else {
      uVar3 = atoi((char *)*piVar1);
      local_c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
    }
    iVar2 = FUN_004ba160(param_1,(char *)*param_2,&local_c,4,PTR_DAT_00551644,0x2000);
  }
  return iVar2;
}



int FUN_004acc54(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  bool bVar2;
  ushort uVar3;
  uint uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int *piVar5;
  ulong uVar6;
  
  puVar1 = PTR_DAT_00551644;
  if (*(int *)(param_3 + 4) == 0) {
    uVar4 = 0xffffffd4;
  }
  else {
    bVar2 = FUN_0041d6ac(*(char **)(param_3 + 4),PTR_DAT_00551644 + 4);
    if (CONCAT31(extraout_var,bVar2) == 0) {
      uVar4 = 0xffffffd4;
    }
    else if (*(int *)(param_3 + 8) == 0) {
      uVar4 = 0xffffffd4;
    }
    else {
      bVar2 = FUN_0041d840(*(char **)(param_3 + 8),(int)(puVar1 + 10));
      if (CONCAT31(extraout_var_00,bVar2) == 0) {
        uVar4 = 0xffffffd4;
      }
      else if (*(int *)(param_3 + 0xc) == 0) {
        uVar4 = 0xffffffd4;
      }
      else {
        bVar2 = FUN_0041d840(*(char **)(param_3 + 0xc),(int)(puVar1 + 0xe));
        if (CONCAT31(extraout_var_01,bVar2) == 0) {
          uVar4 = 0xffffffd4;
        }
        else {
          piVar5 = (int *)(param_3 + 0x10);
          if (*piVar5 == 0) {
            uVar4 = 0xffffffd4;
          }
          else {
            if (DAT_00557704 == '\0') {
              uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
              uVar3 = (ushort)uVar6;
            }
            else {
              uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
              uVar3 = (ushort)(uVar6 >> 8) & 0xff00 | (ushort)(byte)(uVar6 >> 0x18);
            }
            *(ushort *)(puVar1 + 0x12) = uVar3;
            piVar5 = (int *)(param_3 + 0x14);
            if (*piVar5 == 0) {
              uVar4 = 0xffffffd4;
            }
            else {
              if (DAT_00557704 == '\0') {
                uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                uVar3 = (ushort)uVar6;
              }
              else {
                uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                uVar3 = (ushort)(uVar6 >> 8) & 0xff00 | (ushort)(byte)(uVar6 >> 0x18);
              }
              *(ushort *)(puVar1 + 0x14) = uVar3;
              piVar5 = (int *)(param_3 + 0x18);
              if (*piVar5 == 0) {
                uVar4 = 0xffffffd4;
              }
              else {
                if (DAT_00557704 == '\0') {
                  uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                  uVar3 = (ushort)uVar6;
                }
                else {
                  uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                  uVar3 = (ushort)(uVar6 >> 8) & 0xff00 | (ushort)(byte)(uVar6 >> 0x18);
                }
                *(ushort *)(puVar1 + 0x16) = uVar3;
                piVar5 = (int *)(param_3 + 0x1c);
                if (*piVar5 == 0) {
                  uVar4 = 0xffffffd4;
                }
                else {
                  if (DAT_00557704 == '\0') {
                    uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                  }
                  else {
                    uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                    uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                            uVar6 >> 0x18;
                  }
                  *(uint *)(puVar1 + 0x18) = uVar4;
                  piVar5 = (int *)(param_3 + 0x20);
                  if (*piVar5 == 0) {
                    uVar4 = 0xffffffd4;
                  }
                  else {
                    if (DAT_00557704 == '\0') {
                      uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                    }
                    else {
                      uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                      uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                              uVar6 >> 0x18;
                    }
                    *(uint *)(puVar1 + 0x1c) = uVar4;
                    piVar5 = (int *)(param_3 + 0x24);
                    if (*piVar5 == 0) {
                      uVar4 = 0xffffffd4;
                    }
                    else {
                      if (DAT_00557704 == '\0') {
                        uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                        uVar3 = (ushort)uVar6;
                      }
                      else {
                        uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                        uVar3 = (ushort)(uVar6 >> 8) & 0xff00 | (ushort)(byte)(uVar6 >> 0x18);
                      }
                      *(ushort *)(puVar1 + 0x20) = uVar3;
                      piVar5 = (int *)(param_3 + 0x28);
                      if (*piVar5 == 0) {
                        uVar4 = 0xffffffd4;
                      }
                      else {
                        if (DAT_00557704 == '\0') {
                          uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                        }
                        else {
                          uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                          uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                                  uVar6 >> 0x18;
                        }
                        *(uint *)(puVar1 + 0x24) = uVar4;
                        piVar5 = (int *)(param_3 + 0x2c);
                        if (*piVar5 == 0) {
                          uVar4 = 0xffffffd4;
                        }
                        else {
                          if (DAT_00557704 == '\0') {
                            uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                          }
                          else {
                            uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                            uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8
                                    | uVar6 >> 0x18;
                          }
                          *(uint *)(puVar1 + 0x28) = uVar4;
                          piVar5 = (int *)(param_3 + 0x30);
                          if (*piVar5 == 0) {
                            uVar4 = 0xffffffd4;
                          }
                          else {
                            if (DAT_00557704 == '\0') {
                              uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                            }
                            else {
                              uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                              uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 |
                                      (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
                            }
                            *(uint *)(puVar1 + 0x2c) = uVar4;
                            piVar5 = (int *)(param_3 + 0x34);
                            if (*piVar5 == 0) {
                              uVar4 = 0xffffffd4;
                            }
                            else {
                              if (DAT_00557704 == '\0') {
                                uVar4 = strtoul((char *)*piVar5,(char **)0x0,0);
                              }
                              else {
                                uVar6 = strtoul((char *)*piVar5,(char **)0x0,0);
                                uVar4 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 |
                                        (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
                              }
                              *(uint *)(puVar1 + 0x30) = uVar4;
                              if (*(int *)(param_3 + 0x38) == 0) {
                                uVar4 = 0xffffffd4;
                              }
                              else {
                                bcopy(*(void **)(param_3 + 0x38),puVar1 + 0x34,
                                      *(size_t *)(puVar1 + 0x30));
                                *(undefined4 *)puVar1 = 0;
                                uVar4 = FUN_004ba0cc(param_1,(char *)*param_2,puVar1,
                                                     *(int *)(puVar1 + 0x30) + 0x37,PTR_DAT_00551644
                                                     ,0x2000);
                                if (uVar4 == 0) {
                                  *(int *)puVar1 = (int)(char)*PTR_DAT_00551644;
                                  printf("\r\n Session_ID:%d \r\n",*(int *)puVar1);
                                }
                                else {
                                  printf("Get Session Id failed:%s %x\n",(char *)*param_2,uVar4);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return uVar4;
}



int FUN_004ad644(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  uint param2;
  ulong uVar2;
  uint local_18;
  uint local_14;
  ushort local_10;
  ushort local_e;
  ushort local_c;
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    param2 = 0xffffffd4;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_18 = strtoul((char *)*piVar1,(char **)0x0,0);
    }
    else {
      uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
      local_18 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    piVar1 = (int *)(param_3 + 8);
    if (*piVar1 == 0) {
      param2 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        local_14 = strtoul((char *)*piVar1,(char **)0x0,0);
      }
      else {
        uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
        local_14 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
      }
      if (local_14 != 0) {
        piVar1 = (int *)(param_3 + 0xc);
        if (*piVar1 == 0) {
          return -0x2c;
        }
        if (DAT_00557704 == '\0') {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_10 = (ushort)uVar2;
        }
        else {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_10 = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
        }
        piVar1 = (int *)(param_3 + 0x10);
        if (*piVar1 == 0) {
          return -0x2c;
        }
        if (DAT_00557704 == '\0') {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_e = (ushort)uVar2;
        }
        else {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_e = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
        }
        piVar1 = (int *)(param_3 + 0x14);
        if (*piVar1 == 0) {
          return -0x2c;
        }
        if (DAT_00557704 == '\0') {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_c = (ushort)uVar2;
        }
        else {
          uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
          local_c = (ushort)(uVar2 >> 8) & 0xff00 | (ushort)(byte)(uVar2 >> 0x18);
        }
      }
      param2 = FUN_004ba160(param_1,(char *)*param_2,&local_18,0x10,PTR_DAT_00551644,0x2000);
      if (param2 != 0) {
        printf("Get Session Id failed:%s %x\n",(char *)*param_2,param2);
      }
    }
  }
  return param2;
}



int FUN_004adab0(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  uint param2;
  ulong uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint local_10 [2];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    param2 = 0xffffffff;
  }
  else {
    if (DAT_00557704 == '\0') {
      local_10[0] = strtoul((char *)*piVar1,(char **)0x0,0);
    }
    else {
      uVar2 = strtoul((char *)*piVar1,(char **)0x0,0);
      local_10[0] = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    param2 = FUN_004ba0cc(param_1,(char *)*param_2,local_10,4,PTR_DAT_00551644,0x2000);
    if (param2 == 0) {
      if (DAT_00557704 == '\0') {
        uVar3 = *(uint *)PTR_DAT_00551644;
        uVar4 = *(uint *)(PTR_DAT_00551644 + 4);
        uVar5 = *(uint *)(PTR_DAT_00551644 + 8);
      }
      else {
        uVar3 = *(uint *)PTR_DAT_00551644;
        uVar3 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
        uVar4 = *(uint *)(PTR_DAT_00551644 + 4);
        uVar4 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
        uVar5 = *(uint *)(PTR_DAT_00551644 + 8);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      printf("Get Session Id(%d) info : \nKeep alive ipid       : %u\nKeep alive seq num    : %u\nKeep alive ack num    : %u\n"
             ,local_10[0],uVar3,uVar4,uVar5);
    }
    else {
      printf("Get Session connection info failed:%s %x\n",(char *)*param_2,param2);
    }
  }
  return param2;
}



int FUN_004add70(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  int *piVar3;
  uint uVar4;
  ulong uVar5;
  
  puVar1 = PTR_DAT_00551644;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    uVar4 = 0xffffffd4;
  }
  else {
    if (DAT_00557704 == '\0') {
      uVar4 = strtoul((char *)*piVar3,(char **)0x0,0);
    }
    else {
      uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
      uVar4 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    *(uint *)puVar1 = uVar4;
    piVar3 = (int *)(param_3 + 8);
    if (*piVar3 == 0) {
      uVar4 = 0xffffffd4;
    }
    else {
      if (DAT_00557704 == '\0') {
        uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
        uVar2 = (ushort)uVar5;
      }
      else {
        uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
        uVar2 = (ushort)uVar5 << 8 | (ushort)uVar5 >> 8;
      }
      *(ushort *)(puVar1 + 4) = uVar2;
      piVar3 = (int *)(param_3 + 0xc);
      if (*piVar3 == 0) {
        uVar4 = 0xffffffd4;
      }
      else {
        if (DAT_00557704 == '\0') {
          uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
          uVar2 = (ushort)uVar5;
        }
        else {
          uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
          uVar2 = (ushort)uVar5 << 8 | (ushort)uVar5 >> 8;
        }
        *(ushort *)(puVar1 + 6) = uVar2;
        printf("len = %d, id = %d\n",(uint)*(ushort *)(puVar1 + 6),*(int *)puVar1);
        if (*(int *)(param_3 + 0x10) == 0) {
          uVar4 = 0xffffffd4;
        }
        else {
          if ((*(short *)(puVar1 + 6) != 0) && (*(ushort *)(puVar1 + 6) < 0x10)) {
            memcpy(puVar1 + 8,*(void **)(param_3 + 0x10),(uint)*(ushort *)(puVar1 + 6));
          }
          uVar4 = FUN_004ba160(param_1,(char *)*param_2,puVar1,*(ushort *)(puVar1 + 6) + 0xb,
                               PTR_DAT_00551644,0x2000);
          if (uVar4 != 0) {
            printf("Get Session Id failed:%s %x\n",(char *)*param_2,uVar4);
          }
        }
      }
    }
  }
  return uVar4;
}



int FUN_004ae0f0(int *param_1,undefined4 *param_2,int param_3)

{
  undefined *puVar1;
  ushort uVar2;
  int *piVar3;
  uint uVar4;
  ulong uVar5;
  
  puVar1 = PTR_DAT_00551644;
  piVar3 = (int *)(param_3 + 4);
  if (*piVar3 == 0) {
    uVar4 = 0xffffffd4;
  }
  else {
    if (DAT_00557704 == '\0') {
      uVar4 = strtoul((char *)*piVar3,(char **)0x0,0);
    }
    else {
      uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
      uVar4 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    *(uint *)puVar1 = uVar4;
    if (*(int *)(param_3 + 8) == 0) {
      uVar4 = 0xffffffd4;
    }
    else {
      uVar5 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
      puVar1[4] = (char)uVar5;
      if (*(int *)(param_3 + 0xc) == 0) {
        uVar4 = 0xffffffd4;
      }
      else {
        uVar5 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
        puVar1[5] = (char)uVar5;
        piVar3 = (int *)(param_3 + 0x10);
        if (*piVar3 == 0) {
          uVar4 = 0xffffffd4;
        }
        else {
          if (DAT_00557704 == '\0') {
            uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
            uVar2 = (ushort)uVar5;
          }
          else {
            uVar5 = strtoul((char *)*piVar3,(char **)0x0,0);
            uVar2 = (ushort)uVar5 << 8 | (ushort)uVar5 >> 8;
          }
          *(ushort *)(puVar1 + 6) = uVar2;
          uVar4 = FUN_004ba160(param_1,(char *)*param_2,puVar1,8,PTR_DAT_00551644,0x2000);
          if (uVar4 != 0) {
            printf("Get Session Id failed:%s %x\n",(char *)*param_2,uVar4);
          }
        }
      }
    }
  }
  return uVar4;
}



undefined4 FUN_004ae3b4(int *param_1,undefined4 *param_2,int param_3)

{
  int *piVar1;
  undefined4 uVar2;
  size_t sVar3;
  uint param2;
  int local_90;
  undefined1 auStack_8c [132];
  
  piVar1 = (int *)(param_3 + 4);
  if (*piVar1 == 0) {
    uVar2 = 0xffffffd4;
  }
  else {
    sVar3 = strlen((char *)*piVar1);
    if (sVar3 < 0x101) {
      local_90 = FUN_0043dc20((char *)*piVar1,(int)auStack_8c);
      param2 = FUN_004ba160(param_1,(char *)*param_2,&local_90,0x84,PTR_DAT_00551644,0x2000);
      if (param2 != 0) {
        printf("set:%s %x\n",(char *)*param_2,param2);
      }
      uVar2 = 0;
    }
    else {
      uVar2 = 0xffffffd4;
    }
  }
  return uVar2;
}



undefined4 FUN_004ae4dc(int param_1,char *param_2)

{
  char *pcVar1;
  int param1;
  undefined4 uVar2;
  char *__nptr;
  char *__nptr_00;
  char *__nptr_01;
  char *__nptr_02;
  int iVar3;
  char local_14 [8];
  
  local_14[0] = ':';
  local_14[1] = ',';
  local_14[2] = '\0';
  local_14[3] = '\0';
  pcVar1 = strtok(param_2,local_14);
  param1 = atoi(pcVar1);
  if (param1 < 4) {
    pcVar1 = strtok((char *)0x0,local_14);
    __nptr = strtok((char *)0x0,local_14);
    __nptr_00 = strtok((char *)0x0,local_14);
    __nptr_01 = strtok((char *)0x0,local_14);
    __nptr_02 = strtok((char *)0x0,local_14);
    if ((((pcVar1 == (char *)0x0) || (__nptr == (char *)0x0)) || (__nptr_00 == (char *)0x0)) ||
       ((__nptr_01 == (char *)0x0 || (__nptr_02 == (char *)0x0)))) {
      fwrite(" invalid row data format or number of parameters\n",1,0x31,stderr);
      uVar2 = 0xfffffffe;
    }
    else {
      iVar3 = atoi(pcVar1);
      *(char *)(param_1 + param1 * 5) = (char)iVar3;
      iVar3 = atoi(__nptr);
      *(char *)(param_1 + param1 * 5 + 1) = (char)iVar3;
      iVar3 = atoi(__nptr_00);
      *(char *)(param_1 + param1 * 5 + 2) = (char)iVar3;
      iVar3 = atoi(__nptr_01);
      *(char *)(param_1 + param1 * 5 + 3) = (char)iVar3;
      iVar3 = atoi(__nptr_02);
      *(char *)(param_1 + param1 * 5 + 4) = (char)iVar3;
      printf("written table entry:%d: mode:%d, bt_pwr:%d, bt_rssi:%d, wl_rssi_high:%d, wl_rssi_low:%d\n"
             ,param1,(int)*(char *)(param_1 + param1 * 5),(int)*(char *)(param_1 + param1 * 5 + 1),
             (int)*(char *)(param_1 + param1 * 5 + 2),(int)*(char *)(param_1 + param1 * 5 + 3),
             (int)*(char *)(param_1 + param1 * 5 + 4));
      uVar2 = 0;
    }
  }
  else {
    fprintf(stderr," invalid index:%d the data:%s\n",param1,param_2);
    uVar2 = 0xfffffffe;
  }
  return uVar2;
}



int FUN_004ae818(int *param_1,undefined4 param_2,int param_3)

{
  undefined1 uVar1;
  int iVar2;
  char *param3;
  uint uVar3;
  char *param2;
  char *param4;
  int *local_res8;
  int local_c0;
  void *local_bc;
  int local_b8;
  undefined4 auStack_b0 [3];
  int local_a4;
  char local_9f;
  char local_9e;
  char *local_1c;
  int local_14;
  void *local_10 [2];
  
  local_bc = (void *)0x0;
  iVar2 = FUN_00445198(param_1,"btc_dynctl",(void *)0x0,0,local_10);
  local_c0 = -(iVar2 >> 0x1f);
  if (local_c0 == 0) {
    local_res8 = (int *)(param_3 + 4);
    if (*local_res8 == 0) {
      puts(" === btc dynctl: ===");
      if ((*(byte *)((int)local_10[0] + 1) & 1) == 0) {
        param2 = "Off";
      }
      else {
        param2 = "On";
      }
      if ((*(byte *)((int)local_10[0] + 1) & 2) == 0) {
        param3 = "Off";
      }
      else {
        param3 = "On";
      }
      if ((*(byte *)((int)local_10[0] + 1) & 4) == 0) {
        param4 = "Off";
      }
      else {
        param4 = "On";
      }
      printf("DYNCTL(0x%x): %s, Desense:%s, Mode:%s\n",(uint)*(byte *)((int)local_10[0] + 1),param2,
             param3,param4);
      printf("dflt_dsns_level:%d\n",(uint)*(byte *)((int)local_10[0] + 2));
      printf("low_dsns_level:%d\n",(uint)*(byte *)((int)local_10[0] + 3));
      printf("mid_dsns_level:%d\n",(uint)*(byte *)((int)local_10[0] + 4));
      printf("high_dsns_level:%d\n",(uint)*(byte *)((int)local_10[0] + 5));
      printf("btrssi msw hysteresis %d dBm\n",(int)*(char *)((int)local_10[0] + 6));
      printf("default_btc_mode:%d\n",(uint)*(byte *)((int)local_10[0] + 7));
      printf("--- coex mode switch data table msw_rows:%d ---\n",
             (uint)*(byte *)((int)local_10[0] + 8));
      local_b8 = 0;
      while( true ) {
        if (*(byte *)((int)local_10[0] + 8) < 5) {
          uVar3 = (uint)*(byte *)((int)local_10[0] + 8);
        }
        else {
          uVar3 = 4;
        }
        if ((int)uVar3 <= local_b8) break;
        printf("row:%d: btcmode:%d, bt_pwr:%d, bt_rssi:%d, wl_rssi_high:%d, wl_rssi_low:%d\n",
               local_b8,(int)*(char *)((int)local_10[0] + local_b8 * 5 + 10),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0xb),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0xc),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0xd),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0xe));
        local_b8 = local_b8 + 1;
      }
      printf("--- wl desense data table dsns_rows:%d ---\n",(uint)*(byte *)((int)local_10[0] + 9));
      local_b8 = 0;
      while( true ) {
        if (*(byte *)((int)local_10[0] + 9) < 5) {
          uVar3 = (uint)*(byte *)((int)local_10[0] + 9);
        }
        else {
          uVar3 = 4;
        }
        if ((int)uVar3 <= local_b8) break;
        printf("row:%d: btcmode:%d, bt_pwr:%d, bt_rssi:%d, wl_rssi_high:%d, wl_rssi_low:%d\n",
               local_b8,(int)*(char *)((int)local_10[0] + local_b8 * 5 + 0x1e),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0x1f),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0x20),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0x21),
               (int)*(char *)((int)local_10[0] + local_b8 * 5 + 0x22));
        local_b8 = local_b8 + 1;
      }
      local_bc = (void *)0x0;
    }
    else if ((*(char *)*local_res8 == 'h') || (*(char *)*local_res8 == '?')) {
      local_c0 = -0x2c;
    }
    else {
      local_bc = calloc(1,0x3a);
      if (local_bc == (void *)0x0) {
        return -0x1b;
      }
      bcopy(local_10[0],local_bc,0x32);
      FUN_004cbd80(auStack_b0,"wl_btcoex_dynctl",0,0);
      while (iVar2 = FUN_004cbe18(auStack_b0,local_res8), iVar2 != -1) {
        if (iVar2 == 1) {
          local_c0 = -0x2c;
          goto LAB_004af24c;
        }
        local_res8 = local_res8 + local_a4;
        uVar1 = (undefined1)local_14;
        if (local_9e == 'c') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for default_btc_mode\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 7) = uVar1;
        }
        if (local_9e == 'd') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for dflt_dsns_level\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 2) = uVar1;
        }
        if (local_9e == 'l') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for low_dsns_level\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 3) = uVar1;
        }
        if (local_9e == 'm') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for mid_dsns_level\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 4) = uVar1;
        }
        if (local_9e == 'h') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for high_dsns_level\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 5) = uVar1;
        }
        if (local_9e == 'f') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for flags \n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 1) = uVar1;
        }
        if (((local_9e == 'j') && (iVar2 = FUN_004ae4dc((int)local_bc + 10,local_1c), iVar2 != 0))
           || ((local_9e == 'k' && (iVar2 = FUN_004ae4dc((int)local_bc + 0x1e,local_1c), iVar2 != 0)
               ))) goto LAB_004af24c;
        uVar1 = (undefined1)local_14;
        if (local_9e == 'n') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for msw_rows\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          if (4 < local_14) {
            fprintf(stderr,"array index:%d >= MAX:%d !\n",local_14,4);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 8) = uVar1;
        }
        if (local_9e == 'o') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for dsns_rows\n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          if (4 < local_14) {
            fprintf(stderr,"array index;%d >= MAX:%d !\n",local_14,4);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 9) = uVar1;
        }
        if (local_9e == 's') {
          if (local_9f == '\0') {
            fprintf(stderr,"could not parse %s as an int for btrssi_hysteresis \n",local_1c);
            local_c0 = -2;
            goto LAB_004af24c;
          }
          *(undefined1 *)((int)local_bc + 6) = uVar1;
        }
      }
      iVar2 = FUN_00445444(param_1,"btc_dynctl",local_bc,0x32);
      local_c0 = -(iVar2 >> 0x1f);
      if (local_c0 != 0) {
        printf("btc_dynctl: fail to set %d\n",local_c0);
      }
    }
LAB_004af24c:
    if (local_bc != (void *)0x0) {
      free(local_bc);
    }
  }
  else {
    fwrite("btc_dynctl: getbuf ioctl failed\n",1,0x20,stderr);
  }
  return local_c0;
}



int FUN_004af280(int *param_1,undefined4 param_2,int param_3)

{
  ushort uVar1;
  int iVar2;
  char *param1;
  uint param1_00;
  undefined4 local_18;
  char local_14;
  char local_13;
  byte local_12;
  byte local_11;
  void *local_10 [2];
  
  if (*(int *)(param_3 + 4) == 0) {
    iVar2 = FUN_00445198(param_1,"btc_dynctl_status",(void *)0x0,0,local_10);
    iVar2 = -(iVar2 >> 0x1f);
    if (iVar2 == 0) {
      bcopy(local_10[0],&local_18,8);
      puts("--- btc dynctl status ---:");
      if ((char)local_18 == '\0') {
        param1 = "Off";
      }
      else {
        param1 = "On";
      }
      printf("simulation mode:%s\n",param1);
      if (DAT_00557704 == '\0') {
        param1_00 = (uint)(local_18 << 8) >> 0x10;
      }
      else {
        uVar1 = (ushort)((uint)local_18 >> 8);
        param1_00 = (uint)(ushort)(uVar1 << 8 | uVar1 >> 8);
      }
      printf("bt_pwr_shm %x\n",param1_00);
      printf("bt_pwr:%d dBm\n",(int)local_18._3_1_);
      printf("bt_rssi:%d dBm\n",(int)local_14);
      printf("wl_rssi:%d dBm\n",(int)local_13);
      printf("dsns_level:%d\n",(uint)local_12);
      printf("btc_mode:%d\n",(uint)local_11);
    }
    else {
      puts("btc_dynctl: getbuf ioctl failed");
    }
  }
  else {
    fwrite("command doesn\'t accept any params\n",1,0x22,stderr);
    iVar2 = -0x2c;
  }
  return iVar2;
}



int FUN_004af4a4(int *param_1,undefined4 *param_2,int param_3)

{
  undefined1 uVar1;
  int iVar2;
  int *piVar3;
  char *param1;
  int *local_res8;
  int local_b8;
  undefined1 *local_b4;
  undefined4 auStack_ac [3];
  int local_a0;
  char local_9b;
  char local_9a;
  char *local_18;
  undefined4 local_10;
  char *local_c;
  
  local_b4 = (undefined1 *)0x0;
  iVar2 = FUN_00445198(param_1,"btc_dynctl_sim",(void *)0x0,0,&local_c);
  local_b8 = -(iVar2 >> 0x1f);
  if (local_b8 == 0) {
    piVar3 = (int *)(param_3 + 4);
    if (*piVar3 == 0) {
      if (*local_c == '\0') {
        param1 = "Off";
      }
      else {
        param1 = "On";
      }
      printf("btc dynctl simulation mode:%s\n BT pwr:%ddBm\n BT rssi:%ddBm\n WL ssi:%ddBm\n",param1,
             (int)local_c[1],(int)local_c[2],(int)local_c[3]);
      local_b4 = (undefined1 *)0x0;
    }
    else if ((*(char *)*piVar3 == 'h') || (*(char *)*piVar3 == '?')) {
      local_b8 = -0x2c;
    }
    else {
      local_b4 = (undefined1 *)calloc(1,4);
      if (local_b4 == (undefined1 *)0x0) {
        return -0x1b;
      }
      bcopy(local_c,local_b4,4);
      if (*(char *)*piVar3 == '1') {
        *local_b4 = 1;
      }
      else if (*(char *)*piVar3 == '0') {
        *local_b4 = 0;
      }
      local_res8 = (int *)(param_3 + 8);
      FUN_004cbd80(auStack_ac,"wl_btcoex_dynctl_sim",0,0);
      while (iVar2 = FUN_004cbe18(auStack_ac,local_res8), iVar2 != -1) {
        if (iVar2 == 1) {
          local_b8 = -0x2c;
          goto LAB_004af884;
        }
        local_res8 = local_res8 + local_a0;
        uVar1 = (undefined1)local_10;
        if (local_9a == 'b') {
          if (local_9b == '\0') {
            fprintf(stderr,"could not parse %s as an int for sim_btpwr\n",local_18);
            local_b8 = -2;
            goto LAB_004af884;
          }
          local_b4[1] = uVar1;
        }
        if (local_9a == 'r') {
          if (local_9b == '\0') {
            fprintf(stderr,"could not parse %s as an int for sim_btrssi\n",local_18);
            local_b8 = -2;
            goto LAB_004af884;
          }
          local_b4[2] = uVar1;
        }
        if (local_9a == 'w') {
          if (local_9b == '\0') {
            fprintf(stderr,"could not parse %s as an int for sim_wlrssi\n",local_18);
            local_b8 = -2;
            goto LAB_004af884;
          }
          local_b4[3] = uVar1;
        }
      }
      iVar2 = FUN_00445444(param_1,"btc_dynctl_sim",local_b4,4);
      local_b8 = -(iVar2 >> 0x1f);
      if (local_b8 != 0) {
        printf("%s: failed to set %d\n",(char *)*param_2,local_b8);
      }
    }
LAB_004af884:
    if (local_b4 != (undefined1 *)0x0) {
      free(local_b4);
    }
  }
  else {
    puts("btc_dynctl: getbuf ioctl failed");
  }
  return local_b8;
}



void FUN_004af8c0(void)

{
  DAT_00559cb4 = FUN_0040165c();
  FUN_00401460(0x556260);
  return;
}



char * FUN_004af90c(byte *param_1,char *param_2)

{
  byte *local_18;
  char *local_14;
  int local_10;
  
  local_18 = param_1;
  local_14 = param_2;
  for (local_10 = 0; local_10 < 6; local_10 = local_10 + 1) {
    *local_14 = "0123456789abcdef"[*local_18 >> 4];
    local_14[1] = "0123456789abcdef"[*local_18 & 0xf];
    local_14[2] = ':';
    local_14 = local_14 + 3;
    local_18 = local_18 + 1;
  }
  local_14[-1] = '\0';
  return param_2;
}



undefined4 FUN_004afa08(undefined4 param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  undefined4 uVar2;
  char **local_res8;
  undefined **local_2c;
  char *local_28;
  undefined4 local_24;
  char *local_20;
  undefined *local_1c;
  undefined4 local_18;
  char *local_14;
  undefined *local_10;
  undefined4 local_c;
  
  local_28 = "enable";
  local_24 = 0;
  local_20 = "enable";
  local_1c = &DAT_005250ac;
  local_18 = 0;
  local_14 = "enable";
  local_10 = &DAT_005250b0;
  local_c = 0;
  local_2c = &PTR_s_config_00525064;
  local_res8 = (char **)(param_3 + 4);
  if (*local_res8 == (char *)0x0) {
    local_res8 = &local_28;
  }
  else if (**local_res8 == '1') {
    local_res8 = &local_20;
  }
  else if (**local_res8 == '0') {
    local_res8 = &local_14;
  }
  else {
    iVar1 = strcmp(*local_res8,"-h");
    if ((iVar1 == 0) || (iVar1 = strcmp(*local_res8,"help"), iVar1 == 0)) {
      return 0xffffffd4;
    }
  }
  while( true ) {
    if (*local_2c == (undefined *)0x0) {
      return 0xffffffd3;
    }
    iVar1 = strcmp(*local_2c,*local_res8);
    if (iVar1 == 0) break;
    local_2c = local_2c + 4;
  }
  if (local_2c[3] == (undefined *)0x0) {
    return 0xffffffd4;
  }
  uVar2 = (*(code *)local_2c[3])(param_1,local_2c,local_res8 + 1);
  return uVar2;
}



char * FUN_004afc08(char param_1)

{
  char *pcVar1;
  
  if (param_1 == '\x02') {
    pcVar1 = "P2P GO";
  }
  else if (param_1 == '\x04') {
    pcVar1 = "P2P GC";
  }
  else if (param_1 == '\x01') {
    pcVar1 = "P2P device";
  }
  else {
    pcVar1 = "Unknown";
  }
  return pcVar1;
}



undefined1 FUN_004afc90(byte param_1)

{
  undefined1 local_10 [12];
  
  local_10[0] = 0x10;
  local_10[1] = 0x20;
  local_10[2] = 0x40;
  return local_10[param_1];
}



char * FUN_004afce0(char param_1)

{
  char *pcVar1;
  
  if (param_1 == '\x01') {
    pcVar1 = "Publisher";
  }
  else if (param_1 == '\x02') {
    pcVar1 = "Subscriber";
  }
  else {
    pcVar1 = "Unknown";
  }
  return pcVar1;
}



int FUN_004afd54(int *param_1,void *param_2,ushort param_3)

{
  byte bVar1;
  short sVar2;
  int iVar3;
  undefined1 uVar4;
  int iVar5;
  char *pcVar6;
  undefined3 extraout_var;
  int iVar7;
  uint local_40;
  int local_2c;
  char acStack_28 [24];
  
  local_2c = 0;
  iVar5 = FUN_00445198(param_1,"p2p_nan",param_2,(uint)param_3,&local_2c);
  iVar3 = local_2c;
  if ((iVar5 == 0) && (local_2c != 0)) {
    sVar2 = *(short *)(local_2c + 2);
    if (sVar2 == 2) {
      FUN_004af90c((byte *)(local_2c + 0x16),acStack_28);
      pcVar6 = FUN_004afc08(*(char *)(iVar3 + 0x10));
      bVar1 = *(byte *)(iVar3 + 0x11);
      uVar4 = FUN_004afc90(*(byte *)(iVar3 + 0x12));
      printf("Device role = %s\nDevice address = %s\nChannel = %u\nAvailability resolution = %u TU\nRepeat = %u\nAvailability bitmap =%0x\nIE len =%u\n"
             ,pcVar6,acStack_28,(uint)bVar1,CONCAT31(extraout_var,uVar4),
             (uint)*(byte *)(iVar3 + 0x13),*(uint *)(iVar3 + 0x1e),(uint)*(ushort *)(iVar3 + 0x14));
      FUN_004be9f4("P2P IE",iVar3 + 0x22,(uint)*(ushort *)(iVar3 + 0x14));
    }
    else if (sVar2 == 4) {
      iVar7 = local_2c + 6;
      if (*(int *)(local_2c + 10) == 0) {
        puts("No service instances");
      }
      else {
        for (local_40 = 0; local_40 < *(uint *)(iVar3 + 10); local_40 = local_40 + 1) {
          pcVar6 = FUN_004afce0(*(char *)(iVar7 + (local_40 + 4) * 2 + 1));
          printf("service instance: %s id = %u\n",pcVar6,(uint)*(byte *)(iVar7 + (local_40 + 4) * 2)
                );
        }
        putchar(10);
      }
    }
    else if (sVar2 == 1) {
      if (*(char *)(local_2c + 6) == '\x01') {
        pcVar6 = "Enabled";
      }
      else {
        pcVar6 = "Disabled";
      }
      puts(pcVar6);
    }
    else {
      printf("Unknown command %d\n",(uint)*(ushort *)(local_2c + 2));
    }
  }
  return iVar5;
}



void FUN_004b0054(undefined1 *param_1,undefined2 param_2,ushort param_3)

{
  undefined2 uVar1;
  
  if (DAT_00559cb0 == '\0') {
    uVar1 = 1;
  }
  else {
    uVar1 = 0x100;
  }
  *param_1 = (char)uVar1;
  param_1[1] = (char)((ushort)uVar1 >> 8);
  param_1[2] = (char)param_2;
  param_1[3] = (char)((ushort)param_2 >> 8);
  if (DAT_00559cb0 != '\0') {
    param_3 = param_3 << 8 | param_3 >> 8;
  }
  param_1[4] = (char)param_3;
  param_1[5] = (char)(param_3 >> 8);
  return;
}



undefined4 FUN_004b01c0(int *param_1,int param_2,int *param_3)

{
  ushort uVar1;
  bool bVar2;
  undefined1 *__ptr;
  ulong uVar3;
  int iVar4;
  undefined3 extraout_var;
  size_t sVar5;
  char *__s1;
  int *piVar6;
  int *local_res8;
  undefined4 local_30;
  ushort local_2c;
  char *local_c;
  
  local_30 = 0;
  __ptr = (undefined1 *)calloc(1,0x206);
  if (__ptr == (undefined1 *)0x0) {
    local_30 = 0xffffffe5;
  }
  else {
    FUN_004b0054(__ptr,*(undefined2 *)(param_2 + 6),0x200);
    if (*param_3 == 0) {
      FUN_004afd54(param_1,__ptr,0x206);
    }
    else {
      local_2c = 0x1c;
      *(undefined2 *)(__ptr + 6) = 1;
      if (*param_3 == 0) {
        fprintf(stderr,"%s : Missing flags parameter.\n","wl_p2p_nan_subcmd_config");
        local_30 = 0xffffffd4;
      }
      else {
        uVar3 = strtoul((char *)*param_3,&local_c,0);
        if (*local_c == '\0') {
          if ((((uVar3 & 1) == 0) && ((uVar3 & 2) == 0)) && ((uVar3 & 4) == 0)) {
            fprintf(stderr,"%s : Invalid config type %0x\n","wl_p2p_nan_subcmd_config",uVar3);
            local_30 = 0xffffffd4;
          }
          else {
            *(ulong *)(__ptr + 10) = uVar3;
            if (param_3[1] == 0) {
              fprintf(stderr,"%s : Missing instance id parameter.\n","wl_p2p_nan_subcmd_config");
              local_30 = 0xffffffd4;
            }
            else {
              iVar4 = atoi((char *)param_3[1]);
              if ((iVar4 < 0) || (0xff < iVar4)) {
                fprintf(stderr,"%s : Invalid instance id.\n","wl_p2p_nan_subcmd_config");
                local_30 = 0xffffffd4;
              }
              else {
                __ptr[0xe] = (char)iVar4;
                if (param_3[2] == 0) {
                  fprintf(stderr,"%s : Missing instance type parameter.\n",
                          "wl_p2p_nan_subcmd_config");
                  local_30 = 0xffffffd4;
                }
                else {
                  piVar6 = param_3 + 3;
                  iVar4 = atoi((char *)param_3[2]);
                  if ((iVar4 < 1) || (2 < iVar4)) {
                    fprintf(stderr,"%s : Invalid instance type.\n","wl_p2p_nan_subcmd_config");
                    local_30 = 0xffffffd4;
                  }
                  else {
                    __ptr[0xf] = (char)iVar4;
                    if (*piVar6 == 0) {
                      fprintf(stderr,"%s : Missing device role parameter.\n",
                              "wl_p2p_nan_subcmd_config");
                      local_30 = 0xffffffd4;
                    }
                    else {
                      uVar3 = strtoul((char *)*piVar6,&local_c,0);
                      if (*local_c == '\0') {
                        if ((((uVar3 & 1) == 0) && ((uVar3 & 2) == 0)) && ((uVar3 & 4) == 0)) {
                          fprintf(stderr,"%s : Invalid device role.\n","wl_p2p_nan_subcmd_config");
                          local_30 = 0xffffffd4;
                        }
                        else {
                          __ptr[0x10] = (char)uVar3;
                          if (param_3[4] == 0) {
                            fprintf(stderr,"%s : Missing device mac address.\n",
                                    "wl_p2p_nan_subcmd_config");
                            local_30 = 0xffffffd4;
                          }
                          else {
                            bVar2 = FUN_0041d6ac((char *)param_3[4],__ptr + 0x16);
                            if (CONCAT31(extraout_var,bVar2) == 0) {
                              fprintf(stderr,"%s: Invalid ether addr provided\n",
                                      "wl_p2p_nan_subcmd_config");
                              local_30 = 0xffffffd4;
                            }
                            else if (param_3[5] == 0) {
                              fprintf(stderr,"%s : Missing channel.\n","wl_p2p_nan_subcmd_config");
                              local_30 = 0xffffffd4;
                            }
                            else {
                              iVar4 = atoi((char *)param_3[5]);
                              __ptr[0x11] = (char)iVar4;
                              if (param_3[6] == 0) {
                                fprintf(stderr,"%s : Missing availability duration.\n",
                                        "wl_p2p_nan_subcmd_config");
                                local_30 = 0xffffffd4;
                              }
                              else {
                                iVar4 = atoi((char *)param_3[6]);
                                if ((iVar4 < 0) || (2 < iVar4)) {
                                  fprintf(stderr,"%s : Invalid availability resolution.\n",
                                          "wl_p2p_nan_subcmd_config");
                                  local_30 = 0xffffffd4;
                                }
                                else {
                                  __ptr[0x12] = (char)iVar4;
                                  if (param_3[7] == 0) {
                                    fprintf(stderr,"%s : Missing availability repeat.\n",
                                            "wl_p2p_nan_subcmd_config");
                                    local_30 = 0xffffffd4;
                                  }
                                  else {
                                    piVar6 = param_3 + 8;
                                    iVar4 = atoi((char *)param_3[7]);
                                    if ((iVar4 < 0) || (1 < iVar4)) {
                                      fprintf(stderr,"%s : Invalid availability repeat.\n",
                                              "wl_p2p_nan_subcmd_config");
                                      local_30 = 0xffffffd4;
                                    }
                                    else {
                                      __ptr[0x13] = (char)iVar4;
                                      if (*piVar6 == 0) {
                                        fprintf(stderr,"%s : Missing availability bitmap.\n",
                                                "wl_p2p_nan_subcmd_config");
                                        local_30 = 0xffffffd4;
                                      }
                                      else {
                                        uVar3 = strtoul((char *)*piVar6,&local_c,0);
                                        if (*local_c == '\0') {
                                          *(ulong *)(__ptr + 0x1e) = uVar3;
                                          local_res8 = param_3 + 9;
                                          do {
                                            do {
                                              __s1 = (char *)*local_res8;
                                              local_res8 = local_res8 + 1;
                                              if (__s1 == (char *)0x0) {
                                                *(ushort *)(__ptr + 8) = local_2c;
                                                uVar1 = local_2c;
                                                if (DAT_00559cb0 != '\0') {
                                                  uVar1 = local_2c << 8 | local_2c >> 8;
                                                }
                                                __ptr[4] = (char)uVar1;
                                                __ptr[5] = (char)(uVar1 >> 8);
                                                local_30 = FUN_00445444(param_1,"p2p_nan",__ptr,
                                                                        (uint)(ushort)(local_2c + 6)
                                                                       );
                                                goto LAB_004b0ba4;
                                              }
                                              iVar4 = strcasecmp(__s1,"-ie");
                                            } while (iVar4 != 0);
                                            sVar5 = strlen((char *)*local_res8);
                                            local_2c = ((ushort)sVar5 >> 1) + local_2c;
                                            *(ushort *)(__ptr + 0x14) = (ushort)sVar5 >> 1;
                                            iVar4 = FUN_00459628((char *)*local_res8,__ptr + 0x22,
                                                                 (uint)*(ushort *)(__ptr + 0x14));
                                          } while (iVar4 == 0);
                                          local_30 = 0xfffffffe;
                                        }
                                        else {
                                          fprintf(stderr,"%s: Value is not uint or hex %s\n",
                                                  "wl_p2p_nan_subcmd_config",(char *)*piVar6);
                                          local_30 = 0xffffffd4;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      else {
                        fprintf(stderr,"%s: Value is not uint or hex %s\n",
                                "wl_p2p_nan_subcmd_config",(char *)*piVar6);
                        local_30 = 0xffffffd4;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else {
          fprintf(stderr,"%s: Value is not uint or hex %s\n","wl_p2p_nan_subcmd_config",
                  (char *)*param_3);
          local_30 = 0xffffffd4;
        }
      }
    }
LAB_004b0ba4:
    free(__ptr);
  }
  return local_30;
}



undefined4 FUN_004b0bcc(int *param_1,int param_2,int param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined1 *__ptr;
  
  iVar1 = FUN_0040192c(param_3);
  if (iVar1 == 0) {
    __ptr = (undefined1 *)calloc(1,6);
    if (__ptr == (undefined1 *)0x0) {
      uVar2 = 0xffffffe5;
    }
    else {
      FUN_004b0054(__ptr,*(undefined2 *)(param_2 + 6),0);
      uVar2 = FUN_00445444(param_1,"p2p_nan",__ptr,6);
      free(__ptr);
    }
  }
  else {
    uVar2 = 0xffffffd4;
  }
  return uVar2;
}



undefined4 FUN_004b0cb4(int *param_1,int param_2,int *param_3)

{
  undefined1 *__ptr;
  undefined4 local_18;
  
  local_18 = 0;
  __ptr = (undefined1 *)calloc(1,0x206);
  if (__ptr == (undefined1 *)0x0) {
    local_18 = 0xffffffe5;
  }
  else {
    FUN_004b0054(__ptr,*(undefined2 *)(param_2 + 6),0x200);
    if (*param_3 == 0) {
      FUN_004afd54(param_1,__ptr,0x206);
    }
    else {
      local_18 = 0xffffffd4;
    }
    free(__ptr);
  }
  return local_18;
}



void FUN_004b0d8c(int param_1)

{
  char *local_10;
  
  if (param_1 == 0) {
    local_10 = "auto";
  }
  else if (param_1 == 1) {
    local_10 = "non-master-non-sync";
  }
  else if (param_1 == 2) {
    local_10 = "non-master-sync";
  }
  else if (param_1 == 3) {
    local_10 = "master";
  }
  else if (param_1 == 4) {
    local_10 = "anchor-master";
  }
  else {
    local_10 = "undefined";
  }
  printf("> role %d: %s\n",param_1,local_10);
  return;
}



undefined4 FUN_004b0e98(char *param_1,ushort param_2)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  undefined4 uVar4;
  uint param3;
  char acStack_1c [20];
  
  if ((*param_1 == -0x23) && (6 < param_2)) {
    if (param_1[6] == '\0') {
      FUN_004af90c((byte *)(param_1 + 7),acStack_1c);
      bVar1 = param_1[0xd];
      bVar2 = param_1[0xe];
      param3 = *(uint *)(param_1 + 0xf);
      uVar3 = *(ushort *)(param_1 + 0x13);
      puts("----------------------------------------------------------------------");
      printf("RTT MAC %s Chanspec 0x%x Bitmap 0x%08x Mapcontrol 0x%x Proto %d\n",acStack_1c,
             (uint)uVar3,param3,(uint)bVar1,(uint)bVar2);
    }
    else if (param_1[6] == '\x01') {
      FUN_004be9f4(">P2P IE",(int)(param_1 + 7),param_2 - 7);
    }
    else {
      FUN_004be9f4("unKnown Vendor Specific Info",(int)param_1,(uint)param_2);
    }
    uVar4 = 0;
  }
  else {
    uVar4 = 0xffffffff;
  }
  return uVar4;
}



undefined4 FUN_004b1048(uint *param_1,ushort param_2)

{
  undefined4 uVar1;
  uint local_10;
  
  if (param_2 < 0x84) {
    uVar1 = 0xffffffff;
  }
  else {
    printf("Bitmap 0x%08x\n",*param_1);
    for (local_10 = 0; (int)local_10 < 0x20; local_10 = local_10 + 1) {
      if ((*param_1 & 1 << (local_10 & 0x1f)) != 0) {
        printf("Slot %d Chanspec %x\n",local_10,param_1[local_10 + 1]);
      }
    }
    uVar1 = 0;
  }
  return uVar1;
}



undefined4 FUN_004b1134(int param_1,uint *param_2,undefined2 param_3,ushort param_4)

{
  short sVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  char *param1;
  int iVar5;
  uint uVar6;
  size_t sVar7;
  ushort uVar8;
  undefined4 local_118;
  int local_114;
  char *local_110;
  char acStack_4c [68];
  
  local_118 = 0;
  sVar1 = *(short *)(param_1 + 2);
  switch(param_3) {
  case 0:
    local_118 = 0xffffffff;
    break;
  default:
    local_118 = 0xffffffff;
    break;
  case 0x102:
    FUN_004af90c((byte *)param_2,acStack_4c);
    if (sVar1 == 2) {
      printf("> if_addr:    %s\n",acStack_4c);
    }
    else {
      printf("> macaddr:    %s\n",acStack_4c);
    }
    break;
  case 0x103:
    uVar6 = *param_2;
    if (DAT_00559cb0 != '\0') {
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("Reason %d\n",uVar6);
    break;
  case 0x104:
    if (sVar1 == 5) {
      printf("> merge: %d\n",(uint)(byte)*param_2);
    }
    else {
      if ((byte)*param_2 == 0) {
        param1 = "disabled";
      }
      else {
        param1 = "enabled";
      }
      printf("> nan: %s\n",param1);
    }
    break;
  case 0x120:
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[2];
    }
    else {
      uVar6 = param_2[2];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> flags:0x%04x ",uVar6);
    if ((param_2[2] & 0x1000) != 0) {
      printf(" unsolicited/active");
    }
    if ((param_2[2] & 0x2000) != 0) {
      printf(" solicited");
    }
    if (((param_2[2] & 0x1000) == 0) && ((param_2[2] & 0x2000) == 0)) {
      printf(" passive");
    }
    if ((param_2[2] & 0x20000) != 0) {
      printf(" follow-up");
    }
    putchar(10);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[1];
    }
    else {
      uVar6 = param_2[1];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> ttl:0x%08x |",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = *param_2;
    }
    else {
      uVar6 = *param_2;
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf(" period:%d\n",uVar6);
    break;
  case 0x121:
    if (param_4 != 0) {
      FUN_004be9f4("> Match RX",(int)param_2,(uint)param_4);
    }
    break;
  case 0x122:
    if (param_4 != 0) {
      FUN_004be9f4("> Match TX",(int)param_2,(uint)param_4);
    }
    break;
  case 0x123:
    if (param_4 != 0) {
      FUN_004be9f4("> Service Info",(int)param_2,(uint)param_4);
    }
    break;
  case 0x124:
    printf("> Service Name:%.*s\n",6,(char *)param_2);
    break;
  case 0x125:
    puts("------------------");
    printf("> Instance ID:0x%02x\n",(uint)(byte)*param_2);
    break;
  case 0x128:
    if (param_4 != 0) {
      FUN_004b0e98((char *)param_2,param_4);
    }
    break;
  case 0x129:
    if (param_4 != 0) {
      FUN_004be9f4("> SRF",(int)param_2,(uint)param_4);
    }
    break;
  case 0x130:
    if (param_4 != 0) {
      FUN_004be9f4("> Follow-Up",(int)param_2,(uint)param_4);
    }
    break;
  case 0x131:
    printf("> Peer Instance ID:0x%02x\n",(uint)(byte)*param_2);
    break;
  case 0x140:
    printf("> discovery window length:%d\n",(uint)(ushort)*param_2);
    break;
  case 0x141:
    printf("> bcn interval:%d\n",(uint)(ushort)*param_2);
    break;
  case 0x142:
    if (sVar1 == 0x30) {
      puts("-------------------------------");
    }
    FUN_004af90c((byte *)param_2,acStack_4c);
    printf("> cluster_id: %s\n",acStack_4c);
    break;
  case 0x145:
    FUN_004b0d8c(*param_2);
    break;
  case 0x147:
    uVar6 = *param_2;
    printf("> master preference:%d \n",(ushort)uVar6 & 0xff);
    printf("> rnd_factor:%d\n",(uint)(ushort)((ushort)uVar6 >> 8));
    break;
  case 0x148:
    break;
  case 0x149:
    printf("> pre_tbtt_override:%d\n",(uint)(ushort)*param_2);
    break;
  case 0x14a:
    printf("> inited:%d\n",(uint)(byte)*param_2);
    break;
  case 0x14b:
    printf("> joined:%d\n",(uint)(byte)*param_2);
    break;
  case 0x14c:
    uVar2 = (ushort)*param_2;
    iVar5 = FUN_004c0fc0(uVar2);
    if (iVar5 == 0) {
      printf("> chanspec: invalid  0x%x\n",(uint)uVar2);
    }
    else {
      FUN_004c02bc(uVar2,acStack_4c);
      printf("> chanspec:%s 0x%x\n",acStack_4c,(uint)uVar2);
    }
    break;
  case 0x14d:
    FUN_004be9f4("> amr",(int)param_2,8);
    break;
  case 0x14e:
    printf("> hop_count:%d\n",(uint)(byte)*param_2);
    break;
  case 0x14f:
    printf("> ambtt:0x%x\n",*param_2);
    break;
  case 0x150:
    printf("> ratespec:0x%x\n",*param_2);
    break;
  case 0x151:
    printf("> inited:%d\n",(uint)(byte)*param_2);
    printf("> joined:%d\n",(uint)*(byte *)((int)param_2 + 1));
    FUN_004b0d8c((uint)*(byte *)((int)param_2 + 2));
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[1] & 0xffff;
    }
    else {
      uVar6 = (uint)(ushort)((ushort)param_2[1] << 8 | (ushort)param_2[1] >> 8);
    }
    param_2[1] = uVar6;
    iVar5 = FUN_004c0fc0((ushort)param_2[1]);
    if (iVar5 == 0) {
      printf("> chanspec: invalid  0x%x\n",param_2[1]);
    }
    else {
      FUN_004c02bc((ushort)param_2[1],acStack_4c);
      printf("> chanspec:%s 0x%x\n",acStack_4c,param_2[1]);
    }
    printf("> hop_count:%d\n",(uint)*(byte *)((int)param_2 + 3));
    FUN_004af90c((byte *)(param_2 + 9),acStack_4c);
    printf("> cluster_id: %s\n",acStack_4c);
    FUN_004be9f4("> amr",(int)(param_2 + 2),8);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[4];
    }
    else {
      uVar6 = param_2[4];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> cnt_pend_txfrm:%d\n",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[5];
    }
    else {
      uVar6 = param_2[5];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> cnt_bcn_tx:%d\n",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[6];
    }
    else {
      uVar6 = param_2[6];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> cnt_bcn_rx:%d\n",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[7];
    }
    else {
      uVar6 = param_2[7];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> cnt_svc_disc_tx:%d\n",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[8];
    }
    else {
      uVar6 = param_2[8];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> cnt_svc_disc_rx:%d\n",uVar6);
    break;
  case 0x152:
    if (DAT_00559cb0 == '\0') {
      uVar2 = (ushort)param_2[2];
    }
    else {
      uVar2 = (ushort)param_2[2] << 8 | (ushort)param_2[2] >> 8;
    }
    uVar6 = (uint)uVar2;
    if (uVar6 < 9) {
      local_110 = acStack_4c;
      for (local_114 = 0; local_114 < (int)uVar6; local_114 = local_114 + 1) {
        FUN_004c02bc(*(ushort *)((int)param_2 + (local_114 + 4) * 2 + 4),local_110);
        sVar7 = strlen(local_110);
        local_110[sVar7] = ',';
        local_110 = local_110 + sVar7 + 1;
      }
      local_110[-1] = '\0';
      if (DAT_00559cb0 == '\0') {
        uVar2 = (ushort)*param_2;
      }
      else {
        uVar2 = (ushort)*param_2 << 8 | (ushort)*param_2 >> 8;
      }
      if (DAT_00559cb0 == '\0') {
        uVar3 = *(ushort *)((int)param_2 + 2);
      }
      else {
        uVar3 = *(ushort *)((int)param_2 + 2) << 8 | *(ushort *)((int)param_2 + 2) >> 8;
      }
      if (DAT_00559cb0 == '\0') {
        uVar4 = (ushort)param_2[1];
      }
      else {
        uVar4 = (ushort)param_2[1] << 8 | (ushort)param_2[1] >> 8;
      }
      if (DAT_00559cb0 == '\0') {
        uVar8 = *(ushort *)((int)param_2 + 6);
      }
      else {
        uVar8 = *(ushort *)((int)param_2 + 6) << 8 | *(ushort *)((int)param_2 + 6) >> 8;
      }
      printf("scan params:\nscan_time:%d \nhome_time:%d \nmerge_scan_interval:%d \nmerge_scan_duration:%d\nchcnt:%d \nchlist:%s\n"
             ,(uint)uVar2,(uint)uVar3,(uint)uVar4,(uint)uVar8,uVar6,acStack_4c);
    }
    break;
  case 0x153:
    if (DAT_00559cb0 == '\0') {
      uVar2 = *(ushort *)((int)param_2 + 2);
    }
    else {
      uVar2 = *(ushort *)((int)param_2 + 2) << 8 | *(ushort *)((int)param_2 + 2) >> 8;
    }
    if (DAT_00559cb0 == '\0') {
      uVar3 = (ushort)param_2[2];
    }
    else {
      uVar3 = (ushort)param_2[2] << 8 | (ushort)param_2[2] >> 8;
    }
    printf("> debug params:\n  enabled:%d\n  collect:%d\n  msglevel:0x%x\n  last cmd:%x\n  status:%d\n"
           ,(uint)(byte)*param_2,(uint)*(byte *)((int)param_2 + 1),param_2[1],(uint)uVar2,
           (uint)uVar3);
    break;
  case 0x154:
    puts("------------------");
    printf("> Subscriber ID: %d\n",(uint)(byte)*param_2);
    break;
  case 0x155:
    puts("------------------");
    printf("> Publish ID: %d\n",(uint)(byte)*param_2);
    break;
  case 0x156:
    uVar6 = *param_2;
    if (DAT_00559cb0 != '\0') {
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> event_mask: %x\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n  %s:%d\n %s:%d\n"
           ,uVar6,"WL_NAN_EVENT_START",(uint)((uVar6 & 1) != 0),"WL_NAN_EVENT_JOIN",
           (uint)((uVar6 & 2) != 0),"WL_NAN_EVENT_ROLE",(uint)((uVar6 & 4) != 0),
           "WL_NAN_EVENT_SCAN_COMPLETE",(uint)((uVar6 & 8) != 0),"WL_NAN_EVENT_DISCOVERY_RESULT",
           (uint)((uVar6 & 0x10) != 0),"WL_NAN_EVENT_REPLIED",(uint)((uVar6 & 0x20) != 0),
           "WL_NAN_EVENT_TERMINATED",(uint)((uVar6 & 0x40) != 0),"WL_NAN_EVENT_RECEIVE",
           (uint)((uVar6 & 0x80) != 0),"WL_NAN_EVENT_STATUS_CHG",(uint)((uVar6 & 0x100) != 0),
           "WL_NAN_EVENT_MERGE",(uint)((uVar6 & 0x200) != 0),"WL_NAN_EVENT_STOP",
           (uint)((uVar6 & 0x400) != 0),"WL_NAN_EVENT_P2P",(uint)((uVar6 & 0x800) != 0));
    break;
  case 0x158:
    FUN_004be9f4("> master_rank",(int)param_2,8);
    break;
  case 0x159:
    printf("> warm_up_time:%d\n",(uint)(ushort)*param_2);
    break;
  case 0x15a:
    uVar6 = *param_2;
    if (DAT_00559cb0 != '\0') {
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("> pm_option:0x%x\n",uVar6);
    break;
  case 0x15b:
    uVar6 = *param_2;
    if (DAT_00559cb0 != '\0') {
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf("OUI %02X-%02X-%02X type %02X\n",uVar6 & 0xff,uVar6 >> 8 & 0xff,uVar6 >> 0x10 & 0xff,
           uVar6 >> 0x18);
    break;
  case 0x15c:
    printf("NAN Counter:");
    if (DAT_00559cb0 == '\0') {
      uVar6 = *param_2;
    }
    else {
      uVar6 = *param_2;
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf(" nan_bcn_tx %d",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[1];
    }
    else {
      uVar6 = param_2[1];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf(" nan_bcn_rx %d",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[2];
    }
    else {
      uVar6 = param_2[2];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf(" nan_svc_disc_tx %d",uVar6);
    if (DAT_00559cb0 == '\0') {
      uVar6 = param_2[3];
    }
    else {
      uVar6 = param_2[3];
      uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
    }
    printf(" nan_svc_disc_rx %d\n",uVar6);
    break;
  case 0x160:
    if (param_4 != 0) {
      FUN_004b1048(param_2,param_4);
    }
    break;
  case 0x162:
    printf("> idle_dw_timeout:%d\n",(uint)(ushort)*param_2);
    break;
  case 0x163:
    printf("> idle_dw_len:%d\n",(uint)(ushort)*param_2);
  }
  return local_118;
}



int FUN_004b2b68(int *param_1,undefined4 param_2,int *param_3)

{
  int __fd;
  int iVar1;
  void *__buf;
  ssize_t sVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uVar5;
  int local_98;
  sockaddr local_64;
  char acStack_50 [16];
  char local_40 [16];
  char local_30 [16];
  uint local_20;
  char acStack_1c [12];
  byte local_10;
  
  builtin_strncpy(local_30,"eth0",5);
  local_30[5] = 0;
  local_30[6] = 0;
  local_30[7] = 0;
  local_30[8] = 0;
  local_30[9] = 0;
  local_30[10] = 0;
  local_30[0xb] = 0;
  local_30[0xc] = 0;
  local_30[0xd] = 0;
  local_30[0xe] = 0;
  local_30[0xf] = 0;
  if (*param_3 == 0) {
    puts("<ifname> param is missing");
    local_98 = -1;
  }
  else {
    strncpy(local_30,(char *)*param_3,0xf);
    printf("ifname:%s\n",local_30);
    bzero(acStack_50,0x20);
    strncpy(acStack_50,local_30,0xf);
    local_98 = FUN_004ba1f8(param_1,"event_msgs",acStack_1c,0x10);
    if (local_98 == 0) {
      local_10 = local_10 | 0x10;
      local_98 = FUN_004ba2e4(param_1,"event_msgs",acStack_1c,0x10);
      if (local_98 == 0) {
        __fd = socket(0x11,3,0x6c88);
        if (__fd < 0) {
          printf("Cannot create socket %d\n",__fd);
          local_98 = -1;
        }
        else {
          iVar1 = ioctl(__fd,0x8933,acStack_50);
          if (iVar1 < 0) {
            printf("Cannot get iface:%s index \n",acStack_50);
          }
          else {
            bzero(&local_64,0x14);
            local_64.sa_family = 0x11;
            local_64.sa_data[0] = -0x78;
            local_64.sa_data[1] = 'l';
            local_64.sa_data[2] = local_40[0];
            local_64.sa_data[3] = local_40[1];
            local_64.sa_data[4] = local_40[2];
            local_64.sa_data[5] = local_40[3];
            iVar1 = bind(__fd,&local_64,0x14);
            if (iVar1 < 0) {
              printf("Cannot bind %d\n",iVar1);
            }
            else {
              __buf = malloc(0x200);
              if (__buf != (void *)0x0) {
                printf("wating for NAN events on iface:%s\n",acStack_50);
                do {
                  do {
                    while( true ) {
                      fflush(stdout);
                      sVar2 = recv(__fd,__buf,0x200,0);
                      if (0 < sVar2) break;
                      putchar(0x2e);
                    }
                    uVar3 = *(uint *)((int)__buf + 0x1c);
                    uVar4 = *(uint *)((int)__buf + 0x24);
                    local_20 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                               uVar4 >> 0x18;
                    uVar5 = *(undefined4 *)((int)__buf + 0x2c);
                  } while ((uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 |
                           uVar3 >> 0x18) != 100);
                  local_98 = 0;
                  switch(local_20) {
                  default:
                    printf("WARNING: unimplemented NAN APP EVENT code:%d\n",local_20);
                    local_98 = -1;
                    break;
                  case 1:
                    puts("WL_NAN_EVENT_START:");
                    break;
                  case 2:
                    puts("WL_NAN_EVENT_JOIN:");
                    break;
                  case 3:
                    puts("WL_NAN_EVENT_ROLE:");
                    break;
                  case 4:
                    puts("WL_NAN_EVENT_SCAN_COMPLETE:");
                    break;
                  case 5:
                    puts("WL_NAN_EVENT_DISCOVERY_RESULT:");
                    break;
                  case 6:
                    puts("WL_NAN_EVENT_REPLIED:");
                    break;
                  case 7:
                    puts("WL_NAN_EVENT_TERMINATED:");
                    break;
                  case 8:
                    puts("WL_NAN_EVENT_RECEIVE:");
                    break;
                  case 9:
                    puts("WL_NAN_EVENT_STATUS_CHG:");
                    break;
                  case 10:
                    puts("WL_NAN_EVENT_MERGE:");
                    break;
                  case 0xb:
                    puts("WL_NAN_EVENT_STOP:");
                    break;
                  case 0xc:
                    puts("WL_NAN_EVENT_P2P:");
                  }
                  if (local_98 == 0) {
                    FUN_004d3f1c(&local_20,(undefined2 *)((int)__buf + 0x48),
                                 (ushort)((uint)uVar5 >> 8) & 0xff00 |
                                 (ushort)(byte)((uint)uVar5 >> 0x18),1,FUN_004b1134);
                  }
                } while( true );
              }
              printf("Cannot not allocate %d bytes for events receive buffer\n",0x200);
            }
          }
          close(__fd);
          local_98 = FUN_004ba1f8(param_1,"event_msgs",acStack_1c,0x10);
          if (local_98 == 0) {
            local_10 = local_10 & 0xef;
            local_98 = FUN_004ba2e4(param_1,"event_msgs",acStack_1c,0x10);
          }
          fflush(stdout);
        }
      }
    }
    else {
      puts("couldn\'t read event_msgs");
    }
  }
  return local_98;
}



int FUN_004b3288(int *param_1,void *param_2,ushort param_3)

{
  int local_10;
  int local_c;
  
  local_c = 0;
  local_10 = FUN_00445198(param_1,"nan",param_2,(uint)param_3,&local_c);
  if ((local_10 == 0) && (local_c != 0)) {
    local_10 = FUN_004d3f1c(param_2,(undefined2 *)(local_c + 8),*(ushort *)(local_c + 4),1,
                            FUN_004b1134);
  }
  return local_10;
}



int FUN_004b3354(int *param_1,int param_2,int *param_3)

{
  short sVar1;
  undefined2 uVar2;
  undefined1 *__ptr;
  uint uVar3;
  int iVar4;
  int local_1a8;
  byte local_1a4;
  char acStack_190 [376];
  undefined1 *local_18;
  ushort local_14 [2];
  uint local_10 [2];
  
  memcpy(acStack_190,
         "nan event_msgs [bit] [0/1]\n\tbit 0 - WL_NAN_EVENT_START\n\tbit 1 - WL_NAN_EVENT_JOIN\n\tbit 2 - WL_NAN_EVENT_ROLE\n\tbit 3 - WL_NAN_EVENT_SCAN_COMPLETE\n\tbit 4 - WL_NAN_EVENT_DISCOVERY_RESULT\n\tbit 5 - WL_NAN_EVENT_REPLIED\n\tbit 6 - WL_NAN_EVENT_TERMINATED\n\tbit 7 - WL_NAN_EVENT_RECEIVE\n\tbit 8 - WL_NAN_EVENT_STATUS_CHG\n\tbit 10 ..30 - unused\n   bit 31 -  set/clr all eventmask bits\n"
         ,0x175);
  __ptr = (undefined1 *)calloc(1,0x100);
  if (__ptr == (undefined1 *)0x0) {
    local_1a8 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar2 = 1;
    }
    else {
      uVar2 = 0x100;
    }
    *__ptr = (char)uVar2;
    __ptr[1] = (char)((ushort)uVar2 >> 8);
    uVar2 = *(undefined2 *)(param_2 + 6);
    __ptr[2] = (char)uVar2;
    __ptr[3] = (char)((ushort)uVar2 >> 8);
    __ptr[4] = 8;
    __ptr[5] = 0;
    sVar1 = *(short *)(__ptr + 4);
    if (*param_3 == 0) {
      local_1a8 = FUN_004b3288(param_1,__ptr,sVar1 + 9U);
    }
    else {
      local_1a4 = 3;
      local_18 = __ptr + 8;
      local_14[0] = *(ushort *)(__ptr + 4);
      uVar3 = atoi((char *)*param_3);
      if (*(char *)*param_3 == '-') {
        fprintf(stderr,"%s\n",acStack_190);
        local_1a8 = -2;
      }
      else if ((byte)uVar3 < 0x20) {
        if (param_3[1] != 0) {
          iVar4 = atoi((char *)param_3[1]);
          local_1a4 = (byte)iVar4;
        }
        if (local_1a4 < 2) {
          if ((byte)uVar3 == 0x1f) {
            local_10[0] = 0x7fffffff;
          }
          else {
            local_10[0] = 1 << (uVar3 & 0x1f);
          }
          if (local_1a4 == 0) {
            local_10[0] = ~local_10[0];
          }
          if (DAT_00559cb0 != '\0') {
            local_10[0] = local_10[0] << 0x18 | (local_10[0] & 0xff00) << 8 |
                          (local_10[0] & 0xff0000) >> 8 | local_10[0] >> 0x18;
          }
          FUN_004d3d98((int *)&local_18,local_14,0x156,4,local_10,1);
          local_1a8 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(sVar1 + 9U));
        }
        else {
          fwrite("2nd param should be [0|1]\n",1,0x1a,stderr);
          fprintf(stderr,"%s\n",acStack_190);
          local_1a8 = -2;
        }
      }
      else {
        fwrite("1st param should be [0..31]\n",1,0x1c,stderr);
        fprintf(stderr,"%s\n",acStack_190);
        local_1a8 = -2;
      }
    }
    if (local_1a8 != 0) {
      printf("error:%d \n",local_1a8);
    }
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_1a8;
}



int FUN_004b37e4(int *param_1,int param_2,int *param_3)

{
  short sVar1;
  undefined2 uVar2;
  undefined1 *__ptr;
  int iVar3;
  uint uVar4;
  int local_1d8;
  ushort local_1d4;
  undefined1 uStack_1c0;
  undefined1 local_1bf;
  uint local_1bc;
  char acStack_1b4 [416];
  undefined1 *local_14;
  ushort local_10 [4];
  
  local_1d8 = -2;
  memcpy(acStack_1b4,
         "> nan debug -ml [bitnum] [0/1]\nml [bitnums]: \n\tbit 0 - on/off all trace messages, if==0 other levels won\'t print\n\tbit 1 - nan_mac trace\n\tbit 2 - nan_disc\n\tbit 3 - nan_cmn\n\tbit 4 - nan_iov\n\tbit 5 - nan_app_svc, ibss, rtt etc\n\tbit 6 - nan warnings\n\tbit 7 - nan state transitions\n\tbit 8 - nan_mac timing (tsf, etc)\n\tbit 9 - nan events\n\tbit 10..30 - unused\n\tbit 31 - set/clr all [0..30] bits\n> nan debug collect [0/1]\n"
         ,0x19f);
  __ptr = (undefined1 *)calloc(1,0x100);
  if (__ptr == (undefined1 *)0x0) {
    local_1d8 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar2 = 1;
    }
    else {
      uVar2 = 0x100;
    }
    *__ptr = (char)uVar2;
    __ptr[1] = (char)((ushort)uVar2 >> 8);
    uVar2 = *(undefined2 *)(param_2 + 6);
    __ptr[2] = (char)uVar2;
    __ptr[3] = (char)((ushort)uVar2 >> 8);
    __ptr[4] = 0x10;
    __ptr[5] = 0;
    sVar1 = *(short *)(__ptr + 4);
    if (*param_3 == 0) {
      local_1d8 = FUN_004b3288(param_1,__ptr,sVar1 + 9U);
    }
    else {
      local_14 = __ptr + 8;
      local_10[0] = *(ushort *)(__ptr + 4);
      for (local_1d4 = 0; param_3[local_1d4] != 0; local_1d4 = local_1d4 + 1) {
        iVar3 = strcmp((char *)param_3[local_1d4],"-ml");
        if (iVar3 == 0) {
          if (param_3[(ushort)(local_1d4 + 1)] == 0) {
            fprintf(stderr,"%s\n",acStack_1b4);
            goto LAB_004b3d60;
          }
          uVar4 = atoi((char *)param_3[(ushort)(local_1d4 + 1)]);
          if (0x1f < (byte)uVar4) {
            fprintf(stderr,"%s\n","1st param should be [0..31]\n");
            local_1d8 = -2;
            goto LAB_004b3d60;
          }
          local_1d4 = local_1d4 + 2;
          if (param_3[local_1d4] == 0) {
            fprintf(stderr,"%s\n",acStack_1b4);
            local_1d8 = -2;
            goto LAB_004b3d60;
          }
          iVar3 = atoi((char *)param_3[local_1d4]);
          if (1 < (byte)iVar3) {
            fprintf(stderr,"%s\n","2nd param should be [0|1]\n");
            local_1d8 = -2;
            goto LAB_004b3d60;
          }
          if ((byte)uVar4 == 0x1f) {
            local_1bc = 0x7fffffff;
          }
          else {
            local_1bc = 1 << (uVar4 & 0x1f);
          }
          if ((byte)iVar3 == 0) {
            local_1bc = ~local_1bc;
          }
          if (DAT_00559cb0 != '\0') {
            local_1bc = local_1bc << 0x18 | (local_1bc & 0xff00) << 8 | (local_1bc & 0xff0000) >> 8
                        | local_1bc >> 0x18;
          }
        }
        else {
          iVar3 = strcmp((char *)param_3[local_1d4],"-cl");
          if (iVar3 != 0) {
            fprintf(stderr,"%s\n",acStack_1b4);
            goto LAB_004b3d60;
          }
          local_1d4 = local_1d4 + 1;
          iVar3 = atoi((char *)param_3[local_1d4]);
          if (iVar3 == 0) goto LAB_004b3d60;
          iVar3 = atoi((char *)param_3[local_1d4]);
          local_1bf = (undefined1)iVar3;
        }
      }
      FUN_004d3d98((int *)&local_14,local_10,0x153,0xc,&uStack_1c0,1);
      local_1d8 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(sVar1 + 9U));
    }
LAB_004b3d60:
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_1d8;
}



int FUN_004b3d94(int *param_1,int param_2,int *param_3)

{
  short sVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined1 *__ptr;
  int iVar4;
  int *local_res8;
  int local_f8;
  int local_f4;
  int local_f0;
  undefined4 auStack_cc [3];
  int local_c0;
  char local_bb;
  char local_ba;
  char *local_38;
  undefined4 local_34;
  undefined4 local_2c;
  ushort local_28 [4];
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined1 *local_10;
  ushort local_c [2];
  
  local_2c = 0;
  local_28[0] = 0;
  local_28[1] = 0;
  local_28[2] = 0;
  local_28[3] = 0;
  local_18 = 0;
  local_14 = 0;
  local_20 = 0xd02c1006;
  local_1c = 0xd095;
  __ptr = (undefined1 *)calloc(1,0x100);
  if (__ptr == (undefined1 *)0x0) {
    local_f8 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar2 = 1;
    }
    else {
      uVar2 = 0x100;
    }
    *__ptr = (char)uVar2;
    __ptr[1] = (char)((ushort)uVar2 >> 8);
    uVar2 = *(undefined2 *)(param_2 + 6);
    __ptr[2] = (char)uVar2;
    __ptr[3] = (char)((ushort)uVar2 >> 8);
    __ptr[4] = 0x20;
    __ptr[5] = 0;
    sVar1 = *(short *)(__ptr + 4);
    if (*param_3 == 0) {
      local_f8 = FUN_004b3288(param_1,__ptr,sVar1 + 9U);
    }
    else {
      local_f4 = 0;
      local_10 = __ptr + 8;
      local_c[0] = *(ushort *)(__ptr + 4);
      FUN_004cbd80(auStack_cc,"scan_params",0,0);
      local_res8 = param_3;
      while( true ) {
        iVar4 = FUN_004cbe18(auStack_cc,local_res8);
        if (iVar4 == -1) break;
        if (iVar4 == 1) {
          local_f8 = -0x2c;
          goto LAB_004b44fc;
        }
        local_res8 = local_res8 + local_c0;
        uVar2 = (undefined2)local_34;
        if (local_ba == 's') {
          if (local_bb == '\0') {
            fprintf(stderr,"%s: option value %s\" is not an integer\n","scan_params",local_38);
            local_f8 = -2;
            goto LAB_004b44fc;
          }
          local_2c = CONCAT22(local_2c._2_2_,uVar2);
          local_f4 = local_f4 + 1;
        }
        if (local_ba == 'h') {
          if (local_bb == '\0') {
            fprintf(stderr,"%s: option value %s\" is not an integer\n","scan_params",local_38);
            local_f8 = -2;
            goto LAB_004b44fc;
          }
          local_2c = CONCAT22(uVar2,(ushort)local_2c);
          local_f4 = local_f4 + 1;
        }
        if (local_ba == 'i') {
          if (local_bb == '\0') {
            fprintf(stderr,"%s: option value %s\" is not an integer\n","scan_params",local_38);
            local_f8 = -2;
            goto LAB_004b44fc;
          }
          local_28[0] = uVar2;
          local_f4 = local_f4 + 1;
        }
        if (local_ba == 'd') {
          if (local_bb == '\0') {
            fprintf(stderr,"%s: option value %s\" is not an integer\n","scan_params",local_38);
            local_f8 = -2;
            goto LAB_004b44fc;
          }
          local_28[1] = uVar2;
          local_f4 = local_f4 + 1;
        }
        if (local_ba == 'c') {
          iVar4 = FUN_00422494(local_38,(int)&local_20,8);
          if (iVar4 == -1 || 7 < iVar4) {
            fwrite("error parsing channel list arg\n",1,0x1f,stderr);
            local_f8 = -2;
            goto LAB_004b44fc;
          }
          for (local_f0 = 0; local_f0 < iVar4; local_f0 = local_f0 + 1) {
            if (DAT_00559cb0 == '\0') {
              uVar3 = local_28[local_f0 + 4];
            }
            else if (DAT_00559cb0 == '\0') {
              uVar3 = local_28[local_f0 + 4];
            }
            else {
              uVar3 = local_28[local_f0 + 4] << 8 | local_28[local_f0 + 4] >> 8;
            }
            local_28[local_f0 + 4] = uVar3;
          }
          local_28[2] = (ushort)iVar4;
          local_f4 = local_f4 + 1;
        }
      }
      if (local_f4 == 0) {
        local_f8 = -0x2c;
      }
      else {
        if (DAT_00559cb0 != '\0') {
          local_2c._0_2_ = (ushort)local_2c << 8 | (ushort)local_2c >> 8;
          local_2c._2_2_ = local_2c._2_2_ << 8 | local_2c._2_2_ >> 8;
        }
        if (DAT_00559cb0 != '\0') {
          local_28[0] = local_28[0] << 8 | local_28[0] >> 8;
          local_28[1] = local_28[1] << 8 | local_28[1] >> 8;
        }
        FUN_004d3d98((int *)&local_10,local_c,0x152,0x1c,&local_2c,1);
        local_f8 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(sVar1 + 9U));
      }
    }
LAB_004b44fc:
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_f8;
}



int FUN_004b4530(int *param_1,int param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  undefined1 *__ptr;
  undefined3 extraout_var;
  int iVar3;
  undefined1 *local_1c;
  ushort local_18 [2];
  undefined4 local_14;
  undefined2 local_10;
  
  iVar3 = -0x2c;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    return -0x2c;
  }
  __ptr[4] = 0;
  __ptr[5] = 1;
  if (DAT_00559cb0 == '\0') {
    uVar2 = 1;
  }
  else {
    uVar2 = 0x100;
  }
  *__ptr = (char)uVar2;
  __ptr[1] = (char)((ushort)uVar2 >> 8);
  uVar2 = *(undefined2 *)(param_2 + 6);
  __ptr[2] = (char)uVar2;
  __ptr[3] = (char)((ushort)uVar2 >> 8);
  if (DAT_00559cb0 == '\0') {
    uVar2 = 5;
  }
  else {
    uVar2 = 0x500;
  }
  __ptr[4] = (char)uVar2;
  __ptr[5] = (char)((ushort)uVar2 >> 8);
  local_1c = __ptr + 8;
  if (*param_3 == 0) {
    local_14 = 0;
    local_10 = 0;
  }
  else {
    bVar1 = FUN_0041d6ac((char *)*param_3,&local_14);
    if (CONCAT31(extraout_var,bVar1) == 0) goto LAB_004b4824;
  }
  local_18[0] = 0x100;
  iVar3 = FUN_004d3d98((int *)&local_1c,local_18,0x142,6,&local_14,1);
  if (iVar3 == 0) {
    __ptr[4] = (char)(0x100 - (uint)local_18[0]);
    __ptr[5] = (char)(0x100 - (uint)local_18[0] >> 8);
    iVar3 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(*(short *)(__ptr + 4) + 9));
  }
LAB_004b4824:
  if (__ptr != (undefined1 *)0x0) {
    free(__ptr);
  }
  return iVar3;
}



int FUN_004b4858(int *param_1,undefined4 *param_2,int *param_3)

{
  undefined2 uVar1;
  undefined1 *__ptr;
  int iVar2;
  char *param1;
  int local_30;
  ushort local_1e;
  undefined1 *local_1c;
  undefined1 local_18 [12];
  
  local_30 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_30 = -0x1b;
  }
  else {
    __ptr[4] = 0;
    __ptr[5] = 1;
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    uVar1 = *(undefined2 *)((int)param_2 + 6);
    __ptr[2] = (char)uVar1;
    __ptr[3] = (char)((ushort)uVar1 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar1 = 0x109;
    }
    else {
      uVar1 = 0x901;
    }
    __ptr[4] = (char)uVar1;
    __ptr[5] = (char)((ushort)uVar1 >> 8);
    local_1c = __ptr + 8;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0xe);
    }
    else {
      iVar2 = atoi((char *)*param_3);
      local_18[0] = (undefined1)iVar2;
      param1 = (char *)*param_2;
      iVar2 = atoi((char *)*param_3);
      printf("nan %s :%d\n",param1,iVar2);
      local_1e = 0x100;
      iVar2 = FUN_004d3d98((int *)&local_1c,&local_1e,0x104,1,local_18,1);
      if (iVar2 != 0) {
        printf("error:%d \n",iVar2);
        free(__ptr);
        return iVar2;
      }
      __ptr[4] = (char)(0x100 - (uint)local_1e);
      __ptr[5] = (char)(0x100 - (uint)local_1e >> 8);
      local_30 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_1e));
    }
    free(__ptr);
  }
  return local_30;
}



int FUN_004b4bc4(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  undefined1 *__ptr;
  int local_18;
  
  local_18 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_18 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    uVar1 = *(undefined2 *)(param_2 + 6);
    __ptr[2] = (char)uVar1;
    __ptr[3] = (char)((ushort)uVar1 >> 8);
    __ptr[4] = 0;
    __ptr[5] = 1;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0x109);
    }
    else {
      puts("status cmd doesn\'t accept any parameters");
      local_18 = -1;
    }
    if (local_18 != 0) {
      printf("error:%d \n",local_18);
    }
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_18;
}



int FUN_004b4d90(int *param_1,int param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined3 extraout_var;
  int iVar4;
  undefined1 *local_24;
  ushort local_16;
  undefined1 *local_14;
  undefined1 local_10;
  undefined1 local_f;
  undefined1 local_e;
  undefined1 local_d;
  undefined1 local_c;
  undefined1 local_b;
  
  iVar4 = -0x2c;
  local_24 = (undefined1 *)0x0;
  local_10 = 0;
  local_f = 0;
  local_e = 0;
  local_d = 0;
  local_c = 0;
  local_b = 0;
  if ((*param_3 == 0) ||
     (bVar1 = FUN_0041d6ac((char *)*param_3,&local_10), CONCAT31(extraout_var,bVar1) != 0)) {
    local_24 = (undefined1 *)calloc(1,0x109);
    if (local_24 == (undefined1 *)0x0) {
      return -0x2c;
    }
    if (DAT_00559cb0 == '\0') {
      uVar2 = 1;
    }
    else {
      uVar2 = 0x100;
    }
    *local_24 = (char)uVar2;
    local_24[1] = (char)((ushort)uVar2 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar3 = *(ushort *)(param_2 + 6);
    }
    else {
      uVar3 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
    }
    local_24[2] = (char)uVar3;
    local_24[3] = (char)(uVar3 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar2 = 0x100;
    }
    else {
      uVar2 = 1;
    }
    local_24[4] = (char)uVar2;
    local_24[5] = (char)((ushort)uVar2 >> 8);
    local_14 = local_24 + 8;
    local_16 = 0x100;
    iVar4 = FUN_004d3d98((int *)&local_14,&local_16,0x142,6,&local_10,1);
    if (iVar4 == 0) {
      local_24[4] = (char)(0x100 - (uint)local_16);
      local_24[5] = (char)(0x100 - (uint)local_16 >> 8);
      iVar4 = FUN_00445444(param_1,"nan",local_24,(uint)(ushort)(0x109 - local_16));
    }
  }
  else {
    printf("%s : Malformed MAC address parameter\n","wl_nan_subcmd_stop");
  }
  if (local_24 != (undefined1 *)0x0) {
    free(local_24);
  }
  return iVar4;
}



int FUN_004b50fc(int *param_1,int param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  undefined1 *__ptr;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  ulong uVar4;
  int iVar5;
  undefined2 local_64;
  undefined1 *local_3c;
  ushort local_38;
  ushort local_36;
  undefined1 local_34;
  undefined1 local_33;
  undefined1 local_32;
  undefined1 local_31;
  undefined1 local_30;
  undefined1 local_2f;
  uint local_2c;
  ushort local_28;
  ushort local_26;
  undefined1 local_24 [4];
  uint local_20;
  ushort local_1c;
  ushort local_1a;
  undefined2 local_18;
  undefined2 local_16;
  uint local_14;
  undefined2 local_10;
  undefined2 local_e [3];
  
  iVar5 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    return 0;
  }
  __ptr[4] = 0;
  __ptr[5] = 1;
  if (DAT_00559cb0 == '\0') {
    uVar2 = 1;
  }
  else {
    uVar2 = 0x100;
  }
  *__ptr = (char)uVar2;
  __ptr[1] = (char)((ushort)uVar2 >> 8);
  if (DAT_00559cb0 == '\0') {
    uVar2 = 2;
  }
  else {
    uVar2 = 0x200;
  }
  __ptr[2] = (char)uVar2;
  __ptr[3] = (char)((ushort)uVar2 >> 8);
  if (DAT_00559cb0 == '\0') {
    uVar2 = 0x100;
  }
  else {
    uVar2 = 1;
  }
  __ptr[4] = (char)uVar2;
  __ptr[5] = (char)((ushort)uVar2 >> 8);
  local_3c = __ptr + 8;
  if (*param_3 == 0) {
    iVar5 = FUN_004b3288(param_1,__ptr,0x109);
  }
  else {
    local_64 = 1;
    local_34 = 0;
    local_33 = 0;
    local_32 = 0;
    local_31 = 0;
    local_30 = 0;
    local_2f = 0;
    local_2c = 0;
    local_28 = 100;
    local_26 = 0x10;
    local_24[0] = 0;
    local_20 = 6;
    local_1c = 6;
    local_1a = 0x2c;
    local_18 = 0xe6;
    local_16 = 10000;
    local_14 = 0;
    local_10 = 6;
    local_e[0] = 4;
    local_38 = 0x100;
    switch(*(undefined2 *)(param_2 + 8)) {
    case 0x102:
      bVar1 = FUN_0041d6ac((char *)*param_3,&local_34);
      if (CONCAT31(extraout_var_00,bVar1) == 0) {
        puts("Malformed MAC address parameter");
        iVar5 = -0x2c;
        goto LAB_004b5d08;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x102,6,&local_34,1);
      break;
    default:
      iVar5 = -2;
      break;
    case 0x140:
      if (DAT_00559cb0 == '\0') {
        iVar5 = atoi((char *)*param_3);
        local_26 = (ushort)iVar5;
      }
      else {
        iVar5 = atoi((char *)*param_3);
        local_26 = (ushort)iVar5 << 8 | (ushort)iVar5 >> 8;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x140,2,&local_26,1);
      break;
    case 0x141:
      if (DAT_00559cb0 == '\0') {
        iVar5 = atoi((char *)*param_3);
        local_28 = (ushort)iVar5;
      }
      else {
        iVar5 = atoi((char *)*param_3);
        local_28 = (ushort)iVar5 << 8 | (ushort)iVar5 >> 8;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x141,2,&local_28,1);
      break;
    case 0x142:
      bVar1 = FUN_0041d6ac((char *)*param_3,&local_34);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        puts("Malformed MAC address parameter");
        iVar5 = -0x2c;
        goto LAB_004b5d08;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x142,6,&local_34,1);
      break;
    case 0x145:
      if (DAT_00559cb0 == '\0') {
        local_2c = atoi((char *)*param_3);
      }
      else {
        uVar3 = atoi((char *)*param_3);
        local_2c = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x145,4,&local_2c,1);
      break;
    case 0x147:
      if (*param_3 != 0) {
        uVar4 = strtoul((char *)*param_3,(char **)0x0,0);
        local_64 = (ushort)(byte)uVar4;
      }
      if (param_3[1] != 0) {
        uVar4 = strtoul((char *)param_3[1],(char **)0x0,0);
        local_64 = CONCAT11((char)uVar4,(undefined1)local_64);
      }
      if (DAT_00559cb0 != '\0') {
        local_64 = local_64 << 8 | local_64 >> 8;
      }
      local_36 = local_64;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x147,2,&local_36,1);
      break;
    case 0x149:
      iVar5 = atoi((char *)*param_3);
      local_16 = (undefined2)iVar5;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x149,2,&local_16,1);
      break;
    case 0x14c:
      if ((*param_3 != 0) && (local_1c = FUN_004c0638((char *)*param_3), local_1c != 0)) {
        iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x14c,2,&local_1c,1);
      }
      if ((param_3[1] != 0) && (local_1a = FUN_004c0638((char *)param_3[1]), local_1a != 0)) {
        iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x14c,2,&local_1a,1);
      }
      break;
    case 0x14e:
      iVar5 = atoi((char *)*param_3);
      local_24[0] = (undefined1)iVar5;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x14e,1,local_24,1);
      break;
    case 0x150:
      if (DAT_00559cb0 == '\0') {
        local_20 = atoi((char *)*param_3);
      }
      else {
        uVar3 = atoi((char *)*param_3);
        local_20 = uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x150,4,&local_20,1);
      break;
    case 0x159:
      iVar5 = atoi((char *)*param_3);
      local_18 = (undefined2)iVar5;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x159,2,&local_18,1);
      break;
    case 0x15a:
      if (DAT_00559cb0 == '\0') {
        local_14 = strtoul((char *)*param_3,(char **)0x0,0);
      }
      else {
        uVar4 = strtoul((char *)*param_3,(char **)0x0,0);
        local_14 = uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar4 >> 0x18;
      }
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x15a,4,&local_14,1);
      break;
    case 0x162:
      iVar5 = atoi((char *)*param_3);
      local_10 = (undefined2)iVar5;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x162,2,&local_10,1);
      break;
    case 0x163:
      iVar5 = atoi((char *)*param_3);
      local_e[0] = (undefined2)iVar5;
      iVar5 = FUN_004d3d98((int *)&local_3c,&local_38,0x163,2,local_e,1);
    }
    if (iVar5 == 0) {
      __ptr[4] = (char)(0x100 - (uint)local_38);
      __ptr[5] = (char)(0x100 - (uint)local_38 >> 8);
      iVar5 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_38));
    }
    else {
      puts("xtlv pack error");
    }
  }
LAB_004b5d08:
  if (__ptr != (undefined1 *)0x0) {
    free(__ptr);
  }
  return iVar5;
}



int FUN_004b5d3c(int *param_1,undefined4 *param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  ushort uVar3;
  int iVar4;
  undefined3 extraout_var;
  int *local_res8;
  int local_38;
  undefined1 *local_30;
  ushort local_1c [2];
  undefined1 *local_18;
  undefined1 local_14;
  undefined1 local_13;
  undefined1 local_12;
  undefined1 local_11;
  undefined1 local_10;
  undefined1 local_f;
  undefined1 local_e [6];
  
  local_38 = -0x2c;
  local_30 = (undefined1 *)0x0;
  local_14 = 0;
  local_13 = 0;
  local_12 = 0;
  local_11 = 0;
  local_10 = 0;
  local_f = 0;
  local_e[0] = 0;
  printf("ioc:= handler:%s, cmdname:%s cmd:%d, type:%d\n","wl_nan_subcmd_join",(char *)*param_2,
         (uint)*(ushort *)((int)param_2 + 6),(uint)*(ushort *)(param_2 + 2));
  local_res8 = param_3;
  do {
    if (*local_res8 == 0) {
      local_30 = (undefined1 *)calloc(1,0x109);
      if (local_30 == (undefined1 *)0x0) {
        local_38 = -0x1b;
      }
      else {
        if (DAT_00559cb0 == '\0') {
          uVar2 = 1;
        }
        else {
          uVar2 = 0x100;
        }
        *local_30 = (char)uVar2;
        local_30[1] = (char)((ushort)uVar2 >> 8);
        if (DAT_00559cb0 == '\0') {
          uVar3 = *(ushort *)((int)param_2 + 6);
        }
        else {
          uVar3 = *(ushort *)((int)param_2 + 6) << 8 | *(ushort *)((int)param_2 + 6) >> 8;
        }
        local_30[2] = (char)uVar3;
        local_30[3] = (char)(uVar3 >> 8);
        if (DAT_00559cb0 == '\0') {
          uVar2 = 0x100;
        }
        else {
          uVar2 = 1;
        }
        local_30[4] = (char)uVar2;
        local_30[5] = (char)((ushort)uVar2 >> 8);
        local_18 = local_30 + 8;
        local_1c[0] = 0x100;
        local_38 = FUN_004d3d98((int *)&local_18,local_1c,0x142,6,&local_14,1);
        if ((local_38 == 0) &&
           (local_38 = FUN_004d3d98((int *)&local_18,local_1c,0x146,1,local_e,1), local_38 == 0)) {
          local_30[4] = (char)(0x100 - (uint)local_1c[0]);
          local_30[5] = (char)(0x100 - (uint)local_1c[0] >> 8);
          local_38 = FUN_00445444(param_1,"nan",local_30,(uint)(ushort)(0x109 - local_1c[0]));
        }
LAB_004b6178:
        if (local_30 != (undefined1 *)0x0) {
          free(local_30);
        }
      }
      return local_38;
    }
    iVar4 = strcasecmp((char *)*local_res8,"-start");
    if (iVar4 == 0) {
      local_e[0] = 1;
      puts("start=true");
    }
    else {
      bVar1 = FUN_0041d6ac((char *)*local_res8,&local_14);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        printf("%s : Malformed MAC address parameter\n","wl_nan_subcmd_join");
        goto LAB_004b6178;
      }
    }
    local_res8 = local_res8 + 1;
  } while( true );
}



int FUN_004b61ac(int *param_1,undefined4 *param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined3 extraout_var;
  undefined1 *__ptr;
  int iVar4;
  int local_30;
  ushort local_1c [2];
  undefined1 *local_18;
  undefined1 local_14;
  undefined1 local_13;
  undefined1 local_12;
  undefined1 local_11;
  undefined1 local_10;
  undefined1 local_f;
  
  local_14 = 0;
  local_13 = 0;
  local_12 = 0;
  local_11 = 0;
  local_10 = 0;
  local_f = 0;
  printf("ioc:= handler:%s, cmdname:%s cmd:%d, type:%d\n","wl_nan_subcmd_leave",(char *)*param_2,
         (uint)*(ushort *)((int)param_2 + 6),(uint)*(ushort *)(param_2 + 2));
  if ((*param_3 == 0) ||
     (bVar1 = FUN_0041d6ac((char *)*param_3,&local_14), CONCAT31(extraout_var,bVar1) != 0)) {
    __ptr = (undefined1 *)calloc(1,0x109);
    if (__ptr == (undefined1 *)0x0) {
      local_30 = -0x1b;
    }
    else {
      if (DAT_00559cb0 == '\0') {
        uVar2 = 1;
      }
      else {
        uVar2 = 0x100;
      }
      *__ptr = (char)uVar2;
      __ptr[1] = (char)((ushort)uVar2 >> 8);
      if (DAT_00559cb0 == '\0') {
        uVar3 = *(ushort *)((int)param_2 + 6);
      }
      else {
        uVar3 = *(ushort *)((int)param_2 + 6) << 8 | *(ushort *)((int)param_2 + 6) >> 8;
      }
      __ptr[2] = (char)uVar3;
      __ptr[3] = (char)(uVar3 >> 8);
      if (DAT_00559cb0 == '\0') {
        uVar2 = 0x100;
      }
      else {
        uVar2 = 1;
      }
      __ptr[4] = (char)uVar2;
      __ptr[5] = (char)((ushort)uVar2 >> 8);
      local_18 = __ptr + 8;
      local_1c[0] = 0x100;
      iVar4 = memcmp(&local_14,&DAT_00524a08,6);
      if ((iVar4 == 0) ||
         (local_30 = FUN_004d3d98((int *)&local_18,local_1c,0x142,6,&local_14,1), local_30 == 0)) {
        __ptr[4] = (char)(0x100 - (uint)local_1c[0]);
        __ptr[5] = (char)(0x100 - (uint)local_1c[0] >> 8);
        local_30 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_1c[0]));
      }
      if (__ptr != (undefined1 *)0x0) {
        free(__ptr);
      }
    }
  }
  else {
    printf("%s : Malformed MAC address parameter\n","wl_nan_subcmd_leave");
    local_30 = -0x2c;
  }
  return local_30;
}



int FUN_004b657c(int *param_1,int param_2,int *param_3,ulong param_4)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  ulong uVar7;
  ulong uVar8;
  ulong uVar9;
  bool bVar10;
  undefined2 uVar11;
  ushort uVar12;
  int iVar13;
  char *__nptr;
  undefined3 extraout_var;
  ulong uVar14;
  int *piVar15;
  int *local_res8;
  int local_a0;
  undefined1 *local_9c;
  char *local_98;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  byte *local_84;
  undefined4 *local_80;
  undefined4 *local_7c;
  size_t local_74;
  uint local_70;
  char *local_6c;
  char local_68;
  uint local_64;
  ulong local_44;
  ulong local_40;
  ulong local_3c;
  char acStack_38 [7];
  byte local_31;
  char *local_30;
  undefined1 *local_2c;
  ushort local_28 [2];
  undefined4 local_24;
  undefined1 local_20;
  undefined1 local_1f;
  undefined4 *local_1c;
  uint local_18;
  byte local_14;
  undefined4 auStack_10 [2];
  
  local_9c = (undefined1 *)0x0;
  local_94 = (char *)0x0;
  local_90 = (char *)0x0;
  local_8c = (char *)0x0;
  local_88 = (char *)0x0;
  local_84 = (byte *)0x0;
  local_80 = (undefined4 *)0x0;
  local_7c = (undefined4 *)0x0;
  bVar1 = false;
  bVar2 = false;
  local_74 = 0;
  local_1c = (undefined4 *)0x0;
  local_18 = 0xffffffff;
  local_70 = 0;
  local_6c = (char *)0x0;
  local_68 = '\0';
  local_44 = 1;
  local_40 = 0xffffffff;
  local_3c = param_4;
  if (*param_3 == 0) {
    printf("%s : Missing instance id parameter.\n","wl_nan_subcmd_svc");
    local_a0 = -0x2c;
  }
  else {
    iVar13 = atoi((char *)*param_3);
    if ((iVar13 < 0) || (0xff < iVar13)) {
      printf("%s : Invalid instance_id.\n","wl_nan_subcmd_svc");
      local_a0 = -0x2c;
    }
    else {
      local_31 = (byte)iVar13;
      if (param_3[1] == 0) {
        printf("%s : Missing service name parameter.\n","wl_nan_subcmd_svc");
        local_a0 = -0x2c;
      }
      else {
        strncpy(acStack_38,(char *)param_3[1],6);
        local_res8 = param_3 + 2;
        pcVar3 = local_94;
        pcVar4 = local_90;
        pcVar5 = local_8c;
        pcVar6 = local_88;
        uVar7 = local_44;
        uVar8 = local_40;
        uVar9 = local_3c;
LAB_004b6d84:
        local_3c = uVar9;
        local_40 = uVar8;
        local_44 = uVar7;
        local_88 = pcVar6;
        local_8c = pcVar5;
        local_90 = pcVar4;
        local_94 = pcVar3;
        local_98 = (char *)*local_res8;
        piVar15 = local_res8 + 1;
        if (local_98 == (char *)0x0) {
          local_9c = (undefined1 *)calloc(1,0x2000);
          if (local_9c == (undefined1 *)0x0) {
            local_a0 = -0x1b;
            goto LAB_004b75d4;
          }
          if (DAT_00559cb0 == '\0') {
            uVar11 = 1;
          }
          else {
            uVar11 = 0x100;
          }
          *local_9c = (char)uVar11;
          local_9c[1] = (char)((ushort)uVar11 >> 8);
          if (DAT_00559cb0 == '\0') {
            uVar12 = *(ushort *)(param_2 + 6);
          }
          else {
            uVar12 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
          }
          local_9c[2] = (char)uVar12;
          local_9c[3] = (char)(uVar12 >> 8);
          if (DAT_00559cb0 == '\0') {
            uVar11 = 0x2000;
          }
          else {
            uVar11 = 0x20;
          }
          local_9c[4] = (char)uVar11;
          local_9c[5] = (char)((ushort)uVar11 >> 8);
          local_2c = local_9c + 8;
          local_28[0] = 0x2000;
          local_a0 = FUN_004d3d98((int *)&local_2c,local_28,0x120,0x14,&local_44,1);
          if (((((local_a0 != 0) ||
                ((local_94 != (char *)0x0 &&
                 (local_a0 = FUN_004b8848((int *)&local_2c,local_28,0x123,local_94), local_a0 != 0))
                )) || ((local_90 != (char *)0x0 &&
                       (local_a0 = FUN_004b8848((int *)&local_2c,local_28,0x122,local_90),
                       local_a0 != 0)))) ||
              ((local_8c != (char *)0x0 &&
               (((local_90 == (char *)0x0 ||
                 ((local_90 != (char *)0x0 && (iVar13 = strcmp(local_90,local_8c), iVar13 != 0))))
                && (local_a0 = FUN_004b8848((int *)&local_2c,local_28,0x121,local_8c), local_a0 != 0
                   )))))) ||
             ((local_88 != (char *)0x0 &&
              (local_a0 = FUN_004b8848((int *)&local_2c,local_28,0x130,local_88), local_a0 != 0))))
          goto LAB_004b75d4;
          if (local_7c == (undefined4 *)0x0) goto LAB_004b7488;
          local_14 = 0;
          if (local_74 != 0) {
            if (local_18 == 0xffffffff) {
              local_18 = local_31 & 3;
            }
            local_14 = (byte)((local_18 & 0x3f) << 2) | 1;
          }
          if (local_68 == 'i') {
            local_14 = local_14 | 2;
          }
          if (local_74 == 0) {
            if (0x27 < local_70) {
              printf("%s: Too many MAC addresses\n","wl_nan_subcmd_svc");
              local_a0 = -0x2c;
              goto LAB_004b75d4;
            }
            local_84 = (byte *)malloc(local_70 * 6 + 1);
            if (local_84 != (byte *)0x0) {
              *local_84 = local_14;
              memcpy(local_84 + 1,local_7c,local_70 * 6);
              local_a0 = FUN_004d3d98((int *)&local_2c,local_28,0x129,(short)local_70 * 6 + 1,
                                      local_84,1);
              goto joined_r0x004b7480;
            }
            printf("Failed to malloc %d bytes \n",local_70 * 6 + 1);
            local_a0 = -0x1b;
          }
          else {
            iVar13 = FUN_004b765c((int *)&local_1c,&local_18,local_74);
            if (iVar13 != 0) {
              printf("%s: Bloom create failed\n","wl_nan_subcmd_svc");
              local_a0 = -1;
              goto LAB_004b75d4;
            }
            local_80 = local_7c;
            for (local_64 = 0; local_64 < local_70; local_64 = local_64 + 1) {
              iVar13 = FUN_004d4bd0(local_1c,(int)local_80,6);
              if (iVar13 != 0) {
                printf("%s: Cannot add to bloom filter\n","wl_nan_subcmd_svc");
              }
              local_80 = (undefined4 *)((int)local_80 + 6);
            }
            local_84 = (byte *)malloc(local_74 + 1);
            if (local_84 == (byte *)0x0) {
              printf("Failed to malloc %d bytes \n",local_74 + 1);
              local_a0 = -0x1b;
            }
            else {
              *local_84 = local_14;
              iVar13 = FUN_004d4d6c((int)local_1c,local_74,local_84 + 1,auStack_10);
              if (iVar13 == 0) {
                local_a0 = FUN_004d3d98((int *)&local_2c,local_28,0x129,(short)local_74 + 1,local_84
                                        ,1);
joined_r0x004b7480:
                if (local_a0 != 0) goto LAB_004b75d4;
LAB_004b7488:
                if ((local_6c == (char *)0x0) ||
                   (local_a0 = FUN_004b8848((int *)&local_2c,local_28,0x129,local_6c), local_a0 == 0
                   )) {
                  if (DAT_00559cb0 != '\0') {
                    local_28[0] = local_28[0] << 8 | local_28[0] >> 8;
                  }
                  local_9c[4] = (char)(0x2000 - (uint)local_28[0]);
                  local_9c[5] = (char)(0x2000 - (uint)local_28[0] >> 8);
                  local_a0 = FUN_00445444(param_1,"nan",local_9c,0x2009 - local_28[0]);
                }
              }
              else {
                printf("%s: Cannot get filter data\n","wl_nan_subcmd_svc");
                local_a0 = -1;
              }
            }
          }
          goto LAB_004b75d4;
        }
        iVar13 = strcasecmp(local_98,"-bloom");
        pcVar3 = local_94;
        pcVar4 = local_90;
        pcVar5 = local_8c;
        pcVar6 = local_88;
        if (iVar13 == 0) {
          if (bVar1) {
            printf("%s: Cannot use -bloom-idx with -srfraw\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          bVar2 = true;
          if (local_74 != 0) {
            printf("%s: -bloom can only be set once\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          if ((*piVar15 == 0) || (*(char *)*piVar15 == '-')) {
            local_74 = 0xf0;
            local_res8 = piVar15;
            uVar7 = local_44;
            uVar8 = local_40;
            uVar9 = local_3c;
            goto LAB_004b6d84;
          }
          local_74 = strtoul((char *)*piVar15,&local_30,0);
          if (((*local_30 != '\0') || (local_74 == 0)) || (0xfe < local_74)) {
            printf("%s: Invalid bloom length.\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          local_98 = (char *)local_res8[2];
          piVar15 = local_res8 + 3;
        }
        local_res8 = piVar15;
        __nptr = (char *)*local_res8;
        local_res8 = local_res8 + 1;
        if ((*__nptr == '\0') || (*__nptr == '-')) {
          printf("%s: Need value following %s\n","wl_nan_subcmd_svc",local_98);
        }
        iVar13 = strcasecmp(local_98,"-i");
        if ((iVar13 == 0) || (iVar13 = strcasecmp(local_98,"-x"), iVar13 == 0)) {
          if (bVar1) {
            printf("%s: Cannot use -i or -x with -srfraw\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          bVar2 = true;
          if (local_68 == '\0') {
            local_68 = local_98[1];
          }
          else if (local_68 != local_98[1]) {
            printf("%s: Cannot use -i or -x together\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          if ((local_80 == (undefined4 *)0x0) &&
             (local_80 = (undefined4 *)malloc(0x600), local_7c = local_80,
             local_80 == (undefined4 *)0x0)) {
            printf("Failed to malloc %d bytes \n",0x600);
            local_a0 = -0x1b;
            goto LAB_004b75d4;
          }
          bVar10 = FUN_0041d6ac(__nptr,&local_24);
          if (CONCAT31(extraout_var,bVar10) == 0) {
            printf("%s: Invalid ether addr\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          *local_80 = local_24;
          *(undefined1 *)(local_80 + 1) = local_20;
          *(undefined1 *)((int)local_80 + 5) = local_1f;
          local_80 = (undefined4 *)((int)local_80 + 6);
          local_70 = local_70 + 1;
          uVar7 = local_44;
          uVar8 = local_40;
          uVar9 = local_3c;
          goto LAB_004b6d84;
        }
        iVar13 = strcasecmp(local_98,"-bloom-idx");
        if (iVar13 == 0) {
          if (bVar1) {
            printf("%s: Cannot use -bloom-idx with -srfraw\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          bVar2 = true;
          if (local_18 != 0xffffffff) {
            printf("%s: -bloom-idx can only be set once\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          local_18 = atoi(__nptr);
          uVar7 = local_44;
          uVar8 = local_40;
          uVar9 = local_3c;
          if (3 < local_18) {
            printf("%s: Invalid -bloom-idx value\n","wl_nan_subcmd_svc");
            uVar7 = local_44;
            uVar8 = local_40;
            uVar9 = local_3c;
          }
          goto LAB_004b6d84;
        }
        iVar13 = strcasecmp(local_98,"-srfraw");
        if (iVar13 == 0) {
          if (bVar2) {
            printf("%s: srfraw is used without other srf options\n","wl_nan_subcmd_svc");
            local_a0 = -0x2c;
            goto LAB_004b75d4;
          }
          bVar1 = true;
          local_6c = __nptr;
          uVar7 = local_44;
          uVar8 = local_40;
          uVar9 = local_3c;
          goto LAB_004b6d84;
        }
        iVar13 = strcasecmp(local_98,"-info");
        pcVar3 = __nptr;
        uVar7 = local_44;
        uVar8 = local_40;
        uVar9 = local_3c;
        if ((((iVar13 == 0) ||
             (iVar13 = strcasecmp(local_98,"-match"), pcVar3 = local_94, pcVar4 = __nptr,
             uVar7 = local_44, uVar8 = local_40, uVar9 = local_3c, iVar13 == 0)) ||
            (iVar13 = strcasecmp(local_98,"-match-rx"), pcVar4 = local_90, pcVar5 = __nptr,
            uVar7 = local_44, uVar8 = local_40, uVar9 = local_3c, iVar13 == 0)) ||
           (iVar13 = strcasecmp(local_98,"-followup"), pcVar5 = local_8c, pcVar6 = __nptr,
           uVar7 = local_44, uVar8 = local_40, uVar9 = local_3c, iVar13 == 0)) goto LAB_004b6d84;
        uVar14 = strtoul(__nptr,&local_30,0);
        if (*local_30 != '\0') {
          printf("%s: Value is not uint or hex %s\n","wl_nan_subcmd_svc",__nptr);
          local_a0 = -0x2c;
          goto LAB_004b75d4;
        }
        iVar13 = strcasecmp(local_98,"-flags");
        pcVar6 = local_88;
        uVar7 = local_44;
        uVar8 = local_40;
        uVar9 = uVar14;
        if (((iVar13 == 0) ||
            (iVar13 = strcasecmp(local_98,"-period"), uVar7 = uVar14, uVar8 = local_40,
            uVar9 = local_3c, iVar13 == 0)) ||
           (iVar13 = strcasecmp(local_98,"-ttl"), uVar7 = local_44, uVar8 = uVar14, uVar9 = local_3c
           , iVar13 == 0)) goto LAB_004b6d84;
        printf("%s: Unrecognized parameter %s\n","wl_nan_subcmd_svc",local_98);
        local_a0 = -0x2c;
      }
    }
  }
LAB_004b75d4:
  if (local_9c != (undefined1 *)0x0) {
    free(local_9c);
  }
  if (local_84 != (byte *)0x0) {
    free(local_84);
  }
  if (local_7c != (undefined4 *)0x0) {
    free(local_7c);
  }
  if (local_1c != (undefined4 *)0x0) {
    FUN_004d4790((int *)&local_1c,FUN_004b77b0);
  }
  return local_a0;
}



int FUN_004b765c(int *param_1,undefined4 param_2,size_t param_3)

{
  int local_10;
  uint local_c;
  
  local_10 = FUN_004d45c0(FUN_004b7748,FUN_004b77b0,param_2,4,param_3,param_1);
  if (local_10 == 0) {
    local_c = 0;
    while ((local_c < 4 && (local_10 = FUN_004d48a4(*param_1,0x4b77f0,&local_c), local_10 == 0))) {
      local_c = local_c + 1;
    }
  }
  return local_10;
}



void * FUN_004b7748(undefined4 param_1,size_t param_2)

{
  void *local_10;
  
  local_10 = malloc(param_2);
  if (local_10 == (void *)0x0) {
    printf("Failed to malloc %d bytes \n",param_2);
    local_10 = (void *)0x0;
  }
  return local_10;
}



void FUN_004b77b0(undefined4 param_1,void *param_2)

{
  free(param_2);
  return;
}



uint FUN_004b77f0(char *param_1,char param_2,uint *param_3,byte *param_4)

{
  uint uVar1;
  char local_10 [8];
  
  local_10[0] = *param_1 * '\x04' + param_2;
  uVar1 = FUN_004be058((uint *)local_10,(byte *)0x1,0xffffffff);
  uVar1 = FUN_004be058(param_3,param_4,uVar1);
  return uVar1 & 0xffff;
}



int FUN_004b789c(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  ushort uVar2;
  undefined1 *__ptr;
  int local_18;
  
  local_18 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_18 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar2 = *(ushort *)(param_2 + 6);
    }
    else {
      uVar2 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
    }
    __ptr[2] = (char)uVar2;
    __ptr[3] = (char)(uVar2 >> 8);
    __ptr[4] = 0;
    __ptr[5] = 1;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0x109);
    }
    else {
      local_18 = FUN_004b657c(param_1,param_2,param_3,0x3000);
    }
    if (local_18 != 0) {
      printf("error:%d \n",local_18);
    }
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_18;
}



int FUN_004b7abc(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  ushort uVar2;
  undefined1 *__ptr;
  int local_18;
  
  local_18 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_18 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar2 = *(ushort *)(param_2 + 6);
    }
    else {
      uVar2 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
    }
    __ptr[2] = (char)uVar2;
    __ptr[3] = (char)(uVar2 >> 8);
    __ptr[4] = 0;
    __ptr[5] = 1;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0x109);
    }
    else {
      local_18 = FUN_004b657c(param_1,param_2,param_3,0);
    }
    if (local_18 != 0) {
      printf("error:%d \n",local_18);
    }
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_18;
}



int FUN_004b7cdc(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  ushort uVar2;
  int iVar3;
  undefined1 *local_2c;
  undefined1 local_18 [4];
  undefined1 *local_14;
  ushort local_10 [4];
  
  local_2c = (undefined1 *)0x0;
  if ((*param_3 == 0) || (param_3[1] != 0)) {
    printf("%s : Incorrect number of parameters.\n","wl_nan_subcmd_cancel");
    iVar3 = -0x2c;
  }
  else {
    iVar3 = atoi((char *)*param_3);
    if ((iVar3 < 0) || (0xff < iVar3)) {
      printf("%s : Invalid instance id.\n","wl_nan_subcmd_cancel");
      iVar3 = -0x2c;
    }
    else {
      local_18[0] = (undefined1)iVar3;
      local_2c = (undefined1 *)calloc(1,0x109);
      if (local_2c == (undefined1 *)0x0) {
        return 0;
      }
      if (DAT_00559cb0 == '\0') {
        uVar1 = 1;
      }
      else {
        uVar1 = 0x100;
      }
      *local_2c = (char)uVar1;
      local_2c[1] = (char)((ushort)uVar1 >> 8);
      if (DAT_00559cb0 == '\0') {
        uVar2 = *(ushort *)(param_2 + 6);
      }
      else {
        uVar2 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
      }
      local_2c[2] = (char)uVar2;
      local_2c[3] = (char)(uVar2 >> 8);
      if (DAT_00559cb0 == '\0') {
        uVar1 = 0x109;
      }
      else {
        uVar1 = 0x901;
      }
      local_2c[4] = (char)uVar1;
      local_2c[5] = (char)((ushort)uVar1 >> 8);
      local_14 = local_2c + 8;
      local_10[0] = 0x100;
      iVar3 = FUN_004d3d98((int *)&local_14,local_10,0x125,1,local_18,1);
      if (iVar3 == 0) {
        local_2c[4] = (char)(0x100 - (uint)local_10[0]);
        local_2c[5] = (char)(0x100 - (uint)local_10[0] >> 8);
        iVar3 = FUN_00445444(param_1,"nan",local_2c,(uint)(ushort)(0x109 - local_10[0]));
      }
    }
  }
  if (local_2c != (undefined1 *)0x0) {
    free(local_2c);
  }
  return iVar3;
}



void FUN_004b8090(int *param_1,int param_2,int *param_3)

{
  FUN_004b7cdc(param_1,param_2,param_3);
  return;
}



void FUN_004b80d8(int *param_1,int param_2,int *param_3)

{
  FUN_004b7cdc(param_1,param_2,param_3);
  return;
}



int FUN_004b8120(int *param_1,int param_2,int *param_3)

{
  bool bVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined3 extraout_var;
  char *__s1;
  int *piVar4;
  int *local_res8;
  int iVar5;
  undefined1 *local_3c;
  int local_24;
  int local_20;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 local_1a;
  undefined1 local_19;
  undefined1 local_18;
  undefined1 local_17;
  undefined1 local_16 [2];
  undefined1 *local_14;
  ushort local_10 [4];
  
  local_20 = 0;
  local_1c = 0;
  local_1b = 0;
  local_1a = 0;
  local_19 = 0;
  local_18 = 0;
  local_17 = 0;
  local_16[0] = 1;
  local_3c = (undefined1 *)0x0;
  local_14 = (undefined1 *)0x0;
  if (*param_3 == 0) {
    printf("%s : Missing instance id parameter.\n","wl_nan_subcmd_transmit");
    iVar5 = -0x2c;
  }
  else {
    local_24 = atoi((char *)*param_3);
    if ((local_24 < 0) || (0xff < local_24)) {
      printf("%s : Invalid instance_id.\n","wl_nan_subcmd_transmit");
      iVar5 = -0x2c;
    }
    else if (param_3[1] == 0) {
      printf("%s : Missing requestor id parameter.\n","wl_nan_subcmd_transmit");
      iVar5 = -0x2c;
    }
    else {
      local_20 = atoi((char *)param_3[1]);
      if ((local_20 < 0) || (0xff < local_20)) {
        printf("%s : Invalid requestor_id.\n","wl_nan_subcmd_transmit");
        iVar5 = -0x2c;
      }
      else if (param_3[2] == 0) {
        printf("%s : Missing destination MAC address.\n","wl_nan_subcmd_transmit");
        iVar5 = -0x2c;
      }
      else {
        local_res8 = param_3 + 3;
        bVar1 = FUN_0041d6ac((char *)param_3[2],&local_1c);
        if (CONCAT31(extraout_var,bVar1) == 0) {
          printf("%s: Invalid ether addr provided\n","wl_nan_subcmd_transmit");
          iVar5 = -0x2c;
        }
        else {
          local_3c = (undefined1 *)calloc(1,0x2000);
          if (local_3c == (undefined1 *)0x0) {
            return 0;
          }
          if (DAT_00559cb0 == '\0') {
            uVar2 = 1;
          }
          else {
            uVar2 = 0x100;
          }
          *local_3c = (char)uVar2;
          local_3c[1] = (char)((ushort)uVar2 >> 8);
          if (DAT_00559cb0 == '\0') {
            uVar3 = *(ushort *)(param_2 + 6);
          }
          else {
            uVar3 = *(ushort *)(param_2 + 6) << 8 | *(ushort *)(param_2 + 6) >> 8;
          }
          local_3c[2] = (char)uVar3;
          local_3c[3] = (char)(uVar3 >> 8);
          if (DAT_00559cb0 == '\0') {
            uVar2 = 0x2000;
          }
          else {
            uVar2 = 0x20;
          }
          local_3c[4] = (char)uVar2;
          local_3c[5] = (char)((ushort)uVar2 >> 8);
          local_14 = local_3c + 8;
          local_10[0] = 0x2000;
          iVar5 = FUN_004d3d98((int *)&local_14,local_10,0x125,1,&local_24,1);
          if ((iVar5 == 0) &&
             (iVar5 = FUN_004d3d98((int *)&local_14,local_10,0x127,1,&local_20,1), iVar5 == 0)) {
            iVar5 = FUN_004d3d98((int *)&local_14,local_10,0x102,6,&local_1c,1);
            while (iVar5 == 0) {
              while( true ) {
                __s1 = (char *)*local_res8;
                piVar4 = local_res8 + 1;
                if (__s1 == (char *)0x0) {
                  if (DAT_00559cb0 != '\0') {
                    local_10[0] = local_10[0] << 8 | local_10[0] >> 8;
                  }
                  local_3c[4] = (char)(0x2000 - (uint)local_10[0]);
                  local_3c[5] = (char)(0x2000 - (uint)local_10[0] >> 8);
                  iVar5 = FUN_00445444(param_1,"nan",local_3c,(uint)(ushort)(0x2009 - local_10[0]));
                  goto LAB_004b8814;
                }
                iVar5 = strcasecmp(__s1,"-priority");
                if (iVar5 != 0) break;
                local_res8 = local_res8 + 2;
                iVar5 = atoi((char *)*piVar4);
                local_16[0] = (undefined1)iVar5;
                iVar5 = FUN_004d3d98((int *)&local_14,local_10,0x126,1,local_16,1);
                if (iVar5 != 0) goto LAB_004b8814;
              }
              iVar5 = strcasecmp(__s1,"-info");
              if (iVar5 != 0) {
                printf("%s: Unrecognized parameter %s\n","wl_nan_subcmd_transmit",__s1);
                iVar5 = -0x2c;
                break;
              }
              local_res8 = local_res8 + 2;
              iVar5 = FUN_004b8848((int *)&local_14,local_10,0x123,(char *)*piVar4);
            }
          }
        }
      }
    }
  }
LAB_004b8814:
  if (local_3c != (undefined1 *)0x0) {
    free(local_3c);
  }
  return iVar5;
}



undefined4 FUN_004b8848(int *param_1,ushort *param_2,undefined2 param_3,char *param_4)

{
  ushort uVar1;
  undefined1 *puVar2;
  size_t sVar3;
  uint uVar4;
  undefined4 uVar5;
  int iVar6;
  
  puVar2 = (undefined1 *)*param_1;
  sVar3 = strlen(param_4);
  uVar4 = sVar3 >> 1;
  if ((uint)*param_2 < (uVar4 & 0xffff) + 4) {
    printf("bcm_pack_xtlv_entry: no space tlv_buf: requested:%d, available:%d\n",
           (uVar4 & 0xffff) + 4,(uint)*param_2);
    uVar5 = 0xffffffe8;
  }
  else {
    *puVar2 = (char)param_3;
    puVar2[1] = (char)((ushort)param_3 >> 8);
    puVar2[2] = (char)uVar4;
    puVar2[3] = (char)(uVar4 >> 8);
    iVar6 = FUN_00459628(param_4,puVar2 + 4,uVar4 & 0xffff);
    if (iVar6 == 0) {
      iVar6 = *param_1;
      uVar4 = FUN_004d4534((int)puVar2,1);
      *param_1 = iVar6 + uVar4;
      uVar1 = *param_2;
      uVar4 = FUN_004d4534((int)puVar2,1);
      *param_2 = uVar1 - (short)uVar4;
      uVar5 = 0;
    }
    else {
      uVar5 = 0xfffffffe;
    }
  }
  return uVar5;
}



int FUN_004b89f4(int *param_1,undefined4 *param_2,int *param_3)

{
  undefined2 uVar1;
  undefined1 *__ptr;
  int iVar2;
  char *param1;
  int local_30;
  ushort local_1e;
  undefined1 *local_1c;
  undefined1 local_18 [12];
  
  local_30 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_30 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    uVar1 = *(undefined2 *)((int)param_2 + 6);
    __ptr[2] = (char)uVar1;
    __ptr[3] = (char)((ushort)uVar1 >> 8);
    if (DAT_00559cb0 == '\0') {
      uVar1 = 0x109;
    }
    else {
      uVar1 = 0x901;
    }
    __ptr[4] = (char)uVar1;
    __ptr[5] = (char)((ushort)uVar1 >> 8);
    local_1c = __ptr + 8;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0xe);
    }
    else {
      iVar2 = atoi((char *)*param_3);
      local_18[0] = (undefined1)iVar2;
      param1 = (char *)*param_2;
      iVar2 = atoi((char *)*param_3);
      printf("nan %s :%d\n",param1,iVar2);
      local_1e = 0x100;
      iVar2 = FUN_004d3d98((int *)&local_1c,&local_1e,0x104,1,local_18,1);
      if (iVar2 != 0) {
        printf("error:%d \n",iVar2);
        free(__ptr);
        return iVar2;
      }
      __ptr[4] = (char)(0x100 - (uint)local_1e);
      __ptr[5] = (char)(0x100 - (uint)local_1e >> 8);
      local_30 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_1e));
    }
    free(__ptr);
  }
  return local_30;
}



undefined4 FUN_004b8d40(undefined4 param_1,undefined4 param_2,int param_3)

{
  int iVar1;
  undefined4 uVar2;
  char **local_res8;
  undefined **local_2c;
  char *local_28;
  undefined4 local_24;
  char *local_20;
  undefined *local_1c;
  undefined4 local_18;
  char *local_14;
  undefined *local_10;
  undefined4 local_c;
  
  local_28 = "enable";
  local_24 = 0;
  local_20 = "enable";
  local_1c = &DAT_005250ac;
  local_18 = 0;
  local_14 = "enable";
  local_10 = &DAT_005250b0;
  local_c = 0;
  local_2c = &PTR_s_enable_005255d0;
  local_res8 = (char **)(param_3 + 4);
  if (*local_res8 == (char *)0x0) {
    local_res8 = &local_28;
  }
  else if (**local_res8 == '1') {
    local_res8 = &local_20;
  }
  else if (**local_res8 == '0') {
    local_res8 = &local_14;
  }
  else {
    iVar1 = strcmp(*local_res8,"-h");
    if ((iVar1 == 0) || (iVar1 = strcmp(*local_res8,"help"), iVar1 == 0)) {
      return 0xffffffd4;
    }
  }
  while( true ) {
    if (*local_2c == (undefined *)0x0) {
      return 0xffffffd3;
    }
    iVar1 = strcmp(*local_2c,*local_res8);
    if (iVar1 == 0) break;
    local_2c = local_2c + 4;
  }
  if (local_2c[3] == (undefined *)0x0) {
    return 0xffffffd4;
  }
  uVar2 = (*(code *)local_2c[3])(param_1,local_2c,local_res8 + 1);
  return uVar2;
}



int FUN_004b8f40(int *param_1,undefined4 *param_2,int *param_3)

{
  undefined2 uVar1;
  ushort uVar2;
  undefined1 *__ptr;
  undefined2 extraout_var;
  int *local_res8;
  int param2;
  uint local_ac;
  uint local_a8;
  undefined1 *local_94;
  ushort local_90 [2];
  ulong local_8c;
  uint local_88 [32];
  
  param2 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    return 0;
  }
  if (DAT_00559cb0 == '\0') {
    uVar1 = 1;
  }
  else {
    uVar1 = 0x100;
  }
  *__ptr = (char)uVar1;
  __ptr[1] = (char)((ushort)uVar1 >> 8);
  if (DAT_00559cb0 == '\0') {
    uVar2 = *(ushort *)((int)param_2 + 6);
  }
  else {
    uVar2 = *(ushort *)((int)param_2 + 6) << 8 | *(ushort *)((int)param_2 + 6) >> 8;
  }
  __ptr[2] = (char)uVar2;
  __ptr[3] = (char)(uVar2 >> 8);
  __ptr[4] = 0;
  __ptr[5] = 1;
  local_94 = __ptr + 8;
  if (*param_3 == 0) {
    FUN_004b3288(param_1,__ptr,0x109);
    goto LAB_004b94a0;
  }
  bzero(&local_8c,0x84);
  local_a8 = strtoul((char *)*param_3,(char **)0x0,0);
  local_res8 = param_3 + 1;
  local_8c = local_a8;
  if (local_a8 == 0) {
    if ((*local_res8 == 0) || (param_3[2] == 0)) {
      if (*local_res8 == 0) {
        fwrite("missing chanspec\n",1,0x11,stderr);
      }
      else {
        fwrite("missing duration\n",1,0x11,stderr);
      }
      goto LAB_004b94a0;
    }
    uVar2 = FUN_004c0638((char *)*local_res8);
    if (uVar2 == 0) {
      fprintf(stderr,"%s: could not parse \"%s\" as channel\n",(char *)*param_2,(char *)*local_res8)
      ;
      param2 = -2;
      goto LAB_004b94a0;
    }
    uVar2 = FUN_00402c2c(uVar2);
    local_88[0] = CONCAT22(extraout_var,uVar2);
    local_88[1] = atoi((char *)param_3[2]);
  }
  else {
    local_ac = 0;
    while (((int)local_ac < 0x20 && (local_a8 != 0))) {
      if ((1 << (local_ac & 0x1f) & local_a8) != 0) {
        if (*local_res8 == 0) {
          fwrite("missing chanspec\n",1,0x11,stderr);
          goto LAB_004b94a0;
        }
        uVar2 = FUN_004c0638((char *)*local_res8);
        if (uVar2 == 0) {
          fprintf(stderr,"invalid chanspec %s\n",(char *)*local_res8);
          param2 = -2;
          goto LAB_004b94a0;
        }
        local_88[local_ac] = (uint)uVar2;
        local_a8 = local_a8 & ~(1 << (local_ac & 0x1f));
        local_res8 = local_res8 + 1;
      }
      local_ac = local_ac + 1;
    }
  }
  local_90[0] = 0x100;
  param2 = FUN_004d3d98((int *)&local_94,local_90,0x160,0x84,&local_8c,1);
  if (param2 == 0) {
    __ptr[4] = (char)(0x100 - (uint)local_90[0]);
    __ptr[5] = (char)(0x100 - (uint)local_90[0] >> 8);
    param2 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_90[0]));
  }
  else {
    fprintf(stderr,"xtlv error %d\n",param2);
  }
LAB_004b94a0:
  if (__ptr != (undefined1 *)0x0) {
    free(__ptr);
  }
  return param2;
}



int FUN_004b94d4(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  undefined1 *__ptr;
  int local_28;
  ushort local_18 [2];
  undefined1 *local_14;
  ulong local_10 [2];
  
  if (*param_3 == 0) {
    fwrite("missing available bitmap\n",1,0x19,stderr);
    local_28 = -2;
  }
  else {
    __ptr = (undefined1 *)calloc(1,0x109);
    if (__ptr == (undefined1 *)0x0) {
      local_28 = -0x1b;
    }
    else {
      if (DAT_00559cb0 == '\0') {
        uVar1 = 1;
      }
      else {
        uVar1 = 0x100;
      }
      *__ptr = (char)uVar1;
      __ptr[1] = (char)((ushort)uVar1 >> 8);
      uVar1 = *(undefined2 *)(param_2 + 6);
      __ptr[2] = (char)uVar1;
      __ptr[3] = (char)((ushort)uVar1 >> 8);
      __ptr[4] = 0;
      __ptr[5] = 1;
      local_14 = __ptr + 8;
      local_10[0] = strtoul((char *)*param_3,(char **)0x0,0);
      local_18[0] = 0x100;
      local_28 = FUN_004d3d98((int *)&local_14,local_18,0x161,4,local_10,1);
      if (local_28 == 0) {
        __ptr[4] = (char)(0x100 - (uint)local_18[0]);
        __ptr[5] = (char)(0x100 - (uint)local_18[0] >> 8);
        local_28 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_18[0]));
      }
      if (local_28 != 0) {
        printf("error:%d \n",local_28);
      }
      if (__ptr != (undefined1 *)0x0) {
        free(__ptr);
      }
    }
  }
  return local_28;
}



int FUN_004b979c(int *param_1,int param_2,int *param_3)

{
  undefined2 uVar1;
  undefined1 *__ptr;
  int iVar2;
  ulong uVar3;
  int local_28;
  ushort local_16;
  undefined1 *local_14;
  uint local_10 [2];
  
  local_28 = 0;
  __ptr = (undefined1 *)calloc(1,0x109);
  if (__ptr == (undefined1 *)0x0) {
    local_28 = -0x1b;
  }
  else {
    if (DAT_00559cb0 == '\0') {
      uVar1 = 1;
    }
    else {
      uVar1 = 0x100;
    }
    *__ptr = (char)uVar1;
    __ptr[1] = (char)((ushort)uVar1 >> 8);
    uVar1 = *(undefined2 *)(param_2 + 6);
    __ptr[2] = (char)uVar1;
    __ptr[3] = (char)((ushort)uVar1 >> 8);
    __ptr[4] = 0;
    __ptr[5] = 1;
    local_14 = __ptr + 8;
    if (*param_3 == 0) {
      FUN_004b3288(param_1,__ptr,0x109);
    }
    else {
      local_10[0] = 0;
      if (param_3[1] == 0) {
        fwrite("missing OUI type\n",1,0x11,stderr);
        local_28 = -2;
      }
      else {
        iVar2 = FUN_00459510((char *)*param_3,(undefined1 *)local_10);
        if (iVar2 == 0) {
          uVar3 = strtoul((char *)param_3[1],(char **)0x0,0);
          local_10[0] = (local_10[0] & 0xffffff) + uVar3 * 0x1000000;
          local_16 = 0x100;
          local_28 = FUN_004d3d98((int *)&local_14,&local_16,0x15b,4,local_10,1);
          if (local_28 == 0) {
            __ptr[4] = (char)(0x100 - (uint)local_16);
            __ptr[5] = (char)(0x100 - (uint)local_16 >> 8);
            local_28 = FUN_00445444(param_1,"nan",__ptr,(uint)(ushort)(0x109 - local_16));
          }
          else {
            printf("error %d\n",local_28);
          }
        }
        else {
          fwrite("invalid OUI\n",1,0xc,stderr);
          local_28 = -2;
        }
      }
    }
    if (__ptr != (undefined1 *)0x0) {
      free(__ptr);
    }
  }
  return local_28;
}



int FUN_004b9b10(char *param_1,void *param_2,size_t param_3,char *param_4,uint param_5,
                undefined4 *param_6)

{
  size_t sVar1;
  int iVar2;
  int iVar3;
  char *local_10;
  
  sVar1 = strlen(param_1);
  iVar2 = sVar1 + 1;
  if (param_5 < iVar2 + param_3) {
    *param_6 = 0xfffffff2;
    iVar2 = 0;
  }
  else {
    if (param_3 != 0) {
      memmove(param_4 + iVar2,param_2,param_3);
    }
    strcpy(param_4,param_1);
    for (local_10 = param_4; *local_10 != '\0'; local_10 = local_10 + 1) {
      iVar3 = tolower((int)*local_10);
      *local_10 = (char)iVar3;
    }
    *param_6 = 0;
    iVar2 = iVar2 + param_3;
  }
  return iVar2;
}



void FUN_004b9c2c(void)

{
  __bss_start = 0;
  DAT_0055769c = 0;
  return;
}



void FUN_004b9c5c(void)

{
  undefined4 *puVar1;
  undefined4 *local_10;
  
  local_10 = DAT_00557694;
  while (local_10 != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*local_10;
    if (local_10[3] != 0) {
      free((void *)local_10[3]);
    }
    free(local_10);
    local_10 = puVar1;
  }
  DAT_00557694 = (undefined4 *)0x0;
  DAT_00557698 = 0;
  __bss_start = 0;
  return;
}



undefined4 FUN_004b9d04(int param_1,void *param_2,size_t param_3)

{
  undefined4 *puVar1;
  undefined4 *__ptr;
  void *pvVar2;
  
  __ptr = (undefined4 *)malloc(0x10);
  if (__ptr == (undefined4 *)0x0) {
    printf("malloc(%d) failed, free %d batched commands and exit batching mode\n",0x10,__bss_start);
  }
  else {
    if (DAT_00557700 != 0) {
      printf("batching %dth command %d\n",__bss_start + 1,param_1);
    }
    __ptr[1] = param_1;
    __ptr[2] = param_3;
    *__ptr = 0;
    pvVar2 = malloc(param_3);
    __ptr[3] = pvVar2;
    if (__ptr[3] != 0) {
      memcpy((void *)__ptr[3],param_2,param_3);
      puVar1 = __ptr;
      if (DAT_00557698 != (undefined4 *)0x0) {
        *DAT_00557698 = __ptr;
        puVar1 = DAT_00557694;
      }
      DAT_00557694 = puVar1;
      __bss_start = __bss_start + 1;
      DAT_00557698 = __ptr;
      return 0;
    }
    printf("malloc(%d) failed, free %d batched commands and exit batching mode\n",param_3,
           __bss_start);
    free(__ptr);
  }
  FUN_004b9c5c();
  if (DAT_0055769c == '\0') {
    puts("calling add_one_batched_cmd() at non-command-batching mode, weird");
  }
  else {
    DAT_0055769c = '\0';
  }
  return 0xffffffff;
}



int FUN_004b9ef8(int param_1,char *param_2,int param_3)

{
  int iVar1;
  int local_10;
  
  local_10 = param_3;
  if (param_3 == 0x2000) {
    iVar1 = strcmp(param_2,"dump");
    if ((iVar1 == 0) || (param_1 == 0x33)) {
      local_10 = 0x2000;
    }
    else {
      local_10 = 0x600;
    }
  }
  return local_10;
}



undefined4 FUN_004b9f94(int *param_1,int param_2,char *param_3,uint param_4)

{
  undefined4 uVar1;
  
  if ((((DAT_0055769c == '\0') || (param_2 == 0)) || (param_2 == 1)) ||
     ((param_2 == 0x75 || (param_2 == 0xe)))) {
    uVar1 = FUN_004bab9c(param_1,param_2,param_3,param_4);
  }
  else {
    printf("IOCTL GET command %d is not supported in batching mode\n",param_2);
    uVar1 = 0xffffffe9;
  }
  return uVar1;
}



void FUN_004ba050(int *param_1,int param_2,char *param_3,size_t param_4)

{
  if (DAT_0055769c == '\0') {
    FUN_004baca0(param_1,param_2,param_3,param_4);
  }
  else {
    FUN_004b9d04(param_2,param_3,param_4);
  }
  return;
}



int FUN_004ba0cc(int *param_1,char *param_2,void *param_3,size_t param_4,char *param_5,uint param_6)

{
  int local_10 [2];
  
  FUN_004b9b10(param_2,param_3,param_4,param_5,param_6,local_10);
  if (local_10[0] == 0) {
    local_10[0] = FUN_004b9f94(param_1,0x106,param_5,param_6);
  }
  return local_10[0];
}



int FUN_004ba160(int *param_1,char *param_2,void *param_3,size_t param_4,char *param_5,uint param_6)

{
  size_t sVar1;
  int local_c;
  
  sVar1 = FUN_004b9b10(param_2,param_3,param_4,param_5,param_6,&local_c);
  if (local_c == 0) {
    local_c = FUN_004ba050(param_1,0x107,param_5,sVar1);
  }
  return local_c;
}



int FUN_004ba1f8(int *param_1,char *param_2,char *param_3,size_t param_4)

{
  int local_110;
  char acStack_10c [260];
  
  if ((int)param_4 < 0x101) {
    memset(acStack_10c,0,0x100);
    local_110 = FUN_004ba0cc(param_1,param_2,(void *)0x0,0,acStack_10c,0x100);
    if (local_110 == 0) {
      memcpy(param_3,acStack_10c,param_4);
    }
  }
  else {
    local_110 = FUN_004ba0cc(param_1,param_2,(void *)0x0,0,param_3,param_4);
  }
  return local_110;
}



void FUN_004ba2e4(int *param_1,char *param_2,void *param_3,size_t param_4)

{
  char acStack_208 [512];
  
  memset(acStack_208,0,0x200);
  FUN_004ba160(param_1,param_2,param_3,param_4,acStack_208,0x200);
  return;
}



int FUN_004ba35c(int *param_1,char *param_2,uint *param_3)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = FUN_004ba1f8(param_1,param_2,(char *)param_3,4);
  if (-1 < iVar1) {
    if (DAT_00559cc0 == '\0') {
      uVar2 = *param_3;
    }
    else {
      uVar2 = *param_3;
      uVar2 = uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 | uVar2 >> 0x18;
    }
    *param_3 = uVar2;
  }
  return iVar1;
}



void FUN_004ba428(int *param_1,char *param_2,uint param_3)

{
  uint local_res8 [2];
  
  if (DAT_00559cc0 != '\0') {
    param_3 = param_3 << 0x18 | (param_3 & 0xff00) << 8 | (param_3 & 0xff0000) >> 8 |
              param_3 >> 0x18;
  }
  local_res8[0] = param_3;
  FUN_004ba2e4(param_1,param_2,local_res8,4);
  return;
}



void FUN_004ba4e0(char *param_1)

{
  int *piVar1;
  
  fprintf(stderr,"%s: ",DAT_00557690);
  perror(param_1);
  piVar1 = __errno_location();
                    // WARNING: Subroutine does not return
  exit(*piVar1);
}



void FUN_004ba5e0(void)

{
  DAT_00559ce0 = &LAB_004ba540;
  return;
}



int FUN_004ba614(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,
                undefined1 param_5)

{
  int local_30;
  int local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined1 local_20;
  undefined1 local_10;
  
  local_20 = param_5;
  local_2c = param_2;
  local_28 = param_3;
  local_24 = param_4;
  local_10 = local_20;
  local_30 = (*DAT_00559ce0)(param_1,&local_2c);
  if ((local_30 < 0) && (param_2 != 0)) {
    local_30 = -0x2d;
  }
  return local_30;
}



int FUN_004ba6bc(char *param_1,char *param_2,size_t param_3)

{
  int __fd;
  int iVar1;
  int *piVar2;
  char acStack_f0 [16];
  undefined4 *local_e0;
  undefined4 local_d0;
  char acStack_cc [196];
  
  __fd = socket(2,1,0);
  if (__fd < 0) {
    FUN_004ba4e0("socket");
  }
  memset(&local_d0,0,0xc4);
  local_d0 = 3;
  local_e0 = &local_d0;
  strncpy(acStack_f0,param_1,0x10);
  iVar1 = ioctl(__fd,0x8946,acStack_f0);
  if (iVar1 < 0) {
    piVar2 = __errno_location();
    if (*piVar2 == 1) {
      FUN_004ba4e0("wl_get_dev_type");
    }
    *param_2 = '\0';
  }
  else {
    strncpy(param_2,acStack_cc,param_3);
  }
  close(__fd);
  return iVar1;
}



undefined4 FUN_004ba7f4(int *param_1)

{
  FILE *__stream;
  char *pcVar1;
  int iVar2;
  undefined4 local_418;
  char local_40c [16];
  char local_3fc [1000];
  char *local_14;
  char acStack_10 [8];
  
  builtin_strncpy(local_40c,"/proc/net/dev",0xe);
  *(undefined1 *)param_1 = 0;
  __stream = fopen(local_40c,"r");
  if (__stream == (FILE *)0x0) {
    local_418 = 0xffffffff;
  }
  else {
    pcVar1 = fgets(local_3fc,1000,__stream);
    if ((pcVar1 == (char *)0x0) || (pcVar1 = fgets(local_3fc,1000,__stream), pcVar1 == (char *)0x0))
    {
      fclose(__stream);
      local_418 = 0xffffffff;
    }
    else {
      while (pcVar1 = fgets(local_3fc,1000,__stream), pcVar1 != (char *)0x0) {
        local_14 = local_3fc;
        while ((*(ushort *)(__ctype_b + *local_14 * 2) & 0x20) != 0) {
          local_14 = local_14 + 1;
        }
        pcVar1 = strsep(&local_14,":");
        if (pcVar1 != (char *)0x0) {
          strncpy((char *)param_1,pcVar1,0xf);
          *(undefined1 *)((int)param_1 + 0xf) = 0;
          iVar2 = FUN_004ba6bc(pcVar1,acStack_10,3);
          if (((-1 < iVar2) && (iVar2 = strncmp(acStack_10,"wl",2), iVar2 == 0)) &&
             (iVar2 = FUN_00401704(param_1), iVar2 == 0)) break;
          *(undefined1 *)param_1 = 0;
        }
      }
      if ((char)*param_1 == '\0') {
        local_418 = 0xffffffff;
      }
      else {
        local_418 = 0;
      }
      fclose(__stream);
    }
  }
  return local_418;
}



int FUN_004baa48(int *param_1,int param_2,char *param_3,uint *param_4)

{
  undefined4 local_10;
  
  if (DAT_00559cd0 == 0) {
    local_10 = FUN_004ba614(param_1,param_2,param_3,*param_4,0);
  }
  else {
    local_10 = 2;
    FUN_004c589c(param_1,param_2,param_3,param_4,0,2);
  }
  return local_10;
}



int FUN_004baaf0(int *param_1,int param_2,char *param_3,uint *param_4)

{
  undefined4 local_10;
  
  if (DAT_00559cd0 == 0) {
    local_10 = FUN_004ba614(param_1,param_2,param_3,*param_4,1);
  }
  else {
    local_10 = 1;
    FUN_004c5fec(param_1,param_2,param_3,param_4,0,1);
  }
  return local_10;
}



undefined4 FUN_004bab9c(int *param_1,int param_2,char *param_3,uint param_4)

{
  int iVar1;
  undefined4 uVar2;
  int local_res4;
  uint local_c;
  
  local_res4 = param_2;
  if (((DAT_005562a0 == 2) || (DAT_005562a0 == 5)) && (DAT_00559cd0 != 0)) {
    local_res4 = param_2 + -0x1bebe0;
  }
  local_c = param_4;
  iVar1 = FUN_004baa48(param_1,local_res4,param_3,&local_c);
  if (iVar1 == -0x2e) {
    uVar2 = 0xffffffd2;
  }
  else if (iVar1 == -0x28) {
    uVar2 = 0xffffffd8;
  }
  else if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffd3;
  }
  return uVar2;
}



undefined4 FUN_004baca0(int *param_1,int param_2,char *param_3,uint param_4)

{
  int iVar1;
  undefined4 uVar2;
  int local_res4;
  uint local_c;
  
  local_res4 = param_2;
  if (((DAT_005562a0 == 2) || (DAT_005562a0 == 5)) && (DAT_00559cd0 != 0)) {
    local_res4 = param_2 + -0x1bebe0;
  }
  local_c = param_4;
  iVar1 = FUN_004baaf0(param_1,local_res4,param_3,&local_c);
  if (iVar1 == -0x2e) {
    uVar2 = 0xffffffd2;
  }
  else if (iVar1 == -0x28) {
    uVar2 = 0xffffffd8;
  }
  else if (iVar1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar2 = 0xffffffd3;
  }
  return uVar2;
}



int * FUN_004bada4(int param_1,int *param_2)

{
  bool bVar1;
  int iVar2;
  size_t sVar3;
  int *piVar4;
  undefined3 extraout_var;
  char *pcVar5;
  int *local_res4 [3];
  int *local_48;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  char *local_1c;
  int local_18 [3];
  
  local_1c = (char *)0x0;
  local_48 = (int *)0x0;
  local_18[0] = 0;
  DAT_00557690 = (char *)*param_2;
  local_res4[0] = param_2;
  FUN_004016ac();
  FUN_004ba5e0();
  memset(&local_3c,0,0x20);
  local_res4[0] = local_res4[0] + 1;
  iVar2 = FUN_00401988((int *)local_res4,(int *)&local_1c,local_18);
  if (iVar2 == 0) {
    if (local_1c == (char *)0x0) {
      if (local_18[0] != 0) {
        local_res4[0] = local_res4[0] + -1;
      }
    }
    else {
      strncpy((char *)&local_3c,local_1c,0x10);
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--indongle",sVar3);
    if (iVar2 == 0) {
      DAT_005562a4 = '\0';
      local_res4[0] = local_res4[0] + 1;
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--vista",sVar3);
    if (iVar2 == 0) {
      DAT_005562a0 = 5;
      DAT_005562a4 = '\0';
      local_res4[0] = local_res4[0] + 1;
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--nodetect",sVar3);
    if (iVar2 == 0) {
      DAT_005562a4 = '\0';
      local_res4[0] = local_res4[0] + 1;
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--debug",sVar3);
    if (iVar2 == 0) {
      DAT_00559cd8 = 1;
      local_res4[0] = local_res4[0] + 1;
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--socket",sVar3);
    if (iVar2 == 0) {
      piVar4 = local_res4[0] + 1;
      DAT_00559cd0 = 2;
      if (*piVar4 == 0) {
        local_res4[0] = piVar4;
        FUN_004c6ba0(2);
        return (int *)0x0;
      }
      DAT_00559cd4 = *piVar4;
      local_res4[0] = local_res4[0] + 2;
      DAT_0055769e = 8000;
      if (*local_res4[0] != 0) {
        iVar2 = *local_res4[0];
        sVar3 = strlen((char *)*local_res4[0]);
        iVar2 = FUN_004c77ac(iVar2,sVar3);
        if (iVar2 == 1) {
          iVar2 = atoi((char *)*local_res4[0]);
          DAT_0055769e = (undefined2)iVar2;
          local_res4[0] = local_res4[0] + 1;
        }
      }
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--serial",sVar3);
    if (iVar2 == 0) {
      local_res4[0] = local_res4[0] + 1;
      DAT_00559cd0 = 1;
    }
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--dongle",sVar3);
    if (iVar2 == 0) {
      local_res4[0] = local_res4[0] + 1;
      DAT_00559cd0 = 4;
    }
  }
  if ((DAT_00559cd0 == 1) || (DAT_00559cd0 == 4)) {
    if (*local_res4[0] == 0) {
      FUN_004c6ba0(DAT_00559cd0);
      return (int *)0x0;
    }
    PTR_DAT_00556db0 = (undefined *)*local_res4[0];
    local_res4[0] = local_res4[0] + 1;
    piVar4 = (int *)FUN_004cb0bc(DAT_00559cd0);
    if (piVar4 == (int *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("serial device open error\r\n",1,0x1a,stderr);
      }
      return (int *)0xffffffff;
    }
    local_3c = *piVar4;
    local_38 = piVar4[1];
    local_34 = piVar4[2];
    local_30 = piVar4[3];
    local_2c = piVar4[4];
    local_28 = piVar4[5];
    local_24 = piVar4[6];
    local_20 = piVar4[7];
  }
  if (*local_res4[0] != 0) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--wifi",sVar3);
    if (iVar2 == 0) {
      local_res4[0] = local_res4[0] + 1;
      if ((char)local_3c == '\0') {
        FUN_004ba7f4(&local_3c);
      }
      if (((char)local_3c == '\0') || (local_48 = (int *)FUN_00401704(&local_3c), (int)local_48 < 0)
         ) {
        fprintf(stderr,"%s: wl driver adapter not found\n",DAT_00557690);
                    // WARNING: Subroutine does not return
        exit(1);
      }
      DAT_00559cd0 = 3;
      if (param_1 < 4) {
        FUN_004c6ba0(3);
        return local_48;
      }
      bVar1 = FUN_0041d6ac((char *)*local_res4[0],PTR_DAT_00556db4);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        fwrite("could not parse as an ethternet MAC address\n",1,0x2c,stderr);
        return (int *)0xffffffff;
      }
      local_res4[0] = local_res4[0] + 1;
    }
  }
  if ((*local_res4[0] != 0) && (sVar3 = strlen((char *)*local_res4[0]), 2 < sVar3)) {
    pcVar5 = (char *)*local_res4[0];
    sVar3 = strlen((char *)*local_res4[0]);
    iVar2 = strncmp(pcVar5,"--interactive",sVar3);
    if (iVar2 == 0) {
      DAT_00559cdc = 1;
    }
  }
  if (DAT_00559cd0 == 0) {
    if (DAT_00559cdc == 1) {
      local_res4[0] = local_res4[0] + -1;
    }
    FUN_004bb788(&local_3c,local_res4[0]);
    piVar4 = local_res4[0];
  }
  else {
    if (DAT_005562a4 == '\x01') {
      FUN_004c7698(&local_3c,DAT_00559cd8,&DAT_005562a0);
    }
    iVar2 = FUN_00401704(&local_3c);
    if (iVar2 != 0) {
      fprintf(stderr,"%s: wl driver adapter not found\n",DAT_00557690);
                    // WARNING: Subroutine does not return
      exit(1);
    }
    if (DAT_00559cdc == 1) {
      piVar4 = (int *)FUN_004bbfec(&local_3c);
    }
    else if ((*local_res4[0] == 0) || (DAT_00559cdc != 0)) {
      FUN_004c6ba0(DAT_00559cd0);
      if ((DAT_00559cd0 == 4) || (piVar4 = local_48, DAT_00559cd0 == 1)) {
        FUN_004cb10c(DAT_00559cd0,&local_3c);
        piVar4 = local_48;
      }
    }
    else {
      piVar4 = local_res4[0];
      FUN_004bb788(&local_3c,local_res4[0]);
      if ((piVar4 == (int *)0xffffffd2) && (DAT_00559cd0 == 4)) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("\n Retry again\n",1,0xe,stderr);
        }
        FUN_004bb788(&local_3c,local_res4[0]);
        piVar4 = local_res4[0];
      }
    }
  }
  return piVar4;
}



uint * FUN_004bb788(int *param_1,int *param_2)

{
  int iVar1;
  undefined4 *puVar2;
  int *local_res4 [3];
  int local_28;
  uint *puVar3;
  undefined **local_20;
  int local_1c;
  char *local_14;
  int local_10 [2];
  
  local_14 = (char *)0x0;
  local_10[0] = 0;
  puVar3 = (uint *)0x0;
  local_20 = (undefined **)0x0;
  local_res4[0] = param_2;
  do {
    if (*local_res4[0] == 0) {
LAB_004bbe50:
      if ((local_10[0] == 0) || (*local_res4[0] == 0)) {
        if (local_20 == (undefined **)0x0) {
          FUN_0040231c(stdout,(int *)0x0);
        }
        else if (puVar3 == (uint *)0xffffffd4) {
          FUN_00401c48(stderr,local_20);
        }
        else if (puVar3 == (uint *)0xffffffd3) {
          FUN_0044506c(param_1);
        }
        else if ((puVar3 == (uint *)0xffffffd8) && ((DAT_005562a6 & 1) != 0)) {
          fprintf(stderr,"%s : wl driver adapter not found\n",&DAT_0055c104);
        }
      }
      else {
        puVar2 = (undefined4 *)FUN_004bc79c((char *)*local_res4[0]);
        if (puVar2 == (undefined4 *)0x0) {
          if ((DAT_005562a6 & 1) != 0) {
            fprintf(stderr,"%s: Unrecognized command \"%s\", type -h for help\n",DAT_00557690,
                    (char *)*local_res4[0]);
          }
        }
        else {
          FUN_00401c48(stdout,puVar2);
        }
      }
      return puVar3;
    }
    iVar1 = strcmp((char *)*local_res4[0],"sh");
    if ((iVar1 == 0) && (DAT_00559cd0 != 0)) {
      local_res4[0] = local_res4[0] + 1;
      if (*local_res4[0] != 0) {
        puVar3 = FUN_004c5748(param_1,local_res4[0],-1);
        return puVar3;
      }
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Enter the shell command, e.g. ls(Linux) or dir(Win CE)\n",1,0x37,stderr);
      }
      return (uint *)0xffffffff;
    }
    if (DAT_005562a0 == 5) {
      local_28 = 0;
      while (((&PTR_DAT_00556d80)[local_28] != (undefined *)0x0 &&
             (iVar1 = strcmp((&PTR_DAT_00556d80)[local_28],(char *)*local_res4[0]), iVar1 != 0))) {
        local_28 = local_28 + 1;
      }
      if ((&PTR_DAT_00556d80)[local_28] != (undefined *)0x0) {
        puVar3 = FUN_004c5748(param_1,local_res4[0],-3);
        if (DAT_00559cd0 != 3) {
          return puVar3;
        }
        iVar1 = strcmp((char *)*local_res4[0],"join");
        if (iVar1 != 0) {
          return puVar3;
        }
        if ((DAT_005562a6 & 2) != 0) {
          fwrite("\nChannel will be synchronized by Findserver\n\n",1,0x2d,stdout);
        }
        sleep(5);
        local_1c = 0;
        while( true ) {
          if (4 < local_1c) {
            return puVar3;
          }
          iVar1 = FUN_004ca570(param_1,PTR_DAT_00556db4);
          if (iVar1 == 0) break;
          local_1c = local_1c + 1;
        }
        return puVar3;
      }
    }
    iVar1 = FUN_00401988((int *)local_res4,(int *)&local_14,local_10);
    if (iVar1 != 0) {
      if (iVar1 != -1) {
        if (DAT_00559cd0 == 0) {
          if ((char)*param_1 == '\0') {
            FUN_004ba7f4(param_1);
          }
          if (((char)*param_1 == '\0') || (iVar1 = FUN_00401704(param_1), iVar1 < 0)) {
            fprintf(stderr,"%s: wl driver adapter not found\n",DAT_00557690);
                    // WARNING: Subroutine does not return
            exit(1);
          }
          iVar1 = strcmp((char *)*local_res4[0],"--interactive");
          if ((iVar1 == 0) || (DAT_00559cdc == 1)) {
            puVar3 = (uint *)FUN_004bbfec(param_1);
            return puVar3;
          }
        }
        local_20 = (undefined **)FUN_004bc79c((char *)*local_res4[0]);
        if (local_20 == (undefined **)0x0) {
          local_20 = &PTR_DAT_00555b10;
        }
        iVar1 = strcmp(*local_20,"findserver");
        if (iVar1 == 0) {
          FUN_004c93a0(param_1);
        }
        if (DAT_00559cd0 == 3) {
          iVar1 = strcmp((char *)*local_res4[0],"lchannel");
          if (iVar1 == 0) {
            builtin_strncpy((char *)*local_res4[0],"channel",8);
            FUN_004c968c(DAT_00559cd0);
            puVar3 = (uint *)(*(code *)local_20[1])(param_1,local_20,local_res4[0]);
            FUN_004c968c(DAT_00559cd0);
          }
          else {
            puVar3 = (uint *)(*(code *)local_20[1])(param_1,local_20,local_res4[0]);
          }
          iVar1 = strcmp(*local_20,"join");
          if ((iVar1 == 0) ||
             ((iVar1 = strcmp(*local_20,"ssid"), iVar1 == 0 &&
              (local_res4[0] = local_res4[0] + 1, *local_res4[0] != 0)))) {
            if ((DAT_005562a6 & 2) != 0) {
              fwrite("\n Findserver is called to synchronize thechannel\n\n",1,0x32,stdout);
            }
            sleep(5);
            local_1c = 0;
            while ((local_1c < 5 && (iVar1 = FUN_004ca570(param_1,PTR_DAT_00556db4), iVar1 != 0))) {
              local_1c = local_1c + 1;
            }
          }
        }
        else {
          puVar3 = (uint *)(*(code *)local_20[1])(param_1,local_20,local_res4[0]);
        }
      }
      goto LAB_004bbe50;
    }
    if (local_10[0] != 0) goto LAB_004bbe50;
    if (local_14 != (char *)0x0) {
      if (DAT_00559cd0 == 0) {
        strncpy((char *)param_1,local_14,0x10);
      }
      else {
        strncpy(&DAT_0055c104,local_14,0x10);
      }
    }
  } while( true );
}



int FUN_004bbfec(int *param_1)

{
  char *pcVar1;
  int iVar2;
  int local_258;
  int local_254;
  int local_250;
  char local_244 [512];
  char *local_44;
  int local_40;
  
  local_258 = 0;
  do {
    do {
      fwrite(&DAT_00527890,1,2,stdout);
      pcVar1 = fgets(local_244,0x200,stdin);
      if (pcVar1 == (char *)0x0) {
        return local_258;
      }
    } while ((local_244[0] == '\n') || (local_244[0] == '\0'));
    for (local_250 = 0; local_250 < 0xe; local_250 = local_250 + 1) {
      if (local_250 == 0) {
        pcVar1 = local_244;
      }
      else {
        pcVar1 = (char *)0x0;
      }
      pcVar1 = strtok(pcVar1," \t\n");
      if (pcVar1 == (char *)0x0) break;
      if ((*pcVar1 == '\"') && (pcVar1[1] == '\"')) {
        *pcVar1 = '\0';
      }
      (&local_44)[local_250] = pcVar1;
    }
    (&local_44)[local_250] = (char *)0x0;
    if ((local_250 == 0xe) && (pcVar1 = strtok((char *)0x0," \t"), pcVar1 != (char *)0x0)) {
      printf("wl:error: too many args; argc must be < %d\n",0xe);
    }
    else {
      iVar2 = strcmp(local_44,"findserver");
      if (iVar2 == 0) {
        FUN_004c93a0(param_1);
      }
      iVar2 = strcmp(local_44,"q");
      if (iVar2 == 0) {
        return local_258;
      }
      iVar2 = strcmp(local_44,"exit");
      if (iVar2 == 0) {
        return local_258;
      }
      iVar2 = strcmp(local_44,"sh");
      if ((iVar2 == 0) && (DAT_00559cd0 != 0)) {
        if (local_40 == 0) {
          if ((DAT_005562a6 & 1) != 0) {
            fwrite("Give shell command",1,0x12,stderr);
          }
        }
        else {
          FUN_004bb788(param_1,(int *)&local_44);
        }
      }
      else if (DAT_00559cd0 == 3) {
        iVar2 = strcmp(local_44,"lchannel");
        if (iVar2 == 0) {
          builtin_strncpy(local_44,"channel",8);
          FUN_004c968c(DAT_00559cd0);
          local_258 = FUN_004bc4a0(param_1,(int *)&local_44);
          FUN_004c968c(DAT_00559cd0);
        }
        else {
          local_258 = FUN_004bc4a0(param_1,(int *)&local_44);
        }
        iVar2 = strcmp(local_44,"join");
        if ((iVar2 == 0) || (iVar2 = strcmp(local_44,"ssid"), iVar2 == 0)) {
          if ((DAT_005562a6 & 2) != 0) {
            fwrite("\n Findserver is calledafter the join issued to remote \n \n",1,0x39,stdout);
          }
          sleep(5);
          local_254 = 0;
          while ((local_254 < 5 && (iVar2 = FUN_004ca570(param_1,PTR_DAT_00556db4), iVar2 != 0))) {
            local_254 = local_254 + 1;
          }
        }
      }
      else {
        local_258 = FUN_004bc4a0(param_1,(int *)&local_44);
      }
    }
  } while( true );
}



int FUN_004bc4a0(int *param_1,int *param_2)

{
  int iVar1;
  undefined4 *puVar2;
  int *local_res4 [3];
  undefined **local_20;
  int local_1c;
  int local_18;
  int local_14;
  int local_10 [2];
  
  local_20 = (undefined **)0x0;
  local_1c = 0;
  local_14 = 0;
  local_10[0] = 0;
  local_18 = 1;
  local_res4[0] = param_2;
  if ((*param_2 != 0) && (iVar1 = strcmp((char *)*param_2,"wl"), iVar1 == 0)) {
    local_res4[0] = local_res4[0] + 1;
  }
  if (((*local_res4[0] != 0) &&
      (local_18 = FUN_00401988((int *)local_res4,local_10,&local_14), local_18 == 0)) &&
     (local_10[0] != 0)) {
    fwrite("Interface name change not allowed within --interactive\n",1,0x37,stderr);
  }
  if (*local_res4[0] == 0) {
    local_1c = 0;
  }
  else {
    if (local_18 != -1) {
      local_20 = (undefined **)FUN_004bc79c((char *)*local_res4[0]);
      if (local_20 == (undefined **)0x0) {
        local_20 = &PTR_DAT_00555b10;
      }
      local_1c = (*(code *)local_20[1])(param_1,local_20,local_res4[0]);
    }
    if ((local_14 == 0) || (*local_res4[0] == 0)) {
      if (local_20 == (undefined **)0x0) {
        FUN_0040231c(stdout,(int *)0x0);
      }
      else if (local_1c == -0x2c) {
        FUN_00401c48(stderr,local_20);
      }
      else if (local_1c == -0x2d) {
        FUN_0044506c(param_1);
      }
      else if ((local_1c == -0x28) && ((DAT_005562a6 & 1) != 0)) {
        fprintf(stderr,"%s : wl driver adapter not found\n",&DAT_0055c104);
      }
    }
    else {
      puVar2 = (undefined4 *)FUN_004bc79c((char *)*local_res4[0]);
      if (puVar2 == (undefined4 *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fprintf(stderr,"%s: Unrecognized command \"%s\", type -h for help\n",DAT_00557690,
                  (char *)*local_res4[0]);
        }
      }
      else {
        FUN_00401c48(stdout,puVar2);
      }
    }
  }
  return local_1c;
}



void FUN_004bc79c(char *param_1)

{
  FUN_00401514(param_1);
  return;
}



void FUN_004bc7d4(void)

{
  __pid_t __pid;
  
  kill(DAT_005576a0,2);
  __pid = getpid();
  kill(__pid,2);
                    // WARNING: Subroutine does not return
  exit(0);
}



void FUN_004bc824(void)

{
  signal(2,FUN_004c4bbc);
  signal(0xf,FUN_004bc7d4);
  signal(6,FUN_004bc7d4);
  fork();
  return;
}



void FUN_004bc894(__pid_t param_1)

{
  kill(param_1,9);
  signal(2,(__sighandler_t)0x0);
  wait((void *)0x0);
  return;
}



undefined4 FUN_004bc8f0(void)

{
  bool bVar1;
  undefined3 extraout_var;
  hostent *phVar2;
  undefined3 extraout_var_00;
  undefined1 auStack_c [4];
  
  bVar1 = FUN_0041d840(DAT_00559cd4,(int)auStack_c);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    phVar2 = gethostbyname(DAT_00559cd4);
    if (phVar2 == (hostent *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Enter correct IP address/hostname format\n",1,0x29,stderr);
      }
      return 0xffffffff;
    }
    bVar1 = FUN_0041d840(*phVar2->h_addr_list,(int)auStack_c);
    if (CONCAT31(extraout_var_00,bVar1) != 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Error in IP address \n",1,0x15,stderr);
      }
      return 0xffffffff;
    }
    DAT_00559cd4 = inet_ntoa((in_addr)*(in_addr_t *)*phVar2->h_addr_list);
    if (DAT_00559cd4 == (char *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Error at inet_ntoa \n",1,0x14,stderr);
      }
      return 0xffffffff;
    }
  }
  return 1;
}



uint FUN_004bca90(byte *param_1,undefined4 *param_2,uint param_3)

{
  bool bVar1;
  uint uVar2;
  byte *local_res0;
  uint local_res8;
  uint local_14;
  
  local_14 = 0;
  bVar1 = false;
  local_res0 = param_1;
  while (((&DAT_00527ad8)[*local_res0] & 0x20) != 0) {
    local_res0 = local_res0 + 1;
  }
  if (*local_res0 == 0x2b) {
    local_res0 = local_res0 + 1;
  }
  else if (*local_res0 == 0x2d) {
    bVar1 = true;
    local_res0 = local_res0 + 1;
  }
  if (param_3 == 0) {
    if (*local_res0 == 0x30) {
      if ((local_res0[1] == 0x78) || (local_res0[1] == 0x58)) {
        local_res8 = 0x10;
        local_res0 = local_res0 + 2;
      }
      else {
        local_res8 = 8;
        local_res0 = local_res0 + 1;
      }
    }
    else {
      local_res8 = 10;
    }
  }
  else {
    local_res8 = param_3;
    if (((param_3 == 0x10) && (*local_res0 == 0x30)) &&
       ((local_res0[1] == 0x78 || (local_res0[1] == 0x58)))) {
      local_res0 = local_res0 + 2;
    }
  }
  while (((&DAT_00527ad8)[*local_res0] & 0x44) != 0) {
    if (((&DAT_00527ad8)[*local_res0] & 4) == 0) {
      if (((&DAT_00527ad8)[*local_res0] & 2) == 0) {
        uVar2 = (int)(char)*local_res0 - 0x37;
      }
      else {
        uVar2 = (int)(char)*local_res0 - 0x57;
      }
    }
    else {
      uVar2 = (int)(char)*local_res0 - 0x30;
    }
    if (local_res8 <= uVar2) break;
    uVar2 = local_14 * local_res8 + uVar2;
    if ((uVar2 < local_14) && (!bVar1)) {
      if (param_2 == (undefined4 *)0x0) {
        return uVar2;
      }
      while (((&DAT_00527ad8)[*local_res0] & 0x44) != 0) {
        local_res0 = local_res0 + 1;
      }
      *param_2 = local_res0;
      return uVar2;
    }
    local_res0 = local_res0 + 1;
    local_14 = uVar2;
  }
  if (bVar1) {
    local_14 = -local_14;
  }
  if (param_2 != (undefined4 *)0x0) {
    *param_2 = local_res0;
  }
  return local_14;
}



void FUN_004bce0c(byte *param_1)

{
  FUN_004bca90(param_1,(undefined4 *)0x0,10);
  return;
}



char * FUN_004bce4c(char *param_1,char *param_2)

{
  size_t __n;
  size_t sVar1;
  int iVar2;
  int local_18;
  
  if ((param_1 != (char *)0x0) && (param_2 != (char *)0x0)) {
    __n = strlen(param_2);
    sVar1 = strlen(param_1);
    for (local_18 = 0; local_18 < (int)((sVar1 - __n) + 1); local_18 = local_18 + 1) {
      iVar2 = memcmp(param_2,param_1 + local_18,__n);
      if (iVar2 == 0) {
        return param_1 + local_18;
      }
    }
    param_1 = (char *)0x0;
  }
  return param_1;
}



char * FUN_004bcf40(char *param_1,uint param_2,char *param_3,uint param_4)

{
  int iVar1;
  char *local_res0;
  uint local_res4;
  
  local_res0 = param_1;
  local_res4 = param_2;
  while( true ) {
    if (local_res4 < param_4) {
      return (char *)0x0;
    }
    iVar1 = strncmp(local_res0,param_3,param_4);
    if (iVar1 == 0) break;
    local_res0 = local_res0 + 1;
    local_res4 = local_res4 - 1;
  }
  return local_res0;
}



char * FUN_004bcfd8(char *param_1,char *param_2)

{
  char cVar1;
  size_t sVar2;
  char *local_res4;
  char *local_10;
  
  sVar2 = strlen(param_1);
  local_10 = param_1 + sVar2;
  local_res4 = param_2;
  do {
    *local_10 = *local_res4;
    cVar1 = *local_10;
    local_10 = local_10 + 1;
    local_res4 = local_res4 + 1;
  } while (cVar1 != '\0');
  return param_1;
}



char * FUN_004bd068(char *param_1,char *param_2,int param_3)

{
  char cVar1;
  size_t sVar2;
  char *pcVar3;
  char *local_res4;
  char *local_10;
  
  sVar2 = strlen(param_1);
  local_10 = param_1 + sVar2;
  pcVar3 = local_10 + param_3;
  local_res4 = param_2;
  do {
    if (local_10 == pcVar3) {
      return param_1;
    }
    *local_10 = *local_res4;
    cVar1 = *local_10;
    local_10 = local_10 + 1;
    local_res4 = local_res4 + 1;
  } while (cVar1 != '\0');
  return param_1;
}



byte * FUN_004bd118(undefined4 *param_1,byte *param_2,byte *param_3)

{
  byte bVar1;
  byte *pbVar2;
  byte *local_res4;
  byte *local_38;
  int local_34;
  uint auStack_2c [10];
  
  if (param_3 != (byte *)0x0) {
    *param_3 = 0;
  }
  for (local_34 = 0; local_res4 = param_2, local_34 < 8; local_34 = local_34 + 1) {
    auStack_2c[local_34] = 0;
  }
  do {
    auStack_2c[(char)*local_res4 >> 5] =
         auStack_2c[(char)*local_res4 >> 5] | 1 << (*local_res4 & 0x1f);
    bVar1 = *local_res4;
    local_res4 = local_res4 + 1;
  } while (bVar1 != 0);
  for (local_38 = (byte *)*param_1;
      ((pbVar2 = local_38, (auStack_2c[*local_38 >> 5] & 1 << (*local_38 & 0x1f)) != 0 &&
       (*local_38 != 0)) || (*local_38 == 0x20)); local_38 = local_38 + 1) {
  }
  do {
    if (*local_38 == 0) {
LAB_004bd330:
      *param_1 = local_38;
      if (pbVar2 == local_38) {
        pbVar2 = (byte *)0x0;
      }
      return pbVar2;
    }
    if ((auStack_2c[*local_38 >> 5] & 1 << (*local_38 & 0x1f)) != 0) {
      if (param_3 != (byte *)0x0) {
        *param_3 = *local_38;
      }
      *local_38 = 0;
      local_38 = local_38 + 1;
      goto LAB_004bd330;
    }
    local_38 = local_38 + 1;
  } while( true );
}



undefined4 FUN_004bd370(char *param_1,char *param_2)

{
  char cVar1;
  char cVar2;
  undefined4 uVar3;
  char *local_res0;
  char *local_res4;
  
  local_res0 = param_1;
  local_res4 = param_2;
  while( true ) {
    if ((*local_res4 == '\0') || (*local_res0 == '\0')) {
      if ((*local_res0 == '\0') || (*local_res4 != '\0')) {
        if ((*local_res0 == '\0') && (*local_res4 != '\0')) {
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = 0;
        }
      }
      else {
        uVar3 = 1;
      }
      return uVar3;
    }
    if ((*local_res0 < 'A') || ('Z' < *local_res0)) {
      cVar1 = *local_res0;
    }
    else {
      cVar1 = *local_res0 + ' ';
    }
    if ((*local_res4 < 'A') || ('Z' < *local_res4)) {
      cVar2 = *local_res4;
    }
    else {
      cVar2 = *local_res4 + ' ';
    }
    if (cVar1 < cVar2) break;
    if (cVar2 < cVar1) {
      return 1;
    }
    local_res0 = local_res0 + 1;
    local_res4 = local_res4 + 1;
  }
  return 0xffffffff;
}



undefined4 FUN_004bd51c(char *param_1,char *param_2,int param_3)

{
  char cVar1;
  char cVar2;
  undefined4 uVar3;
  char *local_res0;
  char *local_res4;
  int local_res8;
  
  local_res0 = param_1;
  local_res4 = param_2;
  local_res8 = param_3;
  while( true ) {
    if (((*local_res4 == '\0') || (*local_res0 == '\0')) || (local_res8 == 0)) {
      if (local_res8 == 0) {
        uVar3 = 0;
      }
      else if ((*local_res0 == '\0') || (*local_res4 != '\0')) {
        if ((*local_res0 == '\0') && (*local_res4 != '\0')) {
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = 0;
        }
      }
      else {
        uVar3 = 1;
      }
      return uVar3;
    }
    if ((*local_res0 < 'A') || ('Z' < *local_res0)) {
      cVar1 = *local_res0;
    }
    else {
      cVar1 = *local_res0 + ' ';
    }
    if ((*local_res4 < 'A') || ('Z' < *local_res4)) {
      cVar2 = *local_res4;
    }
    else {
      cVar2 = *local_res4 + ' ';
    }
    if (cVar1 < cVar2) break;
    if (cVar2 < cVar1) {
      return 1;
    }
    local_res0 = local_res0 + 1;
    local_res4 = local_res4 + 1;
    local_res8 = local_res8 + -1;
  }
  return 0xffffffff;
}



bool FUN_004bd6fc(byte *param_1,int param_2)

{
  char **ppcVar1;
  byte *local_res0;
  int local_10;
  char *local_c;
  
  local_10 = 0;
  local_res0 = param_1;
  do {
    ppcVar1 = &local_c;
    FUN_004bca90(local_res0,ppcVar1,0x10);
    *(char *)(param_2 + local_10) = (char)ppcVar1;
    local_10 = local_10 + 1;
    local_res0 = (byte *)(local_c + 1);
    if (*local_c == '\0') break;
  } while (local_10 != 6);
  return local_10 == 6;
}



char * FUN_004bd7c0(byte *param_1,char *param_2)

{
  byte *local_18;
  char *local_14;
  int local_10;
  
  local_18 = param_1;
  local_14 = param_2;
  for (local_10 = 0; local_10 < 6; local_10 = local_10 + 1) {
    *local_14 = "0123456789abcdef"[*local_18 >> 4];
    local_14[1] = "0123456789abcdef"[*local_18 & 0xf];
    local_14[2] = ':';
    local_14 = local_14 + 3;
    local_18 = local_18 + 1;
  }
  local_14[-1] = '\0';
  return param_2;
}



char * FUN_004bd8bc(byte *param_1,char *param_2)

{
  snprintf(param_2,0x10,"%d.%d.%d.%d",(uint)*param_1,(uint)param_1[1],(uint)param_1[2],
           (uint)param_1[3]);
  return param_2;
}



char * FUN_004bd940(void *param_1,char *param_2)

{
  int iVar1;
  char *local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  ushort *local_24;
  ushort auStack_18 [4];
  short local_10;
  short local_e;
  ushort local_c [2];
  
  local_30 = -1;
  local_2c = 0;
  local_28 = 1;
  local_24 = (ushort *)0x0;
  memcpy(auStack_18,param_1,0x10);
  for (local_34 = 0; local_34 < 8; local_34 = local_34 + 1) {
    if (auStack_18[local_34] == 0) {
      local_2c = local_2c + 1;
    }
    else {
      if (local_28 < local_2c) {
        local_28 = local_2c;
        local_30 = local_34 - local_2c;
      }
      local_2c = 0;
    }
  }
  if (local_28 < local_2c) {
    local_28 = local_2c;
    local_30 = local_34 - local_2c;
  }
  if ((local_30 == 0) &&
     ((((local_28 == 4 && (local_10 == -1)) && (local_e == 0)) ||
      ((local_28 == 5 && (local_e == -1)))))) {
    local_24 = local_c;
  }
  local_34 = 0;
  local_38 = param_2;
  while( true ) {
    if (7 < local_34) {
      return param_2;
    }
    if (auStack_18 + local_34 == local_24) break;
    if (local_34 == local_30) {
      *local_38 = ':';
      local_34 = local_34 + local_28 + -1;
      local_38[1] = ':';
      local_38[2] = '\0';
      local_38 = local_38 + 1;
    }
    else {
      if (local_34 != 0) {
        *local_38 = ':';
        local_38 = local_38 + 1;
      }
      iVar1 = snprintf(local_38,8,"%x",
                       (uint)(ushort)(auStack_18[local_34] << 8 | auStack_18[local_34] >> 8));
      local_38 = local_38 + iVar1;
    }
    local_34 = local_34 + 1;
  }
  snprintf(local_38,0x10,":%u.%u.%u.%u",(uint)(byte)*local_24,(uint)*(byte *)((int)local_24 + 1),
           (uint)(byte)local_24[1],(uint)*(byte *)((int)local_24 + 3));
  return param_2;
}



undefined1 * FUN_004bdc74(undefined1 param_1,void *param_2,size_t param_3,undefined1 *param_4)

{
  undefined1 *local_10;
  
  local_10 = param_4;
  if ((((param_4 != (undefined1 *)0x0) && (-1 < (int)param_3)) && ((int)param_3 < 0x100)) &&
     ((param_2 != (void *)0x0 || (param_3 == 0)))) {
    *param_4 = param_1;
    param_4[1] = (char)param_3;
    if (0 < (int)param_3) {
      memcpy(param_4 + 2,param_2,param_3);
    }
    local_10 = param_4 + param_3 + 2;
  }
  return local_10;
}



undefined1 *
FUN_004bdd60(undefined1 param_1,void *param_2,size_t param_3,undefined1 *param_4,int param_5)

{
  undefined4 local_10;
  
  local_10 = param_4;
  if (((-1 < (int)param_3) && ((int)param_3 < 0x100)) && ((int)(param_3 + 2) <= param_5)) {
    local_10 = FUN_004bdc74(param_1,param_2,param_3,param_4);
  }
  return local_10;
}



void * FUN_004bddf8(void *param_1,void *param_2)

{
  size_t __n;
  undefined4 local_18;
  
  local_18 = param_2;
  if ((param_2 != (void *)0x0) && (param_1 != (void *)0x0)) {
    __n = *(byte *)((int)param_1 + 1) + 2;
    memcpy(param_2,param_1,__n);
    local_18 = (void *)((int)param_2 + __n);
  }
  return local_18;
}



void * FUN_004bde88(void *param_1,void *param_2,int param_3)

{
  undefined4 local_10;
  
  local_10 = param_2;
  if (((param_1 != (void *)0x0) && (1 < param_3)) &&
     ((int)(*(byte *)((int)param_1 + 1) + 2) <= param_3)) {
    local_10 = FUN_004bddf8(param_1,param_2);
  }
  return local_10;
}



byte FUN_004bdf20(byte *param_1,int param_2,byte param_3)

{
  bool bVar1;
  byte *local_res0;
  int local_res4;
  byte local_res8;
  
  local_res0 = param_1;
  local_res4 = param_2;
  local_res8 = param_3;
  while (bVar1 = local_res4 != 0, local_res4 = local_res4 + -1, bVar1) {
    local_res8 = (&DAT_00527bf8)[*local_res0 ^ local_res8];
    local_res0 = local_res0 + 1;
  }
  return local_res8;
}



ushort FUN_004bdfb4(byte *param_1,int param_2,ushort param_3)

{
  bool bVar1;
  byte *local_res0;
  int local_res4;
  ushort local_res8;
  
  local_res0 = param_1;
  local_res4 = param_2;
  local_res8 = param_3;
  while (bVar1 = local_res4 != 0, local_res4 = local_res4 + -1, bVar1) {
    local_res8 = local_res8 >> 8 ^
                 *(ushort *)(&DAT_00527cf8 + (((uint)local_res8 ^ (uint)*local_res0) & 0xff) * 2);
    local_res0 = local_res0 + 1;
  }
  return local_res8;
}



uint FUN_004be058(uint *param_1,byte *param_2,uint param_3)

{
  uint *puVar1;
  uint uVar2;
  uint uVar3;
  uint *local_res0;
  byte *local_res4;
  uint local_res8;
  
  local_res0 = param_1;
  local_res4 = param_2;
  local_res8 = param_3;
  if ((byte *)0x3 < param_2) {
    puVar1 = (uint *)((int)param_1 + 3U & 0xfffffffc);
    local_res4 = param_2 + ((int)param_1 - (int)puVar1);
    for (; local_res0 < puVar1; local_res0 = (uint *)((int)local_res0 + 1)) {
      local_res8 = local_res8 >> 8 ^
                   *(uint *)(&DAT_00527ef8 + (((byte)*local_res0 ^ local_res8) & 0xff) * 4);
    }
  }
  if ((byte *)0x3 < local_res4) {
    puVar1 = (uint *)((int)local_res0 + ((uint)local_res4 & 0xfffffffc));
    for (; local_res0 < puVar1; local_res0 = local_res0 + 1) {
      uVar3 = *local_res0;
      uVar2 = local_res8 >> 8 ^ *(uint *)(&DAT_00527ef8 + ((uVar3 & 0xff ^ local_res8) & 0xff) * 4);
      uVar2 = uVar2 >> 8 ^ *(uint *)(&DAT_00527ef8 + ((uVar3 >> 8 & 0xff ^ uVar2) & 0xff) * 4);
      uVar2 = uVar2 >> 8 ^ *(uint *)(&DAT_00527ef8 + ((uVar3 >> 0x10 & 0xff ^ uVar2) & 0xff) * 4);
      local_res8 = uVar2 >> 8 ^ *(uint *)(&DAT_00527ef8 + ((uVar3 >> 0x18 ^ uVar2) & 0xff) * 4);
    }
  }
  puVar1 = (uint *)((int)local_res0 + ((uint)local_res4 & 3));
  for (; local_res0 < puVar1; local_res0 = (uint *)((int)local_res0 + 1)) {
    local_res8 = local_res8 >> 8 ^
                 *(uint *)(&DAT_00527ef8 + (((byte)*local_res0 ^ local_res8) & 0xff) * 4);
  }
  return local_res8;
}



int FUN_004be2ec(int param_1,int *param_2)

{
  int iVar1;
  int iVar2;
  
  if ((*param_2 < 2) || (*param_2 < (int)(*(byte *)(param_1 + 1) + 2))) {
    iVar1 = 0;
  }
  else {
    iVar2 = param_1 + (uint)*(byte *)(param_1 + 1);
    iVar1 = iVar2 + 2;
    *param_2 = *param_2 + (-2 - (uint)*(byte *)(param_1 + 1));
    if ((*param_2 < 2) || (*param_2 < (int)(*(byte *)(iVar2 + 3) + 2))) {
      iVar1 = 0;
    }
  }
  return iVar1;
}



byte * FUN_004be3d8(byte *param_1,int param_2,uint param_3)

{
  uint uVar1;
  byte *local_18;
  int local_14;
  
  local_18 = param_1;
  local_14 = param_2;
  while( true ) {
    if (local_14 < 2) {
      return (byte *)0x0;
    }
    uVar1 = (uint)local_18[1];
    if ((*local_18 == param_3) && ((int)(uVar1 + 2) <= local_14)) break;
    local_18 = local_18 + uVar1 + 2;
    local_14 = local_14 + (-2 - uVar1);
  }
  return local_18;
}



byte * FUN_004be4a4(byte *param_1,int param_2,uint param_3)

{
  uint uVar1;
  byte *local_18;
  int local_14;
  
  local_18 = param_1;
  local_14 = param_2;
  while( true ) {
    if (local_14 < 2) {
      return (byte *)0x0;
    }
    uVar1 = (uint)local_18[1];
    if (param_3 < *local_18) break;
    if ((*local_18 == param_3) && ((int)(uVar1 + 2) <= local_14)) {
      return local_18;
    }
    local_18 = local_18 + uVar1 + 2;
    local_14 = local_14 + (-2 - uVar1);
  }
  return (byte *)0x0;
}



size_t FUN_004be594(uint *param_1,uint param_2,char *param_3,int param_4)

{
  uint uVar1;
  size_t sVar2;
  char *__s;
  int local_20;
  
  uVar1 = *param_1;
  if ((1 < param_4) && (param_3 != (char *)0x0)) {
    *param_3 = '\0';
    local_20 = 0;
    while (__s = *(char **)(param_1[1] + local_20 * 8 + 4), __s != (char *)0x0) {
      if ((param_2 & uVar1) == *(uint *)(param_1[1] + local_20 * 8)) {
        sVar2 = strlen(__s);
        if ((int)sVar2 < param_4) {
          sVar2 = strlen(__s);
          strncpy(param_3,__s,sVar2 + 1);
          return sVar2;
        }
        return 0;
      }
      local_20 = local_20 + 1;
    }
  }
  return 0;
}



int FUN_004be6e4(int param_1,uint param_2,char *param_3,int param_4)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  uint local_res4;
  int local_30;
  char *local_2c;
  int local_28;
  char *local_24;
  char acStack_18 [16];
  
  local_28 = 0;
  if ((param_4 < 2) || (param_3 == (char *)0x0)) {
    iVar1 = 0;
  }
  else {
    *param_3 = '\0';
    local_30 = 0;
    local_res4 = param_2;
    local_2c = param_3;
    while (local_res4 != 0) {
      uVar2 = *(uint *)(param_1 + local_30 * 8);
      local_24 = *(char **)(param_1 + local_30 * 8 + 4);
      if ((uVar2 == 0) && (local_res4 != 0)) {
        snprintf(acStack_18,0x10,"0x%X",local_res4);
        local_24 = acStack_18;
        local_res4 = 0;
LAB_004be7e0:
        local_res4 = local_res4 & ~uVar2;
        sVar3 = strlen(local_24);
        local_28 = local_28 + sVar3;
        if (local_res4 != 0) {
          local_28 = local_28 + 1;
        }
        if (param_4 <= local_28) break;
        strncpy(local_2c,local_24,sVar3 + 1);
        local_2c = local_2c + sVar3;
        if (local_res4 != 0) {
          *local_2c = ' ';
          local_2c[1] = '\0';
          local_2c = local_2c + 1;
        }
      }
      else if ((local_res4 & uVar2) != 0) goto LAB_004be7e0;
      local_30 = local_30 + 1;
    }
    if (local_res4 != 0) {
      if (param_4 < 2) {
        local_2c = local_2c + -(2 - param_4);
      }
      *local_2c = '>';
      local_2c[1] = '\0';
      local_2c = local_2c + 1;
    }
    iVar1 = (int)local_2c - (int)param_3;
  }
  return iVar1;
}



int FUN_004be93c(char *param_1,byte *param_2,int param_3)

{
  int iVar1;
  int local_18;
  char *local_14;
  byte *local_10;
  
  local_14 = param_1;
  local_10 = param_2;
  for (local_18 = 0; local_18 < param_3; local_18 = local_18 + 1) {
    iVar1 = snprintf(local_14,3,"%02X",(uint)*local_10);
    local_14 = local_14 + iVar1;
    local_10 = local_10 + 1;
  }
  return (int)local_14 - (int)param_1;
}



void FUN_004be9f4(char *param_1,int param_2,uint param_3)

{
  int iVar1;
  char *local_98;
  size_t local_94;
  uint local_90;
  char acStack_88 [128];
  
  local_94 = 0x80;
  if ((param_1 != (char *)0x0) && (*param_1 != '\0')) {
    printf("%s:\n",param_1);
  }
  local_98 = acStack_88;
  for (local_90 = 0; local_90 < param_3; local_90 = local_90 + 1) {
    if ((local_90 & 0xf) == 0) {
      iVar1 = snprintf(local_98,local_94,"  %04x: ",local_90);
      local_98 = local_98 + iVar1;
      local_94 = local_94 - iVar1;
    }
    if (0 < (int)local_94) {
      iVar1 = snprintf(local_98,local_94,"%02x ",(uint)*(byte *)(param_2 + local_90));
      local_98 = local_98 + iVar1;
      local_94 = local_94 - iVar1;
    }
    if ((local_90 & 0xf) == 0xf) {
      puts(acStack_88);
      local_98 = acStack_88;
      local_94 = 0x80;
    }
  }
  if (local_98 != acStack_88) {
    puts(acStack_88);
  }
  return;
}



undefined * FUN_004beb9c(uint param_1)

{
  undefined *puVar1;
  
  if (param_1 < 0xc) {
    puVar1 = (&PTR_DAT_005562b0)[param_1];
  }
  else {
    puVar1 = &DAT_0052839c;
  }
  return puVar1;
}



void FUN_004bebf8(undefined1 *param_1,int param_2)

{
  bool bVar1;
  undefined1 *local_res0;
  int local_res4;
  
  local_res0 = param_1;
  local_res4 = param_2;
  while (bVar1 = local_res4 != 0, local_res4 = local_res4 + -1, bVar1) {
    *local_res0 = (&DAT_005562e0)[(uint)local_res0 & 3];
    local_res0 = local_res0 + 1;
  }
  return;
}



char * FUN_004bec74(uint param_1,char *param_2,size_t param_3)

{
  char *__format;
  
  if ((param_1 < 0xa001) && (0x3fff < param_1)) {
    __format = "%x";
  }
  else {
    __format = "%d";
  }
  snprintf(param_2,param_3,__format,param_1);
  return param_2;
}



char * FUN_004bed04(uint param_1,char *param_2)

{
  uchar param3;
  
  if (param_1 < 0x100) {
    snprintf(param_2,8,"%d.%d",(param_1 & 0xf0) >> 4,param_1 & 0xf);
  }
  else {
    if ((param_1 & 0xf000) == 0x1000) {
      param3 = 'P';
    }
    else {
      param3 = 'A';
    }
    snprintf(param_2,8,"%c%03x",param3,param_1 & 0xfff);
  }
  return param_2;
}



void FUN_004bedd0(char *param_1)

{
  char cVar1;
  char *local_res0;
  uint local_18;
  
  local_18 = strlen(param_1);
  local_res0 = param_1;
  for (; 0x200 < local_18; local_18 = local_18 - 0x200) {
    cVar1 = local_res0[0x200];
    local_res0[0x200] = '\0';
    printf("%s",local_res0);
    local_res0[0x200] = cVar1;
    local_res0 = local_res0 + 0x200;
  }
  puts(local_res0);
  return;
}



int FUN_004beeac(undefined *param_1,undefined4 param_2,undefined4 param_3,int *param_4,char *param_5
                ,uint param_6)

{
  undefined4 uVar1;
  char *__format;
  int local_20;
  uint local_1c;
  int *local_18;
  
  local_20 = 0;
  for (local_18 = param_4; (1 < param_6 && (*local_18 != 0)); local_18 = local_18 + 3) {
    __format = (char *)*local_18;
    uVar1 = (*(code *)param_1)(param_2,param_3,local_18[1]);
    local_1c = snprintf(param_5,param_6,__format,uVar1);
    if (((int)local_1c < 0) || (param_6 <= local_1c)) {
      local_1c = param_6 - 1;
    }
    param_5 = param_5 + local_1c;
    param_6 = param_6 - local_1c;
    local_20 = local_20 + local_1c;
  }
  return local_20;
}



int FUN_004befe0(char *param_1,void *param_2,size_t param_3,char *param_4,uint param_5)

{
  size_t sVar1;
  int iVar2;
  
  sVar1 = strlen(param_1);
  iVar2 = sVar1 + 1;
  if (param_5 < iVar2 + param_3) {
    iVar2 = 0;
  }
  else {
    strncpy(param_4,param_1,param_5);
    memcpy(param_4 + iVar2,param_2,param_3);
    iVar2 = iVar2 + param_3;
  }
  return iVar2;
}



uint FUN_004bf09c(byte param_1)

{
  uint uVar1;
  uint local_10;
  int local_c;
  
  local_10 = 1;
  local_c = param_1 - 0x99;
  if (local_c < 0x28) {
    for (; local_c < 0; local_c = local_c + 0x28) {
      local_10 = local_10 * 10;
    }
    if (local_10 == 0) {
      trap(7);
    }
    uVar1 = ((uint)*(ushort *)(&DAT_005283b8 + local_c * 2) + (local_10 >> 1)) / local_10 & 0xffff;
  }
  else {
    uVar1 = 0xffff;
  }
  return uVar1;
}



char FUN_004bf160(ushort param_1)

{
  char cVar1;
  byte local_18;
  uint local_10;
  
  local_10 = (uint)param_1;
  if (local_10 < 2) {
    cVar1 = '\0';
  }
  else {
    cVar1 = -0x67;
    for (; local_10 < 0x195d; local_10 = local_10 * 10) {
      cVar1 = cVar1 + -0x28;
    }
    local_18 = 0;
    while ((local_18 < 0x27 &&
           ((uint)*(ushort *)(&DAT_005283b8 + (uint)local_18 * 2) +
            (int)((uint)*(ushort *)(&DAT_005283b8 + (local_18 + 1) * 2) -
                 (uint)*(ushort *)(&DAT_005283b8 + (uint)local_18 * 2)) / 2 <= local_10))) {
      local_18 = local_18 + 1;
    }
    cVar1 = cVar1 + local_18;
  }
  return cVar1;
}



int FUN_004bf2b8(int param_1,uint param_2)

{
  undefined4 local_18;
  undefined4 local_14;
  undefined1 local_10;
  
  local_18 = 0;
  for (local_14 = 0; local_14 < param_2; local_14 = local_14 + 1) {
    for (local_10 = *(byte *)(param_1 + local_14); local_10 != 0; local_10 = local_10 - 1 & local_10
        ) {
      local_18 = local_18 + 1;
    }
  }
  return local_18;
}



uint FUN_004bf368(undefined1 *param_1,uint param_2)

{
  bool bVar1;
  int iVar2;
  undefined1 *local_20;
  int local_18;
  uint local_14;
  uint local_10;
  
  bVar1 = false;
  local_18 = 0;
  local_20 = param_1;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    if ((param_1[local_10] != '\r') && ((!bVar1 || (param_1[local_10] == '\n')))) {
      bVar1 = false;
      if (param_1[local_10] == '#') {
        bVar1 = true;
      }
      else if (param_1[local_10] == '\n') {
        if (local_18 != 0) {
          *local_20 = 0;
          local_20 = local_20 + 1;
          local_18 = 0;
        }
      }
      else {
        *local_20 = param_1[local_10];
        local_20 = local_20 + 1;
        local_18 = local_18 + 1;
      }
    }
  }
  local_14 = (int)local_20 - (int)param_1;
  if ((((local_14 & 3) != 0) && (iVar2 = 4 - (local_14 & 3), iVar2 != 0)) &&
     (local_14 + iVar2 <= param_2)) {
    local_14 = local_14 + iVar2;
  }
  for (; local_20 < param_1 + local_10; local_20 = local_20 + 1) {
    *local_20 = 0;
  }
  return local_14;
}



void FUN_004bf594(int *param_1,uint *param_2,uint param_3,uint param_4,uint param_5)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  
  uVar1 = param_3 >> 0x10;
  uVar2 = param_3 & 0xffff;
  uVar3 = param_4 >> 0x10;
  uVar4 = param_4 & 0xffff;
  uVar5 = uVar2 * uVar4;
  uVar6 = uVar1 * uVar4 * 0x10000;
  uVar7 = (uVar5 & 0x7fffffff) + (uVar6 & 0x7fffffff);
  uVar8 = uVar2 * uVar3 * 0x10000;
  uVar9 = (uVar7 & 0x7fffffff) + (uVar8 & 0x7fffffff);
  uVar10 = (uVar9 & 0x7fffffff) + (param_5 & 0x7fffffff);
  if (((((((int)uVar5 < 0 != (int)uVar6 < 0) != (int)uVar7 < 0) != (int)uVar8 < 0) != (int)uVar9 < 0
       ) != (int)param_5 < 0) == (int)uVar10 < 0) {
    uVar11 = 0;
  }
  else {
    uVar11 = 0x80000000;
  }
  *param_1 = uVar1 * uVar3 + (uVar1 * uVar4 >> 0x10) + (uVar3 * uVar2 >> 0x10) +
             ((uint)((int)uVar5 < 0) + (uint)((int)uVar6 < 0) + (uint)((int)uVar7 < 0) +
              (uint)((int)uVar8 < 0) + (uint)((int)uVar9 < 0) + (uint)((int)param_5 < 0) +
              (uint)((int)uVar10 < 0) >> 1);
  *param_2 = uVar10 & 0x7fffffff | uVar11;
  return;
}



void FUN_004bf854(int *param_1,uint param_2,uint param_3,uint param_4)

{
  int local_18;
  uint local_14;
  uint local_10 [2];
  
  local_18 = 0;
  local_14 = param_2;
  local_10[0] = param_3;
  if (1 < param_4) {
    while (local_14 != 0) {
      if (param_4 == 0) {
        trap(7);
      }
      local_18 = local_18 + (0xffffffff / param_4) * local_14;
      if (param_4 == 0) {
        trap(7);
      }
      if (param_4 == 0) {
        trap(7);
      }
      FUN_004bf594((int *)&local_14,local_10,(0xffffffffU % param_4 + 1) % param_4,local_14,
                   local_10[0]);
    }
    if (param_4 == 0) {
      trap(7);
    }
    *param_1 = local_18 + local_10[0] / param_4;
  }
  return;
}



void FUN_004bf974(int param_1,uint param_2,uint param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  undefined4 local_20;
  
  uVar2 = param_2 >> 3;
  uVar3 = param_3 >> 3;
  if (param_3 < param_2) {
    FUN_004bf974(param_1,param_2,param_4,param_4);
    FUN_004bf974(param_1,0,param_3,param_4);
  }
  else {
    local_20 = param_2;
    if (uVar3 - uVar2 < 2) {
      for (; local_20 <= param_3; local_20 = local_20 + 1) {
        *(byte *)(param_1 + (local_20 >> 3)) =
             *(byte *)(param_1 + (local_20 >> 3)) | (byte)(1 << (local_20 & 7));
      }
    }
    else {
      local_20 = uVar2;
      while (local_20 = local_20 + 1, uVar1 = param_2, local_20 < uVar3) {
        *(undefined1 *)(param_1 + local_20) = 0xff;
      }
      while (local_20 = uVar1, uVar1 = uVar3 << 3, local_20 <= (uVar2 + 1) * 8 - 1) {
        *(byte *)(param_1 + (local_20 >> 3)) =
             *(byte *)(param_1 + (local_20 >> 3)) | (byte)(1 << (local_20 & 7));
        uVar1 = local_20 + 1;
      }
      while (local_20 = uVar1, local_20 <= param_3) {
        *(byte *)(param_1 + (local_20 >> 3)) =
             *(byte *)(param_1 + (local_20 >> 3)) | (byte)(1 << (local_20 & 7));
        uVar1 = local_20 + 1;
      }
    }
  }
  return;
}



void FUN_004bfbf4(uint param_1)

{
  uint local_10;
  
  for (local_10 = 0x1f; -1 < (int)local_10; local_10 = local_10 - 1) {
    if ((1 << (local_10 & 0x1f) & param_1) == 0) {
      printf("0");
    }
    else {
      printf("1");
    }
    if ((local_10 & 7) == 0) {
      putchar(0x20);
    }
  }
  putchar(10);
  return;
}



void FUN_004bfcb8(uint *param_1,uint param_2,uint param_3,uint param_4)

{
  if (param_4 == 0) {
    *param_1 = param_3;
  }
  else if (param_4 < 0x20) {
    *param_1 = param_3 >> (param_4 & 0x1f) |
               (param_2 & (1 << (param_4 & 0x1f)) - 1U) << (0x20 - param_4 & 0x1f);
  }
  else {
    *param_1 = param_2 >> (param_4 - 0x20 & 0x1f);
  }
  return;
}



void FUN_004bfdc0(int *param_1,uint *param_2,int param_3)

{
  uint uVar1;
  
  uVar1 = *param_2;
  *param_2 = *param_2 + param_3;
  if (*param_2 < uVar1) {
    *param_1 = *param_1 + 1;
  }
  return;
}



void FUN_004bfe3c(int *param_1,uint *param_2,int param_3)

{
  uint uVar1;
  
  uVar1 = *param_2;
  *param_2 = *param_2 - param_3;
  if (uVar1 < *param_2) {
    *param_1 = *param_1 + -1;
  }
  return;
}



uint FUN_004bfeb8(byte *param_1,uint param_2,uint param_3)

{
  byte *local_res0;
  uint local_res4;
  uint local_res8;
  
  local_res0 = param_1;
  local_res8 = param_3;
  for (local_res4 = param_2; 1 < local_res4; local_res4 = local_res4 - 2) {
    local_res8 = local_res8 + CONCAT11(*local_res0,local_res0[1]);
    local_res0 = local_res0 + 2;
  }
  if (local_res4 != 0) {
    local_res8 = local_res8 + (uint)*local_res0 * 0x100;
  }
  for (; local_res8 >> 0x10 != 0; local_res8 = (local_res8 & 0xffff) + (local_res8 >> 0x10)) {
  }
  return ~(local_res8 & 0xffff) & 0xffff;
}



undefined1 FUN_004bffb0(ushort param_1)

{
  undefined1 uVar1;
  uint uVar2;
  
  uVar2 = (int)(param_1 & 0x3800) >> 0xb;
  if (uVar2 < 7) {
    uVar1 = (&DAT_00528544)[uVar2];
  }
  else {
    uVar1 = 0;
  }
  return uVar1;
}



uint FUN_004c0018(int param_1)

{
  return (param_1 - 0x14U) / 10 & 0xff;
}



uint FUN_004c005c(uint param_1,int param_2)

{
  uint uVar1;
  
  uVar1 = FUN_004c0018(param_2);
  return (param_1 & 0xff) - uVar1 & 0xff;
}



uint FUN_004c00b0(uint param_1,int param_2,uint param_3)

{
  uint uVar1;
  
  uVar1 = FUN_004c005c(param_1,param_3);
  if ((param_2 - uVar1 & 3) == 0) {
    uVar1 = param_2 - uVar1 >> 2;
    if (param_3 / 0x14 <= uVar1) {
      uVar1 = 0xffffffff;
    }
  }
  else {
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



uint FUN_004c0168(uint param_1,int param_2,uint param_3)

{
  uint uVar1;
  
  uVar1 = FUN_004c005c(param_1,param_2);
  return uVar1 + (param_3 & 0x3f) * 4 & 0xff;
}



uint FUN_004c01c8(uint param_1)

{
  uint local_10;
  
  local_10 = 0;
  while( true ) {
    if (5 < local_10) {
      return 0xffffffff;
    }
    if ((byte)(&DAT_00528558)[local_10] == param_1) break;
    local_10 = local_10 + 1;
  }
  return local_10;
}



char * FUN_004c0248(ushort param_1,char *param_2)

{
  char *pcVar1;
  
  pcVar1 = FUN_004c02bc(param_1,param_2);
  if (pcVar1 == (char *)0x0) {
    snprintf(param_2,0x14,"invalid 0x%04x",(uint)param_1);
  }
  return param_2;
}



char * FUN_004c02bc(ushort param_1,char *param_2)

{
  int iVar1;
  uint param3;
  char *param5;
  uint uVar2;
  uint param4;
  char *local_20;
  
  iVar1 = FUN_004c0dc0(param_1);
  if (iVar1 == 0) {
    local_20 = "";
    if ((((param_1 & 0xc000) == 0) && (0xe < (param_1 & 0xff))) ||
       (((param_1 & 0xc000) == 0xc000 && ((param_1 & 0xff) < 0xf)))) {
      if ((param_1 & 0xc000) == 0) {
        local_20 = "2g";
      }
      else {
        local_20 = "5g";
      }
    }
    param3 = FUN_004c13a4(param_1);
    if ((param_1 & 0x3800) == 0x1000) {
      snprintf(param_2,0x14,"%s%d",local_20,param3);
    }
    else if ((param_1 & 0x3800) == 0x3000) {
      uVar2 = (int)(param_1 & 0xf0) >> 4;
      if ((param_1 & 0xf) < 6) {
        param4 = (uint)(byte)(&DAT_00528558)[param_1 & 0xf];
      }
      else {
        param4 = 0;
      }
      if (uVar2 < 6) {
        uVar2 = (uint)(byte)(&DAT_00528558)[uVar2];
      }
      else {
        uVar2 = 0;
      }
      snprintf(param_2,0x14,"%d/80+80/%d-%d",param3,param4,uVar2);
    }
    else if ((param_1 & 0x3800) == 0x1800) {
      if (((param_1 & 0x700) == 0x100) && ((param_1 & 0x3800) == 0x1800)) {
        param5 = "u";
      }
      else {
        param5 = "l";
      }
      snprintf(param_2,0x14,"%s%d%s",local_20,param3,param5);
    }
    else {
      snprintf(param_2,0x14,"%s%d/%s",local_20,param3,
               (&PTR_DAT_005562f0)[(int)(param_1 & 0x3800) >> 0xb]);
    }
  }
  else {
    param_2 = (char *)0x0;
  }
  return param_2;
}



bool FUN_004c05a4(int *param_1,ulong *param_2)

{
  ulong uVar1;
  char *pcVar2;
  char *local_c;
  
  local_c = (char *)0x0;
  uVar1 = strtoul((char *)*param_1,&local_c,10);
  pcVar2 = (char *)*param_1;
  if (pcVar2 != local_c) {
    *param_1 = (int)local_c;
    *param_2 = uVar1;
  }
  return pcVar2 != local_c;
}



ushort FUN_004c0638(char *param_1)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  bool bVar4;
  char cVar5;
  ushort uVar6;
  ushort uVar7;
  undefined3 extraout_var;
  int iVar8;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  char *local_res0 [4];
  ushort local_50;
  ushort local_44;
  char local_40;
  char local_3f;
  int local_3c;
  undefined *local_38;
  int local_34;
  uint local_30;
  ulong local_1c;
  uint local_18;
  uint local_14;
  ulong local_10;
  ulong local_c;
  
  local_3f = '\0';
  local_1c = 0x14;
  local_44 = 0;
  uVar3 = local_44;
  local_44 = 0;
  local_c = 0;
  local_10 = 0;
  local_50 = 0;
  uVar2 = local_50;
  local_50 = 0;
  uVar7 = local_50;
  local_res0[0] = param_1;
  bVar4 = FUN_004c05a4((int *)local_res0,&local_18);
  if (CONCAT31(extraout_var,bVar4) == 0) {
    return 0;
  }
  iVar8 = tolower((int)*local_res0[0]);
  local_40 = (char)iVar8;
  if (local_40 == 'g') {
    local_res0[0] = local_res0[0] + 1;
    if (local_18 == 2) {
      uVar6 = 0;
    }
    else {
      if (local_18 != 5) {
        return 0;
      }
      uVar6 = 0xc000;
    }
    bVar4 = FUN_004c05a4((int *)local_res0,&local_14);
    if (CONCAT31(extraout_var_00,bVar4) == 0) {
      return 0;
    }
    iVar8 = tolower((int)*local_res0[0]);
    local_40 = (char)iVar8;
  }
  else {
    local_14 = local_18;
    if (local_18 < 0xf) {
      uVar6 = 0;
    }
    else {
      uVar6 = 0xc000;
    }
  }
  if (local_40 == '\0') {
    uVar1 = 0x1000;
  }
  else {
    local_res0[0] = local_res0[0] + 1;
    if ((local_40 == 'u') || (local_40 == 'l')) {
      local_3f = local_40;
      uVar1 = 0x1800;
    }
    else {
      if (local_40 != '/') {
        return 0;
      }
      bVar4 = FUN_004c05a4((int *)local_res0,&local_1c);
      if (CONCAT31(extraout_var_01,bVar4) == 0) {
        return 0;
      }
      if (local_1c == 0x14) {
        uVar1 = 0x1000;
      }
      else if (local_1c == 0x28) {
        uVar1 = 0x1800;
      }
      else if (local_1c == 0x50) {
        uVar1 = 0x2000;
      }
      else {
        if (local_1c != 0xa0) {
          return 0;
        }
        uVar1 = 0x2800;
      }
      iVar8 = tolower((int)*local_res0[0]);
      cVar5 = (char)iVar8;
      if (((uVar6 == 0) && (local_1c == 0x28)) && ((cVar5 == 'u' || (cVar5 == 'l')))) {
        local_res0[0] = local_res0[0] + 1;
        local_3f = cVar5;
      }
      else if (cVar5 == '+') {
        uVar1 = 0x3000;
        for (local_3c = 0; local_res0[0] = local_res0[0] + 1, local_3c < 3; local_3c = local_3c + 1)
        {
          cVar5 = *PTR_DAT_00556310;
          PTR_DAT_00556310 = PTR_DAT_00556310 + 1;
          if (*local_res0[0] != cVar5) {
            return 0;
          }
        }
        bVar4 = FUN_004c05a4((int *)local_res0,&local_10);
        if (CONCAT31(extraout_var_02,bVar4) == 0) {
          return 0;
        }
        if (*local_res0[0] != '-') {
          return 0;
        }
        local_res0[0] = local_res0[0] + 1;
        bVar4 = FUN_004c05a4((int *)local_res0,&local_c);
        if (CONCAT31(extraout_var_03,bVar4) == 0) {
          return 0;
        }
      }
    }
  }
  for (; *local_res0[0] == ' '; local_res0[0] = local_res0[0] + 1) {
  }
  if (*local_res0[0] != '\0') {
    return 0;
  }
  local_50 = (ushort)local_14;
  if (local_3f == '\0') {
    if (uVar1 == 0x1000) {
      local_44 = 0;
      uVar7 = local_50;
    }
    else if (uVar1 == 0x3000) {
      uVar9 = FUN_004c01c8(local_10);
      uVar10 = FUN_004c01c8(local_c);
      if (((int)uVar9 < 0) || ((int)uVar10 < 0)) {
        return 0;
      }
      uVar11 = FUN_004c00b0(local_10,local_14,local_1c);
      if ((int)uVar11 < 0) {
        return 0;
      }
      local_44 = (ushort)(uVar11 << 8);
      uVar7 = (ushort)(uVar10 << 4) | (ushort)uVar9;
    }
    else {
      local_30 = 0xffffffff;
      if (uVar1 == 0x1800) {
        local_38 = &DAT_0052854c;
        local_34 = 0xc;
      }
      else if (uVar1 == 0x2000) {
        local_38 = &DAT_00528558;
        local_34 = 6;
      }
      else {
        if (uVar1 != 0x2800) {
          return 0;
        }
        local_38 = &DAT_00528560;
        local_34 = 2;
      }
      for (local_3c = 0; local_44 = uVar3, local_50 = uVar2, local_3c < local_34;
          local_3c = local_3c + 1) {
        local_30 = FUN_004c00b0((uint)(byte)local_38[local_3c],local_14,local_1c);
        if (-1 < (int)local_30) {
          local_50 = (ushort)(byte)local_38[local_3c];
          local_44 = (ushort)(local_30 << 8);
          break;
        }
      }
      uVar7 = local_50;
      if ((int)local_30 < 0) {
        return 0;
      }
    }
  }
  else if (local_3f == 'l') {
    if (local_14 < 0xde) {
      uVar7 = local_50 + 2;
    }
    else {
      uVar7 = 0;
    }
    local_44 = 0;
  }
  else if (local_3f == 'u') {
    if (local_14 < 3) {
      uVar7 = 0;
    }
    else {
      uVar7 = local_50 - 2;
    }
    local_44 = 0x100;
  }
  local_50 = uVar7;
  local_44 = local_50 | uVar6 | uVar1 | local_44;
  iVar8 = FUN_004c0dc0(local_44);
  if (iVar8 != 0) {
    local_44 = 0;
  }
  return local_44;
}



undefined4 FUN_004c0dc0(ushort param_1)

{
  ushort uVar1;
  
  uVar1 = param_1 & 0x3800;
  if ((param_1 & 0xc000) == 0) {
    if ((uVar1 != 0x1000) && (uVar1 != 0x1800)) {
      return 1;
    }
  }
  else {
    if ((param_1 & 0xc000) != 0xc000) {
      return 1;
    }
    if (uVar1 == 0x3000) {
      if ((5 < (param_1 & 0xf)) || (5 < (uint)((int)(param_1 & 0xf0) >> 4))) {
        return 1;
      }
    }
    else {
      if ((((uVar1 != 0x1000) && (uVar1 != 0x1800)) && (uVar1 != 0x2000)) && (uVar1 != 0x2800)) {
        return 1;
      }
      if (0xe0 < (param_1 & 0xff)) {
        return 1;
      }
    }
  }
  if (uVar1 == 0x1000) {
    if ((param_1 & 0x700) != 0) {
      return 1;
    }
  }
  else if (uVar1 == 0x1800) {
    if (0x100 < (param_1 & 0x700)) {
      return 1;
    }
  }
  else if (((uVar1 == 0x2000) || (uVar1 == 0x3000)) && (0x300 < (param_1 & 0x700))) {
    return 1;
  }
  return 0;
}



undefined4 FUN_004c0fc0(ushort param_1)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined *local_20;
  uint local_1c;
  uint local_18;
  
  uVar1 = param_1 & 0x3800;
  uVar2 = param_1 & 0xff;
  iVar3 = FUN_004c0dc0(param_1);
  if (iVar3 != 0) {
    return 0;
  }
  if ((param_1 & 0xc000) == 0) {
    if (uVar1 == 0x1000) {
      if (((param_1 & 0xff) != 0) && (uVar2 < 0xf)) {
        return 1;
      }
    }
    else if (((uVar1 == 0x1800) && (2 < uVar2)) && (uVar2 < 0xc)) {
      return 1;
    }
  }
  else if ((param_1 & 0xc000) == 0xc000) {
    if (uVar1 == 0x3000) {
      if (((ushort)((byte)(&DAT_00528558)[param_1 & 0xf] + 0x10) <
           (ushort)(byte)(&DAT_00528558)[(int)(param_1 & 0xf0) >> 4]) ||
         ((ushort)((byte)(&DAT_00528558)[(int)(param_1 & 0xf0) >> 4] + 0x10) <
          (ushort)(byte)(&DAT_00528558)[param_1 & 0xf])) {
        return 1;
      }
    }
    else {
      if ((uVar1 == 0x1000) || (uVar1 == 0x1800)) {
        local_20 = &DAT_0052854c;
        local_1c = 0xc;
      }
      else if (uVar1 == 0x2000) {
        local_20 = &DAT_00528558;
        local_1c = 6;
      }
      else {
        if (uVar1 != 0x2800) {
          return 0;
        }
        local_20 = &DAT_00528560;
        local_1c = 2;
      }
      if (uVar1 == 0x1000) {
        for (local_18 = 0; local_18 < local_1c; local_18 = local_18 + 1) {
          if ((byte)local_20[local_18] < 3) {
            uVar4 = 0;
          }
          else {
            uVar4 = (byte)local_20[local_18] - 2;
          }
          if (uVar4 == uVar2) break;
          if ((byte)local_20[local_18] < 0xde) {
            uVar4 = (byte)local_20[local_18] + 2;
          }
          else {
            uVar4 = 0;
          }
          if (uVar4 == uVar2) break;
        }
        if (local_18 == local_1c) {
          if (uVar2 == 0xa5) {
            local_18 = 0;
          }
          if ((((uVar2 == 0x22) || (uVar2 == 0x26)) || (uVar2 == 0x2a)) || (uVar2 == 0x2e)) {
            local_18 = 0;
          }
        }
      }
      else {
        for (local_18 = 0; (local_18 < local_1c && ((byte)local_20[local_18] != uVar2));
            local_18 = local_18 + 1) {
        }
      }
      if (local_18 < local_1c) {
        return 1;
      }
    }
  }
  return 0;
}



uint FUN_004c13a4(ushort param_1)

{
  undefined1 uVar1;
  uint uVar2;
  undefined3 extraout_var;
  uint local_18;
  int local_14;
  
  if ((param_1 & 0x3800) == 0x1000) {
    uVar2 = param_1 & 0xff;
  }
  else {
    if ((param_1 & 0x3800) == 0x3000) {
      local_14 = 0x50;
      local_18 = (uint)(byte)(&DAT_00528558)[param_1 & 0xf];
    }
    else {
      uVar1 = FUN_004bffb0(param_1);
      local_14 = CONCAT31(extraout_var,uVar1);
      local_18 = param_1 & 0xff;
    }
    uVar2 = FUN_004c0168(local_18,local_14,(int)(param_1 & 0x700) >> 8);
  }
  return uVar2;
}



ushort FUN_004c1484(ushort param_1)

{
  uint uVar1;
  undefined2 local_10;
  
  local_10 = param_1;
  if ((param_1 & 0x3800) != 0x1000) {
    uVar1 = FUN_004c13a4(param_1);
    local_10 = param_1 & 0xc000 | (byte)uVar1 | 0x1000;
  }
  return local_10;
}



ushort FUN_004c1518(uint param_1,int param_2)

{
  uint local_res4;
  ushort local_20;
  undefined *local_1c;
  int local_18;
  uint local_14;
  int local_10;
  
  local_14 = 0xffffffff;
  if (param_1 < 0xf) {
    local_20 = 0;
  }
  else {
    local_20 = 0xc000;
  }
  local_20 = (ushort)param_2 | local_20;
  if (param_2 == 0x1800) {
    local_1c = &DAT_0052854c;
    local_18 = 0xc;
    local_res4 = 0x28;
  }
  else if (param_2 == 0x2000) {
    local_1c = &DAT_00528558;
    local_18 = 6;
    local_res4 = 0x50;
  }
  else {
    if (param_2 != 0x2800) {
      if (param_2 == 0x1000) {
        return (ushort)param_1 | local_20;
      }
      return 0;
    }
    local_1c = &DAT_00528560;
    local_18 = 2;
    local_res4 = 0xa0;
  }
  local_10 = 0;
  do {
    if (local_18 <= local_10) {
LAB_004c16f8:
      if ((int)local_14 < 0) {
        local_20 = 0;
      }
      return local_20;
    }
    local_14 = FUN_004c00b0((uint)(byte)local_1c[local_10],param_1,local_res4);
    if (-1 < (int)local_14) {
      local_20 = (ushort)(local_14 << 8) | (byte)local_1c[local_10] | local_20;
      goto LAB_004c16f8;
    }
    local_10 = local_10 + 1;
  } while( true );
}



ushort FUN_004c172c(ushort param_1)

{
  ushort uVar1;
  ushort uVar2;
  undefined2 local_res0;
  undefined2 local_18;
  
  if (((param_1 & 0x3800) == 0x3000) || (local_res0 = param_1, (param_1 & 0x3800) == 0x2800)) {
    local_res0 = FUN_004c1f08(param_1);
  }
  local_18 = param_1;
  if ((local_res0 & 0x3800) == 0x2000) {
    uVar1 = local_res0 & 0x700;
    if (uVar1 < 0x200) {
      uVar2 = (local_res0 & 0xff) - 4;
    }
    else {
      uVar2 = (local_res0 & 0xff) + 4;
      uVar1 = uVar1 - 0x200;
    }
    local_18 = uVar1 | uVar2 | 0xd800;
  }
  return local_18;
}



int FUN_004c1830(uint param_1,uint param_2)

{
  int iVar1;
  uint uVar2;
  uint local_res4;
  
  local_res4 = param_2;
  if (param_2 == 0) {
    if ((param_1 < 0x960) || (0x9c4 < param_1)) {
      if ((4999 < param_1) && (param_1 < 0x1771)) {
        local_res4 = 10000;
      }
    }
    else {
      local_res4 = 0x12ce;
    }
  }
  if ((param_1 == 0x9b4) && (local_res4 == 0x12ce)) {
    iVar1 = 0xe;
  }
  else {
    uVar2 = local_res4 >> 1;
    if ((param_1 < uVar2) || (uVar2 + 1000 < param_1)) {
      iVar1 = -1;
    }
    else {
      iVar1 = (int)(param_1 - uVar2) / 5;
      if (iVar1 * 5 == param_1 - uVar2) {
        if ((local_res4 == 0x12ce) && ((iVar1 < 1 || (0xd < iVar1)))) {
          iVar1 = -1;
        }
      }
      else {
        iVar1 = -1;
      }
    }
  }
  return iVar1;
}



int FUN_004c19cc(uint param_1,uint param_2)

{
  undefined4 local_10;
  
  if (((param_2 == 0x12ce) && ((param_1 == 0 || (0xe < param_1)))) || (200 < param_1)) {
    local_10 = -1;
  }
  else if ((param_2 == 0x12ce) && (param_1 == 0xe)) {
    local_10 = 0x9b4;
  }
  else {
    local_10 = param_1 * 5 + (param_2 >> 1);
  }
  return local_10;
}



ushort FUN_004c1a94(byte param_1,byte param_2)

{
  ushort uVar1;
  uint uVar2;
  uint local_14;
  
  local_14 = 0;
  while( true ) {
    if (3 < local_14) {
      return 0xff;
    }
    uVar1 = (ushort)param_1 | *(ushort *)(&DAT_005285b0 + local_14 * 2) | 0xe000;
    uVar2 = FUN_004c13a4(uVar1);
    if (param_2 == uVar2) break;
    local_14 = local_14 + 1;
  }
  return uVar1;
}



ushort FUN_004c1b68(byte param_1,byte param_2,byte param_3)

{
  ushort uVar1;
  uint uVar2;
  uint local_20;
  uint local_1c;
  uint local_18;
  
  uVar2 = FUN_004c01c8((uint)param_2);
  local_18 = FUN_004c01c8((uint)param_3);
  if ((uVar2 == 0xffffffff) || (local_18 == 0xffffffff)) {
    uVar1 = 0xff;
  }
  else {
    local_20 = FUN_004c00b0((uint)param_2,(uint)param_1,0x50);
    local_1c = uVar2;
    if (((int)local_20 < 0) &&
       (local_20 = FUN_004c00b0((uint)param_3,(uint)param_1,0x50), local_1c = local_18,
       local_18 = uVar2, (int)local_20 < 0)) {
      uVar1 = 0xff;
    }
    else {
      uVar1 = (ushort)(local_18 << 4) | (ushort)local_1c | (ushort)(local_20 << 8) | 0xf000;
    }
  }
  return uVar1;
}



undefined1 FUN_004c1cd8(byte param_1)

{
  undefined1 uVar1;
  
  if (param_1 < 6) {
    uVar1 = (&DAT_00528558)[param_1];
  }
  else {
    uVar1 = 0;
  }
  return uVar1;
}



byte FUN_004c1d30(ushort param_1)

{
  undefined1 local_10;
  
  local_10 = (byte)param_1;
  if ((param_1 & 0x3800) != 0x2000) {
    if ((param_1 & 0x3800) == 0x3000) {
      local_10 = FUN_004c1cd8(local_10 & 0xf);
    }
    else if ((param_1 & 0x3800) == 0x2800) {
      if ((uint)((int)(param_1 & 0x700) >> 8) < 4) {
        local_10 = local_10 - 8;
      }
      else {
        local_10 = local_10 + 8;
      }
    }
    else {
      local_10 = 0xff;
    }
  }
  return local_10;
}



char FUN_004c1e2c(ushort param_1)

{
  undefined1 local_10;
  
  if ((param_1 & 0x3800) == 0x3000) {
    local_10 = FUN_004c1cd8((byte)((int)(param_1 & 0xf0) >> 4));
  }
  else if ((param_1 & 0x3800) == 0x2800) {
    if ((uint)((int)(param_1 & 0x700) >> 8) < 4) {
      local_10 = (char)param_1 + '\b';
    }
    else {
      local_10 = (char)param_1 + -8;
    }
  }
  else {
    local_10 = -1;
  }
  return local_10;
}



ushort FUN_004c1f08(ushort param_1)

{
  undefined1 uVar1;
  ushort uVar2;
  ushort uVar3;
  undefined3 extraout_var;
  undefined2 local_18;
  
  local_18 = param_1;
  if ((param_1 & 0x3800) != 0x2000) {
    if ((param_1 & 0x3800) == 0x3000) {
      uVar1 = FUN_004c1cd8((byte)param_1 & 0xf);
      local_18 = param_1 & 0x700 | (ushort)CONCAT31(extraout_var,uVar1) | 0xe000;
    }
    else if ((param_1 & 0x3800) == 0x2800) {
      uVar2 = param_1 & 0x700;
      if (uVar2 < 0x400) {
        uVar3 = (param_1 & 0xff) - 8;
      }
      else {
        uVar3 = (param_1 & 0xff) + 8;
        uVar2 = uVar2 - 0x400;
      }
      local_18 = uVar2 | uVar3 | 0xe000;
    }
    else {
      local_18 = 0xff;
    }
  }
  return local_18;
}



undefined4 FUN_004c2070(char *param_1)

{
  bool bVar1;
  int iVar2;
  int local_20;
  int local_1c;
  int local_18;
  
  local_20 = 0;
  local_1c = 0x131;
  local_18 = 0x98;
  do {
    iVar2 = strcmp(param_1,(&PTR_DAT_00556320)[local_18 * 2]);
    if (iVar2 == 0) {
      return *(undefined4 *)(&DAT_00556324 + local_18 * 8);
    }
    if (iVar2 < 1) {
      local_1c = local_18 + -1;
    }
    else {
      local_20 = local_18 + 1;
    }
    iVar2 = (local_20 + local_1c) / 2;
    bVar1 = local_18 != iVar2;
    local_18 = iVar2;
  } while (bVar1);
  return 0;
}



void FUN_004c2184(FILE *param_1,char *param_2)

{
  int local_10;
  
  fprintf(param_1,"Usage:  %s [<options>] [-T <type>] [<substr>]\n",param_2);
  fwrite("    -h Display help message\t\t-i Show description (info)\n",1,0x38,param_1);
  fwrite("    -m Show module name\t\t\t-t Show variable types\n",1,0x31,param_1);
  fwrite("    -a Show all names\t\t\t-d Show default values\n",1,0x2f,param_1);
  fwrite("    -1 Display names in a single column\n",1,0x28,param_1);
  fwrite("    -e Exact match of substring\n",1,0x20,param_1);
  fwrite("    -v (verbose) Show module, type, default values\n",1,0x33,param_1);
  fwrite("    -V (verbose) Like -v plus descriptions\n",1,0x2b,param_1);
  fwrite("    -u (undoc) Show only driver variables without UI info\n",1,0x3a,param_1);
  fwrite("    -x Show only variable with UI info that are not in current driver\n",1,0x46,param_1);
  fwrite("    -T <type> Restrict to variables of the given type (see below)\n",1,0x42,param_1);
  fwrite("    <substr> Display all names containing the given substring\n",1,0x3e,param_1);
  fwrite("-u and -x are mutually exclusive\n",1,0x21,param_1);
  fwrite("\nKnown variable types include:\n    ",1,0x23,param_1);
  for (local_10 = 0; local_10 < DAT_00556cd8; local_10 = local_10 + 1) {
    fprintf(param_1,"%s ",(&PTR_DAT_00556cb0)[local_10]);
  }
  fputc(10,param_1);
  return;
}



undefined4 FUN_004c23a8(FILE *param_1,undefined4 param_2,int param_3,undefined4 *param_4)

{
  size_t __n;
  void *pvVar1;
  undefined4 uVar2;
  int iVar3;
  int local_18;
  int local_14;
  
  memset(param_4,0,0x2c);
  param_4[1] = 0xffffffff;
  param_4[6] = param_2;
  *(undefined1 *)((int)param_4 + 0xd) = 1;
  local_18 = 1;
  do {
    if (*(int *)(param_3 + local_18 * 4) == 0) {
      pvVar1 = malloc(0x140);
      param_4[7] = pvVar1;
      if (param_4[7] == 0) {
        fprintf(param_1,"ERROR: Could not allocate transfer buffer of %d bytes\n",0x140);
        uVar2 = 0xffffffff;
      }
      else {
        memset((void *)param_4[7],0,0x140);
        param_4[8] = 0x140;
        __n = DAT_00556d70;
        if (*(char *)((int)param_4 + 0xe) != '\0') {
          pvVar1 = malloc(DAT_00556d70);
          param_4[9] = pvVar1;
          if (param_4[9] == 0) {
            fwrite("Unable to show variables missing from local info\n",1,0x31,param_1);
            *(undefined1 *)((int)param_4 + 0xe) = 0;
          }
          else {
            memset((void *)param_4[9],0,__n);
          }
        }
        if (*(char *)((int)param_4 + 10) != '\0') {
          DAT_00559d00 = 0x10;
          DAT_00559d04 = 0x40;
          iVar3 = FUN_004bab9c((int *)param_4[6],0x115,(char *)&DAT_00559d00,0x400);
          if (iVar3 < 0) {
            fwrite("Unable to show module names\n",1,0x1c,param_1);
            *(undefined1 *)((int)param_4 + 10) = 0;
          }
        }
        uVar2 = 0;
      }
      return uVar2;
    }
    iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-T");
    if (iVar3 == 0) {
      local_18 = local_18 + 1;
      if (*(int *)(param_3 + local_18 * 4) == 0) {
        fwrite("Must specify type with -t.\n",1,0x1b,param_1);
        return 0xffffffff;
      }
      for (local_14 = 0; local_14 < DAT_00556cd8; local_14 = local_14 + 1) {
        iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),(&PTR_DAT_00556cb0)[local_14]);
        if (iVar3 == 0) {
          param_4[1] = local_14;
          break;
        }
      }
      if ((int)param_4[1] < 0) {
        fprintf(param_1,"Unknown variable type: %s\n",*(char **)(param_3 + local_18 * 4));
        return 0xffffffff;
      }
    }
    else {
      iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-v");
      if (iVar3 == 0) {
        *(undefined1 *)(param_4 + 2) = 1;
        *(undefined1 *)((int)param_4 + 10) = 1;
        *(undefined1 *)((int)param_4 + 0xb) = 1;
      }
      else {
        iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-V");
        if (iVar3 == 0) {
          *(undefined1 *)(param_4 + 2) = 1;
          *(undefined1 *)((int)param_4 + 10) = 1;
          *(undefined1 *)((int)param_4 + 0xb) = 1;
          *(undefined1 *)((int)param_4 + 9) = 1;
        }
        else {
          iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-m");
          if (iVar3 == 0) {
            *(undefined1 *)((int)param_4 + 10) = 1;
          }
          else {
            iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-t");
            if (iVar3 == 0) {
              *(undefined1 *)(param_4 + 2) = 1;
            }
            else {
              iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-i");
              if (iVar3 == 0) {
                *(undefined1 *)((int)param_4 + 9) = 1;
              }
              else {
                iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-d");
                if (iVar3 == 0) {
                  *(undefined1 *)((int)param_4 + 0xb) = 1;
                }
                else {
                  iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-e");
                  if (iVar3 == 0) {
                    *(undefined1 *)(param_4 + 3) = 1;
                  }
                  else {
                    iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-1");
                    if (iVar3 == 0) {
                      *(undefined1 *)((int)param_4 + 0xf) = 1;
                    }
                    else {
                      iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-u");
                      if (iVar3 == 0) {
                        if (*(char *)((int)param_4 + 0xe) != '\0') {
                          return 0xffffffff;
                        }
                        *(undefined1 *)((int)param_4 + 0xd) = 1;
                      }
                      else {
                        iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-x");
                        if (iVar3 == 0) {
                          if (*(char *)((int)param_4 + 0xd) != '\0') {
                            return 0xffffffff;
                          }
                          *(undefined1 *)((int)param_4 + 0xe) = 1;
                        }
                        else {
                          iVar3 = strcmp(*(char **)(param_3 + local_18 * 4),"-a");
                          if (iVar3 != 0) {
                            *param_4 = *(undefined4 *)(param_3 + local_18 * 4);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    local_18 = local_18 + 1;
  } while( true );
}



void FUN_004c2aac(int param_1)

{
  if (param_1 != 0) {
    if (*(int *)(param_1 + 0x1c) != 0) {
      free(*(void **)(param_1 + 0x1c));
      *(undefined4 *)(param_1 + 0x1c) = 0;
    }
    if (*(int *)(param_1 + 0x24) != 0) {
      free(*(void **)(param_1 + 0x24));
      *(undefined4 *)(param_1 + 0x24) = 0;
    }
  }
  return;
}



int FUN_004c2b3c(char *param_1)

{
  int iVar1;
  int local_10;
  
  local_10 = 0;
  while( true ) {
    if (DAT_00556d70 <= local_10) {
      return -1;
    }
    iVar1 = strcmp((&PTR_s_2g_mrate_0052cee4)[local_10 * 5],param_1);
    if (iVar1 == 0) break;
    local_10 = local_10 + 1;
  }
  return local_10;
}



undefined4 FUN_004c2be0(int param_1,int *param_2)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  int iVar4;
  undefined4 uVar5;
  
  if ((param_2[1] < 0) || ((uint)*(byte *)(param_1 + 1) == param_2[1])) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  if (((*param_2 == 0) || (*(char *)*param_2 == '\0')) ||
     (pcVar3 = strstr((char *)(param_1 + 2),(char *)*param_2), pcVar3 != (char *)0x0)) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  if ((char)param_2[3] != '\0') {
    if (((param_2 == (int *)0x0) || (*param_2 == 0)) ||
       (iVar4 = strcmp((char *)*param_2,(char *)(param_1 + 2)), iVar4 != 0)) {
      bVar2 = false;
    }
    else {
      bVar2 = true;
    }
  }
  if ((bVar1) && (bVar2)) {
    uVar5 = 1;
  }
  else {
    uVar5 = 0;
  }
  return uVar5;
}



undefined ** FUN_004c2d44(int param_1,int *param_2)

{
  int iVar1;
  int local_18;
  undefined **local_14;
  
  local_18 = -1;
  local_14 = (undefined **)0x0;
  param_2[4] = param_2[4] + 1;
  iVar1 = FUN_004c2be0(param_1,param_2);
  if ((iVar1 != 0) || (*(char *)((int)param_2 + 0xe) != '\0')) {
    local_18 = FUN_004c2b3c((char *)(param_1 + 2));
  }
  if (((-1 < local_18) && (*(char *)((int)param_2 + 0xe) != '\0')) && (param_2[9] != 0)) {
    *(undefined1 *)(param_2[9] + local_18) = 1;
  }
  if (iVar1 != 0) {
    if ((*(char *)((int)param_2 + 0xd) != '\0') && (local_18 < 0)) {
      local_14 = (undefined **)&DAT_00529520;
    }
    if ((*(char *)((int)param_2 + 0xd) == '\0') && (-1 < local_18)) {
      local_14 = &PTR_s_2g_mrate_0052cee4 + local_18 * 5;
    }
  }
  return local_14;
}



void FUN_004c2e94(FILE *param_1,int *param_2)

{
  int iVar1;
  char *local_60;
  char local_5c [84];
  
  builtin_strncpy(local_5c,"Variables ",0xb);
  local_60 = local_5c + 10;
  if ((uint)param_2[1] < 9) {
    iVar1 = sprintf(local_60,"of type %s",(&PTR_DAT_00556cb0)[param_2[1]]);
    local_60 = local_60 + iVar1;
  }
  if ((*param_2 != 0) && (*(char *)*param_2 != '\0')) {
    iVar1 = sprintf(local_60,"matching =%s=",(char *)*param_2);
    local_60 = local_60 + iVar1;
  }
  fprintf(param_1,"%s\n",local_60);
  if (((((char)param_2[2] != '\0') || (*(char *)((int)param_2 + 10) != '\0')) ||
      (*(char *)((int)param_2 + 9) != '\0')) || (*(char *)((int)param_2 + 0xb) != '\0')) {
    iVar1 = sprintf(local_5c,"%-30s","Variable name");
    local_60 = local_5c + iVar1;
    if ((char)param_2[2] != '\0') {
      iVar1 = sprintf(local_60," %-8s","Type");
      local_60 = local_60 + iVar1;
    }
    if (*(char *)((int)param_2 + 10) != '\0') {
      iVar1 = sprintf(local_60," %-20s","Module");
      local_60 = local_60 + iVar1;
    }
    if (*(char *)((int)param_2 + 0xb) != '\0') {
      sprintf(local_60," %-10s","Default");
    }
    fprintf(param_1,"%s\n",local_5c);
  }
  return;
}



void FUN_004c3108(FILE *param_1,byte *param_2,int *param_3)

{
  undefined **ppuVar1;
  char *pcVar2;
  int iVar3;
  char *local_60;
  char acStack_58 [80];
  
  ppuVar1 = FUN_004c2d44((int)param_2,param_3);
  if ((ppuVar1 != (undefined **)0x0) && (*(char *)((int)param_3 + 0xe) == '\0')) {
    if (((char)param_3[2] == '\0') &&
       (((*(char *)((int)param_3 + 10) == '\0' && (*(char *)((int)param_3 + 9) == '\0')) &&
        (*(char *)((int)param_3 + 0xb) == '\0')))) {
      if (*(char *)((int)param_3 + 0xf) == '\0') {
        if ((param_3[5] + 1) % 3 == 0) {
          pcVar2 = "\n";
        }
        else {
          pcVar2 = " ";
        }
        fprintf(param_1,"%-25s%s",(char *)(param_2 + 2),pcVar2);
      }
      else {
        fprintf(param_1,"%s\n",(char *)(param_2 + 2));
      }
    }
    else {
      iVar3 = sprintf(acStack_58,"%-30s",(char *)(param_2 + 2));
      local_60 = acStack_58 + iVar3;
      if ((char)param_3[2] != '\0') {
        if (param_2[1] < 9) {
          pcVar2 = (&PTR_DAT_00556cb0)[param_2[1]];
        }
        else {
          pcVar2 = "no-type";
        }
        iVar3 = sprintf(local_60," %-8s",pcVar2);
        local_60 = local_60 + iVar3;
      }
      if (*(char *)((int)param_3 + 10) != '\0') {
        if (*param_2 < 0x40) {
          pcVar2 = (char *)(&DAT_00559d00 + (uint)*param_2 * 4);
        }
        else {
          pcVar2 = "no-mod";
        }
        iVar3 = sprintf(local_60," %-20s",pcVar2);
        local_60 = local_60 + iVar3;
      }
      if (*(char *)((int)param_3 + 0xb) != '\0') {
        if (((uint)ppuVar1[2] & 8) == 0) {
          sprintf(local_60," %-10s","?");
        }
        else {
          sprintf(local_60," %-10d",(int)ppuVar1[3]);
        }
      }
      fprintf(param_1,"%s\n",acStack_58);
      if (*(char *)((int)param_3 + 9) != '\0') {
        fprintf(param_1,"    %s\n",ppuVar1[4]);
      }
    }
    param_3[5] = param_3[5] + 1;
  }
  return;
}



void FUN_004c345c(FILE *param_1,int param_2)

{
  bool bVar1;
  char *param3;
  int local_18;
  int local_14;
  
  bVar1 = true;
  if ((*(char *)(param_2 + 0xe) != '\0') && (*(int *)(param_2 + 0x24) != 0)) {
    local_14 = 0;
    for (local_18 = 0; local_18 < DAT_00556d70; local_18 = local_18 + 1) {
      if (*(char *)(*(int *)(param_2 + 0x24) + local_18) == '\0') {
        if (bVar1) {
          fwrite("UI variables not in driver:\n",1,0x1c,param_1);
          bVar1 = false;
        }
        local_14 = local_14 + 1;
        if (local_14 % 3 == 0) {
          param3 = "\n";
        }
        else {
          param3 = " ";
        }
        fprintf(param_1,"%-25s%s",(&PTR_s_2g_mrate_0052cee4)[local_18 * 5],param3);
        *(int *)(param_2 + 0x14) = *(int *)(param_2 + 0x14) + 1;
      }
    }
    if (local_14 % 3 != 0) {
      fputc(10,param_1);
    }
  }
  return;
}



undefined4 FUN_004c361c(int *param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  byte *local_48;
  int local_44;
  undefined4 local_40;
  int aiStack_38 [4];
  undefined4 local_28;
  int local_24;
  byte *local_1c;
  uint local_18;
  
  local_40 = 0;
  if ((param_3[1] == 0) || (iVar1 = strcmp((char *)param_3[1],"-h"), iVar1 != 0)) {
    iVar1 = FUN_004c23a8(stderr,param_1,(int)param_3,aiStack_38);
    if (iVar1 < 0) {
      fprintf(stderr,"Error parsing arguments for command %s\n",(char *)*param_3);
      FUN_004c2184(stderr,*param_3);
      local_40 = 0xffffffff;
    }
    else {
      FUN_004c2e94(stdout,aiStack_38);
      do {
        local_1c[0] = 0x1e;
        local_1c[1] = 0;
        local_1c[2] = 0;
        local_1c[3] = 0;
        *(undefined4 *)(local_1c + 4) = local_28;
        local_1c[8] = 10;
        local_1c[9] = 0;
        local_1c[10] = 0;
        local_1c[0xb] = 0;
        iVar1 = FUN_004bab9c(param_1,0x114,(char *)local_1c,local_18);
        if (iVar1 < 0) {
          fwrite("Error on wl_get getting IOV block\n",1,0x22,stderr);
          local_40 = 0xffffffff;
          break;
        }
        local_44 = 0;
        for (local_48 = local_1c; (local_44 < 10 && (local_48[2] != 0)); local_48 = local_48 + 0x20)
        {
          FUN_004c3108(stdout,local_48,aiStack_38);
          local_44 = local_44 + 1;
        }
      } while (local_44 == 10);
      FUN_004c345c(stdout,(int)aiStack_38);
      fputc(10,stdout);
      if (local_24 == 0) {
        fwrite("No matching variables found\n",1,0x1c,stdout);
      }
      FUN_004c2aac((int)aiStack_38);
    }
  }
  else {
    FUN_004c2184(stderr,*param_3);
    local_40 = 0;
  }
  return local_40;
}



void FUN_004c38dc(FILE *param_1,char *param_2)

{
  int local_10;
  
  fprintf(param_1,"Usage:  wl %s [-s <substr>] [<categories>]\n",param_2);
  fwrite("    Display commands matching substr in any of the given categories\n",1,0x44,param_1);
  fwrite("Command categories include (use lower case to specify):\n",1,0x38,param_1);
  for (local_10 = 0; local_10 < 0x11; local_10 = local_10 + 1) {
    fprintf(param_1,"    %-8s %s\n",(&PTR_DAT_00556cdc)[local_10],
            (&PTR_s_PHY_and_radio__speed__band__etc_00556d20)[local_10]);
  }
  return;
}



int FUN_004c39d8(char *param_1)

{
  size_t sVar1;
  size_t __n;
  size_t sVar2;
  int iVar3;
  uint local_18;
  
  if ((param_1 != (char *)0x0) && (*param_1 != '\0')) {
    for (local_18 = 0; (int)local_18 < 0x11; local_18 = local_18 + 1) {
      sVar1 = strlen(param_1);
      __n = 3;
      if (2 < (int)sVar1) {
        __n = sVar1;
      }
      sVar2 = strlen((&PTR_DAT_00556cdc)[local_18]);
      if (((int)sVar1 <= (int)sVar2) &&
         (iVar3 = strncmp(param_1,(&PTR_DAT_00556cdc)[local_18],__n), iVar3 == 0)) {
        return 1 << (local_18 & 0x1f);
      }
    }
    fprintf(stderr,"Unrecognized command category: %s\n",param_1);
  }
  return 0;
}



int FUN_004c3b30(uint param_1,char *param_2)

{
  char *pcVar1;
  int local_10;
  int local_c;
  
  local_10 = 0;
  for (local_c = 0; local_c < 0x132; local_c = local_c + 1) {
    if (((*(uint *)(&DAT_00556324 + local_c * 8) & param_1) != 0) &&
       ((param_2 == (char *)0x0 ||
        (pcVar1 = strstr((&PTR_DAT_00556320)[local_c * 2],param_2), pcVar1 != (char *)0x0)))) {
      local_10 = local_10 + 1;
    }
  }
  return local_10;
}



void FUN_004c3c00(uint param_1,char *param_2,int param_3)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  char *local_b8;
  int local_b4;
  undefined **local_b0;
  char local_a8 [160];
  
  local_b8 = local_a8;
  local_b4 = 0;
  local_a8[0] = '\0';
  for (local_b0 = &PTR_DAT_00551e20; *local_b0 != (undefined *)0x0; local_b0 = local_b0 + 5) {
    uVar1 = FUN_004c2070(*local_b0);
    if (((uVar1 & param_1) != 0) &&
       ((param_2 == (char *)0x0 || (pcVar2 = strstr(*local_b0,param_2), pcVar2 != (char *)0x0)))) {
      if (param_3 == 0) {
        iVar3 = sprintf(local_b8,"%-18s ",*local_b0);
        local_b8 = local_b8 + iVar3;
        local_b4 = local_b4 + 1;
        if (local_b4 == 4) {
          puts(local_a8);
          local_b4 = 0;
          local_b8 = local_a8;
        }
      }
      else {
        FUN_00401c48(stdout,local_b0);
      }
    }
  }
  if ((param_3 == 0) && (0 < local_b4)) {
    puts(local_a8);
  }
  return;
}



undefined4 FUN_004c3d88(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  char *local_20;
  int local_1c;
  uint local_18;
  
  local_20 = (char *)0x0;
  local_1c = 1;
  local_18 = 0;
  if ((param_3[1] == 0) || (iVar1 = strcmp((char *)param_3[1],"-h"), iVar1 == 0)) {
    FUN_004c38dc(stderr,*param_3);
  }
  else {
    iVar1 = strcmp((char *)param_3[1],"-s");
    if ((iVar1 == 0) || (iVar1 = strcmp((char *)param_3[1],"-g"), iVar1 == 0)) {
      if (param_3[2] == 0) {
        local_1c = 2;
      }
      else {
        local_20 = (char *)param_3[2];
        local_1c = 3;
      }
    }
    while (param_3[local_1c] != 0) {
      puVar2 = param_3 + local_1c;
      local_1c = local_1c + 1;
      uVar3 = FUN_004c39d8((char *)*puVar2);
      if (uVar3 == 0) {
        return 0xffffffff;
      }
      local_18 = local_18 | uVar3;
    }
    if (local_18 == 0) {
      local_18 = 0xffff;
    }
    iVar1 = FUN_004c3b30(local_18,local_20);
    if (iVar1 == 0) {
      puts("No matching commands");
    }
    else {
      FUN_004c3c00(local_18,local_20,(uint)(iVar1 < 7));
    }
  }
  return 0;
}



int FUN_004c3fc0(void)

{
  bool bVar1;
  int *piVar2;
  int iVar3;
  int local_30;
  int local_20;
  sockaddr local_1c;
  
  local_20 = -1;
  local_30 = 0;
  bVar1 = false;
  memset(&local_1c,0,0x10);
  while ((!bVar1 && (local_30 < 0x14))) {
    if ((DAT_005562a6 & 4) != 0) {
      fprintf(stdout,"rwl_connect_socket_server retry %d\n",local_30);
    }
    piVar2 = (int *)FUN_004cb0bc(DAT_00559cd0);
    local_20 = *piVar2;
    if (local_20 == -1) {
      local_30 = local_30 + 1;
    }
    else {
      iVar3 = FUN_004bc8f0();
      if (iVar3 == 0) {
        local_30 = local_30 + 1;
      }
      else {
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"ServerIP:%s,ServerPort:%d\n",DAT_00559cd4,(uint)DAT_0055769e);
        }
        local_1c.sa_family = 2;
        local_1c.sa_data._0_2_ = DAT_0055769e << 8 | DAT_0055769e >> 8;
        local_1c.sa_data._2_4_ = inet_addr(DAT_00559cd4);
        iVar3 = FUN_004cbc34(local_20,&local_1c,0x10);
        if (iVar3 < 0) {
          FUN_004cb10c(DAT_00559cd0,&local_20);
          local_30 = local_30 + 1;
        }
        else {
          bVar1 = true;
        }
      }
    }
  }
  return local_20;
}



undefined4
FUN_004c41e4(undefined4 param_1,undefined4 param_2,void *param_3,uint *param_4,uint *param_5,
            undefined4 param_6)

{
  uint uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 local_18;
  int local_c;
  
  local_c = FUN_004c3fc0();
  if (local_c < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("Error in getting the Socket Descriptor\n",1,0x27,stderr);
    }
    local_18 = 0xffffffff;
  }
  else {
    uVar1 = FUN_004cb14c(&local_c,param_2,param_3,*param_4,*param_5,param_6);
    if ((int)uVar1 < 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("query_info_fe: Send command failed\n",1,0x23,stderr);
      }
      FUN_004cb10c(DAT_00559cd0,&local_c);
      local_18 = 0xffffffff;
    }
    else {
      puVar2 = FUN_004cb844(&local_c);
      if (puVar2 == (undefined4 *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("query_info_fe: Reading CDC header \tfailed\n",1,0x2a,stderr);
        }
        FUN_004cb10c(DAT_00559cd0,&local_c);
        local_18 = 0xffffffff;
      }
      else {
        FUN_004cbd00(puVar2);
        if (*param_4 < (uint)puVar2[1]) {
          if ((DAT_005562a6 & 1) != 0) {
            fprintf(stderr,"query_info_fe: needed size(%d) > actual size(%ld)\n",puVar2[1],*param_4)
            ;
          }
          FUN_004cb10c(DAT_00559cd0,&local_c);
          local_18 = 0xffffffff;
        }
        else {
          iVar3 = FUN_004cba5c(&local_c,(int)puVar2,param_3);
          if (iVar3 == -1) {
            if ((DAT_005562a6 & 1) != 0) {
              fwrite("query_info_fe: No results!\n",1,0x1b,stderr);
            }
            FUN_004cb10c(DAT_00559cd0,&local_c);
            local_18 = 0xffffffff;
          }
          else {
            if ((puVar2[2] & 4) == 0) {
              local_18 = 0;
            }
            else {
              local_18 = *puVar2;
            }
            FUN_004cb10c(DAT_00559cd0,&local_c);
          }
        }
      }
    }
  }
  return local_18;
}



undefined4 FUN_004c450c(int *param_1,undefined4 *param_2,void *param_3,size_t *param_4)

{
  void *__src;
  void *__src_00;
  int iVar1;
  undefined4 *local_res4;
  undefined4 local_20;
  size_t local_1c;
  uint local_18;
  int local_14;
  
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"rem_ptr->msg.len=%d \t rem_ptr->data_len=%d\n",param_2[1],param_2[4]);
  }
  if (param_2[4] == 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"data_len is:%d\n",param_2[4]);
    }
    local_20 = 0xffffffff;
  }
  else {
    local_18 = *param_4 / (uint)param_2[4];
    if (param_2[4] == 0) {
      trap(7);
    }
    if (param_2[4] == 0) {
      trap(7);
    }
    if (*param_4 % (uint)param_2[4] != 0) {
      local_18 = local_18 + 1;
    }
    if ((DAT_005562a6 & 4) != 0) {
      fprintf(stdout,"No of frames=%d\n",local_18);
    }
    __src = malloc(param_2[1]);
    if (__src == (void *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Malloc failed for serial fragmented framelocal result \n",1,0x37,stderr);
      }
      local_20 = 0xffffffff;
    }
    else {
      local_1c = 0;
      local_14 = 0;
      local_res4 = param_2;
      while (*param_4 != local_1c) {
        __src_00 = malloc(local_res4[4]);
        if (__src_00 == (void *)0x0) {
          free(__src);
          return 0xffffffff;
        }
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"Total bytes=%d\n",local_1c);
        }
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"Frame (Reverse):%d\n",local_18);
        }
        iVar1 = FUN_004cba5c(param_1,(int)local_res4,__src_00);
        if (iVar1 == -1) {
          free(__src_00);
          free(__src);
          return 0xffffffff;
        }
        memcpy((void *)((int)__src + local_14 * 0x3c0),__src_00,local_res4[4]);
        local_1c = local_1c + local_res4[4];
        local_14 = local_14 + 1;
        local_18 = local_18 - 1;
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"Total bytes=%d\n",local_1c);
        }
        if ((local_18 == 0) && (memcpy(param_3,__src,local_1c), (local_res4[2] & 4) != 0)) {
          local_20 = *local_res4;
        }
        if (((*param_4 != local_1c) &&
            (local_res4 = FUN_004cb844(param_1), local_res4 == (undefined4 *)0x0)) &&
           ((DAT_005562a6 & 1) != 0)) {
          fwrite("query_info_fe: Reading CDC header failed",1,0x28,stderr);
        }
        free(__src_00);
      }
      free(__src);
    }
  }
  return local_20;
}



undefined4
FUN_004c494c(int *param_1,undefined4 param_2,void *param_3,size_t *param_4,uint param_5,
            undefined4 param_6)

{
  uint uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 local_10;
  
  uVar1 = FUN_004cb14c(param_1,param_2,param_3,*param_4,param_5,param_6);
  if ((int)uVar1 < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("query_info_fe: Send command failed\n",1,0x23,stderr);
    }
    local_10 = 0xffffffff;
  }
  else {
    puVar2 = FUN_004cb844(param_1);
    if (puVar2 == (undefined4 *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("query_info_fe: Reading CDC header failed\n",1,0x29,stderr);
      }
      local_10 = 0xfffffffd;
    }
    else if (*param_4 < (uint)puVar2[1]) {
      if ((DAT_005562a6 & 4) != 0) {
        fprintf(stdout,"query_info_fe: needed size(%d) > actualsize(%ld)\n",puVar2[1],*param_4);
      }
      local_10 = 0xffffffff;
    }
    else if ((uint)puVar2[4] < 0x3c0) {
      iVar3 = FUN_004cba5c(param_1,(int)puVar2,param_3);
      if (iVar3 == -1) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("query_info_fe: No results!\n",1,0x1b,stderr);
        }
        local_10 = 0xffffffff;
      }
      else if ((puVar2[2] & 4) == 0) {
        local_10 = 0;
      }
      else {
        local_10 = *puVar2;
      }
    }
    else {
      local_10 = FUN_004c450c(param_1,puVar2,param_3,param_4);
    }
  }
  return local_10;
}



void FUN_004c4bbc(void)

{
  DAT_00556da8 = 0;
  return;
}



int FUN_004c4be8(int *param_1,int param_2,char *param_3,uint *param_4)

{
  uint uVar1;
  char *pcVar2;
  int *piVar3;
  int iVar4;
  void *__ptr;
  void *__dest;
  int iVar5;
  int local_24;
  char *local_20;
  char local_1c;
  int local_c;
  
  iVar5 = 0;
  local_20 = (char *)0x0;
  local_24 = 8;
  if (param_2 == -3) {
    local_24 = 0x100;
  }
  if (DAT_00559cd0 == 2) {
    local_c = FUN_004c3fc0();
    if (local_c < 0) {
      if ((DAT_005562a6 & 1) == 0) {
        return 0;
      }
      fwrite(" Error in getting the SocDes\n",1,0x1d,stderr);
      return 0;
    }
    uVar1 = FUN_004cb14c(&local_c,param_2,param_3,*param_4,*param_4,local_24);
    if ((int)uVar1 < 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("shell_info_fe: Send command failed\n",1,0x23,stderr);
      }
      FUN_004cb10c(DAT_00559cd0,&local_c);
      return 0;
    }
    if (((local_24 == 8) && (pcVar2 = strchr(param_3,0x25), pcVar2 == (char *)0x0)) &&
       (pcVar2 = strstr(param_3,"kill"), pcVar2 == (char *)0x0)) {
      iVar5 = FUN_004c7030(&local_c,0,param_3);
    }
    else {
      piVar3 = FUN_004cb844(&local_c);
      if (piVar3 == (int *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("shell_info_fe: Receiving CDCheader failed\n",1,0x2a,stderr);
        }
        FUN_004cb10c(DAT_00559cd0,&local_c);
        return 0;
      }
      local_20 = (char *)malloc(piVar3[1] + 1);
      if (local_20 == (char *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("Mem alloc fails\n",1,0x10,stderr);
        }
        FUN_004cb10c(DAT_00559cd0,&local_c);
        return 0;
      }
      iVar4 = FUN_004cba5c(&local_c,(int)piVar3,local_20);
      if (iVar4 == -1) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("shell_info_fe: No results!\n",1,0x1b,stderr);
        }
        FUN_004cb10c(DAT_00559cd0,&local_c);
        free(local_20);
        return 0;
      }
      local_20[piVar3[1]] = '\0';
      if ((piVar3[2] & 4U) != 0) {
        iVar5 = *piVar3;
      }
      fputs(local_20,stdout);
    }
    FUN_004cb10c(DAT_00559cd0,&local_c);
    goto LAB_004c5714;
  }
  if (DAT_00559cd0 < 3) {
    if (DAT_00559cd0 != 1) goto LAB_004c5714;
  }
  else {
    if (DAT_00559cd0 == 3) {
      __ptr = malloc(0x416);
      if (__ptr == (void *)0x0) {
        return 0;
      }
      piVar3 = (int *)malloc(0x24);
      if (piVar3 == (int *)0x0) {
        free(__ptr);
        return 0;
      }
      __dest = malloc(*param_4);
      if (__dest == (void *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("Malloc failed for shell response\n",1,0x21,stderr);
        }
        free(piVar3);
        free(__ptr);
        return 0;
      }
      memcpy(__dest,param_3,*param_4);
      for (local_1c = '\0'; local_1c < '\x05'; local_1c = local_1c + '\x01') {
        FUN_004ca2f8(param_1);
        uVar1 = FUN_004cb14c(param_1,param_2,param_3,*param_4,*param_4,local_24);
        if ((int)uVar1 < 0) {
          if ((DAT_005562a6 & 4) != 0) {
            fwrite("rwl_shell_information_fe(wifi):Send command failed\n",1,0x33,stdout);
          }
          FUN_004c9348(1000);
          free(piVar3);
          free(__ptr);
          return iVar5;
        }
        if (((local_24 == 8) && (pcVar2 = strchr(param_3,0x25), pcVar2 == (char *)0x0)) &&
           (pcVar2 = strstr(param_3,"kill"), pcVar2 == (char *)0x0)) {
          iVar5 = FUN_004c72b8(param_1,piVar3,param_3);
          if (piVar3[1] == 0) break;
        }
        else if (local_24 == 0x100) {
          iVar5 = FUN_004c9e20(param_1,piVar3,0,(char *)0x0,'\x01');
          if (iVar5 < 0) {
            if ((DAT_005562a6 & 4) != 0) {
              fwrite("rwl_shell_information_fe(wifi):error in reading shell response\n",1,0x3f,
                     stdout);
            }
          }
          else {
            if ((piVar3[2] & 4U) != 0) {
              iVar5 = *piVar3;
              break;
            }
            FUN_004c9348(1000);
          }
        }
        else if (local_24 == 0x20) {
          while( true ) {
            while( true ) {
              memcpy(param_3,__dest,*param_4);
              iVar5 = FUN_004c9e20(param_1,piVar3,0,(char *)0x0,'\x01');
              if (-1 < iVar5) break;
              if ((DAT_005562a6 & 4) != 0) {
                fwrite("rwl_shell_information_fe(wifi):err in reading shell response\n",1,0x3d,
                       stdout);
              }
            }
            if ((piVar3[2] & 4U) != 0) break;
            FUN_004c9348(1000);
          }
          iVar5 = *piVar3;
          local_1c = '\x05';
        }
      }
      free(piVar3);
      free(__ptr);
      if (__dest != (void *)0x0) {
        free(__dest);
      }
      goto LAB_004c5714;
    }
    if (DAT_00559cd0 != 4) goto LAB_004c5714;
  }
  uVar1 = FUN_004cb14c(param_1,param_2,param_3,*param_4,*param_4,local_24);
  if ((int)uVar1 < 0) {
    if ((DAT_005562a6 & 1) == 0) {
      return 0;
    }
    fwrite("shell_info_fe: Send command failed\n",1,0x23,stderr);
    return 0;
  }
  if (((local_24 == 0x20) || (pcVar2 = strchr(param_3,0x25), pcVar2 != (char *)0x0)) ||
     (pcVar2 = strstr(param_3,"kill"), pcVar2 != (char *)0x0)) {
    piVar3 = FUN_004cb844(param_1);
    if (piVar3 == (int *)0x0) {
      if ((DAT_005562a6 & 1) == 0) {
        return 0;
      }
      fwrite("shell_info_fe:Receiving CDC header failed\n",1,0x2a,stderr);
      return 0;
    }
    FUN_004cbd00(piVar3);
    local_20 = (char *)malloc(piVar3[1] + 1);
    if (local_20 == (char *)0x0) {
      if ((DAT_005562a6 & 1) == 0) {
        return 0;
      }
      fwrite("Mem alloc fails for shell response buffer\n",1,0x2a,stderr);
      return 0;
    }
    if ((uint)piVar3[4] < 0x3c0) {
      iVar4 = FUN_004cba5c(param_1,(int)piVar3,local_20);
      if (iVar4 == -1) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("shell_info_fe: No results!\n",1,0x1b,stderr);
        }
        free(local_20);
        return 0;
      }
    }
    else {
      iVar5 = FUN_004c450c(param_1,piVar3,local_20,(size_t *)(piVar3 + 1));
    }
    local_20[piVar3[1]] = '\0';
    if ((piVar3[2] & 4U) != 0) {
      iVar5 = *piVar3;
    }
    fputs(local_20,stdout);
  }
  else {
    iVar5 = FUN_004c7418(param_1,0,param_3,param_2);
  }
LAB_004c5714:
  if (local_20 != (char *)0x0) {
    free(local_20);
  }
  return iVar5;
}



uint * FUN_004c5748(int *param_1,int *param_2,int param_3)

{
  char *__dest;
  uint *puVar1;
  size_t sVar2;
  int *local_res4;
  uint local_18 [3];
  
  local_18[0] = 0x100;
  __dest = (char *)malloc(0x100);
  if (__dest == (char *)0x0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("\n Mem alloc fails for shell cmd buffer\n",1,0x27,stderr);
    }
    puVar1 = (uint *)0xffffffff;
  }
  else {
    memset(__dest,0,4);
    local_res4 = param_2;
    while (*local_res4 != 0) {
      strcat(__dest,(char *)*local_res4);
      local_res4 = local_res4 + 1;
      if (*local_res4 != 0) {
        sVar2 = strlen(__dest);
        __dest[sVar2] = ' ';
        (__dest + sVar2)[1] = '\0';
      }
    }
    puVar1 = local_18;
    FUN_004c4be8(param_1,param_3,__dest,puVar1);
    free(__dest);
  }
  return puVar1;
}



int FUN_004c589c(int *param_1,int param_2,char *param_3,uint *param_4,undefined4 param_5,
                undefined4 param_6)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  size_t __size;
  void *__dest;
  int iVar4;
  int local_1c;
  
  iVar4 = 0;
  if (DAT_00559cd0 == 2) {
    if (0x2000 < (int)*param_4) {
      *param_4 = 0x2000;
    }
    iVar4 = FUN_004c41e4(param_1,param_2,param_3,param_4,param_4,param_6);
    return iVar4;
  }
  if (DAT_00559cd0 < 3) {
    if (DAT_00559cd0 == 1) {
      uVar1 = *param_4;
      if (0x2000 < uVar1) {
        uVar1 = 0x2000;
      }
      uVar1 = FUN_004cb14c(param_1,param_2,param_3,uVar1,uVar1,param_6);
      if ((int)uVar1 < 0) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("query_info_fe: Send command failed\n",1,0x23,stderr);
        return 0;
      }
      piVar2 = FUN_004cb844(param_1);
      if (piVar2 == (int *)0x0) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("query_info_fe: Reading CDC header failed\n",1,0x29,stderr);
        return 0;
      }
      if (piVar2[2] == 4) {
        if (*param_4 < (uint)piVar2[1]) {
          if ((DAT_005562a6 & 1) == 0) {
            return 0;
          }
          fprintf(stderr,"query_info_fe: needed size(%d) greater than actual size(%lu)\n",piVar2[1],
                  *param_4);
          return 0;
        }
        iVar4 = *piVar2;
        if ((iVar4 != 0) && ((DAT_005562a6 & 1) != 0)) {
          fprintf(stderr,"query_info_fe: remote cdc header return error code %d\n",iVar4);
        }
        iVar3 = FUN_004cba5c(param_1,(int)piVar2,param_3);
        if (iVar3 != -1) {
          if ((piVar2[2] & 4U) == 0) {
            return iVar4;
          }
          return *piVar2;
        }
        if ((DAT_005562a6 & 1) == 0) {
          return iVar4;
        }
        fwrite("query_info_fe: No results!\n",1,0x1b,stderr);
        return iVar4;
      }
      if ((DAT_005562a6 & 1) == 0) {
        return 0;
      }
      fwrite("query_info_fe: response format error.\n",1,0x26,stderr);
      return 0;
    }
  }
  else {
    if (DAT_00559cd0 == 3) {
      if (0x2000 < (int)*param_4) {
        *param_4 = 0x2000;
      }
      __size = *param_4;
      if (0x3c0 < __size) {
        __size = 0x3c0;
      }
      piVar2 = (int *)malloc(0x24);
      if (piVar2 == (int *)0x0) {
        return 0;
      }
      __dest = malloc(__size);
      if (__dest == (void *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("Malloc failed for query information fecharacter buf \n",1,0x35,stderr);
        }
        free(piVar2);
        return 0;
      }
      memcpy(__dest,param_3,__size);
      local_1c = 0;
      do {
        if (4 < local_1c) {
LAB_004c5f44:
          free(piVar2);
          if (__dest == (void *)0x0) {
            return iVar4;
          }
          free(__dest);
          return iVar4;
        }
        FUN_004ca2f8(param_1);
        if ((3 < local_1c) && ((DAT_005562a6 & 2) != 0)) {
          fprintf(stdout,"ir_queryinformation_fe : retry %dcmd %d\n",local_1c,param_2);
        }
        memcpy(param_3,__dest,__size);
        iVar4 = FUN_004c99b0(param_1,param_2,param_3,*param_4,__size,param_6);
        if (iVar4 < 0) {
          if ((DAT_005562a6 & 4) != 0) {
            fwrite("query_info_fe: Send command failed\n",1,0x23,stdout);
          }
          FUN_004c9348(1000);
        }
        else {
          iVar4 = FUN_004c9e20(param_1,piVar2,*param_4,param_3,'\0');
          iVar4 = -(iVar4 >> 0x1f);
          if (iVar4 == 0) {
            if ((piVar2[2] & 4U) != 0) {
              iVar4 = *piVar2;
              goto LAB_004c5f44;
            }
            FUN_004c9348(1000);
          }
          else {
            if ((DAT_005562a6 & 4) != 0) {
              fwrite("ir_queryinformation_fe :Error in reading the frag bytes\n",1,0x38,stdout);
            }
            FUN_004c9348(1000);
          }
        }
        local_1c = local_1c + 1;
      } while( true );
    }
    if (DAT_00559cd0 == 4) {
      if (0x2000 < (int)*param_4) {
        *param_4 = 0x2000;
      }
      uVar1 = *param_4;
      if (0x100 < uVar1) {
        uVar1 = 0x100;
      }
      iVar4 = FUN_004c494c(param_1,param_2,param_3,param_4,uVar1,param_6);
      return iVar4;
    }
  }
  if ((DAT_005562a6 & 1) != 0) {
    fprintf(stderr,"rwl_queryinformation_fe: Unknownremote_type %d\n",DAT_00559cd0);
  }
  return iVar4;
}



int FUN_004c5fec(int *param_1,int param_2,char *param_3,uint *param_4,undefined4 param_5,
                undefined4 param_6)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  size_t __size;
  void *__dest;
  char *__ptr;
  int iVar4;
  char local_1c;
  
  iVar4 = 0;
  if (DAT_00559cd0 == 2) {
    iVar4 = FUN_004c41e4(param_1,param_2,param_3,param_4,param_4,param_6);
    return iVar4;
  }
  if (DAT_00559cd0 < 3) {
    if (DAT_00559cd0 == 1) {
      uVar1 = FUN_004cb14c(param_1,param_2,param_3,*param_4,*param_4,param_6);
      if ((int)uVar1 < 0) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("set_info_fe: Send command failed\n",1,0x21,stderr);
        return 0;
      }
      piVar2 = FUN_004cb844(param_1);
      if (piVar2 == (int *)0x0) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("set_info_fe: Reading CDC header failed\n",1,0x27,stderr);
        return 0;
      }
      if (piVar2[2] != 4) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("set_info_fe: response format error.\n",1,0x24,stderr);
        return 0;
      }
      if ((uint)piVar2[1] <= *param_4) {
        iVar4 = *piVar2;
        if ((iVar4 != 0) && ((DAT_005562a6 & 1) != 0)) {
          fprintf(stderr,"set_info_fe: remote cdc header return error code (%d)\n",iVar4);
        }
        iVar3 = FUN_004cba5c(param_1,(int)piVar2,param_3);
        if (iVar3 != -1) {
          if ((piVar2[2] & 4U) == 0) {
            return iVar4;
          }
          return *piVar2;
        }
        if ((DAT_005562a6 & 1) == 0) {
          return iVar4;
        }
        fwrite("set_info_fe: fetching results failed\n",1,0x25,stderr);
        return iVar4;
      }
      if ((DAT_005562a6 & 1) == 0) {
        return 0;
      }
      fprintf(stderr,"set_info_fe: needed size (%d) greater than actual size (%lu)\n",piVar2[1],
              *param_4);
      return 0;
    }
  }
  else {
    if (DAT_00559cd0 == 3) {
      if (0x2000 < (int)*param_4) {
        *param_4 = 0x2000;
      }
      __size = *param_4;
      if (0x3c0 < __size) {
        __size = 0x3c0;
      }
      __dest = malloc(__size);
      if (__dest == (void *)0x0) {
        if ((DAT_005562a6 & 1) == 0) {
          return 0;
        }
        fwrite("Malloc failed for set_info_fe character buf\n",1,0x2c,stderr);
        return 0;
      }
      __ptr = (char *)malloc(0x416);
      if (__ptr == (char *)0x0) {
        free(__dest);
        return 0;
      }
      piVar2 = (int *)malloc(0x24);
      if (piVar2 == (int *)0x0) {
        free(__ptr);
        free(__dest);
        return 0;
      }
      memcpy(__dest,param_3,__size);
      local_1c = '\0';
      do {
        if ('\x04' < local_1c) {
LAB_004c6728:
          free(piVar2);
          free(__ptr);
          if (__dest == (void *)0x0) {
            return iVar4;
          }
          free(__dest);
          return iVar4;
        }
        FUN_004ca2f8(param_1);
        memcpy(param_3,__dest,__size);
        if (('\x03' < local_1c) && ((DAT_005562a6 & 2) != 0)) {
          fprintf(stdout,"retry %d cmd %d\n",(int)local_1c,param_2);
        }
        iVar4 = FUN_004c99b0(param_1,param_2,param_3,*param_4,__size,param_6);
        iVar4 = -(iVar4 >> 0x1f);
        if (iVar4 == 0) {
          if ((param_3 != (char *)0x0) && (iVar3 = strcmp(param_3,"findserver"), iVar3 == 0))
          goto LAB_004c6728;
          iVar4 = FUN_004c9cc4(param_1,__ptr);
          iVar4 = -(iVar4 >> 0x1f);
          if (iVar4 == 0) {
            memcpy(piVar2,__ptr + 6,0x24);
            FUN_004cbd00(piVar2);
            memcpy(param_3,__ptr + 0x2a,piVar2[1]);
            if ((piVar2[2] & 4U) != 0) {
              iVar4 = *piVar2;
              goto LAB_004c6728;
            }
            FUN_004c9348(1000);
          }
          else {
            if ((DAT_005562a6 & 1) != 0) {
              fwrite("ir_setinformation_fe: failed to readthe response\n",1,0x31,stderr);
            }
            FUN_004c9348(1000);
          }
        }
        else {
          if ((DAT_005562a6 & 1) != 0) {
            fwrite("ir_setinformation_fe: Sendcommand failed\n",1,0x29,stderr);
          }
          FUN_004c9348(1000);
        }
        local_1c = local_1c + '\x01';
      } while( true );
    }
    if (DAT_00559cd0 == 4) {
      if (0x2000 < (int)*param_4) {
        *param_4 = 0x2000;
      }
      uVar1 = *param_4;
      if (0x200 < uVar1) {
        uVar1 = 0x200;
      }
      iVar4 = FUN_004c494c(param_1,param_2,param_3,param_4,uVar1,param_6);
      return iVar4;
    }
  }
  if ((DAT_005562a6 & 1) != 0) {
    fprintf(stderr,"rwl_setinformation_fe: Unknown remote_type:%d\n",DAT_00559cd0);
  }
  return iVar4;
}



undefined4 FUN_004c67dc(int *param_1,char *param_2,void *param_3,size_t param_4,undefined4 *param_5)

{
  size_t sVar1;
  undefined4 uVar2;
  
  memset(PTR_DAT_00556da4,0,0x2000);
  strcpy(PTR_DAT_00556da4,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00556da4 + sVar1 + 1,param_3,param_4);
  }
  *param_5 = PTR_DAT_00556da4;
  FUN_004c968c(DAT_00559cd0);
  uVar2 = FUN_004bab9c(param_1,0x106,PTR_DAT_00556da4,0x2000);
  FUN_004c968c(DAT_00559cd0);
  return uVar2;
}



undefined4 FUN_004c68f0(int *param_1,char *param_2,void *param_3,size_t param_4)

{
  size_t sVar1;
  undefined4 uVar2;
  
  memset(PTR_DAT_00556da4,0,0x2000);
  strcpy(PTR_DAT_00556da4,param_2);
  sVar1 = strlen(param_2);
  if (param_4 != 0) {
    memcpy(PTR_DAT_00556da4 + sVar1 + 1,param_3,param_4);
  }
  FUN_004c968c(DAT_00559cd0);
  uVar2 = FUN_004baca0(param_1,0x107,PTR_DAT_00556da4,sVar1 + 1 + param_4);
  FUN_004c968c(DAT_00559cd0);
  return uVar2;
}



undefined4 FUN_004c6a04(int *param_1,char *param_2,void *param_3,size_t param_4)

{
  size_t sVar1;
  int iVar2;
  undefined4 uVar3;
  size_t local_resc;
  
  local_resc = param_4;
  memset(PTR_DAT_00556da4,0,0x2000);
  strcpy(PTR_DAT_00556da4,param_2);
  sVar1 = strlen(param_2);
  if (local_resc != 0) {
    memcpy(PTR_DAT_00556da4 + sVar1 + 0xd,param_3,local_resc);
  }
  memset(PTR_DAT_00556da4 + sVar1 + 9,0,4);
  memcpy(PTR_DAT_00556da4 + sVar1 + 1,PTR_DAT_00556db4,6);
  memcpy(PTR_DAT_00556da4 + sVar1 + 7,&local_resc,2);
  iVar2 = local_resc + 0xc;
  FUN_004c968c(DAT_00559cd0);
  uVar3 = FUN_004baca0(param_1,0x107,PTR_DAT_00556da4,sVar1 + 1 + iVar2);
  FUN_004c968c(DAT_00559cd0);
  return uVar3;
}



void FUN_004c6ba0(int param_1)

{
  if (param_1 == 2) {
    fwrite(" Usage: wl/dhd --socket <IP ADDRESS> [<PORT>] <command>\n",1,0x38,stderr);
    fwrite("\t<IPADDRESS> IP address of server machine\n",1,0x2a,stderr);
    fwrite("\t<PORT> Port no of server\n",1,0x1a,stderr);
    fwrite("\t<command> - wl, shell or dhd command\n",1,0x26,stderr);
    fwrite("\tDepending on the client you are using(wl or dhd)\n",1,0x32,stderr);
    fwrite("\t\t shell command usage: sh <command>\n",1,0x25,stderr);
    fwrite("\t If <PORT> is omitted, use default port number 8000\n",1,0x35,stderr);
  }
  else if (param_1 < 3) {
    if (param_1 == 1) {
      fwrite(" Usage: wl/dhd [--linuxdut/linux] [--debug]",1,0x2b,stderr);
      fwrite(" [--serial port no]",1,0x13,stderr);
      fwrite("[--ReadTimeout n] [--interactive] [--clientbatch] \n",1,0x33,stderr);
      fwrite("\t--linuxdut/linux removes the WLC_OID_BASE",1,0x2a,stderr);
      fwrite("when sending the IOCTL command \n",1,0x20,stderr);
      fwrite("\t--debug prints out tx packets sending down ",1,0x2c,stderr);
      fwrite(" the serial line, and other debug info \n",1,0x28,stderr);
      fwrite("\t--serial enables the remoteWL serial port number\n",1,0x32,stderr);
      fwrite("\t--interactive enables using WL in interactive mode\n",1,0x34,stderr);
      fwrite("\t--clientbatch enables command batchinng on the client,",1,0x37,stderr);
      fwrite(" the default is batching on driver\n",1,0x23,stderr);
    }
  }
  else if (param_1 == 3) {
    fwrite(" Usage: wl/dhd --wifi <MAC Address> <command>\n",1,0x2e,stderr);
    fwrite("\t<MAC Address> MAC Address\n",1,0x1b,stderr);
    fwrite("\t<command> - wl, shell or dhd command\n",1,0x26,stderr);
    fwrite("\tDepending on the client you are using(wl or dhd)\n",1,0x32,stderr);
    fwrite("\t\t shell command usage: sh <command>\n",1,0x25,stderr);
  }
  else if (param_1 == 4) {
    fwrite(" Usage: wl/dhd --dongle <Device Name>  <command>\n",1,0x31,stderr);
    fwrite("\t<Device Name> COM1/COM2 (WinXP) or /dev/ttyS0 or /dev/ttyS1 (Linux)\n",1,0x45,stderr);
    fwrite("\t<command> - wl, shell or dhd command\n",1,0x26,stderr);
    fwrite("\tDepending on the client you are using(wl or dhd)\n",1,0x32,stderr);
    fwrite("\t\t shell command usage: sh <command>\n",1,0x25,stderr);
  }
  return;
}



undefined4 FUN_004c7030(int *param_1,undefined4 param_2,void *param_3)

{
  int iVar1;
  undefined4 *puVar2;
  size_t __n;
  void *__buf;
  int iVar3;
  undefined4 local_20;
  
  DAT_00556da8 = 1;
  iVar1 = FUN_004bc824();
  DAT_005576a0 = iVar1;
  if (iVar1 == 0) {
    do {
    } while (DAT_00556da8 != 0);
    FUN_004cb14c(param_1,0,param_3,0,0,0xfffffffc);
                    // WARNING: Subroutine does not return
    exit(0);
  }
  do {
    puVar2 = FUN_004cb844(param_1);
    if (puVar2 == (undefined4 *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("rwl_socket_shellresp: Receiving CDCheader failed\n",1,0x31,stderr);
      }
      return 0xffffffff;
    }
    __n = puVar2[1];
    __buf = malloc(puVar2[1] + 1);
    if (__buf == (void *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("rwl_socket_shellresp: Mem alloc fails\n",1,0x26,stderr);
      }
      return 0xffffffff;
    }
    if ((0 < (int)__n) && (iVar3 = FUN_004cba5c(param_1,(int)puVar2,__buf), iVar3 == -1)) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("rwl_socket_shellresp: No results!\n",1,0x22,stderr);
      }
      free(__buf);
      return 0xffffffff;
    }
    *(undefined1 *)((int)__buf + puVar2[1]) = 0;
    if ((puVar2[2] & 4) != 0) {
      local_20 = *puVar2;
    }
    write(1,__buf,__n);
  } while (__n != 0);
  FUN_004bc894(iVar1);
  return local_20;
}



int FUN_004c72b8(int *param_1,int *param_2,void *param_3)

{
  int iVar1;
  int local_18;
  int local_14;
  
  DAT_00556da8 = 1;
  iVar1 = FUN_004bc824();
  DAT_005576a0 = iVar1;
  if (iVar1 == 0) {
    do {
    } while (DAT_00556da8 != 0);
    FUN_004cb14c(param_1,0,param_3,0,0,0xfffffffc);
                    // WARNING: Subroutine does not return
    exit(0);
  }
  do {
    local_14 = FUN_004c9e20(param_1,param_2,0,(char *)0x0,'\x01');
    if (local_14 < 0) {
      if ((DAT_005562a6 & 4) != 0) {
        fwrite("rwl_shell_information_fe(wifi):error in reading shell response\n",1,0x3f,stdout);
      }
    }
    else {
      local_18 = param_2[1];
      local_14 = *param_2;
    }
  } while (local_18 != 0);
  FUN_004bc894(iVar1);
  return local_14;
}



undefined4 FUN_004c7418(int *param_1,undefined4 param_2,void *param_3,undefined4 param_4)

{
  int iVar1;
  undefined4 *puVar2;
  size_t __n;
  void *__buf;
  int iVar3;
  undefined4 local_20;
  
  DAT_00556da8 = 1;
  iVar1 = FUN_004bc824();
  DAT_005576a0 = iVar1;
  if (iVar1 == 0) {
    do {
    } while (DAT_00556da8 != 0);
    FUN_004cb14c(param_1,param_4,param_3,0,0,0xfffffffc);
                    // WARNING: Subroutine does not return
    exit(0);
  }
  do {
    puVar2 = FUN_004cb844(param_1);
    if (puVar2 == (undefined4 *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("shell_info_fe: Receiving CDC header failed\n",1,0x2b,stderr);
      }
      return 0xffffffd2;
    }
    __n = puVar2[1];
    __buf = malloc(puVar2[1] + 1);
    if (__buf == (void *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Mem alloc fails for shell response buffer\n",1,0x2a,stderr);
      }
      return 0xffffffff;
    }
    iVar3 = FUN_004cba5c(param_1,(int)puVar2,__buf);
    if (iVar3 == -1) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("shell_info_fe: No results!\n",1,0x1b,stderr);
      }
      free(__buf);
      return 0xffffffff;
    }
    *(undefined1 *)((int)__buf + puVar2[1]) = 0;
    if ((puVar2[2] & 4) != 0) {
      local_20 = *puVar2;
    }
    write(1,__buf,__n);
  } while (__n != 0);
  FUN_004bc894(iVar1);
  return local_20;
}



undefined4 FUN_004c7698(int *param_1,byte param_2,int *param_3)

{
  uint *puVar1;
  undefined4 uVar2;
  int local_14 [3];
  
  local_14[0] = 0;
  local_14[1] = 4;
  puVar1 = (uint *)(local_14 + 1);
  FUN_004c589c(param_1,0,(char *)local_14,puVar1,(uint)param_2,0x200);
  if (((puVar1 == (uint *)0x0) && (0 < local_14[0])) && (local_14[0] < 7)) {
    *param_3 = local_14[0];
    if (param_2 != 0) {
      fprintf(stderr,"Autodetect: %d\n",*param_3);
    }
    uVar2 = 0;
  }
  else {
    fwrite("Autodetect failed, rwl server is either too old or unreachable. Use --nodetect to disable autodetect.\n"
           ,1,0x66,stderr);
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



undefined4 FUN_004c77ac(int param_1,int param_2)

{
  int local_10;
  
  local_10 = 0;
  while( true ) {
    if (param_2 <= local_10) {
      return 1;
    }
    if ((*(ushort *)(__ctype_b + *(char *)(param_1 + local_10) * 2) & 8) == 0) break;
    local_10 = local_10 + 1;
  }
  return 0xffffffff;
}



int FUN_004c7840(int param_1,int param_2,int param_3)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  
  iVar1 = socket(param_1,param_2,param_3);
  if (iVar1 == -1) {
    perror("rwl_opensocket Fails:");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\nerrno:%d\n",*piVar2);
    }
    iVar1 = -1;
  }
  return iVar1;
}



undefined4 FUN_004c7904(int param_1,int param_2,int param_3,undefined4 param_4)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  undefined4 local_resc;
  
  local_resc = param_4;
  iVar1 = setsockopt(param_1,param_2,param_3,&local_resc,4);
  if (iVar1 == -1) {
    perror("Error at SetTCPSocketOpt()");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



undefined4 FUN_004c79d8(int param_1,sockaddr *param_2,socklen_t param_3)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  
  iVar1 = connect(param_1,param_2,param_3);
  if (iVar1 == -1) {
    perror("Failed to connect() to server");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



undefined4 FUN_004c7a9c(int param_1,sockaddr *param_2,socklen_t param_3)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  
  iVar1 = bind(param_1,param_2,param_3);
  if (iVar1 == -1) {
    perror("Error at rwl_bindSocket()");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



undefined4 FUN_004c7b60(int param_1,int param_2)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  
  iVar1 = listen(param_1,param_2);
  if (iVar1 == -1) {
    perror("Error at rwl_listensocket()");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



int FUN_004c7c18(int param_1,sockaddr *param_2,socklen_t *param_3)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  
  iVar1 = accept(param_1,param_2,param_3);
  if (iVar1 == -1) {
    perror("Error at rwl_acceptConnection()");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    iVar1 = -1;
  }
  return iVar1;
}



undefined4 FUN_004c7cdc(int param_1)

{
  FILE *param0;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  
  iVar1 = close(param_1);
  if (iVar1 == -1) {
    perror("Error at rwl_closeSocket()");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"\n errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



int FUN_004c7d8c(int param_1,void *param_2,int param_3,int param_4)

{
  FILE *param0;
  ssize_t param3;
  int *piVar1;
  void *local_res4;
  int local_18;
  
  local_18 = 0;
  local_res4 = param_2;
  while( true ) {
    if (param_3 <= local_18) {
      return local_18;
    }
    param3 = send(param_1,local_res4,param_3 - local_18,param_4);
    if (param3 == -1) break;
    if (param3 == param_3) {
      return param3;
    }
    if ((param_3 - local_18 != param3) && ((DAT_005562a6 & 4) != 0)) {
      fprintf(stdout,"wanted to send %d bytes sent only %d bytes\n",param_3 - local_18,param3);
    }
    local_18 = local_18 + param3;
    local_res4 = (void *)((int)local_res4 + param3);
  }
  perror("Failed to send()");
  param0 = stderr;
  if ((DAT_005562a6 & 1) != 0) {
    piVar1 = __errno_location();
    fprintf(param0,"\n errno:%d\n",*piVar1);
  }
  return -1;
}



ssize_t FUN_004c7f24(int param_1,void *param_2,int param_3,int param_4)

{
  FILE *param0;
  int *piVar1;
  void *local_res4;
  ssize_t local_18;
  int local_14;
  
  local_14 = 0;
  local_res4 = param_2;
  while( true ) {
    if (param_3 <= local_14) {
      return local_18;
    }
    local_18 = recv(param_1,local_res4,param_3 - local_14,param_4);
    if (local_18 == -1) break;
    if ((param_3 - local_14 != local_18) && ((DAT_005562a6 & 4) != 0)) {
      fprintf(stdout,"asked %d bytes got %d bytes\n",param_3 - local_14,local_18);
    }
    if (local_18 == 0) {
      return 0;
    }
    local_14 = local_14 + local_18;
    local_res4 = (void *)((int)local_res4 + local_18);
  }
  perror("Failed to Receive()");
  param0 = stderr;
  if ((DAT_005562a6 & 1) != 0) {
    piVar1 = __errno_location();
    fprintf(param0,"\n errno:%d\n",*piVar1);
  }
  return -1;
}



int FUN_004c80b0(int param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  undefined4 *local_res4;
  ushort local_50;
  char local_3c [32];
  sockaddr local_1c;
  
  local_50 = 8000;
  builtin_strncpy(local_3c,"eth0",5);
  local_res4 = param_2;
  if (param_1 == 3) {
    if ((*(ushort *)(__ctype_b + *(char *)param_2[1] * 2) & 4) == 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("USAGE ERROR:Incorrect network interface\n",1,0x28,stderr);
      }
      return -1;
    }
    strcpy(local_3c,(char *)param_2[1]);
    local_res4 = param_2 + 2;
    if ((*(ushort *)(__ctype_b + *(char *)*local_res4 * 2) & 8) == 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("USAGE ERROR:Incorrect port\n",1,0x1b,stderr);
      }
      return -1;
    }
    iVar1 = atoi((char *)*local_res4);
    local_50 = (ushort)iVar1;
  }
  if (param_1 == 2) {
    local_res4 = local_res4 + 1;
    if ((*(ushort *)(__ctype_b + *(char *)*local_res4 * 2) & 4) == 0) {
      if ((*(ushort *)(__ctype_b + *(char *)*local_res4 * 2) & 8) == 0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("USAGE ERROR\n",1,0xc,stderr);
        }
        return -1;
      }
      iVar1 = atoi((char *)*local_res4);
      local_50 = (ushort)iVar1;
    }
    else {
      strcpy(local_3c,(char *)*local_res4);
    }
  }
  if ((DAT_005562a6 & 2) != 0) {
    fprintf(stdout,"INFO: Network Interface:%s, Port:%d\n",local_3c,(uint)local_50);
  }
  piVar2 = FUN_004c9040(param_3);
  iVar1 = *piVar2;
  if (iVar1 == -1) {
    iVar1 = -1;
  }
  else {
    iVar3 = FUN_004c7904(iVar1,0xffff,4,1);
    if (iVar3 == -1) {
      iVar1 = -1;
    }
    else {
      memset(&local_1c,0,0x10);
      FUN_004c84f8(local_3c,&local_1c);
      local_1c.sa_family = 2;
      local_1c.sa_data._0_2_ = local_50 << 8 | local_50 >> 8;
      iVar3 = FUN_004c7a9c(iVar1,&local_1c,0x10);
      if (iVar3 == -1) {
        iVar1 = -1;
      }
      else {
        iVar3 = FUN_004c7b60(iVar1,4);
        if (iVar3 == -1) {
          iVar1 = -1;
        }
        else if ((DAT_005562a6 & 4) != 0) {
          fwrite("Waiting for client to connect...\n",1,0x21,stdout);
        }
      }
    }
  }
  return iVar1;
}



undefined4 FUN_004c84f8(char *param_1,void *param_2)

{
  int __fd;
  undefined4 uVar1;
  int iVar2;
  char acStack_2c [16];
  undefined2 local_1c [10];
  
  __fd = socket(2,1,0);
  if (__fd < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("socket open error\n",1,0x12,stderr);
    }
    uVar1 = 0xffffffff;
  }
  else {
    strcpy(acStack_2c,param_1);
    local_1c[0] = 2;
    iVar2 = ioctl(__fd,0x8915,acStack_2c);
    if (iVar2 == 0) {
      memcpy(param_2,local_1c,0x10);
      close(__fd);
      uVar1 = 1;
    }
    else {
      close(__fd);
      uVar1 = 0xffffffff;
    }
  }
  return uVar1;
}



int FUN_004c8610(int param_1,char *param_2)

{
  FILE *param0;
  int *piVar1;
  int iVar2;
  speed_t sVar3;
  int local_60;
  int local_5c;
  tcflag_t local_44;
  tcflag_t local_40;
  uint local_3c;
  tcflag_t local_38;
  byte local_2f;
  byte local_2e;
  
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"\n rwl_open_serial:%s\n",param_2);
  }
  if (param_1 == 4) {
    local_60 = open(param_2,0x882);
  }
  else {
    local_60 = open(param_2,0x892);
  }
  param0 = stderr;
  if (local_60 < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      piVar1 = __errno_location();
      fprintf(param0,"open COM failed with error %d.\n",*piVar1);
    }
  }
  else {
    fcntl(local_60,4,0);
    bzero(&local_44,0x34);
    tcgetattr(local_60,(termios *)&local_44);
    cfsetispeed((termios *)&local_44,0x1002);
    cfsetospeed((termios *)&local_44,0x1002);
    if (param_1 == 4) {
      iVar2 = tcsetattr(local_60,0x540e,(termios *)&local_44);
      if (iVar2 < 0) {
        perror("tcsetattr:setspeed");
        local_60 = -1;
      }
      else {
        sVar3 = cfgetospeed((termios *)&local_44);
        if (sVar3 == 0x1002) {
          local_5c = 0x1c200;
        }
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"Baud_rate set is:%d\n",local_5c);
        }
        local_3c = 0x18b3;
        local_44 = 4;
        local_40 = 0;
        local_38 = 0;
        local_2f = 0x10;
        local_2e = 0x32;
        tcflush(local_60,2);
        iVar2 = tcsetattr(local_60,0x540e,(termios *)&local_44);
        if (iVar2 < 0) {
          perror("tcsetattr:");
          local_60 = -1;
        }
        else {
          iVar2 = tcgetattr(local_60,(termios *)&local_44);
          if (iVar2 < 0) {
            perror("tcgetattr:");
            local_60 = -1;
          }
          else {
            if ((DAT_005562a6 & 4) != 0) {
              fprintf(stdout,"tcgetattr:VMIN is:%d\n",(uint)local_2f);
            }
            if ((DAT_005562a6 & 4) != 0) {
              fprintf(stdout,"tcgetattr:VTIME is:%d\n",(uint)local_2e);
            }
            tcflush(local_60,2);
          }
        }
      }
    }
    else {
      local_3c = local_3c & 0xfffffe8f | 0x8b0;
      local_2e = 0xff;
      local_2f = '\x01';
      local_44 = 1;
      local_40 = local_40 & 0xffffff80;
      local_38 = local_38 & 0xffffdef0 | 0x80;
      tcsetattr(local_60,0x540e,(termios *)&local_44);
      tcflush(local_60,2);
    }
  }
  return local_60;
}



undefined4 FUN_004c8b04(int *param_1,void *param_2,size_t param_3,size_t *param_4)

{
  FILE *param0;
  size_t sVar1;
  int *piVar2;
  undefined4 uVar3;
  
  sVar1 = write(*param_1,param_2,param_3);
  *param_4 = sVar1;
  if (sVar1 == 0xffffffff) {
    perror("WriteToPort Failed");
    param0 = stderr;
    if ((DAT_005562a6 & 1) != 0) {
      piVar2 = __errno_location();
      fprintf(param0,"Errno:%d\n",*piVar2);
    }
    uVar3 = 0xffffffff;
  }
  else if (*param_4 == param_3) {
    uVar3 = 1;
  }
  else {
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"rwl_write_serial_port failed numwritten %ld != len %ld\n",*param_4,param_3);
    }
    uVar3 = 0xffffffff;
  }
  return uVar3;
}



// WARNING: Removing unreachable block (ram,0x004c8c74)

undefined4 FUN_004c8c40(int *param_1,int param_2,int *param_3)

{
  int iVar1;
  int local_20;
  int local_10 [2];
  
  local_10[0] = 0;
  if (param_3 != (int *)0x0) {
    *param_3 = 0;
  }
  local_20 = 0;
  while( true ) {
    if (param_2 / 10 <= local_20) {
      return 0xffffffff;
    }
    iVar1 = ioctl(*param_1,0x467f,local_10);
    if ((iVar1 == 0) && (0 < local_10[0])) break;
    usleep(10000);
    local_20 = local_20 + 1;
  }
  if (param_3 != (int *)0x0) {
    *param_3 = local_10[0];
  }
  return 0;
}



undefined4 FUN_004c8d6c(int *param_1,void *param_2,uint param_3,ssize_t *param_4)

{
  FILE *param0;
  int iVar1;
  ssize_t sVar2;
  int *piVar3;
  void *local_res4;
  uint local_28;
  int local_24;
  size_t local_20;
  size_t local_18 [3];
  
  local_28 = 0;
  local_24 = 0;
  local_res4 = param_2;
  while( true ) {
    if (param_3 <= local_28) {
      return 1;
    }
    iVar1 = FUN_004c8c40(param_1,10000,(int *)local_18);
    if (iVar1 != 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("input buffer is empty\n",1,0x16,stderr);
      }
      return 0xffffffff;
    }
    local_20 = param_3 - local_28;
    if ((int)local_18[0] < (int)local_20) {
      local_20 = local_18[0];
    }
    sVar2 = read(*param_1,local_res4,local_20);
    *param_4 = sVar2;
    if (sVar2 == -1) {
      perror("ReadFromPort Failed");
      param0 = stderr;
      if ((DAT_005562a6 & 1) != 0) {
        piVar3 = __errno_location();
        fprintf(param0,"Errno:%d\n",*piVar3);
      }
      return 0xffffffff;
    }
    if ((*param_4 != param_3 - local_28) && ((DAT_005562a6 & 4) != 0)) {
      fprintf(stdout,"asked for %d bytes got %d bytes\n",param_3 - local_28,*param_4);
    }
    if ((*param_4 == 0) && (10000 < local_24)) break;
    local_28 = local_28 + *param_4;
    local_res4 = (void *)((int)local_res4 + *param_4);
    local_24 = local_24 + 1;
  }
  if ((DAT_005562a6 & 1) != 0) {
    fprintf(stderr,"rwl_read_serial_port failed after %d retries\n",local_24);
  }
  return 0xffffffff;
}



void FUN_004c8ff8(uint param_1)

{
  if (1 < param_1) {
    FUN_004c9348(200);
  }
  return;
}



undefined4 * FUN_004c9040(int param_1)

{
  if (param_1 == 2) {
    DAT_005576ac = FUN_004c7840(2,2,6);
    if (DAT_005576ac == -1) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("\nCan\'t open socket \n",1,0x14,stderr);
      }
      return (undefined4 *)0x0;
    }
  }
  else {
    if ((param_1 != 4) && (param_1 != 1)) {
      if ((DAT_005562a6 & 1) != 0) {
        fprintf(stderr,"rwl_open_transport: Unknown remote_type %d\n",param_1);
      }
      return (undefined4 *)0x0;
    }
    DAT_005576ac = FUN_004c8610(param_1,PTR_DAT_00556db0);
    if ((DAT_005576ac == -1) &&
       (DAT_005576ac = FUN_004c8610(param_1,PTR_DAT_00556db0), DAT_005576ac == -1)) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("Can\'t open serial port\n",1,0x17,stderr);
      }
      return (undefined4 *)0x0;
    }
  }
  return &DAT_005576ac;
}



undefined4 FUN_004c922c(int param_1,int *param_2)

{
  int iVar1;
  
  if (param_1 == 2) {
    iVar1 = FUN_004c7cdc(*param_2);
    if (iVar1 == -1) {
      return 0xffffffff;
    }
  }
  else if ((param_1 == 4) || (param_1 == 1)) {
    iVar1 = close(*param_2);
    if (iVar1 == -1) {
      return 0xffffffff;
    }
  }
  else if ((DAT_005562a6 & 1) != 0) {
    fprintf(stderr,"close_pipe: Unknown remote_type %d\n",param_1);
  }
  return 1;
}



void FUN_004c9348(int param_1)

{
  usleep(param_1 * 1000);
  return;
}



void FUN_004c93a0(undefined4 param_1)

{
  size_t sVar1;
  uint local_b8;
  uint local_b4;
  char cStack_ac;
  undefined1 auStack_ab [63];
  int aiStack_6c [2];
  undefined1 auStack_64 [92];
  
  memcpy(aiStack_6c,&DAT_0052fa64,0x60);
  for (local_b4 = 0; local_b4 < 8; local_b4 = local_b4 + 1) {
    if (*(int *)(auStack_64 + local_b4 * 0xc + -4) == 0) {
      local_b8 = 4;
    }
    else {
      sVar1 = strlen(*(char **)(auStack_64 + local_b4 * 0xc + -4));
      local_b8 = sVar1 + 5;
    }
    if (local_b8 < 0x41) {
      if (*(int *)(auStack_64 + local_b4 * 0xc + -4) == 0) {
        memcpy(&cStack_ac,auStack_64 + local_b4 * 0xc,4);
      }
      else {
        strcpy(&cStack_ac,*(char **)(auStack_64 + local_b4 * 0xc + -4));
        sVar1 = strlen(*(char **)(auStack_64 + local_b4 * 0xc + -4));
        memcpy(auStack_ab + sVar1,auStack_64 + local_b4 * 0xc,4);
      }
      if (aiStack_6c[local_b4 * 3] == 2) {
        FUN_004ba614(param_1,aiStack_6c[local_b4 * 3],0,0,1);
      }
      else {
        FUN_004ba614(param_1,aiStack_6c[local_b4 * 3],&cStack_ac,local_b8,1);
      }
      FUN_004c9348(500);
    }
    else if ((DAT_005562a6 & 1) != 0) {
      fwrite("Err: command len exceeds buf len. Checkinitialization cmds\n",1,0x3b,stderr);
    }
  }
  return;
}



void FUN_004c968c(int param_1)

{
  if (param_1 == 3) {
    DAT_00559cd0 = 0;
    DAT_0055c138 = param_1;
  }
  else if (DAT_0055c138 == 3) {
    DAT_00559cd0 = DAT_0055c138;
    DAT_0055c138 = param_1;
  }
  return;
}



void FUN_004c9710(int param_1)

{
  undefined4 local_10;
  
  for (local_10 = 0; local_10 < 0x7f; local_10 = local_10 + 1) {
    if (*(int *)(param_1 + local_10 * 4) != 0) {
      free(*(void **)(param_1 + local_10 * 4));
    }
  }
  return;
}



int FUN_004c97a0(int *param_1,int param_2,undefined4 *param_3)

{
  int local_18;
  undefined4 local_14;
  undefined4 local_10;
  int local_c;
  
  local_18 = -1;
  if (param_2 == 0x1d) {
    memset(&local_14,0,0xc);
    local_18 = FUN_004bab9c(param_1,0x1d,(char *)&local_14,0xc);
    if (local_18 < 0) {
      return local_18;
    }
    if (local_c != 0) {
      puts("Scan in progress.");
    }
    *param_3 = local_14;
  }
  if (param_2 == 0x1e) {
    local_10 = *param_3;
    FUN_004c968c(DAT_00559cd0);
    local_18 = FUN_004baca0(param_1,0x1e,(char *)&local_10,4);
    FUN_004c968c(DAT_00559cd0);
  }
  return local_18;
}



undefined1 * FUN_004c98e8(void)

{
  undefined1 *puVar1;
  
  puVar1 = (undefined1 *)malloc(0x416);
  if (puVar1 == (undefined1 *)0x0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("rwl_wifi_allocate_actionframe: unable to allocate frame \n",1,0x39,stderr);
    }
  }
  else {
    *puVar1 = 0x7f;
    puVar1[1] = 0;
    puVar1[2] = 0x90;
    puVar1[3] = 0x4c;
    puVar1[4] = 0;
    puVar1[5] = 0;
  }
  return puVar1;
}



int FUN_004c99b0(undefined4 param_1,undefined4 param_2,char *param_3,uint param_4,uint param_5,
                undefined4 param_6)

{
  size_t sVar1;
  int iVar2;
  undefined1 *__ptr;
  int local_18;
  int local_14;
  
  DAT_0055c11c = param_6;
  DAT_0055c124 = param_5;
  DAT_0055c114 = param_2;
  DAT_0055c118 = param_4;
  if (DAT_0055c104 != '\0') {
    strncpy(&DAT_0055c128,&DAT_0055c104,0x10);
  }
  FUN_004cbd00(&DAT_0055c114);
  if (param_4 < param_5) {
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"remote_CDC_wifi_tx: data_len (%d) > buf_len (%d)\n",param_5,param_4);
    }
    local_18 = -1;
  }
  else {
    if ((0x3c0 < param_5) && ((DAT_005562a6 & 4) != 0)) {
      fprintf(stdout,"data size exceeds data_len %d\n",DAT_0055c118);
    }
    if (((param_3 == (char *)0x0) || (sVar1 = strlen(param_3), sVar1 < 10)) ||
       (iVar2 = strcmp(param_3,"findserver"), iVar2 != 0)) {
      __ptr = FUN_004c98e8();
      if (__ptr == (undefined1 *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("remote_CDC_wifi_tx: Failed to allocate memory\n",1,0x2e,stderr);
        }
        local_18 = -1;
      }
      else {
        memcpy(__ptr + 6,&DAT_0055c114,0x24);
        if (param_3 != (char *)0x0) {
          memcpy(__ptr + 0x2a,param_3,param_5);
        }
        local_18 = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
        if ((local_18 < 0) && ((DAT_005562a6 & 1) != 0)) {
          fprintf(stderr,"Unable to read the action frame %d error\n",local_18);
        }
        free(__ptr);
      }
    }
    else {
      local_14 = 0;
      while ((local_14 < 5 && (local_18 = FUN_004ca570(param_1,PTR_DAT_00556db4), local_18 != 0))) {
        local_14 = local_14 + 1;
      }
    }
  }
  return local_18;
}



int FUN_004c9cc4(int *param_1,char *param_2)

{
  int local_18;
  int local_14;
  void *local_10 [2];
  
  local_10[0] = (void *)0x0;
  for (local_14 = 0; local_14 < 0x14; local_14 = local_14 + 1) {
    local_18 = FUN_004c67dc(param_1,"rwlwifivsaction",param_2,0x416,local_10);
    if (local_18 < 0) {
      if ((DAT_005562a6 & 1) == 0) {
        return local_18;
      }
      fprintf(stderr,"remote_CDC_DATA_wifi_rx: Error in reading the frame %d\n",local_18);
      return local_18;
    }
    memcpy(param_2,local_10[0],0x416);
    if (*param_2 == '\x7f') break;
    if (DAT_005576b0 == 0) {
      FUN_004c9348(0xfa);
    }
    else {
      FUN_004c9348(10);
    }
  }
  if (*param_2 != '\x7f') {
    local_18 = -1;
  }
  return local_18;
}



int FUN_004c9e20(undefined4 param_1,undefined4 *param_2,undefined4 param_3,char *param_4,
                char param_5)

{
  char *__ptr;
  size_t __n;
  int local_228;
  uint local_224;
  int local_220;
  int local_21c;
  size_t local_218;
  char *local_214;
  int local_20c [127];
  char local_10;
  
  local_10 = param_5;
  local_218 = 0;
  memset(local_20c,0,0x1fc);
  local_214 = param_4;
  if (local_10 != '\0') {
    local_214 = PTR_DAT_00556db8;
    memset(PTR_DAT_00556db8,0,0x1fc00);
  }
  local_224 = 0x7f;
  local_21c = 0;
  while( true ) {
    if ((int)local_224 < local_21c) {
      local_220 = 0;
      while( true ) {
        if ((int)local_224 <= local_220) {
          if (local_224 == 0) {
            memcpy(local_214,(void *)(local_20c[0] + 0x2a),param_2[1]);
          }
          else {
            memcpy(local_214,(void *)(local_20c[0] + 0x2a),0x3c0);
          }
          for (local_220 = 1; local_220 < (int)local_224; local_220 = local_220 + 1) {
            memcpy(local_214 + local_220 * 0x3c0,(void *)(local_20c[local_220] + 6),0x3c0);
          }
          if ((local_218 != 0) && (local_224 != 0)) {
            memcpy(local_214 + local_220 * 0x3c0,(void *)(local_20c[local_220] + 6),local_218);
          }
          if (local_10 != '\0') {
            __n = strlen(local_214);
            write(1,local_214,__n);
          }
          FUN_004c9710((int)local_20c);
          return local_228;
        }
        if (local_20c[local_220] == 0) break;
        local_220 = local_220 + 1;
      }
      if ((DAT_005562a6 & 4) != 0) {
        fprintf(stdout,"Missing frag number %d\n",local_220);
      }
      FUN_004c9710((int)local_20c);
      return -1;
    }
    __ptr = FUN_004c98e8();
    if (__ptr == (char *)0x0) {
      if ((DAT_005562a6 & 4) != 0) {
        fwrite("malloc failure\n",1,0xf,stdout);
      }
      FUN_004c9710((int)local_20c);
      return -1;
    }
    local_228 = FUN_004c9cc4(param_1,__ptr);
    if (local_228 < 0) break;
    if ((byte)__ptr[5] < 0x7f) {
      if (local_20c[(byte)__ptr[5]] == 0) {
        local_20c[(byte)__ptr[5]] = (int)__ptr;
      }
      else {
        local_21c = local_21c + -1;
        free(__ptr);
      }
      if (__ptr[5] == '\0') {
        memcpy(param_2,(void *)(local_20c[(byte)__ptr[5]] + 6),0x24);
        FUN_004cbd00(param_2);
        local_224 = (uint)param_2[1] / 0x3c0;
        local_218 = (uint)param_2[1] % 0x3c0;
      }
    }
    else {
      if ((DAT_005562a6 & 4) != 0) {
        fprintf(stdout," Read bogus subtype %d\n",(uint)(byte)__ptr[5]);
      }
      free(__ptr);
    }
    local_21c = local_21c + 1;
  }
  free(__ptr);
  FUN_004c9710((int)local_20c);
  return -1;
}



void FUN_004ca2f8(int *param_1)

{
  char *__dest;
  int iVar1;
  void *local_c;
  
  local_c = (void *)0x0;
  __dest = (char *)malloc(0x416);
  if (__dest == (char *)0x0) {
    if ((DAT_005562a6 & 4) != 0) {
      fwrite("Purge Error in reading the frame \n",1,0x22,stdout);
    }
  }
  else {
    do {
      iVar1 = FUN_004c67dc(param_1,"rwlwifivsaction",__dest,0x416,&local_c);
      if (iVar1 < 0) {
        if ((DAT_005562a6 & 4) != 0) {
          fwrite("rwl_wifi_purge_actionframes:Purge Error in reading the frame \n",1,0x3e,stdout);
        }
        break;
      }
      memcpy(__dest,local_c,0x416);
    } while (*__dest == '\x7f');
    free(__dest);
  }
  return;
}



void FUN_004ca438(undefined4 param_1,void *param_2)

{
  int param2;
  int local_18;
  uint local_10 [2];
  
  if (*(char *)((int)param_2 + 4) == '\t') {
    *(undefined1 *)((int)param_2 + 4) = 10;
    FUN_004c97a0(param_1,0x1d,local_10);
    if (*(byte *)((int)param_2 + 0x38) == local_10[0]) {
      *(char *)((int)param_2 + 0x39) = (char)local_10[0];
      for (local_18 = 0; local_18 < 5; local_18 = local_18 + 1) {
        param2 = FUN_004c6a04(param_1,"wifiaction",param_2,0x416);
        if (param2 < 0) {
          if ((DAT_005562a6 & 1) == 0) {
            return;
          }
          fprintf(stderr,"rwl_wifi_find_server_response: Failedto Send the Frame %d\n",param2);
          return;
        }
        FUN_004c9348(100);
      }
    }
  }
  return;
}



int FUN_004ca570(int *param_1,void *param_2)

{
  undefined1 *__ptr;
  char *__ptr_00;
  int iVar1;
  int local_80;
  int local_7c;
  int aiStack_64 [20];
  uint local_14;
  void *local_10 [2];
  
  memcpy(aiStack_64,&DAT_0052feb4,0x50);
  DAT_005576b0 = 1;
  __ptr = FUN_004c98e8();
  if (__ptr == (undefined1 *)0x0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite(" rwl_find_remote_wifi_server : Failed to allocate \n",1,0x33,stderr);
    }
    local_7c = -1;
  }
  else {
    __ptr_00 = FUN_004c98e8();
    if (__ptr_00 == (char *)0x0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite(" rwl_find_remote_wifi_server : Failed to allocate\n",1,0x32,stderr);
      }
      free(__ptr);
      local_7c = -1;
    }
    else {
      FUN_004ca2f8(param_1);
      __ptr[4] = 9;
      DAT_0055c114 = 0;
      DAT_0055c118 = 0x3c0;
      DAT_0055c11c = 0x10;
      DAT_0055c124 = 0x3c0;
      FUN_004cbd00(&DAT_0055c114);
      memcpy(__ptr + 6,&DAT_0055c114,0x24);
      memcpy(__ptr + 0x17,param_2,6);
      iVar1 = FUN_004c67dc(param_1,"cur_etheraddr",(void *)0x0,0,local_10);
      if (iVar1 < 0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("Error getting current Mac addr \n",1,0x20,stderr);
        }
        local_7c = -1;
      }
      else {
        memcpy(__ptr + 0x1d,local_10[0],6);
        for (local_80 = 0; local_80 < 0x14; local_80 = local_80 + 1) {
          if ((DAT_005562a6 & 2) != 0) {
            fprintf(stdout,"Scanning Channel: %d ...\n",aiStack_64[local_80]);
          }
          local_7c = FUN_004c97a0(param_1,0x1e,aiStack_64 + local_80);
          if (local_7c < 0) {
            if ((DAT_005562a6 & 1) != 0) {
              fprintf(stderr," Failed to set the specified channel %d\n",aiStack_64[local_80]);
            }
            break;
          }
          __ptr[0x38] = (char)aiStack_64[local_80];
          local_7c = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
          if (local_7c < 0) {
            if ((DAT_005562a6 & 4) != 0) {
              fprintf(stdout,"Failed to Send the Frame %d\n",local_7c);
            }
            break;
          }
          local_7c = FUN_004c9cc4(param_1,__ptr_00);
          if (local_7c < 0) {
            FUN_004c9348(0xfa);
          }
          else {
            if (__ptr_00[4] == '\n') {
              if (__ptr_00[0x39] == __ptr_00[0x38]) {
                if ((DAT_005562a6 & 2) != 0) {
                  fprintf(stdout,"Server is on channel # %d\n",(uint)(byte)__ptr_00[0x39]);
                }
                local_14 = (uint)(byte)__ptr_00[0x39];
                iVar1 = FUN_004c97a0(param_1,0x1e,&local_14);
                local_7c = -(iVar1 >> 0x1f);
                if (local_7c == 0) {
                  if ((DAT_005562a6 & 1) != 0) {
                    fprintf(stderr,"REF now moved to thechannel of server # %d\n",local_14);
                  }
                }
                else if ((DAT_005562a6 & 1) != 0) {
                  fprintf(stderr,"Failed to set the specifiedchannel %d\n",local_14);
                }
                break;
              }
              if ((DAT_005562a6 & 2) != 0) {
                fwrite("Server is operating on diffrent channel.continue scanning\n",1,0x3a,stdout);
              }
            }
            FUN_004c9348(0xfa);
          }
        }
        DAT_005576b0 = 0;
        free(__ptr);
        free(__ptr_00);
      }
    }
  }
  return local_7c;
}



undefined4 FUN_004cab28(int *param_1,undefined4 *param_2,void *param_3)

{
  size_t param2;
  int iVar1;
  undefined4 uVar2;
  uint local_68;
  uint local_64;
  size_t local_60;
  size_t local_50;
  undefined2 local_4c [2];
  char acStack_48 [64];
  
  local_4c[0] = 0xa0a;
  sprintf(acStack_48,"rwl %d %d %d %d ",*param_2,param_2[1],param_2[2],param_2[4]);
  param2 = strlen(acStack_48);
  iVar1 = param_2[4];
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"rwl %x %d %d %d ",*param_2,param_2[1],param_2[2],iVar1);
  }
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"CDC Header:No of bytes to be sent=%d\n",param2);
  }
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"Data:No of bytes to be sent=%d\n",iVar1);
  }
  iVar1 = FUN_004c8b04(param_1,acStack_48,param2,&local_50);
  if (iVar1 < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("CDC_Tx: Header: Write failed\n",1,0x1d,stderr);
    }
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"CDC_Tx: Header: numwritten %ld != n_bytes %d\n",local_50,param2);
    }
    uVar2 = 0xffffffff;
  }
  else {
    local_68 = (uint)param_2[4] >> 6;
    if (local_68 == 0) {
      iVar1 = FUN_004c8b04(param_1,param_3,param_2[4],&local_50);
      if (iVar1 < 0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("Data_Tx: Header: Write failed\n",1,0x1e,stderr);
        }
        if ((DAT_005562a6 & 1) != 0) {
          fprintf(stderr,"Data_Tx: Header: numwritten %ld != len %d\n",local_50,param_2[4]);
        }
        return 0xffffffff;
      }
    }
    else {
      if ((param_2[4] & 0x3f) == 0) {
        local_60 = 0x40;
      }
      else {
        local_60 = param_2[4] & 0x3f;
        local_68 = local_68 + 1;
      }
      for (local_64 = 0; local_64 < local_68; local_64 = local_64 + 1) {
        if (local_68 - 1 == local_64) {
          memcpy(acStack_48,(void *)((int)param_3 + local_64 * 0x40),local_60);
          iVar1 = FUN_004c8b04(param_1,acStack_48,local_60,&local_50);
          if (iVar1 == -1) {
            if ((DAT_005562a6 & 1) != 0) {
              fwrite("Data_Tx: Header: Write failed\n",1,0x1e,stderr);
            }
            return 0xffffffff;
          }
        }
        else {
          memcpy(acStack_48,(void *)((int)param_3 + local_64 * 0x40),0x40);
          iVar1 = FUN_004c8b04(param_1,acStack_48,0x40,&local_50);
          if (iVar1 == -1) {
            if ((DAT_005562a6 & 1) != 0) {
              fwrite("Data_Tx: Header: Write failed\n",1,0x1e,stderr);
            }
            return 0xffffffff;
          }
        }
        FUN_004c9348(100);
      }
    }
    iVar1 = FUN_004c8b04(param_1,local_4c,2,&local_50);
    if (iVar1 == -1) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("CDC_Tx: Header: Write failed\n",1,0x1d,stderr);
      }
      if ((DAT_005562a6 & 1) != 0) {
        fprintf(stderr,"CDC_Tx: Header: numwritten %ld != len %d\n",local_50,2);
      }
      uVar2 = 0xffffffff;
    }
    else {
      if ((DAT_005562a6 & 4) != 0) {
        fwrite("Packet sent!\n",1,0xd,stdout);
      }
      uVar2 = param_2[1];
    }
  }
  return uVar2;
}



void FUN_004cb0bc(int param_1)

{
  FUN_004c9040(param_1);
  return;
}



void FUN_004cb10c(int param_1,int *param_2)

{
  FUN_004c922c(param_1,param_2);
  return;
}



uint FUN_004cb14c(int *param_1,undefined4 param_2,void *param_3,uint param_4,uint param_5,
                 undefined4 param_6)

{
  size_t sVar1;
  int iVar2;
  undefined1 *__ptr;
  uint uVar3;
  uint local_28;
  size_t local_c;
  
  local_c = 0;
  memset(&DAT_0055c114,0,0x24);
  DAT_0055c11c = param_6;
  DAT_0055c124 = param_5;
  DAT_0055c114 = param_2;
  DAT_0055c118 = param_4;
  if (DAT_0055c104 != '\0') {
    strncpy(&DAT_0055c128,&DAT_0055c104,0x10);
  }
  FUN_004cbd00(&DAT_0055c114);
  if (param_4 < param_5) {
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"remote_CDC_tx: data_len (%d) > buf_len (%d)\n",param_5,param_4);
    }
    param_4 = 0xffffffff;
  }
  else if (DAT_00559cd0 == 1) {
    sVar1 = FUN_004c8b04(param_1,&DAT_0055c114,0x24,&local_c);
    if (sVar1 == 0xffffffff) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("CDC_Tx: Data: Write failed \n",1,0x1c,stderr);
      }
      param_4 = 0xffffffff;
    }
    else {
      local_c = sVar1;
      iVar2 = FUN_004c8b04(param_1,param_3,param_5,&local_c);
      if (iVar2 == -1) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("CDC_Tx: Data: Write failed \n",1,0x1c,stderr);
        }
        param_4 = 0xffffffff;
      }
    }
  }
  else if (DAT_00559cd0 == 4) {
    param_4 = FUN_004cab28(param_1,&DAT_0055c114,param_3);
  }
  else if (DAT_00559cd0 == 2) {
    iVar2 = FUN_004c7d8c(*param_1,&DAT_0055c114,0x24,0);
    if (iVar2 == -1) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("CDC_Tx: Data: Write failed \n",1,0x1c,stderr);
      }
      param_4 = 0xffffffff;
    }
    else {
      iVar2 = FUN_004c7d8c(*param_1,param_3,param_5,0);
      if (iVar2 == -1) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("CDC_Tx: Data: Write failed \n",1,0x1c,stderr);
        }
        param_4 = 0xffffffff;
      }
    }
  }
  else {
    if (DAT_00559cd0 == 3) {
      __ptr = FUN_004c98e8();
      if (__ptr == (undefined1 *)0x0) {
        if ((DAT_005562a6 & 1) != 0) {
          fwrite("remote_CDC_tx: Failed to get allocated buffer\n",1,0x2e,stderr);
        }
        return 0xffffffff;
      }
      if (param_4 < 0x3c1) {
        memcpy(__ptr + 6,&DAT_0055c114,0x24);
        if (param_3 != (void *)0x0) {
          memcpy(__ptr + 0x2a,param_3,param_5);
        }
        uVar3 = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
        free(__ptr);
        return uVar3;
      }
      memcpy(__ptr + 6,&DAT_0055c114,0x24);
      memcpy(__ptr + 0x2a,param_3,0x3c0);
      __ptr[4] = 0x55;
      __ptr[5] = 0;
      uVar3 = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
      if ((int)uVar3 < 0) {
        if ((DAT_005562a6 & 4) != 0) {
          fprintf(stdout,"Failed to Send the Frame %d\n",uVar3);
        }
        free(__ptr);
        return uVar3;
      }
      for (local_28 = 1; local_28 < param_4 / 0x3c0; local_28 = local_28 + 1) {
        __ptr[4] = 0x55;
        __ptr[5] = (char)local_28;
        memcpy(__ptr + 6,(void *)((int)param_3 + local_28 * 0x3c0),0x3c0);
        uVar3 = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
        if ((int)uVar3 < 0) {
          free(__ptr);
          return uVar3;
        }
        FUN_004c9348(100);
      }
      if ((param_4 / 0x3c0) * 0x3c0 != param_4) {
        __ptr[4] = 0x55;
        __ptr[5] = (char)local_28;
        memcpy(__ptr + 6,(void *)((int)param_3 + local_28 * 0x3c0),param_4 + local_28 * -0x3c0);
        uVar3 = FUN_004c6a04(param_1,"wifiaction",__ptr,0x416);
        if ((int)uVar3 < 0) {
          free(__ptr);
          return uVar3;
        }
      }
    }
    param_4 = 0;
  }
  return param_4;
}



undefined4 * FUN_004cb844(int *param_1)

{
  int iVar1;
  undefined4 *local_18;
  ssize_t local_10 [2];
  
  local_10[0] = 0;
  local_18 = &DAT_0055c114;
  memset(&DAT_0055c114,0,0x24);
  if (DAT_00559cd0 == 2) {
    local_10[0] = FUN_004c7f24(*param_1,&DAT_0055c114,0x24,0);
    if (local_10[0] == -1) {
      if ((DAT_005562a6 & 1) != 0) {
        fprintf(stderr,"remote_CDC_rx_hdr: numread:%d",-1);
      }
      local_18 = (undefined4 *)0x0;
    }
    else if (local_10[0] == 0) {
      if ((DAT_005562a6 & 4) != 0) {
        fwrite("\n remote_CDC_rx_hdr:No data to receive\n",1,0x27,stdout);
      }
      local_18 = (undefined4 *)0x0;
    }
  }
  else if ((DAT_00559cd0 == 4) || (DAT_00559cd0 == 1)) {
    iVar1 = FUN_004c8d6c(param_1,&DAT_0055c114,0x24,local_10);
    if (iVar1 < 0) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("remote_CDC_rx_hdr: Header Read failed \n",1,0x27,stderr);
      }
      local_18 = (undefined4 *)0x0;
    }
  }
  else if ((DAT_005562a6 & 1) != 0) {
    fwrite("\n Unknown Transport Type\n",1,0x19,stderr);
  }
  return local_18;
}



undefined4 FUN_004cba5c(int *param_1,int param_2,void *param_3)

{
  undefined4 uVar1;
  int iVar2;
  ssize_t sVar3;
  ssize_t local_c;
  
  local_c = 0;
  if (*(uint *)(param_2 + 4) < *(uint *)(param_2 + 0x10)) {
    if ((DAT_005562a6 & 1) != 0) {
      fprintf(stderr,"remote_CDC_rx: remote data len (%d) > msg len (%d)\n",*(int *)(param_2 + 0x10)
              ,*(int *)(param_2 + 4));
    }
    uVar1 = 0xffffffff;
  }
  else if (((DAT_00559cd0 == 4) || (DAT_00559cd0 == 1)) &&
          (iVar2 = FUN_004c8d6c(param_1,param_3,*(uint *)(param_2 + 0x10),&local_c), iVar2 < 0)) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("remote_CDC_rx_hdr: Data Receivefailed \n",1,0x27,stderr);
    }
    uVar1 = 0xffffffff;
  }
  else {
    if ((DAT_00559cd0 == 2) &&
       (sVar3 = FUN_004c7f24(*param_1,param_3,*(int *)(param_2 + 0x10),0), sVar3 == -1)) {
      if ((DAT_005562a6 & 1) != 0) {
        fwrite("remote_CDC_rx:Data Receive failed\n",1,0x22,stderr);
      }
      return 0xffffffff;
    }
    uVar1 = 1;
  }
  return uVar1;
}



undefined4 FUN_004cbc34(int param_1,sockaddr *param_2,socklen_t param_3)

{
  int iVar1;
  undefined4 uVar2;
  
  if ((DAT_005562a6 & 4) != 0) {
    fprintf(stdout,"sockconnet SockDes=%d\n",param_1);
  }
  iVar1 = FUN_004c79d8(param_1,param_2,param_3);
  if (iVar1 < 0) {
    if ((DAT_005562a6 & 1) != 0) {
      fwrite("\n rwl_socketconnect failed\n",1,0x1b,stderr);
    }
    uVar2 = 0xffffffff;
  }
  else {
    uVar2 = 1;
  }
  return uVar2;
}



void FUN_004cbd00(undefined4 *param_1)

{
  *param_1 = *param_1;
  param_1[1] = param_1[1];
  param_1[2] = param_1[2];
  param_1[3] = param_1[3];
  param_1[4] = param_1[4];
  return;
}



void FUN_004cbd80(undefined4 *param_1,undefined4 param_2,int param_3,undefined1 param_4)

{
  memset(param_1,0,0xa0);
  *param_1 = param_2;
  if (param_3 == 0) {
    param_1[1] = PTR_DAT_00556dc0;
  }
  else {
    param_1[1] = param_3;
  }
  *(undefined1 *)(param_1 + 2) = param_4;
  return;
}



int FUN_004cbe18(undefined4 *param_1,int *param_2)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  ulong uVar4;
  int *local_res4;
  size_t local_20;
  char *local_1c;
  char *local_18;
  int local_14;
  char *local_c;
  
  local_c = (char *)0x0;
  local_14 = 0;
  param_1[3] = 0;
  *(undefined1 *)(param_1 + 4) = 0;
  memset((void *)((int)param_1 + 0x13),0,0x80);
  *(undefined1 *)((int)param_1 + 0x12) = 0;
  param_1[0x25] = 0;
  *(undefined1 *)((int)param_1 + 0x11) = 0;
  local_18 = (char *)0x0;
  if (*param_2 == 0) {
    local_14 = -1;
    goto LAB_004cc294;
  }
  local_1c = (char *)*param_2;
  local_res4 = param_2 + 1;
  param_1[3] = param_1[3] + 1;
  if ((*(char *)((int)param_1 + 9) == '\0') && (iVar1 = strcmp(local_1c,"--"), iVar1 == 0)) {
    *(undefined1 *)((int)param_1 + 9) = 1;
    if (*local_res4 == 0) {
      local_14 = -1;
      goto LAB_004cc294;
    }
    local_1c = (char *)*local_res4;
    local_res4 = param_2 + 2;
    param_1[3] = param_1[3] + 1;
  }
  if (*(char *)((int)param_1 + 9) == '\0') {
    iVar1 = strncmp(local_1c,"--",2);
    if (iVar1 == 0) {
      pcVar2 = strchr(local_1c,0x3d);
      if ((pcVar2 == (char *)0x0) && (*(char *)(param_1 + 2) == '\0')) {
        fprintf(stderr,"%s: missing \" = \" in long param \"%s\"\n",(char *)*param_1,local_1c);
        local_14 = 1;
        goto LAB_004cc294;
      }
      if (pcVar2 == (char *)0x0) {
        local_20 = strlen(local_1c);
        local_20 = local_20 - 2;
      }
      else {
        local_20 = (int)pcVar2 - (int)(local_1c + 2);
      }
      if (0x3f < (int)local_20) {
        local_20 = 0x3f;
      }
      memcpy((void *)((int)param_1 + 0x13),local_1c + 2,local_20);
      if ((pcVar2 != (char *)0x0) && (local_18 = pcVar2 + 1, *local_18 == '\0')) {
        fprintf(stderr,"%s: missing value after \" = \" in long param \"%s\"\n",(char *)*param_1,
                local_1c);
        local_14 = 1;
        goto LAB_004cc294;
      }
    }
    else if (*local_1c == '-') {
      *(char *)((int)param_1 + 0x12) = local_1c[1];
      sVar3 = strlen(local_1c);
      if (2 < sVar3) {
        fprintf(stderr,"%s: only single char options, error on param \"%s\"\n",(char *)*param_1,
                local_1c);
        local_14 = 1;
        goto LAB_004cc294;
      }
      pcVar2 = strchr((char *)param_1[1],(int)*(char *)((int)param_1 + 0x12));
      if (pcVar2 == (char *)0x0) {
        if (*local_res4 == 0) {
          fprintf(stderr,"%s: missing value parameter after \"%s\"\n",(char *)*param_1,local_1c);
          local_14 = 1;
          goto LAB_004cc294;
        }
        local_18 = (char *)*local_res4;
        param_1[3] = param_1[3] + 1;
      }
      else {
        local_18 = (char *)0x0;
      }
    }
    else {
      *(undefined1 *)(param_1 + 4) = 1;
      local_18 = local_1c;
    }
  }
  else {
    *(undefined1 *)(param_1 + 4) = 1;
    local_18 = local_1c;
  }
  if (local_18 != (char *)0x0) {
    uVar4 = strtoul(local_18,&local_c,0);
    param_1[0x26] = uVar4;
    param_1[0x27] = param_1[0x26];
    *(bool *)((int)param_1 + 0x11) = *local_c == '\0';
  }
  param_1[0x25] = local_18;
LAB_004cc294:
  if (local_14 == 1) {
    *(undefined1 *)((int)param_1 + 0x12) = 0x3f;
  }
  return local_14;
}



undefined2 * FUN_004cc2d0(undefined2 *param_1,undefined2 *param_2,char param_3)

{
  int local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_1c = 0;
  local_18 = 0;
  local_14 = 0;
  local_10 = 0;
  param_2[1] = 0;
  for (local_20 = 0; local_20 < (int)(uint)(ushort)param_1[1]; local_20 = local_20 + 1) {
    if (*(int *)(param_1 + local_20 * 10 + 2) != 0) {
      local_1c = local_1c + *(int *)(param_1 + local_20 * 10 + 2);
      local_18 = local_18 + *(int *)(param_1 + local_20 * 10 + 4);
      local_14 = local_14 + *(int *)(param_1 + local_20 * 10 + 6);
      local_10 = local_10 + *(int *)(param_1 + local_20 * 10 + 8);
      param_2[1] = param_2[1] + 1;
    }
  }
  *param_2 = *param_1;
  if ((param_2[1] != 0) && (local_1c != 0)) {
    if (param_3 == '\0') {
      if ((ushort)param_2[1] == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 2) = local_1c / (ushort)param_2[1];
      if ((ushort)param_2[1] == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 4) = local_18 / (ushort)param_2[1];
      if ((ushort)param_2[1] == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 6) = local_14 / (ushort)param_2[1];
      if ((ushort)param_2[1] == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 8) = local_10 / (ushort)param_2[1];
    }
    else {
      if ((ushort)param_2[1] == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 2) = local_1c / (ushort)param_2[1];
      if (local_1c == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 4) = (local_18 * 100) / local_1c;
      if (local_1c == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 6) = (local_14 * 100) / local_1c;
      if (local_1c == 0) {
        trap(7);
      }
      *(uint *)(param_2 + 8) = (local_10 * 100) / local_1c;
    }
  }
  return param_2;
}



void FUN_004cc5e8(int param_1,int param_2,int *param_3,int *param_4)

{
  int iVar1;
  undefined4 local_10;
  
  *param_3 = 0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    iVar1 = local_10;
    if (local_10 < 0) {
      iVar1 = local_10 + 7;
    }
    if (((int)(uint)*(byte *)(param_1 + (iVar1 >> 3)) >> (local_10 % 8 & 0x1fU) & 1U) != 0) {
      *param_3 = *param_3 + 1;
      *param_4 = local_10;
    }
  }
  return;
}



char FUN_004cc6b8(ushort param_1)

{
  undefined1 local_10;
  
  local_10 = (char)param_1;
  if ((param_1 & 0x3800) != 0x1000) {
    if ((param_1 & 0x3800) == 0x1800) {
      local_10 = local_10 + -4;
    }
    else {
      local_10 = local_10 + -8;
    }
    local_10 = ((byte)(param_1 >> 8) & 7) * '\x04' + local_10 + '\x02';
  }
  return local_10;
}



undefined4 FUN_004cc774(int param_1,int param_2,uint param_3,undefined2 *param_4)

{
  ushort uVar1;
  char cVar2;
  undefined4 uVar3;
  undefined3 extraout_var;
  int iVar5;
  int local_28;
  uint local_24;
  byte abStack_18 [8];
  int local_10;
  int local_c;
  int iVar4;
  
  local_24 = 0x40000000;
  for (local_10 = 0; local_10 < 5; local_10 = local_10 + 1) {
    abStack_18[local_10] = 0;
  }
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    if (**(short **)(param_1 + local_10 * 4) != 0) {
      iVar4 = local_10;
      if (local_10 < 0) {
        iVar4 = local_10 + 7;
      }
      abStack_18[iVar4 >> 3] = abStack_18[iVar4 >> 3] | (byte)(1 << (local_10 % 8 & 0x1fU));
    }
  }
  FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
  if (local_c == 0) {
    uVar3 = 5;
  }
  else {
    if ((param_3 & 1) != 0) {
      for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
        if ((**(ushort **)(param_1 + local_10 * 4) & 0xc000) != 0) {
          iVar4 = local_10;
          if (local_10 < 0) {
            iVar4 = local_10 + 7;
          }
          abStack_18[iVar4 >> 3] = abStack_18[iVar4 >> 3] & ~(byte)(1 << (local_10 % 8 & 0x1fU));
        }
      }
    }
    FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
    if (local_c == 0) {
      uVar3 = 1;
    }
    else {
      if ((param_3 & 2) != 0) {
        for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
          if ((**(ushort **)(param_1 + local_10 * 4) & 0xc000) != 0xc000) {
            iVar4 = local_10;
            if (local_10 < 0) {
              iVar4 = local_10 + 7;
            }
            abStack_18[iVar4 >> 3] = abStack_18[iVar4 >> 3] & ~(byte)(1 << (local_10 % 8 & 0x1fU));
          }
        }
      }
      FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
      if (local_c == 0) {
        uVar3 = 1;
      }
      else {
        if ((param_3 & 4) == 0) {
          for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
            if (*(uint *)(*(int *)(param_1 + local_10 * 4) + 4) < 0xe) {
              iVar4 = local_10;
              if (local_10 < 0) {
                iVar4 = local_10 + 7;
              }
              abStack_18[iVar4 >> 3] = abStack_18[iVar4 >> 3] & ~(byte)(1 << (local_10 % 8 & 0x1fU))
              ;
            }
          }
        }
        FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
        if (local_c == 0) {
          uVar3 = 2;
        }
        else {
          if ((param_3 & 0x10) != 0) {
            cVar2 = FUN_004cc6b8(**(ushort **)(param_1 + local_10 * 4));
            iVar4 = CONCAT31(extraout_var,cVar2);
            uVar1 = **(ushort **)(param_1 + local_10 * 4);
            for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
              if (((((uVar1 & 0xc000) == 0) && (iVar4 != 1)) && (iVar4 != 6)) && (iVar4 != 0xb)) {
                iVar5 = local_10;
                if (local_10 < 0) {
                  iVar5 = local_10 + 7;
                }
                abStack_18[iVar5 >> 3] =
                     abStack_18[iVar5 >> 3] & ~(byte)(1 << (local_10 % 8 & 0x1fU));
              }
            }
          }
          FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
          if (local_c == 0) {
            uVar3 = 3;
          }
          else {
            if ((param_3 & 0x20) == 0) {
              for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
                if (6 < *(uint *)(*(int *)(param_1 + local_10 * 4) + 0x10)) {
                  iVar4 = local_10;
                  if (local_10 < 0) {
                    iVar4 = local_10 + 7;
                  }
                  abStack_18[iVar4 >> 3] =
                       abStack_18[iVar4 >> 3] & ~(byte)(1 << (local_10 % 8 & 0x1fU));
                }
              }
              FUN_004cc5e8((int)abStack_18,param_2,&local_c,&local_10);
              if (local_c == 0) {
                return 4;
              }
            }
            local_28 = 0;
            for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
              iVar4 = local_10;
              if (local_10 < 0) {
                iVar4 = local_10 + 7;
              }
              if ((((int)(uint)abStack_18[iVar4 >> 3] >> (local_10 % 8 & 0x1fU) & 1U) != 0) &&
                 (*(uint *)(*(int *)(param_1 + local_10 * 4) + 0xc) < local_24)) {
                local_28 = local_10;
                local_24 = *(uint *)(*(int *)(param_1 + local_10 * 4) + 0xc);
              }
            }
            *param_4 = **(undefined2 **)(param_1 + local_28 * 4);
            uVar3 = 0;
          }
        }
      }
    }
  }
  return uVar3;
}



undefined * FUN_004ccf40(int param_1)

{
  return (&PTR_DAT_00556dd0)[param_1];
}



char * FUN_004ccf7c(uint param_1)

{
  int iVar1;
  char *pcVar2;
  
  iVar1 = FUN_004ccfec(param_1);
  if (iVar1 < 0) {
    pcVar2 = "NO_RATE";
  }
  else {
    pcVar2 = (&PTR_s_DSSS1_00556e7c)[iVar1];
  }
  return pcVar2;
}



undefined4 FUN_004ccfec(uint param_1)

{
  bool bVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  undefined4 local_28;
  undefined4 local_24;
  
  local_28 = 0xffffffff;
  local_24 = 0;
  if (param_1 == 0) {
    local_28 = 0xffffffff;
  }
  else {
    uVar3 = param_1 & 0x3000000;
    iVar4 = (int)(param_1 & 0x300) >> 8;
    bVar1 = (param_1 & 0x100000) != 0;
    bVar2 = (param_1 & 0x200000) == 0;
    if ((!bVar1) || (bVar2)) {
      if (bVar2) {
        if (bVar1) {
          local_24 = 1;
        }
      }
      else {
        local_24 = 2;
      }
      if (uVar3 == 0) {
        local_28 = FUN_004cd1ac(param_1 & 0xff,iVar4,local_24);
      }
      else if (uVar3 == 0x1000000) {
        local_28 = FUN_004cd51c(param_1 & 0xff,iVar4,local_24);
      }
      else if (uVar3 == 0x2000000) {
        local_28 = FUN_004cd724(param_1 & 0xf,(int)(param_1 & 0xf0) >> 4,iVar4,local_24);
      }
    }
    else {
      local_28 = 0xffffffff;
    }
  }
  return local_28;
}



undefined4 FUN_004cd1ac(int param_1,int param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  undefined4 local_10;
  
  local_10 = 0xffffffff;
  iVar1 = FUN_004cd294(param_1);
  if ((iVar1 == -1) || ((param_3 == 2 && (iVar1 < 4)))) {
    fprintf(stderr,"ERROR: Bad legacy rate spec: %d\n",param_1);
  }
  else {
    iVar2 = FUN_004cd37c(param_2,param_3);
    local_10 = *(undefined4 *)(&DAT_0055719c + (iVar1 * 5 + iVar2) * 4);
  }
  return local_10;
}



int FUN_004cd294(int param_1)

{
  int local_3c;
  int local_38 [13];
  
  local_38[0] = 2;
  local_38[1] = 4;
  local_38[2] = 0xb;
  local_38[3] = 0x16;
  local_38[4] = 0xc;
  local_38[5] = 0x12;
  local_38[6] = 0x18;
  local_38[7] = 0x24;
  local_38[8] = 0x30;
  local_38[9] = 0x48;
  local_38[10] = 0x60;
  local_38[0xb] = 0x6c;
  local_3c = 0;
  while( true ) {
    if (0xb < local_3c) {
      return -1;
    }
    if (local_38[local_3c] == param_1) break;
    local_3c = local_3c + 1;
  }
  return local_3c;
}



undefined4 FUN_004cd37c(int param_1,uint param_2)

{
  FILE *param0;
  char *pcVar1;
  undefined4 local_18;
  
  param0 = stderr;
  local_18 = 0;
  if (param_1 == 0) {
    local_18 = 0;
  }
  else if (param_1 == 1) {
    if (param_2 == 0) {
      local_18 = 1;
    }
    else if (param_2 == 2) {
      local_18 = 3;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad legacy tx_expansion spec: %d expansion mode %s\n",1,pcVar1);
    }
  }
  else if (param_1 == 2) {
    if (param_2 == 0) {
      local_18 = 2;
    }
    else if (param_2 == 2) {
      local_18 = 4;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad legacy tx_expansion spec: %d expansion mode %s\n",2,pcVar1);
    }
  }
  else {
    pcVar1 = FUN_004cdd88(param_2);
    fprintf(param0,"ERROR: Bad legacy tx_expansion spec: %d expansion mode %s\n",param_1,pcVar1);
  }
  return local_18;
}



undefined4 FUN_004cd51c(int param_1,int param_2,uint param_3)

{
  undefined4 local_18;
  int local_14;
  int local_10;
  
  local_18 = 0xffffffff;
  local_14 = 0xc;
  local_10 = 0;
  if (param_1 < 0x67) {
    if ((((param_1 == 0x57) || (param_1 == 0x58)) || (param_1 == 99)) ||
       (((param_1 == 100 || (param_1 == 0x65)) || (param_1 == 0x66)))) {
      switch(param_1) {
      case 0x57:
        local_10 = 1;
        local_14 = 10;
        break;
      case 0x58:
        local_10 = 1;
        local_14 = 0xb;
        break;
      case 99:
        local_10 = 2;
        local_14 = 10;
        break;
      case 100:
        local_10 = 2;
        local_14 = 0xb;
        break;
      case 0x65:
        local_10 = 3;
        local_14 = 10;
        break;
      case 0x66:
        local_10 = 3;
        local_14 = 0xb;
      }
    }
    else {
      local_14 = param_1 % 8;
      if (param_1 < 0) {
        param_1 = param_1 + 7;
      }
      local_10 = (param_1 >> 3) + 1;
    }
    local_18 = FUN_004cd724(local_14,local_10,param_2,param_3);
  }
  else {
    fprintf(stderr,"ERROR: Bad ht mcs spec: %d\n",param_1);
  }
  return local_18;
}



undefined4 FUN_004cd724(int param_1,int param_2,int param_3,uint param_4)

{
  int iVar1;
  int iVar2;
  undefined4 local_10;
  
  local_10 = 0xffffffff;
  iVar1 = FUN_004cd868(param_1);
  if (param_2 == 1) {
    iVar2 = FUN_004cd8e8(param_3,param_4);
    local_10 = *(undefined4 *)(&DAT_0055728c + (iVar1 * 7 + iVar2) * 4);
  }
  else if (param_2 == 2) {
    iVar2 = FUN_004cdb14(param_3,param_4);
    local_10 = *(undefined4 *)(&DAT_005573dc + (iVar1 * 4 + iVar2) * 4);
  }
  else if (param_2 == 3) {
    iVar2 = FUN_004cdc94(param_3,param_4);
    local_10 = *(undefined4 *)(&DAT_0055749c + (iVar1 * 2 + iVar2) * 4);
  }
  return local_10;
}



int FUN_004cd868(int param_1)

{
  int iVar1;
  int local_10;
  
  local_10 = 0;
  if ((param_1 < 0) || (iVar1 = param_1, 0xb < param_1)) {
    fprintf(stderr,"ERROR: Bad vht mcs spec: %d\n",param_1);
    iVar1 = local_10;
  }
  local_10 = iVar1;
  return local_10;
}



undefined4 FUN_004cd8e8(int param_1,uint param_2)

{
  FILE *param0;
  char *pcVar1;
  undefined4 local_18;
  
  param0 = stderr;
  local_18 = 0;
  if (param_1 == 0) {
    if (param_2 == 0) {
      local_18 = 0;
    }
    else if (param_2 == 1) {
      local_18 = 2;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss1 mode: %d, expansion mode %s\n",0,pcVar1);
    }
  }
  else if (param_1 == 1) {
    if (param_2 == 1) {
      local_18 = 4;
    }
    else if (param_2 == 0) {
      local_18 = 1;
    }
    else if (param_2 == 2) {
      local_18 = 5;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss1 mode: %d, expansion mode %s\n",1,pcVar1);
    }
  }
  else if (param_1 == 2) {
    if (param_2 == 0) {
      local_18 = 3;
    }
    else if (param_2 == 2) {
      local_18 = 6;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss1 mode: %d, expansion mode %s\n",2,pcVar1);
    }
  }
  else {
    pcVar1 = FUN_004cdd88(param_2);
    fprintf(param0,"ERROR: Bad vht ss1 mode: %d, expansion mode: %s\n",param_1,pcVar1);
  }
  return local_18;
}



undefined4 FUN_004cdb14(int param_1,uint param_2)

{
  FILE *param0;
  char *pcVar1;
  undefined4 local_18;
  
  param0 = stderr;
  local_18 = 0;
  if (param_1 == 0) {
    if (param_2 == 0) {
      local_18 = 0;
    }
    else if (param_2 == 2) {
      local_18 = 2;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss2 mode: %d, expansion mode %s\n",0,pcVar1);
    }
  }
  else if (param_1 == 1) {
    if (param_2 == 0) {
      local_18 = 1;
    }
    else if (param_2 == 2) {
      local_18 = 3;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss2 mode: %d, expansion mode %s\n",1,pcVar1);
    }
  }
  else {
    pcVar1 = FUN_004cdd88(param_2);
    fprintf(param0,"ERROR: Bad vht ss2 mode: %d expansion mode: %s\n",param_1,pcVar1);
  }
  return local_18;
}



undefined4 FUN_004cdc94(int param_1,uint param_2)

{
  FILE *param0;
  char *pcVar1;
  undefined4 local_18;
  
  param0 = stderr;
  local_18 = 0;
  if (param_1 == 0) {
    if (param_2 == 0) {
      local_18 = 0;
    }
    else if (param_2 == 2) {
      local_18 = 1;
    }
    else {
      pcVar1 = FUN_004cdd88(param_2);
      fprintf(param0,"ERROR: Bad vht ss3 mode: %d, expansion mode: %s\n",0,pcVar1);
    }
  }
  else {
    pcVar1 = FUN_004cdd88(param_2);
    fprintf(param0,"ERROR: Bad vht ss3 mode: %d, expansion: %s\n",param_1,pcVar1);
  }
  return local_18;
}



char * FUN_004cdd88(uint param_1)

{
  char *pcVar1;
  
  if (param_1 < 3) {
    pcVar1 = (&PTR_DAT_005574fc)[param_1];
  }
  else {
    pcVar1 = "Unknown expansion mode";
  }
  return pcVar1;
}



undefined4 FUN_004cddf0(void)

{
  return 7;
}



short FUN_004cde30(byte param_1)

{
  short sVar1;
  byte bVar2;
  undefined2 local_10;
  
  local_10 = 0x16;
  bVar2 = param_1 & 3;
  if (1 < bVar2) {
    local_10 = 0x40;
  }
  if (2 < bVar2) {
    local_10 = local_10 + 0x34;
  }
  sVar1 = local_10;
  if (((param_1 & 4) != 0) && (sVar1 = local_10 + 0x1c, 2 < bVar2)) {
    sVar1 = local_10 + 0x42;
  }
  local_10 = sVar1;
  return local_10;
}



undefined4 FUN_004cdefc(undefined4 param_1)

{
  undefined4 uVar1;
  
  switch(param_1) {
  case 0:
    uVar1 = 1;
    break;
  case 1:
    uVar1 = 2;
    break;
  case 2:
    uVar1 = 3;
    break;
  default:
    uVar1 = 0;
    break;
  case 6:
    uVar1 = 4;
    break;
  case 0xb:
    uVar1 = 5;
  }
  return uVar1;
}



int FUN_004cdf90(byte param_1,undefined4 param_2)

{
  short sVar1;
  undefined2 extraout_var;
  int iVar2;
  
  sVar1 = FUN_004cde30(param_1);
  iVar2 = FUN_004cdefc(param_2);
  return CONCAT22(extraout_var,sVar1) * iVar2;
}



int FUN_004cdfe8(void *param_1,int *param_2,uint param_3)

{
  int iVar1;
  uint uVar2;
  undefined4 local_18;
  
  uVar2 = param_3 & 3;
  memcpy((void *)*param_2,param_1,0x16);
  *param_2 = *param_2 + 0x16;
  local_18 = 0x16;
  if (1 < uVar2) {
    memcpy((void *)*param_2,(void *)((int)param_1 + 0x16),0x2a);
    *param_2 = *param_2 + 0x2a;
    local_18 = 0x40;
  }
  if (2 < uVar2) {
    memcpy((void *)*param_2,(void *)((int)param_1 + 0x40),0x34);
    *param_2 = *param_2 + 0x34;
    local_18 = local_18 + 0x34;
  }
  iVar1 = local_18;
  if ((param_3 & 4) != 0) {
    memcpy((void *)*param_2,(void *)((int)param_1 + 0x74),0x1c);
    *param_2 = *param_2 + 0x1c;
    iVar1 = local_18 + 0x1c;
    if (2 < uVar2) {
      memcpy((void *)*param_2,(void *)((int)param_1 + 0x90),0x26);
      *param_2 = *param_2 + 0x26;
      iVar1 = local_18 + 0x42;
    }
  }
  local_18 = iVar1;
  return local_18;
}



int FUN_004ce1d8(undefined4 *param_1,undefined1 *param_2,uint param_3)

{
  short sVar1;
  short sVar2;
  byte extraout_var;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined1 *local_res4;
  uint local_res8;
  uint local_28;
  undefined4 *local_24;
  int local_20;
  
  local_20 = 10;
  *param_2 = 2;
  param_2[1] = (char)*param_1;
  local_res4 = param_2;
  local_res8 = param_3;
  iVar3 = FUN_004cddf0();
  uVar4 = FUN_004cddf0();
  uVar5 = FUN_004cddf0();
  uVar6 = FUN_004cddf0();
  *(uint *)(param_2 + 4) =
       iVar3 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar6 >> 0x18;
  sVar1 = FUN_004cde30((byte)local_res8);
  sVar2 = FUN_004cde30((byte)local_res8);
  param_2[2] = (char)((ushort)sVar2 >> 8);
  param_2[3] = (byte)sVar1 | extraout_var;
  param_2[8] = 0;
  param_2[9] = 0x34;
  local_res4 = local_res4 + 10;
  uVar4 = FUN_004cdefc((uint)(byte)param_2[1]);
  local_24 = param_1 + 1;
  for (local_28 = 0; local_28 < uVar4; local_28 = local_28 + 1) {
    iVar3 = FUN_004cdfe8(local_24,(int *)&local_res4,local_res8);
    local_20 = local_20 + iVar3;
    local_24 = (undefined4 *)((int)local_24 + 0xb6);
  }
  return local_20;
}



void FUN_004ce3c0(void *param_1,int *param_2,uint param_3,ushort param_4)

{
  ushort uVar1;
  uint uVar2;
  undefined2 local_20;
  
  uVar2 = param_3 & 3;
  local_20 = 0x16;
  memcpy(param_1,(void *)*param_2,0x16);
  *param_2 = *param_2 + 0x16;
  if (1 < uVar2) {
    memcpy((void *)((int)param_1 + 0x16),(void *)*param_2,0x2a);
    *param_2 = *param_2 + 0x2a;
    local_20 = 0x40;
  }
  if (2 < uVar2) {
    memcpy((void *)((int)param_1 + 0x40),(void *)*param_2,0x34);
    *param_2 = *param_2 + 0x34;
    local_20 = local_20 + 0x34;
  }
  uVar1 = local_20;
  if ((param_3 & 4) != 0) {
    memcpy((void *)((int)param_1 + 0x74),(void *)*param_2,0x1c);
    *param_2 = *param_2 + 0x1c;
    uVar1 = local_20 + 0x1c;
    if (2 < uVar2) {
      memcpy((void *)((int)param_1 + 0x90),(void *)*param_2,0x26);
      *param_2 = *param_2 + 0x26;
      uVar1 = local_20 + 0x42;
    }
  }
  local_20 = uVar1;
  if (local_20 < param_4) {
    *param_2 = *param_2 + ((uint)param_4 - (uint)local_20);
  }
  return;
}



void FUN_004ce5e8(undefined4 *param_1,int param_2,uint param_3,undefined4 param_4,ushort param_5)

{
  uint uVar1;
  int local_res4;
  uint local_res8;
  undefined4 local_resc;
  uint local_20;
  undefined4 *local_1c;
  
  *param_1 = param_4;
  local_res4 = param_2;
  local_res8 = param_3;
  local_resc = param_4;
  uVar1 = FUN_004cdefc(param_4);
  local_1c = param_1 + 1;
  for (local_20 = 0; local_20 < uVar1; local_20 = local_20 + 1) {
    FUN_004ce3c0(local_1c,&local_res4,local_res8,param_5);
    local_1c = (undefined4 *)((int)local_1c + 0xb6);
  }
  return;
}



int FUN_004ce6bc(int param_1,int param_2)

{
  undefined4 local_10;
  
  local_10 = 0;
  if (param_2 == 0) {
    local_10 = param_1 + 4;
  }
  return local_10;
}



int FUN_004ce704(int param_1,int param_2)

{
  undefined4 local_10;
  
  local_10 = 0;
  if (param_2 == 1) {
    local_10 = param_1 + 4;
  }
  else if ((param_2 == 0) || (param_2 == 3)) {
    local_10 = param_1 + 0xba;
  }
  return local_10;
}



int FUN_004ce790(int param_1,uint param_2)

{
  undefined4 local_10;
  
  local_10 = 0;
  if (param_2 < 6) {
    if (0x44000000 << (param_2 & 0x1f) < 0) {
      local_10 = param_1 + 0x170;
    }
    else if (-0x68000000 << (param_2 & 0x1f) < 0) {
      local_10 = param_1 + 0xba;
    }
    else if (0x20000000 << (param_2 & 0x1f) < 0) {
      local_10 = param_1 + 4;
    }
  }
  return local_10;
}



int FUN_004ce84c(int param_1,undefined4 param_2)

{
  int local_10;
  
  local_10 = 0;
  switch(param_2) {
  case 0:
  case 3:
  case 4:
  case 7:
    local_10 = param_1 + 0xba;
    break;
  case 1:
  case 5:
  case 8:
    local_10 = param_1 + 0x170;
    break;
  case 2:
  case 9:
    local_10 = param_1 + 0x226;
    break;
  case 6:
    local_10 = param_1 + 4;
  }
  return local_10;
}



int FUN_004ce900(int param_1,undefined4 param_2)

{
  int local_10;
  
  local_10 = 0;
  switch(param_2) {
  case 0:
  case 3:
  case 4:
  case 0xd:
    local_10 = param_1 + 0x226;
    break;
  case 1:
  case 5:
  case 0xe:
    local_10 = param_1 + 0x2dc;
    break;
  case 2:
  case 0xf:
    local_10 = param_1 + 0x170;
    break;
  case 0xb:
    local_10 = param_1 + 4;
    break;
  case 0xc:
    local_10 = param_1 + 0xba;
  }
  return local_10;
}



undefined4 FUN_004ce9c8(int *param_1,undefined4 param_2)

{
  undefined4 uVar1;
  uint local_10;
  
  if (param_1 != (int *)0x0) {
    for (local_10 = 0; local_10 < 5; local_10 = local_10 + 1) {
      if (*(int *)(&DAT_00532f08 + local_10 * 8) == *param_1) {
        uVar1 = (*(code *)(&PTR_FUN_00532f0c)[local_10 * 2])(param_1,param_2);
        return uVar1;
      }
    }
  }
  return 0;
}



int FUN_004ceaa4(int param_1,int param_2)

{
  int iVar1;
  int local_10;
  
  local_10 = 0;
  if (param_2 == 2) {
    iVar1 = param_1 + 0x16;
  }
  else if (param_2 == 3) {
    iVar1 = param_1 + 0x40;
  }
  else {
    iVar1 = param_1;
    if (param_2 != 1) {
      iVar1 = local_10;
    }
  }
  local_10 = iVar1;
  return local_10;
}



int FUN_004ceb40(int param_1,int param_2,int param_3)

{
  undefined4 local_10;
  
  local_10 = 0;
  if (param_3 == 2) {
    if (param_2 == 3) {
      local_10 = param_1 + 0x74;
    }
    else {
      local_10 = param_1 + 0x1a;
    }
  }
  else if (param_3 == 3) {
    if (param_2 == 3) {
      local_10 = param_1 + 0x90;
    }
    else {
      local_10 = param_1 + 0x44;
    }
  }
  else if (param_3 == 1) {
    local_10 = param_1 + 4;
  }
  return local_10;
}



int FUN_004cec2c(int param_1,int param_2,int param_3,uint param_4)

{
  int local_10;
  
  local_10 = 0;
  if (param_2 == 2) {
    if (((1 < param_4) && (param_4 < 4)) &&
       (*(int *)(&DAT_00532fb0 + ((param_4 - 2) * 4 + param_3) * 4) != -1)) {
      local_10 = param_1 + *(int *)(&DAT_00532fb0 + ((param_4 - 2) * 4 + param_3) * 4);
    }
  }
  else if (param_2 == 3) {
    if ((param_4 == 3) && (*(int *)(&DAT_00532fe0 + param_3 * 4) != -1)) {
      local_10 = param_1 + *(int *)(&DAT_00532fe0 + param_3 * 4);
    }
  }
  else if (((param_2 == 1) && (param_4 < 4)) &&
          (*(int *)(&DAT_00532f60 + ((param_4 - 1) * 4 + param_3) * 4) != -1)) {
    local_10 = param_1 + *(int *)(&DAT_00532f60 + ((param_4 - 1) * 4 + param_3) * 4);
  }
  return local_10;
}



undefined4 FUN_004cedec(int param_1)

{
  undefined4 local_10;
  
  if (param_1 == 1) {
    local_10 = 0x16c;
  }
  else if (param_1 == 0) {
    local_10 = 0xb6;
  }
  else if (param_1 == 2) {
    local_10 = 0x222;
  }
  else if (param_1 == 0xb) {
    local_10 = 0x38e;
  }
  else {
    local_10 = 0;
  }
  return local_10;
}



void FUN_004cee98(int *param_1,int param_2)

{
  size_t __n;
  
  __n = FUN_004cef68(param_2);
  memset(param_1,-0x80,__n);
  *param_1 = param_2;
  return;
}



void FUN_004ceef8(int *param_1)

{
  size_t __n;
  
  __n = FUN_004cedec(*param_1);
  memset(param_1 + 1,-0x80,__n);
  return;
}



int FUN_004cef68(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_004cedec(param_1);
  return iVar1 + 4;
}



int FUN_004cefa4(int *param_1)

{
  int iVar1;
  
  iVar1 = FUN_004cedec(*param_1);
  return iVar1 + 10;
}



int FUN_004ceff4(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_004cedec(param_1);
  return iVar1 + 10;
}



int * FUN_004cf030(undefined4 param_1,int param_2)

{
  size_t __size;
  int *piVar1;
  
  __size = FUN_004cef68(param_2);
  piVar1 = (int *)malloc(__size);
  if (piVar1 != (int *)0x0) {
    FUN_004cee98(piVar1,param_2);
  }
  return piVar1;
}



undefined4 FUN_004cf09c(undefined4 *param_1,int param_2,uint param_3)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  if ((param_1 == (undefined4 *)0x0) || (uVar1 = FUN_004ceff4(param_2), param_3 < uVar1)) {
    uVar2 = 0xfffffffe;
  }
  else {
    *param_1 = 0xffc0efbe;
    iVar3 = FUN_004cddf0();
    uVar1 = FUN_004cddf0();
    uVar4 = FUN_004cddf0();
    uVar5 = FUN_004cddf0();
    param_1[1] = iVar3 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 | uVar5 >> 0x18;
    memset(param_1 + 2,0x80,param_3 - 8);
    uVar2 = 0;
  }
  return uVar2;
}



void FUN_004cf1ac(undefined4 *param_1,int *param_2,uint param_3)

{
  FUN_004cf09c(param_1,*param_2,param_3);
  return;
}



void FUN_004cf208(undefined4 param_1,void *param_2)

{
  free(param_2);
  return;
}



undefined4 FUN_004cf244(undefined4 *param_1)

{
  return *param_1;
}



undefined4 FUN_004cf27c(void)

{
  return 0xb;
}



int FUN_004cf2a0(int *param_1,undefined4 param_2,int param_3,void *param_4)

{
  int iVar1;
  void *__src;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __src = (void *)FUN_004ceaa4(iVar1,param_3);
    if (__src != (void *)0x0) {
      memcpy(param_4,__src,4);
      local_18 = 4;
    }
  }
  if (local_18 == 0) {
    memset(param_4,-0x80,4);
  }
  return local_18;
}



int FUN_004cf364(int *param_1,undefined4 param_2,int param_3,int param_4,void *param_5)

{
  int iVar1;
  void *__src;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __src = (void *)FUN_004ceb40(iVar1,param_3,param_4);
    if (__src != (void *)0x0) {
      memcpy(param_5,__src,8);
      local_18 = 8;
    }
  }
  if (local_18 == 0) {
    memset(param_5,-0x80,8);
  }
  return local_18;
}



int FUN_004cf42c(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,void *param_6)

{
  int iVar1;
  void *__src;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __src = (void *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (__src != (void *)0x0) {
      memcpy(param_6,__src,8);
      local_18 = 8;
    }
  }
  if (local_18 == 0) {
    memset(param_6,-0x80,8);
  }
  return local_18;
}



int FUN_004cf4f8(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,void *param_6)

{
  int iVar1;
  void *__src;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __src = (void *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (__src != (void *)0x0) {
      memcpy(param_6,__src,10);
      local_18 = 10;
    }
  }
  if (local_18 == 0) {
    memset(param_6,-0x80,10);
  }
  return local_18;
}



undefined4
FUN_004cf5c4(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,char *param_6)

{
  char cVar1;
  int iVar2;
  undefined4 local_18;
  undefined4 local_14;
  
  local_18 = 0xffffffff;
  *param_6 = '\x7f';
  iVar2 = FUN_004ce9c8(param_1,param_2);
  if (iVar2 != 0) {
    iVar2 = FUN_004cec2c(iVar2,param_3,param_4,param_5);
    if (iVar2 != 0) {
      for (local_14 = 0; local_14 < 10; local_14 = local_14 + 1) {
        if (*(char *)(iVar2 + local_14) != -0x80) {
          cVar1 = *(char *)(iVar2 + local_14);
          if (*param_6 < *(char *)(iVar2 + local_14)) {
            cVar1 = *param_6;
          }
          *param_6 = cVar1;
        }
      }
      local_18 = 0;
    }
  }
  return local_18;
}



undefined4 FUN_004cf6e4(int *param_1,undefined4 param_2,int param_3,void *param_4)

{
  int iVar1;
  void *__dest;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __dest = (void *)FUN_004ceaa4(iVar1,param_3);
    if (__dest != (void *)0x0) {
      memcpy(__dest,param_4,4);
      local_18 = 4;
    }
  }
  return local_18;
}



undefined4 FUN_004cf784(int *param_1,undefined4 param_2,int param_3,int param_4,void *param_5)

{
  int iVar1;
  void *__dest;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __dest = (void *)FUN_004ceb40(iVar1,param_3,param_4);
    if (__dest != (void *)0x0) {
      memcpy(__dest,param_5,8);
      local_18 = 8;
    }
  }
  return local_18;
}



undefined4
FUN_004cf828(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,void *param_6)

{
  int iVar1;
  void *__dest;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __dest = (void *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (__dest != (void *)0x0) {
      memcpy(__dest,param_6,8);
      local_18 = 8;
    }
  }
  return local_18;
}



undefined4
FUN_004cf8d0(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,void *param_6)

{
  int iVar1;
  void *__dest;
  undefined4 local_18;
  
  local_18 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    __dest = (void *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (__dest != (void *)0x0) {
      memcpy(__dest,param_6,10);
      local_18 = 10;
    }
  }
  return local_18;
}



undefined4 FUN_004cf978(int *param_1,undefined4 param_2,int param_3,undefined1 param_4)

{
  int iVar1;
  undefined1 *local_18;
  undefined4 local_14;
  int local_10;
  
  local_14 = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    local_18 = (undefined1 *)FUN_004ceaa4(iVar1,param_3);
    if (local_18 != (undefined1 *)0x0) {
      local_14 = 4;
      for (local_10 = 0; local_10 < 4; local_10 = local_10 + 1) {
        *local_18 = param_4;
        local_18 = local_18 + 1;
      }
    }
  }
  return local_14;
}



undefined4 FUN_004cfa48(int *param_1,undefined4 param_2,int param_3,int param_4,undefined1 param_5)

{
  int iVar1;
  undefined1 *local_20;
  undefined4 local_1c;
  int local_18;
  
  local_1c = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    local_20 = (undefined1 *)FUN_004ceb40(iVar1,param_3,param_4);
    if (local_20 != (undefined1 *)0x0) {
      local_1c = 8;
      for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {
        *local_20 = param_5;
        local_20 = local_20 + 1;
      }
    }
  }
  return local_1c;
}



undefined4
FUN_004cfb20(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,undefined1 param_6
            )

{
  int iVar1;
  undefined1 *local_20;
  undefined4 local_1c;
  int local_18;
  
  local_1c = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    local_20 = (undefined1 *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (local_20 != (undefined1 *)0x0) {
      local_1c = 8;
      for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {
        *local_20 = param_6;
        local_20 = local_20 + 1;
      }
    }
  }
  return local_1c;
}



undefined4
FUN_004cfbfc(int *param_1,undefined4 param_2,int param_3,int param_4,uint param_5,undefined1 param_6
            )

{
  int iVar1;
  undefined1 *local_20;
  undefined4 local_1c;
  int local_18;
  
  local_1c = 0;
  iVar1 = FUN_004ce9c8(param_1,param_2);
  if (iVar1 != 0) {
    local_20 = (undefined1 *)FUN_004cec2c(iVar1,param_3,param_4,param_5);
    if (local_20 != (undefined1 *)0x0) {
      local_1c = 10;
      for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
        *local_20 = param_6;
        local_20 = local_20 + 1;
      }
    }
  }
  return local_1c;
}



uint FUN_004cfcd8(int *param_1,char param_2)

{
  char cVar1;
  uint uVar2;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar2 = FUN_004cedec(*param_1), local_10 < uVar2; local_10 = local_10 + 1) {
    cVar1 = (char)*local_c;
    if (param_2 < (char)*local_c) {
      cVar1 = param_2;
    }
    *(char *)local_c = cVar1;
    local_c = (int *)((int)local_c + 1);
  }
  return local_10;
}



void FUN_004cfda4(int param_1,char param_2,uint param_3)

{
  uint local_10;
  
  for (local_10 = 0; (local_10 < param_3 && (local_10 < 8)); local_10 = local_10 + 1) {
    if (*(char *)(param_1 + local_10) < param_2) {
      for (local_10 = 0; local_10 < param_3; local_10 = local_10 + 1) {
        *(undefined1 *)(param_1 + local_10) = 0x80;
      }
      return;
    }
  }
  for (; local_10 < param_3; local_10 = local_10 + 1) {
    if (*(char *)(param_1 + local_10) < param_2) {
      *(undefined1 *)(param_1 + local_10) = 0x80;
    }
  }
  return;
}



undefined4 FUN_004cfed4(int *param_1,char param_2)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined4 local_18;
  undefined4 local_14;
  
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    iVar1 = FUN_004ce9c8(param_1,local_18);
    if (iVar1 != 0) {
      iVar2 = FUN_004ceaa4(iVar1,1);
      FUN_004cfda4(iVar2,param_2,4);
      iVar2 = FUN_004ceb40(iVar1,0,1);
      FUN_004cfda4(iVar2,param_2,8);
      iVar2 = FUN_004cec2c(iVar1,1,0,1);
      FUN_004cfda4(iVar2,param_2,10);
      iVar2 = FUN_004ceaa4(iVar1,2);
      FUN_004cfda4(iVar2,param_2,4);
      iVar2 = FUN_004ceb40(iVar1,2,2);
      FUN_004cfda4(iVar2,param_2,8);
      uVar3 = FUN_004cec2c(iVar1,1,2,2);
      for (local_14 = uVar3; local_14 < uVar3 + 0x1e; local_14 = local_14 + 10) {
        FUN_004cfda4(local_14,param_2,10);
      }
      iVar2 = FUN_004ceb40(iVar1,3,2);
      FUN_004cfda4(iVar2,param_2,8);
      uVar3 = FUN_004cec2c(iVar1,1,3,2);
      for (local_14 = uVar3; local_14 < uVar3 + 0x14; local_14 = local_14 + 10) {
        FUN_004cfda4(local_14,param_2,10);
      }
      iVar2 = FUN_004ceaa4(iVar1,3);
      FUN_004cfda4(iVar2,param_2,4);
      iVar2 = FUN_004ceb40(iVar1,2,3);
      FUN_004cfda4(iVar2,param_2,8);
      uVar3 = FUN_004cec2c(iVar1,1,2,3);
      for (local_14 = uVar3; local_14 < uVar3 + 0x28; local_14 = local_14 + 10) {
        FUN_004cfda4(local_14,param_2,10);
      }
      iVar2 = FUN_004ceb40(iVar1,3,3);
      FUN_004cfda4(iVar2,param_2,8);
      uVar3 = FUN_004cec2c(iVar1,1,3,3);
      for (local_14 = uVar3; local_14 < uVar3 + 0x1e; local_14 = local_14 + 10) {
        FUN_004cfda4(local_14,param_2,10);
      }
    }
  }
  return 0;
}



void FUN_004d029c(int param_1,uint param_2)

{
  undefined4 local_10;
  
  for (local_10 = 8; local_10 < param_2; local_10 = local_10 + 1) {
    *(undefined1 *)(param_1 + local_10) = 0x80;
  }
  return;
}



undefined4 FUN_004d0308(int *param_1)

{
  int iVar1;
  uint uVar2;
  undefined4 local_18;
  undefined4 local_14;
  
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    iVar1 = FUN_004ce9c8(param_1,local_18);
    if (iVar1 != 0) {
      uVar2 = FUN_004cec2c(iVar1,1,2,2);
      for (local_14 = uVar2; local_14 < uVar2 + 0x1e; local_14 = local_14 + 10) {
        FUN_004d029c(local_14,10);
      }
      uVar2 = FUN_004cec2c(iVar1,1,3,2);
      for (local_14 = uVar2; local_14 < uVar2 + 0x14; local_14 = local_14 + 10) {
        FUN_004d029c(local_14,10);
      }
      uVar2 = FUN_004cec2c(iVar1,1,2,3);
      for (local_14 = uVar2; local_14 < uVar2 + 0x28; local_14 = local_14 + 10) {
        FUN_004d029c(local_14,10);
      }
      uVar2 = FUN_004cec2c(iVar1,1,3,3);
      for (local_14 = uVar2; local_14 < uVar2 + 0x1e; local_14 = local_14 + 10) {
        FUN_004d029c(local_14,10);
      }
    }
  }
  return 0;
}



undefined4 FUN_004d0500(int param_1,char param_2)

{
  char cVar1;
  char cVar2;
  char cVar3;
  undefined4 local_18;
  
  cVar1 = param_2 + -0xc;
  cVar2 = param_2 + -0x13;
  for (local_18 = 0; local_18 < 0x16; local_18 = local_18 + 1) {
    cVar3 = *(char *)(param_1 + local_18);
    if (param_2 < *(char *)(param_1 + local_18)) {
      cVar3 = param_2;
    }
    *(char *)(param_1 + local_18) = cVar3;
  }
  for (local_18 = 0x16; local_18 < 0x40; local_18 = local_18 + 1) {
    cVar3 = *(char *)(param_1 + local_18);
    if (cVar1 < *(char *)(param_1 + local_18)) {
      cVar3 = cVar1;
    }
    *(char *)(param_1 + local_18) = cVar3;
  }
  for (local_18 = 0x40; local_18 < 0x74; local_18 = local_18 + 1) {
    cVar3 = *(char *)(param_1 + local_18);
    if (cVar2 < *(char *)(param_1 + local_18)) {
      cVar3 = cVar2;
    }
    *(char *)(param_1 + local_18) = cVar3;
  }
  for (local_18 = 0x74; local_18 < 0x90; local_18 = local_18 + 1) {
    cVar3 = *(char *)(param_1 + local_18);
    if (cVar1 < *(char *)(param_1 + local_18)) {
      cVar3 = cVar1;
    }
    *(char *)(param_1 + local_18) = cVar3;
  }
  for (local_18 = 0x90; local_18 < 0xb6; local_18 = local_18 + 1) {
    cVar1 = *(char *)(param_1 + local_18);
    if (cVar2 < *(char *)(param_1 + local_18)) {
      cVar1 = cVar2;
    }
    *(char *)(param_1 + local_18) = cVar1;
  }
  return 0xb6;
}



int FUN_004d07ac(int *param_1,char param_2)

{
  int iVar1;
  int iVar2;
  int local_10;
  
  local_10 = 0;
  if (param_2 == '\x7f') {
    local_10 = 0;
  }
  else {
    iVar2 = *param_1;
    if (iVar2 == 1) {
      local_10 = FUN_004d0500((int)(param_1 + 1),param_2);
      iVar2 = FUN_004d0500((int)param_1 + 0xba,param_2);
      local_10 = local_10 + iVar2;
    }
    else if (iVar2 == 0) {
      local_10 = FUN_004d0500((int)(param_1 + 1),param_2);
    }
    else if (iVar2 == 2) {
      iVar2 = FUN_004d0500((int)(param_1 + 1),param_2);
      iVar1 = FUN_004d0500((int)param_1 + 0xba,param_2);
      local_10 = FUN_004d0500((int)(param_1 + 0x5c),param_2);
      local_10 = iVar2 + iVar1 + local_10;
    }
  }
  return local_10;
}



uint FUN_004d0960(int *param_1,char param_2)

{
  char cVar1;
  uint uVar2;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar2 = FUN_004cedec(*param_1), local_10 < uVar2; local_10 = local_10 + 1) {
    cVar1 = (char)*local_c;
    if ((char)*local_c < param_2) {
      cVar1 = param_2;
    }
    *(char *)local_c = cVar1;
    local_c = (int *)((int)local_c + 1);
  }
  return local_10;
}



uint FUN_004d0a2c(int *param_1,int *param_2)

{
  char cVar1;
  uint uVar2;
  uint local_18;
  int *local_14;
  int *local_10;
  
  local_18 = 0;
  local_14 = param_1 + 1;
  local_10 = param_2 + 1;
  if (*param_1 == *param_2) {
    for (local_18 = 0; uVar2 = FUN_004cedec(*param_1), local_18 < uVar2; local_18 = local_18 + 1) {
      cVar1 = (char)*local_10;
      if ((char)*local_14 < (char)*local_10) {
        cVar1 = (char)*local_14;
      }
      *(char *)local_14 = cVar1;
      local_14 = (int *)((int)local_14 + 1);
      local_10 = (int *)((int)local_10 + 1);
    }
  }
  return local_18;
}



uint FUN_004d0b3c(int *param_1,int *param_2)

{
  byte bVar1;
  uint uVar2;
  uint local_18;
  byte *local_14;
  byte *local_10;
  
  local_18 = 0;
  local_14 = (byte *)(param_1 + 1);
  local_10 = (byte *)(param_2 + 1);
  if (*param_1 == *param_2) {
    for (local_18 = 0; uVar2 = FUN_004cedec(*param_1), local_18 < uVar2; local_18 = local_18 + 1) {
      bVar1 = *local_10;
      if (*local_10 < *local_14) {
        bVar1 = *local_14;
      }
      *local_14 = bVar1;
      local_14 = local_14 + 1;
      local_10 = local_10 + 1;
    }
  }
  return local_18;
}



int FUN_004d0c58(int *param_1)

{
  char cVar1;
  uint uVar2;
  uint local_18;
  char *local_14;
  char local_10;
  
  local_14 = (char *)((int)param_1 + 5);
  local_10 = (char)param_1[1];
  for (local_18 = 1; uVar2 = FUN_004cedec(*param_1), local_18 < uVar2; local_18 = local_18 + 1) {
    cVar1 = *local_14;
    if (*local_14 < local_10) {
      cVar1 = local_10;
    }
    local_14 = local_14 + 1;
    local_10 = cVar1;
  }
  return (int)local_10;
}



int FUN_004d0d30(int *param_1,char param_2)

{
  int iVar1;
  char cVar2;
  uint uVar3;
  uint local_18;
  int *local_14;
  char local_10;
  
  local_14 = param_1 + 1;
  local_18 = 0;
  local_10 = -0x80;
  while ((uVar3 = FUN_004cedec(*param_1), local_18 < uVar3 &&
         ((local_10 == -0x80 || (local_10 == param_2))))) {
    iVar1 = *local_14;
    local_18 = local_18 + 1;
    local_14 = (int *)((int)local_14 + 1);
    local_10 = (char)iVar1;
  }
  for (; uVar3 = FUN_004cedec(*param_1), local_18 < uVar3; local_18 = local_18 + 1) {
    cVar2 = local_10;
    if ((((char)*local_14 != -0x80) && (param_2 != (char)*local_14)) &&
       (cVar2 = (char)*local_14, local_10 < (char)*local_14)) {
      cVar2 = local_10;
    }
    local_10 = cVar2;
    local_14 = (int *)((int)local_14 + 1);
  }
  return (int)local_10;
}



int FUN_004d0eb0(int *param_1,undefined4 param_2)

{
  char cVar1;
  uint local_18;
  char *local_14;
  char local_10;
  
  local_14 = (char *)FUN_004ce9c8(param_1,param_2);
  if (local_14 == (char *)0x0) {
    local_10 = -0x80;
  }
  else {
    local_10 = *local_14;
    for (local_18 = 1; local_14 = local_14 + 1, local_18 < 0xb6; local_18 = local_18 + 1) {
      cVar1 = *local_14;
      if (*local_14 < local_10) {
        cVar1 = local_10;
      }
      local_10 = cVar1;
    }
  }
  return (int)local_10;
}



int FUN_004d0f94(int *param_1,undefined4 param_2)

{
  char cVar1;
  uint local_18;
  char *local_14;
  char local_10;
  
  local_14 = (char *)FUN_004ce9c8(param_1,param_2);
  if (local_14 == (char *)0x0) {
    local_10 = -0x80;
  }
  else {
    local_10 = *local_14;
    for (local_18 = 1; local_14 = local_14 + 1, local_18 < 0xb6; local_18 = local_18 + 1) {
      cVar1 = *local_14;
      if (local_10 < *local_14) {
        cVar1 = local_10;
      }
      local_10 = cVar1;
    }
  }
  return (int)local_10;
}



void FUN_004d1078(undefined *param_1,undefined4 param_2,int *param_3,int *param_4,undefined4 param_5
                 ,int param_6)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  iVar1 = FUN_004ce9c8(param_3,param_5);
  iVar2 = FUN_004ce9c8(param_4,param_5);
  if ((iVar1 != 0) && (iVar2 != 0)) {
    local_20 = FUN_004ceaa4(iVar1,param_6);
    local_1c = FUN_004ceaa4(iVar2,param_6);
    if ((local_20 != 0) && (local_1c != 0)) {
      for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
        (*(code *)param_1)(param_2,local_20,local_1c);
        local_20 = local_20 + 1;
        local_1c = local_1c + 1;
      }
    }
  }
  return;
}



void FUN_004d1190(undefined *param_1,undefined4 param_2,int *param_3,int *param_4,undefined4 param_5
                 ,int param_6,int param_7)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  iVar1 = FUN_004ce9c8(param_3,param_5);
  iVar2 = FUN_004ce9c8(param_4,param_5);
  if ((iVar1 != 0) && (iVar2 != 0)) {
    local_20 = FUN_004ceb40(iVar1,param_6,param_7);
    local_1c = FUN_004ceb40(iVar2,param_6,param_7);
    if ((local_20 != 0) && (local_1c != 0)) {
      for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {
        (*(code *)param_1)(param_2,local_20,local_1c);
        local_20 = local_20 + 1;
        local_1c = local_1c + 1;
      }
    }
  }
  return;
}



void FUN_004d12b0(undefined *param_1,undefined4 param_2,int *param_3,int *param_4,undefined4 param_5
                 ,int param_6,int param_7,uint param_8)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  iVar1 = FUN_004ce9c8(param_3,param_5);
  iVar2 = FUN_004ce9c8(param_4,param_5);
  if ((iVar1 != 0) && (iVar2 != 0)) {
    local_20 = FUN_004cec2c(iVar1,param_6,param_7,param_8);
    local_1c = FUN_004cec2c(iVar2,param_6,param_7,param_8);
    if ((local_20 != 0) && (local_1c != 0)) {
      for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {
        (*(code *)param_1)(param_2,local_20,local_1c);
        local_20 = local_20 + 1;
        local_1c = local_1c + 1;
      }
    }
  }
  return;
}



void FUN_004d13d8(undefined *param_1,undefined4 param_2,int *param_3,int *param_4,undefined4 param_5
                 ,int param_6,int param_7,uint param_8)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  iVar1 = FUN_004ce9c8(param_3,param_5);
  iVar2 = FUN_004ce9c8(param_4,param_5);
  if ((iVar1 != 0) && (iVar2 != 0)) {
    local_20 = FUN_004cec2c(iVar1,param_6,param_7,param_8);
    local_1c = FUN_004cec2c(iVar2,param_6,param_7,param_8);
    if ((local_20 != 0) && (local_1c != 0)) {
      for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
        (*(code *)param_1)(param_2,local_20,local_1c);
        local_20 = local_20 + 1;
        local_1c = local_1c + 1;
      }
    }
  }
  return;
}



void FUN_004d1500(undefined *param_1,undefined4 param_2,int *param_3,int *param_4)

{
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  local_1c = FUN_004ce9c8(param_3,0);
  local_18 = FUN_004ce9c8(param_4,0);
  if ((local_1c != 0) && (local_18 != 0)) {
    for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
      (*(code *)param_1)(param_2,local_1c,local_18);
      local_1c = local_1c + 1;
      local_18 = local_18 + 1;
    }
  }
  local_1c = FUN_004ce9c8(param_3,1);
  local_18 = FUN_004ce9c8(param_4,1);
  if ((local_1c != 0) && (local_18 != 0)) {
    for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
      (*(code *)param_1)(param_2,local_1c,local_18);
      local_1c = local_1c + 1;
      local_18 = local_18 + 1;
    }
    local_1c = FUN_004ce9c8(param_3,3);
    local_18 = FUN_004ce9c8(param_4,3);
    if ((local_1c != 0) && (local_18 != 0)) {
      for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
        (*(code *)param_1)(param_2,local_1c,local_18);
        local_1c = local_1c + 1;
        local_18 = local_18 + 1;
      }
    }
  }
  local_1c = FUN_004ce9c8(param_3,2);
  local_18 = FUN_004ce9c8(param_4,2);
  if ((local_1c != 0) && (local_18 != 0)) {
    for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
      (*(code *)param_1)(param_2,local_1c,local_18);
      local_1c = local_1c + 1;
      local_18 = local_18 + 1;
    }
    local_1c = FUN_004ce9c8(param_3,4);
    local_18 = FUN_004ce9c8(param_4,4);
    if ((local_1c != 0) && (local_18 != 0)) {
      for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
        (*(code *)param_1)(param_2,local_1c,local_18);
        local_1c = local_1c + 1;
        local_18 = local_18 + 1;
      }
    }
    local_1c = FUN_004ce9c8(param_3,5);
    local_18 = FUN_004ce9c8(param_4,5);
    if ((local_1c != 0) && (local_18 != 0)) {
      for (local_20 = 0; local_20 < 0xb6; local_20 = local_20 + 1) {
        (*(code *)param_1)(param_2,local_1c,local_18);
        local_1c = local_1c + 1;
        local_18 = local_18 + 1;
      }
    }
  }
  return;
}



void FUN_004d1958(int *param_1,char param_2)

{
  size_t __n;
  
  __n = FUN_004cedec(*param_1);
  memset(param_1 + 1,(int)param_2,__n);
  return;
}



void FUN_004d19dc(int *param_1,int *param_2)

{
  size_t __n;
  void *pvVar1;
  void *pvVar2;
  
  if (*param_1 == *param_2) {
    __n = FUN_004cedec(*param_1);
    memcpy(param_2 + 1,param_1 + 1,__n);
  }
  else {
    pvVar1 = (void *)FUN_004ce9c8(param_1,0);
    pvVar2 = (void *)FUN_004ce9c8(param_2,0);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
    pvVar1 = (void *)FUN_004ce9c8(param_1,1);
    pvVar2 = (void *)FUN_004ce9c8(param_2,1);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
    pvVar1 = (void *)FUN_004ce9c8(param_1,3);
    pvVar2 = (void *)FUN_004ce9c8(param_2,3);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
    pvVar1 = (void *)FUN_004ce9c8(param_1,2);
    pvVar2 = (void *)FUN_004ce9c8(param_2,2);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
    pvVar1 = (void *)FUN_004ce9c8(param_1,4);
    pvVar2 = (void *)FUN_004ce9c8(param_2,4);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
    pvVar1 = (void *)FUN_004ce9c8(param_1,5);
    pvVar2 = (void *)FUN_004ce9c8(param_2,5);
    if ((pvVar1 != (void *)0x0) && (pvVar2 != (void *)0x0)) {
      memcpy(pvVar2,pvVar1,0xb6);
    }
  }
  return;
}



void FUN_004d1c80(int *param_1,char param_2)

{
  uint uVar1;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar1 = FUN_004cedec(*param_1), local_10 < uVar1; local_10 = local_10 + 1) {
    if ((char)*local_c != -0x80) {
      *(char *)local_c = param_2 - (char)*local_c;
    }
    local_c = (int *)((int)local_c + 1);
  }
  return;
}



void FUN_004d1d50(int *param_1,char param_2)

{
  uint uVar1;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar1 = FUN_004cedec(*param_1), local_10 < uVar1; local_10 = local_10 + 1) {
    if ((char)*local_c != -0x80) {
      *(char *)local_c = (char)*local_c - param_2;
    }
    local_c = (int *)((int)local_c + 1);
  }
  return;
}



void FUN_004d1e20(int *param_1,char param_2)

{
  uint uVar1;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar1 = FUN_004cedec(*param_1), local_10 < uVar1; local_10 = local_10 + 1) {
    if ((char)*local_c != -0x80) {
      *(char *)local_c = (char)*local_c + param_2;
    }
    local_c = (int *)((int)local_c + 1);
  }
  return;
}



void FUN_004d1ef0(int *param_1,byte param_2)

{
  uint uVar1;
  uint local_10;
  int *local_c;
  
  local_c = param_1 + 1;
  for (local_10 = 0; uVar1 = FUN_004cedec(*param_1), local_10 < uVar1; local_10 = local_10 + 1) {
    if ((char)*local_c != -0x80) {
      *(char *)local_c = (char)((int)((int)(char)*local_c * (uint)param_2) / 100);
    }
    local_c = (int *)((int)local_c + 1);
  }
  return;
}



void FUN_004d1fd8(int *param_1,int *param_2)

{
  char cVar1;
  uint local_18;
  int *local_14;
  int *local_10;
  uint local_c;
  
  local_14 = (int *)0x0;
  local_10 = (int *)0x0;
  local_c = 0;
  if (*param_1 == *param_2) {
    local_14 = param_1 + 1;
    local_10 = param_2 + 1;
    local_c = FUN_004cedec(*param_1);
  }
  for (local_18 = 0; local_18 < local_c; local_18 = local_18 + 1) {
    cVar1 = (char)*local_10;
    if ((char)*local_14 < (char)*local_10) {
      cVar1 = (char)*local_14;
    }
    *(char *)local_14 = cVar1;
    local_14 = (int *)((int)local_14 + 1);
    local_10 = (int *)((int)local_10 + 1);
  }
  return;
}



void FUN_004d20f0(int *param_1,int *param_2)

{
  char cVar1;
  uint local_18;
  int *local_14;
  int *local_10;
  uint local_c;
  
  local_14 = (int *)0x0;
  local_10 = (int *)0x0;
  local_c = 0;
  if (*param_1 == *param_2) {
    local_14 = param_1 + 1;
    local_10 = param_2 + 1;
    local_c = FUN_004cedec(*param_1);
  }
  for (local_18 = 0; local_18 < local_c; local_18 = local_18 + 1) {
    cVar1 = (char)*local_10;
    if ((char)*local_10 < (char)*local_14) {
      cVar1 = (char)*local_14;
    }
    *(char *)local_14 = cVar1;
    local_14 = (int *)((int)local_14 + 1);
    local_10 = (int *)((int)local_10 + 1);
  }
  return;
}



undefined4 FUN_004d2208(undefined4 *param_1,uint *param_2,uint param_3,int *param_4)

{
  uint uVar1;
  int iVar2;
  undefined4 local_18;
  uint local_14;
  
  local_18 = 0;
  if (param_3 < 9) {
    local_18 = 0xfffffff2;
  }
  else {
    local_14 = param_2[1] << 0x18 | (param_2[1] & 0xff00) << 8 | (param_2[1] & 0xff0000) >> 8 |
               param_2[1] >> 0x18;
    if ((*param_2 << 0x18 | (*param_2 & 0xff00) << 8 | (*param_2 & 0xff0000) >> 8 | *param_2 >> 0x18
        ) != 0xbeefc0ff) {
      local_14 = FUN_004cddf0();
    }
    uVar1 = FUN_004cdf90((byte)local_14,*param_1);
    if (param_3 < uVar1) {
      local_18 = 0xfffffff2;
    }
    else {
      iVar2 = FUN_004ce1d8(param_1,(undefined1 *)param_2,local_14);
      *param_4 = iVar2;
    }
  }
  return local_18;
}



undefined4 FUN_004d23d8(undefined4 param_1,char *param_2,uint param_3,undefined4 *param_4)

{
  char cVar1;
  char cVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 local_28;
  int *local_24;
  
  local_28 = 0;
  local_24 = (int *)0x0;
  if (((param_3 < 0xb) || (param_2 == (char *)0x0)) || (*param_2 != '\x02')) {
    if (param_3 < 0xb) {
      local_28 = 0xfffffff2;
    }
    else if (param_2 == (char *)0x0) {
      local_28 = 0xfffffffe;
    }
    else {
      local_28 = 0xffffffdb;
    }
  }
  else {
    uVar3 = (uint)(byte)param_2[1];
    iVar4 = FUN_004cedec(uVar3);
    local_24 = FUN_004cf030(param_1,uVar3);
    if (local_24 == (int *)0x0) {
      if (param_3 < iVar4 + 10U) {
        local_28 = 0xfffffff2;
      }
      else {
        local_28 = 0xffffffe5;
      }
    }
    else {
      iVar4 = *(int *)(param_2 + 4);
      uVar6 = *(uint *)(param_2 + 4);
      uVar5 = *(uint *)(param_2 + 4);
      uVar7 = *(uint *)(param_2 + 4);
      cVar1 = param_2[2];
      cVar2 = param_2[3];
      FUN_004d1958(local_24,-0x80);
      FUN_004ce5e8(local_24,(int)(param_2 + 10),
                   iVar4 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar7 >> 0x18,
                   uVar3,CONCAT11(cVar1,cVar2));
    }
  }
  *param_4 = local_24;
  return local_28;
}



undefined4 FUN_004d267c(uint *param_1,char *param_2,uint param_3)

{
  byte bVar1;
  char cVar2;
  char cVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 local_20;
  
  local_20 = 0;
  if (((param_3 < 0xb) || (param_2 == (char *)0x0)) || (*param_2 != '\x02')) {
    if (param_3 < 0xb) {
      local_20 = 0xfffffff2;
    }
    else if (param_2 == (char *)0x0) {
      local_20 = 0xfffffffe;
    }
    else {
      local_20 = 0xffffffdb;
    }
  }
  else {
    bVar1 = param_2[1];
    if (*param_1 == (uint)bVar1) {
      iVar4 = *(int *)(param_2 + 4);
      uVar6 = *(uint *)(param_2 + 4);
      uVar5 = *(uint *)(param_2 + 4);
      uVar7 = *(uint *)(param_2 + 4);
      cVar2 = param_2[2];
      cVar3 = param_2[3];
      FUN_004d1958((int *)param_1,-0x80);
      FUN_004ce5e8(param_1,(int)(param_2 + 10),
                   iVar4 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar7 >> 0x18,
                   (uint)bVar1,CONCAT11(cVar2,cVar3));
    }
    else {
      local_20 = 0xfffffffe;
    }
  }
  return local_20;
}



int FUN_004d28cc(int *param_1,undefined4 param_2,int *param_3,uint param_4,uint param_5)

{
  bool bVar1;
  int iVar2;
  undefined1 *puVar3;
  void *__src;
  int local_28;
  uint local_24;
  
  local_28 = 0;
  iVar2 = FUN_004ce9c8(param_1,param_2);
  local_24 = 1;
  while( true ) {
    if (param_5 < local_24) {
      return local_28;
    }
    puVar3 = (undefined1 *)*param_3;
    if (param_4 < local_28 + 8U) break;
    bVar1 = false;
    if ((iVar2 != 0) && (__src = (void *)FUN_004ceaa4(iVar2,local_24), __src != (void *)0x0)) {
      memcpy(puVar3 + 4,__src,4);
      bVar1 = true;
    }
    if (bVar1) {
      *puVar3 = 1;
      puVar3[1] = 6;
      puVar3[2] = (char)param_2;
      puVar3[3] = (char)local_24;
      local_28 = local_28 + 8;
      *param_3 = *param_3 + 8;
    }
    local_24 = local_24 + 1;
  }
  return local_28;
}



int FUN_004d2a44(int *param_1,undefined4 param_2,int *param_3,uint param_4,uint param_5)

{
  bool bVar1;
  int iVar2;
  undefined1 *puVar3;
  void *__src;
  int local_28;
  uint local_24;
  uint local_20;
  
  local_28 = 0;
  iVar2 = FUN_004ce9c8(param_1,param_2);
  local_24 = 1;
  do {
    if (param_5 < local_24) {
      return local_28;
    }
    for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
      puVar3 = (undefined1 *)*param_3;
      bVar1 = false;
      if (param_4 < local_28 + 0xdU) {
        return local_28;
      }
      if ((iVar2 != 0) &&
         (__src = (void *)FUN_004ceb40(iVar2,local_20,local_24), __src != (void *)0x0)) {
        memcpy(puVar3 + 5,__src,8);
        bVar1 = true;
      }
      if (bVar1) {
        *puVar3 = 2;
        puVar3[1] = 0xb;
        puVar3[2] = (char)param_2;
        puVar3[3] = (char)local_24;
        puVar3[4] = (char)local_20;
        local_28 = local_28 + 0xd;
        *param_3 = *param_3 + 0xd;
      }
    }
    local_24 = local_24 + 1;
  } while( true );
}



int FUN_004d2c00(int *param_1,undefined4 param_2,int *param_3,uint param_4,uint param_5)

{
  bool bVar1;
  int iVar2;
  undefined1 *puVar3;
  void *__src;
  int local_28;
  uint local_24;
  uint local_20;
  byte local_1c;
  
  local_28 = 0;
  iVar2 = FUN_004ce9c8(param_1,param_2);
  local_24 = 1;
  do {
    if (param_5 < local_24) {
      return local_28;
    }
    for (local_1c = 1; local_1c <= local_24; local_1c = local_1c + 1) {
      for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
        puVar3 = (undefined1 *)*param_3;
        if (param_4 < local_28 + 0x10U) {
          return local_28;
        }
        bVar1 = false;
        if ((iVar2 != 0) &&
           (__src = (void *)FUN_004cec2c(iVar2,(uint)local_1c,local_20,local_24),
           __src != (void *)0x0)) {
          memcpy(puVar3 + 6,__src,10);
          bVar1 = true;
        }
        if (bVar1) {
          *puVar3 = 3;
          puVar3[1] = 0xe;
          puVar3[2] = (char)param_2;
          puVar3[3] = (char)local_24;
          puVar3[4] = (char)local_20;
          puVar3[5] = local_1c;
          local_28 = local_28 + 0x10;
          *param_3 = *param_3 + 0x10;
        }
      }
    }
    local_24 = local_24 + 1;
  } while( true );
}



void FUN_004d2e00(int *param_1,int param_2,undefined1 *param_3,uint param_4,uint param_5)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  undefined1 *local_res8;
  uint local_resc;
  uint local_10;
  uint local_c;
  
  *param_3 = 4;
  local_res8 = param_3 + 1;
  local_resc = param_4;
  if (param_2 == 1) {
    iVar2 = FUN_004d28cc(param_1,3,(int *)&local_res8,param_4,param_5);
    iVar3 = FUN_004d2a44(param_1,3,(int *)&local_res8,param_4 - iVar2,param_5);
    uVar1 = (param_4 - iVar2) - iVar3;
    iVar2 = FUN_004d2c00(param_1,3,(int *)&local_res8,uVar1,param_5);
    uVar1 = uVar1 - iVar2;
    iVar2 = FUN_004d2a44(param_1,1,(int *)&local_res8,uVar1,param_5);
    FUN_004d2c00(param_1,1,(int *)&local_res8,uVar1 - iVar2,param_5);
  }
  else if (param_2 == 0) {
    iVar2 = FUN_004d28cc(param_1,0,(int *)&local_res8,param_4,param_5);
    iVar3 = FUN_004d2a44(param_1,0,(int *)&local_res8,param_4 - iVar2,param_5);
    FUN_004d2c00(param_1,0,(int *)&local_res8,(param_4 - iVar2) - iVar3,param_5);
  }
  else if (param_2 == 2) {
    local_10 = param_4;
    for (local_c = 2; local_c < 6; local_c = local_c + 1) {
      if (local_c != 3) {
        if (local_c == 4) {
          iVar2 = FUN_004d28cc(param_1,4,(int *)&local_res8,local_10,param_5);
          local_10 = local_10 - iVar2;
        }
        iVar2 = FUN_004d2a44(param_1,local_c,(int *)&local_res8,local_10,param_5);
        iVar3 = FUN_004d2c00(param_1,local_c,(int *)&local_res8,local_10 - iVar2,param_5);
        local_10 = (local_10 - iVar2) - iVar3;
      }
    }
  }
  return;
}



undefined4 FUN_004d3100(int *param_1,char *param_2,int param_3)

{
  char cVar1;
  int local_res8 [2];
  char *local_20;
  undefined4 local_1c;
  
  local_20 = param_2 + 1;
  local_1c = 0;
  local_res8[0] = param_3;
  if (*param_2 == '\x04') {
    do {
      cVar1 = *local_20;
      if (cVar1 == '\x02') {
        FUN_004cf784(param_1,(uint)(byte)local_20[2],(uint)(byte)local_20[4],(uint)(byte)local_20[3]
                     ,local_20 + 5);
      }
      else if (cVar1 == '\x03') {
        FUN_004cf8d0(param_1,(uint)(byte)local_20[2],(uint)(byte)local_20[5],(uint)(byte)local_20[4]
                     ,(uint)(byte)local_20[3],local_20 + 6);
      }
      else if (cVar1 == '\x01') {
        FUN_004cf6e4(param_1,(uint)(byte)local_20[2],(uint)(byte)local_20[3],local_20 + 4);
      }
      local_20 = (char *)FUN_004be2ec((int)local_20,local_res8);
    } while (local_20 != (char *)0x0);
  }
  else {
    local_1c = 0xffffffdb;
  }
  return local_1c;
}



undefined4 FUN_004d32c8(void)

{
  return 4;
}



void FUN_004d32f0(undefined4 param_1,size_t param_2)

{
  calloc(1,param_2);
  return;
}



void FUN_004d3330(undefined4 param_1,void *param_2)

{
  free(param_2);
  return;
}



uint FUN_004d3370(int param_1,ushort param_2)

{
  uint uVar1;
  
  if ((param_2 & 1) == 0) {
    uVar1 = param_1 + 4;
  }
  else {
    uVar1 = param_1 + 7U & 0xfffffffc;
  }
  return uVar1;
}



int FUN_004d33d0(int param_1,int *param_2,ushort param_3)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  
  if ((param_1 == 0) ||
     (iVar2 = *param_2, uVar1 = FUN_004d4534(param_1,param_3), iVar2 < (int)uVar1)) {
    iVar2 = 0;
  }
  else {
    uVar1 = FUN_004d4534(param_1,param_3);
    iVar2 = param_1 + uVar1;
    *param_2 = *param_2 - uVar1;
    if ((iVar2 == 0) || (iVar3 = *param_2, uVar1 = FUN_004d4534(iVar2,param_3), iVar3 < (int)uVar1))
    {
      iVar2 = 0;
    }
  }
  return iVar2;
}



undefined4 FUN_004d34d4(undefined2 *param_1,int param_2,short param_3,undefined2 param_4)

{
  undefined4 uVar1;
  
  if (((param_1 == (undefined2 *)0x0) || (param_2 == 0)) || (param_3 == 0)) {
    uVar1 = 0xfffffffe;
  }
  else {
    *param_1 = param_4;
    param_1[1] = param_3;
    *(int *)(param_1 + 2) = param_2;
    *(int *)(param_1 + 4) = param_2;
    uVar1 = 0;
  }
  return uVar1;
}



uint FUN_004d3570(int param_1)

{
  uint uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(int *)(param_1 + 8) - *(int *)(param_1 + 4) & 0xffff;
  }
  return uVar1;
}



uint FUN_004d35c8(int param_1)

{
  ushort uVar1;
  uint uVar2;
  
  if (param_1 == 0) {
    uVar2 = 0;
  }
  else {
    uVar1 = *(ushort *)(param_1 + 2);
    uVar2 = FUN_004d3570(param_1);
    uVar2 = uVar1 - uVar2 & 0xffff;
  }
  return uVar2;
}



undefined4 FUN_004d3630(int param_1)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_1 + 8);
  }
  return uVar1;
}



undefined4 FUN_004d3674(int param_1)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_1 + 4);
  }
  return uVar1;
}



undefined4 FUN_004d36b8(ushort *param_1,undefined2 param_2,void *param_3,ushort param_4)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  
  if (param_1 == (ushort *)0x0) {
    uVar1 = 0xfffffffe;
  }
  else {
    uVar2 = FUN_004d3370((uint)param_4,*param_1);
    uVar3 = FUN_004d35c8((int)param_1);
    if ((int)uVar3 < (int)uVar2) {
      uVar1 = 0xffffffe5;
    }
    else {
      puVar4 = (undefined1 *)FUN_004d3630((int)param_1);
      *puVar4 = (char)param_2;
      puVar4[1] = (char)((ushort)param_2 >> 8);
      *(ushort *)(puVar4 + 2) = param_4;
      memcpy(puVar4 + 4,param_3,(uint)param_4);
      *(uint *)(param_1 + 4) = *(int *)(param_1 + 4) + uVar2;
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined4 FUN_004d3818(ushort *param_1,undefined2 param_2,undefined1 param_3)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  
  if (param_1 == (ushort *)0x0) {
    uVar1 = 0xfffffffe;
  }
  else {
    uVar2 = FUN_004d3370(1,*param_1);
    uVar3 = FUN_004d35c8((int)param_1);
    if ((int)uVar3 < (int)uVar2) {
      uVar1 = 0xffffffe5;
    }
    else {
      puVar4 = (undefined1 *)FUN_004d3630((int)param_1);
      *puVar4 = (char)param_2;
      puVar4[1] = (char)((ushort)param_2 >> 8);
      puVar4[2] = 1;
      puVar4[3] = 0;
      puVar4[4] = param_3;
      *(uint *)(param_1 + 4) = *(int *)(param_1 + 4) + uVar2;
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined4 FUN_004d3944(ushort *param_1,undefined2 param_2,undefined2 param_3)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  
  if (param_1 == (ushort *)0x0) {
    uVar1 = 0xfffffffe;
  }
  else {
    uVar2 = FUN_004d3370(2,*param_1);
    uVar3 = FUN_004d35c8((int)param_1);
    if ((int)uVar3 < (int)uVar2) {
      uVar1 = 0xffffffe5;
    }
    else {
      puVar4 = (undefined1 *)FUN_004d3630((int)param_1);
      *puVar4 = (char)param_2;
      puVar4[1] = (char)((ushort)param_2 >> 8);
      puVar4[2] = 2;
      puVar4[3] = 0;
      puVar4[4] = (char)param_3;
      puVar4[5] = (char)((ushort)param_3 >> 8);
      *(uint *)(param_1 + 4) = *(int *)(param_1 + 4) + uVar2;
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined4 FUN_004d3aa4(ushort *param_1,undefined2 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  undefined1 *puVar4;
  
  if (param_1 == (ushort *)0x0) {
    uVar1 = 0xfffffffe;
  }
  else {
    uVar2 = FUN_004d3370(4,*param_1);
    uVar3 = FUN_004d35c8((int)param_1);
    if ((int)uVar3 < (int)uVar2) {
      uVar1 = 0xffffffe5;
    }
    else {
      puVar4 = (undefined1 *)FUN_004d3630((int)param_1);
      *puVar4 = (char)param_2;
      puVar4[1] = (char)((ushort)param_2 >> 8);
      puVar4[2] = 4;
      puVar4[3] = 0;
      puVar4[4] = (char)param_3;
      puVar4[5] = (char)((uint)param_3 >> 8);
      puVar4[6] = (char)((uint)param_3 >> 0x10);
      puVar4[7] = (char)((uint)param_3 >> 0x18);
      *(uint *)(param_1 + 4) = *(int *)(param_1 + 4) + uVar2;
      uVar1 = 0;
    }
  }
  return uVar1;
}



undefined4 FUN_004d3c2c(int *param_1,ushort param_2,ushort param_3,void *param_4,ushort param_5)

{
  ushort uVar1;
  ushort *puVar2;
  uint uVar3;
  int iVar4;
  
  puVar2 = (ushort *)*param_1;
  uVar1 = puVar2[1];
  if (uVar1 == 0) {
    puts("z-len, skip unpack");
  }
  else {
    if ((*puVar2 != param_2) || (param_3 < uVar1)) {
      printf("xtlv_unpack Error: found[type:%d,len:%d] != xpct[type:%d,len:%d]\n",(uint)*puVar2,
             (uint)uVar1,(uint)param_2,(uint)param_3);
      return 0xfffffffe;
    }
    memcpy(param_4,puVar2 + 2,(uint)puVar2[1]);
  }
  iVar4 = *param_1;
  uVar3 = FUN_004d4534((int)puVar2,param_5);
  *param_1 = iVar4 + uVar3;
  return 0;
}



undefined4
FUN_004d3d98(int *param_1,ushort *param_2,undefined2 param_3,ushort param_4,void *param_5,
            ushort param_6)

{
  undefined1 *puVar1;
  uint param1;
  undefined4 uVar2;
  
  puVar1 = (undefined1 *)*param_1;
  param1 = FUN_004d3370((uint)param_4,param_6);
  if ((int)(uint)*param_2 < (int)param1) {
    printf("bcm_pack_xtlv_entry: no space tlv_buf: requested:%d, available:%d\n",param1,
           (uint)*param_2);
    uVar2 = 0xffffffe8;
  }
  else {
    *puVar1 = (char)param_3;
    puVar1[1] = (char)((ushort)param_3 >> 8);
    *(ushort *)(puVar1 + 2) = param_4;
    memcpy(puVar1 + 4,param_5,(uint)param_4);
    *param_1 = *param_1 + param1;
    *param_2 = *param_2 - (short)param1;
    uVar2 = 0;
  }
  return uVar2;
}



int FUN_004d3f1c(undefined4 param_1,undefined2 *param_2,ushort param_3,ushort param_4,
                undefined *param_5)

{
  ushort uVar1;
  undefined2 uVar2;
  uint uVar3;
  int iVar4;
  undefined2 *local_res4;
  uint local_1c;
  
  local_1c = (uint)param_3;
  local_res4 = param_2;
  while( true ) {
    if ((int)local_1c < 4) {
      return 0;
    }
    uVar1 = local_res4[1];
    uVar2 = *local_res4;
    uVar3 = FUN_004d3370((uint)uVar1,param_4);
    local_1c = local_1c - uVar3;
    if ((int)local_1c < 0) break;
    iVar4 = (*(code *)param_5)(param_1,local_res4 + 2,uVar2,uVar1);
    if (iVar4 != 0) {
      return iVar4;
    }
    local_res4 = (undefined2 *)((int)local_res4 + uVar3);
  }
  return 0;
}



undefined4
FUN_004d4054(undefined4 param_1,undefined1 *param_2,ushort param_3,ushort param_4,undefined *param_5
            ,undefined *param_6,int *param_7)

{
  uint uVar1;
  undefined4 local_38;
  undefined1 *local_34;
  char local_30;
  undefined2 local_10;
  ushort local_e [3];
  
  local_38 = 0;
  local_30 = '\x01';
  for (local_34 = param_2; (local_30 != '\0' && (local_34 < param_2 + param_3));
      local_34 = local_34 + uVar1) {
    local_30 = (*(code *)param_5)(param_1,&local_10,local_e);
    uVar1 = FUN_004d3370((uint)local_e[0],param_4);
    if (param_2 + param_3 <= local_34 + uVar1) {
      local_38 = 0xfffffff2;
      goto LAB_004d4210;
    }
    *local_34 = (char)local_10;
    local_34[1] = (char)((ushort)local_10 >> 8);
    local_34[2] = (char)local_e[0];
    local_34[3] = (char)(local_e[0] >> 8);
    (*(code *)param_6)(param_1,local_10,local_e[0],local_34 + 4);
  }
  if (local_30 != '\0') {
    local_38 = 0xfffffff2;
  }
LAB_004d4210:
  if (param_7 != (int *)0x0) {
    *param_7 = (int)local_34 - (int)param_2;
  }
  return local_38;
}



bool FUN_004d424c(int *param_1,ushort *param_2,short *param_3,ushort param_4)

{
  bool bVar1;
  int iVar2;
  short *local_res8;
  int local_c;
  
  bVar1 = false;
  local_c = *param_1;
  for (local_res8 = param_3; *local_res8 != 0; local_res8 = local_res8 + 4) {
    if (local_res8[1] != 0) {
      iVar2 = FUN_004d3d98(&local_c,param_2,*local_res8,local_res8[1],*(void **)(local_res8 + 2),
                           param_4);
      bVar1 = iVar2 != 0;
      if (bVar1) break;
    }
  }
  *param_1 = local_c;
  return bVar1;
}



int FUN_004d4340(short *param_1,int *param_2,short *param_3,ushort param_4)

{
  uint uVar1;
  int iVar2;
  int local_20;
  short *local_1c;
  short *local_18;
  
  local_20 = 0;
  if ((param_1 == (short *)0x0) ||
     (iVar2 = *param_2, uVar1 = FUN_004d4534((int)param_1,param_4), iVar2 < (int)uVar1)) {
    param_1 = (short *)0x0;
  }
  if ((param_1 == (short *)0x0) || (local_1c = param_1, param_3 == (short *)0x0)) {
    local_20 = -2;
  }
  else {
    while ((local_1c != (short *)0x0 && (local_20 == 0))) {
      for (local_18 = param_3; *local_18 != 0; local_18 = local_18 + 4) {
        if (*local_1c == *local_18) {
          if (local_1c[1] == local_18[1]) {
            memcpy(*(void **)(local_18 + 2),local_1c + 2,(uint)(ushort)local_1c[1]);
          }
          else {
            local_20 = -0x18;
          }
          break;
        }
      }
      if (*local_18 == 0) {
        local_20 = -0x1e;
      }
      local_1c = (short *)FUN_004d33d0((int)local_1c,param_2,param_4);
    }
    if ((*param_2 != 0) && (local_20 == 0)) {
      local_20 = -0xe;
    }
  }
  return local_20;
}



uint FUN_004d4534(int param_1,ushort param_2)

{
  uint uVar1;
  
  uVar1 = FUN_004d3370((uint)*(ushort *)(param_1 + 2),param_2);
  return uVar1;
}



int FUN_004d45c0(undefined *param_1,undefined *param_2,undefined4 param_3,int param_4,size_t param_5
                ,undefined4 *param_6)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  int local_18;
  undefined4 *local_14 [2];
  
  local_18 = 0;
  local_14[0] = (undefined4 *)0x0;
  if (((param_6 == (undefined4 *)0x0) || (param_1 == (undefined *)0x0)) || (param_4 == 0)) {
    local_18 = -2;
  }
  else {
    local_14[0] = (undefined4 *)(*(code *)param_1)(param_3,0x14);
    if (local_14[0] == (undefined4 *)0x0) {
      local_18 = -0x1b;
    }
    else {
      memset(local_14[0],0,0x14);
      puVar1 = local_14[0];
      *local_14[0] = param_3;
      local_14[0][1] = param_4;
      uVar3 = (*(code *)param_1)(param_3,param_4 << 2);
      puVar2 = local_14[0];
      puVar1[2] = uVar3;
      if (local_14[0][2] == 0) {
        local_18 = -0x1b;
      }
      else {
        if (param_5 != 0) {
          uVar3 = (*(code *)param_1)(param_3,param_5);
          puVar2[4] = uVar3;
          if (local_14[0][4] == 0) {
            local_18 = -0x1b;
            goto LAB_004d4750;
          }
          local_14[0][3] = param_5;
          memset((void *)local_14[0][4],0,param_5);
        }
        *param_6 = local_14[0];
      }
    }
  }
LAB_004d4750:
  if (local_18 != 0) {
    FUN_004d4790((int *)local_14,param_2);
  }
  return local_18;
}



undefined4 FUN_004d4790(int *param_1,undefined *param_2)

{
  undefined4 *puVar1;
  
  if (((param_1 != (int *)0x0) && (*param_1 != 0)) && (param_2 != (undefined *)0x0)) {
    puVar1 = (undefined4 *)*param_1;
    *param_1 = 0;
    if (puVar1[4] != 0) {
      (*(code *)param_2)(*puVar1,puVar1[4],puVar1[3]);
    }
    if (puVar1[2] != 0) {
      (*(code *)param_2)(*puVar1,puVar1[2],puVar1[1] << 2);
    }
    (*(code *)param_2)(*puVar1,puVar1,0x14);
  }
  return 0;
}



undefined4 FUN_004d48a4(int param_1,int param_2,uint *param_3)

{
  undefined4 uVar1;
  uint local_10;
  
  if (((param_1 == 0) || (param_2 == 0)) || (param_3 == (uint *)0x0)) {
    uVar1 = 0xfffffffe;
  }
  else {
    for (local_10 = 0;
        (local_10 < *(uint *)(param_1 + 4) && (*(int *)(*(int *)(param_1 + 8) + local_10 * 4) != 0))
        ; local_10 = local_10 + 1) {
    }
    if (local_10 < *(uint *)(param_1 + 4)) {
      *(int *)(*(int *)(param_1 + 8) + local_10 * 4) = param_2;
      *param_3 = local_10;
      uVar1 = 0;
    }
    else {
      uVar1 = 0xffffffea;
    }
  }
  return uVar1;
}



undefined4 FUN_004d49ac(int param_1,uint param_2)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0xfffffffe;
  }
  else if (param_2 < *(uint *)(param_1 + 4)) {
    *(undefined4 *)(*(int *)(param_1 + 8) + param_2 * 4) = 0;
    uVar1 = 0;
  }
  else {
    uVar1 = 0xffffffe2;
  }
  return uVar1;
}



undefined1 FUN_004d4a2c(undefined4 *param_1,int param_2,int param_3,int param_4,int param_5)

{
  uint uVar1;
  int local_resc;
  uint local_18;
  
  if ((param_2 != 0) && (param_3 != 0)) {
    if ((param_4 == 0) || (local_resc = param_4, param_5 == 0)) {
      if (param_1[4] == 0) {
        return 0;
      }
      local_resc = param_1[4];
      param_5 = param_1[3];
    }
    for (local_18 = 0; local_18 < (uint)param_1[1]; local_18 = local_18 + 1) {
      if (*(int *)(param_1[2] + local_18 * 4) != 0) {
        uVar1 = (**(code **)(param_1[2] + local_18 * 4))(*param_1,local_18,param_2,param_3);
        if (param_5 << 3 == 0) {
          trap(7);
        }
        if (param_5 << 3 == 0) {
          trap(7);
        }
        if (((int)(uint)*(byte *)(local_resc + (uVar1 % (uint)(param_5 << 3) >> 3)) >>
             (uVar1 % (uint)(param_5 << 3) & 7) & 1U) == 0) {
          return 0xe2;
        }
      }
    }
  }
  return 0;
}



undefined4 FUN_004d4bd0(undefined4 *param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  uint uVar2;
  uint uVar3;
  uint local_10;
  
  if (((param_1 == (undefined4 *)0x0) || (param_2 == 0)) || (param_3 == 0)) {
    uVar1 = 0xfffffffe;
  }
  else if (param_1[4] == 0) {
    uVar1 = 0xffffffe9;
  }
  else {
    for (local_10 = 0; local_10 < (uint)param_1[1]; local_10 = local_10 + 1) {
      if (*(int *)(param_1[2] + local_10 * 4) != 0) {
        uVar2 = (**(code **)(param_1[2] + local_10 * 4))(*param_1,local_10,param_2,param_3);
        if (param_1[3] << 3 == 0) {
          trap(7);
        }
        uVar3 = uVar2 % (uint)(param_1[3] << 3) >> 3;
        if (param_1[3] << 3 == 0) {
          trap(7);
        }
        *(byte *)(param_1[4] + uVar3) =
             *(byte *)(param_1[4] + uVar3) | (byte)(1 << (uVar2 % (uint)(param_1[3] << 3) & 7));
      }
    }
    uVar1 = 0;
  }
  return uVar1;
}



undefined4 FUN_004d4d6c(int param_1,uint param_2,void *param_3,undefined4 *param_4)

{
  undefined4 uVar1;
  
  if (param_1 == 0) {
    uVar1 = 0xfffffffe;
  }
  else {
    if (param_4 != (undefined4 *)0x0) {
      *param_4 = *(undefined4 *)(param_1 + 0xc);
    }
    if (param_2 < *(uint *)(param_1 + 0xc)) {
      uVar1 = 0xfffffff2;
    }
    else {
      if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(param_1 + 0xc) != 0)) {
        memcpy(param_3,*(void **)(param_1 + 0x10),*(size_t *)(param_1 + 0xc));
      }
      uVar1 = 0;
    }
  }
  return uVar1;
}



int FUN_004d4e50(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  int *piVar2;
  int iVar3;
  ushort local_28;
  uchar local_20;
  ushort local_10;
  ushort local_e;
  ushort *local_c;
  
  local_28 = 0;
  piVar2 = (int *)(param_3 + 4);
  if (*piVar2 == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,&local_10,4,&local_c);
    if (iVar3 == 0) {
      if (DAT_0055c140 == '\0') {
        uVar1 = *local_c;
      }
      else {
        uVar1 = *local_c << 8 | *local_c >> 8;
      }
      printf("%d\n",(uint)uVar1);
      if (uVar1 != 0) {
        local_20 = 'u';
        if (DAT_0055c140 == '\0') {
          local_28 = local_c[1];
        }
        else {
          local_28 = local_c[1] << 8 | local_c[1] >> 8;
        }
        if ((short)local_28 < 0) {
          local_20 = 'r';
          local_28 = local_28 & 0x7fff;
        }
        if (local_28 == 2) {
          printf("%s %c\n","initiator",local_20);
        }
        else if (local_28 == 3) {
          printf("%s %c\n","target",local_20);
        }
        else if (local_28 == 1) {
          printf("%s %c\n","neutral",local_20);
        }
      }
    }
  }
  else if ((*(ushort *)(__ctype_b + *(char *)*piVar2 * 2) & 8) == 0) {
    iVar3 = FUN_004de6b8(param_1,param_2,piVar2);
  }
  else {
    iVar3 = atoi((char *)*piVar2);
    uVar1 = (ushort)iVar3;
    if (uVar1 != 0) {
      if (*(int *)(param_3 + 8) == 0) {
        local_28 = 0x8001;
      }
      else {
        iVar3 = strcasecmp(*(char **)(param_3 + 8),"initiator");
        if (iVar3 == 0) {
          local_28 = 2;
        }
        else {
          iVar3 = strcasecmp(*(char **)(param_3 + 8),"target");
          if (iVar3 == 0) {
            local_28 = 3;
          }
          else {
            iVar3 = strcasecmp(*(char **)(param_3 + 8),"neutral");
            if (iVar3 != 0) {
              return -0x2c;
            }
            local_28 = 0x8001;
          }
        }
        if (*(int *)(param_3 + 0xc) != 0) {
          if ((**(char **)(param_3 + 0xc) == 'R') || (**(char **)(param_3 + 0xc) == 'r')) {
            local_28 = local_28 | 0x8000;
          }
          else if ((**(char **)(param_3 + 0xc) == 'u') || (**(char **)(param_3 + 0xc) == 'U')) {
            local_28 = local_28 & 0x7fff;
          }
        }
      }
    }
    local_10 = uVar1;
    if (DAT_0055c140 != '\0') {
      local_28 = local_28 << 8 | local_28 >> 8;
      local_10 = uVar1 << 8 | uVar1 >> 8;
    }
    local_e = local_28;
    iVar3 = FUN_00445444(param_1,(char *)*param_2,&local_10,4);
  }
  return iVar3;
}



int FUN_004d5364(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  char *param1;
  byte *local_18;
  undefined4 local_14;
  undefined1 local_10;
  undefined2 local_e;
  
  bzero(&local_14,0xc);
  local_14 = 2;
  local_10 = 4;
  local_e = (undefined2)param_3;
  iVar1 = FUN_00445198(param_1,(char *)*param_2,&local_14,0xc,&local_18);
  if (iVar1 == 0) {
    if (param_3 == 0) {
      puts("\n/* Debug Informations */");
    }
    if (local_18[2] == 0) {
      param1 = "TX";
    }
    else {
      param1 = "RX";
    }
    printf("%s[%u,%u]: type %u action(%u,%u) token(%u, %u)\n",param1,(uint)*local_18,
           (uint)local_18[1],(uint)local_18[3],(uint)local_18[4],(uint)local_18[5],(uint)local_18[6]
           ,(uint)local_18[7]);
    if ((*(short *)(local_18 + 10) == 0) && (*(short *)(local_18 + 0xc) == 0)) {
      putchar(10);
      iVar1 = 0;
    }
    else {
      printf("Index=%d\n",(uint)*(ushort *)(local_18 + 8));
      printf("M_TOF_CMD=0x%04x\tM_TOF_RSP=0x%04x\tM_TOF_ID=0x%04x\n",
             (uint)*(ushort *)(local_18 + 10),(uint)*(ushort *)(local_18 + 0xc),
             (uint)*(ushort *)(local_18 + 0x16));
      printf("M_TOF_AVB_RX_L=0x%04x\tM_TOF_AVB_RX_H=0x%04x\t",(uint)*(ushort *)(local_18 + 0xe),
             (uint)*(ushort *)(local_18 + 0x10));
      printf("M_TOF_AVB_TX_L=0x%04x\tM_TOF_AVB_TX_H=0x%04x\n",(uint)*(ushort *)(local_18 + 0x12),
             (uint)*(ushort *)(local_18 + 0x14));
      printf("M_TOF_STATUS0=0x%04x\tM_TOF_STATUS2=0x%04x\t",(uint)*(ushort *)(local_18 + 0x18),
             (uint)*(ushort *)(local_18 + 0x1a));
      printf("M_TOF_CHNSM_0=0x%04x\tM_TOF_CHNSM_1=0x%04x\n",(uint)*(ushort *)(local_18 + 0x1c),0);
      printf("M_TOF_PHYCTL0=0x%04x\tM_TOF_PHYCTL1=0x%04x\tM_TOF_PHYCTL2=0x%04x\n",
             (uint)*(ushort *)(local_18 + 0x1e),(uint)*(ushort *)(local_18 + 0x20),
             (uint)*(ushort *)(local_18 + 0x22));
      printf("M_TOF_LSIG=0x%04x\tM_TOF_VHTA0=0x%04x\tM_TOF_VHTA1=0x%04x\n",
             (uint)*(ushort *)(local_18 + 0x24),(uint)*(ushort *)(local_18 + 0x26),
             (uint)*(ushort *)(local_18 + 0x28));
      printf("M_TOF_VHTA2=0x%04x\tM_TOF_VHTB0=0x%04x\tM_TOF_VHTB1=0x%04x\n",
             (uint)*(ushort *)(local_18 + 0x2a),(uint)*(ushort *)(local_18 + 0x2c),
             (uint)*(ushort *)(local_18 + 0x2e));
      printf("M_TOF_AMPDU_CTL=0x%04x\tM_TOF_AMPDU_DLIM=0x%04x\tM_TOF_AMPDU_LEN=0x%04x\n\n",
             (uint)*(ushort *)(local_18 + 0x30),(uint)*(ushort *)(local_18 + 0x32),
             (uint)*(ushort *)(local_18 + 0x34));
      iVar1 = 0;
    }
  }
  return iVar1;
}



void FUN_004d5878(ushort *param_1)

{
  char *pcVar1;
  int local_10;
  
  printf("total_frames %lu\n",(uint)*param_1);
  printf("nfft %lu\n",(uint)param_1[1]);
  printf("bandwidth %lu\n",(uint)param_1[2]);
  printf("channel %lu\n",(uint)param_1[3]);
  printf("chanspec %lu\n",*(ulong *)(param_1 + 4));
  printf("fpfactor %lu\n",*(ulong *)(param_1 + 6));
  printf("fpfactor_shift %lu\n",(uint)param_1[8]);
  printf("distance %li\n",*(long *)(param_1 + 9));
  printf("meanrtt %lu\n",*(ulong *)(param_1 + 0xb));
  printf("modertt %lu\n",*(ulong *)(param_1 + 0xd));
  printf("medianrtt %lu\n",*(ulong *)(param_1 + 0xf));
  printf("sdrtt %lu\n",*(ulong *)(param_1 + 0x11));
  printf("clkdivisor %lu\n",*(ulong *)(param_1 + 0x13));
  printf("chipnum %lu\n",(uint)param_1[0x15]);
  printf("chiprev %lu\n",(uint)(byte)param_1[0x16]);
  printf("phyver %lu\n",(uint)*(byte *)((int)param_1 + 0x2d));
  pcVar1 = FUN_0041d780((int)(param_1 + 0x17));
  printf("loaclMacAddr %s\n",pcVar1);
  pcVar1 = FUN_0041d780((int)(param_1 + 0x1a));
  printf("remoteMacAddr %s\n",pcVar1);
  printf("params_Ki %lu\n",*(ulong *)(param_1 + 0x1d));
  printf("params_Kt %lu\n",*(ulong *)(param_1 + 0x1f));
  printf("params_vhtack %li\n",(int)(short)param_1[0x21]);
  printf("params_N_log2 %d\n",3);
  for (local_10 = 0; local_10 < 3; local_10 = local_10 + 1) {
    printf("%li\n",(int)(short)param_1[local_10 + 0x22]);
  }
  printf("params_N_scale %d\n",3);
  for (local_10 = 0; local_10 < 3; local_10 = local_10 + 1) {
    printf("%li\n",(int)*(short *)((int)param_1 + (local_10 + 0x34) * 2 + 3));
  }
  printf("params_sw_adj %lu\n",(uint)*(byte *)((int)param_1 + 0x75));
  printf("params_hw_adj %lu\n",(uint)(byte)param_1[0x3b]);
  printf("params_seq_en %lu\n",(uint)*(byte *)((int)param_1 + 0x77));
  printf("params_core %lu\n",(uint)*(byte *)((int)param_1 + 0x69));
  puts("params_N_log2_seq 2");
  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {
    printf("%li\n",(int)(short)param_1[local_10 + 0x25]);
  }
  puts("params_N_scale_seq 2");
  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {
    printf("%li\n",(int)*(short *)((int)param_1 + (local_10 + 0x37) * 2 + 3));
  }
  printf("params_w_offset %d\n",3);
  for (local_10 = 0; local_10 < 3; local_10 = local_10 + 1) {
    printf("%li\n",(int)(short)param_1[local_10 + 0x27]);
  }
  printf("params_w_len %d\n",3);
  for (local_10 = 0; local_10 < 3; local_10 = local_10 + 1) {
    printf("%li\n",(int)(short)param_1[local_10 + 0x2a]);
  }
  printf("params_maxDT %li\n",*(long *)(param_1 + 0x2d));
  printf("params_minDT %li\n",*(long *)(param_1 + 0x2f));
  printf("params_totalfrmcnt %lu\n",(uint)(byte)param_1[0x31]);
  printf("params_rsv_media %lu\n",(uint)*(ushort *)((int)param_1 + 99));
  return;
}



void FUN_004d6000(ushort *param_1)

{
  short sVar1;
  int local_10;
  
  printf("info_type %lu\n",(uint)*param_1);
  printf("info_index %lu\n",(uint)param_1[1]);
  printf("info_tof_cmd %lu\n",(uint)param_1[2]);
  printf("info_tof_rsp %lu\n",(uint)param_1[3]);
  printf("info_tof_avb_rxl %lu\n",(uint)param_1[4]);
  printf("info_tof_avb_rxh %lu\n",(uint)param_1[5]);
  printf("info_tof_avb_txl %lu\n",(uint)param_1[6]);
  printf("info_tof_avb_txh %lu\n",(uint)param_1[7]);
  printf("info_tof_id %lu\n",(uint)param_1[8]);
  printf("info_tof_frame_type %lu\n",(uint)(byte)param_1[9]);
  printf("info_tof_frame_bw %lu\n",(uint)*(byte *)((int)param_1 + 0x13));
  printf("info_tof_rssi %li\n",(int)(char)param_1[10]);
  printf("info_tof_cfo %li\n",*(long *)((int)param_1 + 0x15));
  printf("info_gd_adj_ns %li\n",*(long *)((int)param_1 + 0x19));
  printf("info_gd_h_adj_ns %li\n",*(long *)((int)param_1 + 0x1d));
  printf("info_nfft %li\n",(int)*(short *)((int)param_1 + 0x21));
  sVar1 = *(short *)((int)param_1 + 0x21);
  printf("H %d\n",(int)sVar1);
  for (local_10 = 0; local_10 < sVar1; local_10 = local_10 + 1) {
    printf("%lu\n",*(ulong *)((int)param_1 + (local_10 + 8) * 4 + 3));
  }
  return;
}



int FUN_004d6354(int *param_1,undefined4 *param_2,FILE *param_3,undefined2 param_4)

{
  ushort *puVar1;
  int iVar2;
  size_t __n;
  size_t param3;
  ushort *local_18;
  undefined4 local_14;
  undefined1 local_10;
  undefined2 local_e;
  
  bzero(&local_14,0xc);
  local_14 = 2;
  local_10 = 3;
  local_e = param_4;
  iVar2 = FUN_00445198(param_1,(char *)*param_2,&local_14,0xc,&local_18);
  puVar1 = local_18;
  if (iVar2 == 0) {
    FUN_004d6000(local_18);
    __n = (*(short *)((int)puVar1 + 0x21) + -0x111) * 4 + 0x467;
    param3 = fwrite(local_18,1,__n,param_3);
    if (param3 == __n) {
      iVar2 = 0;
    }
    else {
      fprintf(stderr,"Error writing %d bytes to file, rc %d!\n",__n,param3);
      iVar2 = -1;
    }
  }
  return iVar2;
}



int FUN_004d64b8(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  bool bVar2;
  bool bVar3;
  ushort *puVar4;
  ushort *puVar5;
  ushort uVar6;
  int iVar7;
  size_t param2;
  double in_f12_13;
  int *local_res8;
  int local_58;
  char *local_54;
  FILE *local_50;
  int local_4c;
  ushort *local_30;
  undefined4 local_2c;
  undefined1 local_28;
  undefined1 local_27;
  char acStack_20 [20];
  undefined4 local_c;
  
  local_54 = "proxd_collect.dat";
  local_50 = (FILE *)0x0;
  bVar3 = false;
  bVar2 = false;
  local_c = 0xbf800000;
  bzero(&local_2c,0xc);
  local_2c = 2;
  local_res8 = (int *)(param_3 + 4);
  while (*local_res8 != 0) {
    iVar7 = strcmp((char *)*local_res8,"disable");
    if ((iVar7 == 0) || (*(char *)*local_res8 == '0')) {
      local_28 = 1;
      local_27 = 0;
      iVar7 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
      return iVar7;
    }
    iVar7 = strcmp((char *)*local_res8,"enable");
    if ((iVar7 == 0) || (*(char *)*local_res8 == '1')) {
      local_28 = 1;
      local_27 = 1;
      iVar7 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
      return iVar7;
    }
    iVar7 = strcmp((char *)*local_res8,"debug");
    if ((iVar7 == 0) || (*(char *)*local_res8 == '2')) {
      local_28 = 1;
      local_27 = 2;
      iVar7 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
      return iVar7;
    }
    iVar7 = strcmp((char *)*local_res8,"-l");
    if (iVar7 == 0) {
      bVar3 = true;
      local_res8 = local_res8 + 1;
    }
    else {
      iVar7 = strcmp((char *)*local_res8,"-r");
      if (iVar7 == 0) {
        bVar2 = true;
        local_res8 = local_res8 + 1;
      }
      else {
        iVar7 = strcmp((char *)*local_res8,"-f");
        if (iVar7 == 0) {
          if (local_res8[1] == 0) {
            return -1;
          }
          local_54 = (char *)local_res8[1];
          local_res8 = local_res8 + 2;
        }
        else {
          iVar7 = strcmp((char *)*local_res8,"-d");
          if (iVar7 != 0) {
            return -1;
          }
          if (local_res8[1] == 0) {
            return -1;
          }
          sscanf((char *)local_res8[1],"%f",(double *)&local_c);
          local_res8 = local_res8 + 2;
        }
      }
    }
  }
  local_28 = 0;
  local_58 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
  puVar4 = local_30;
  if (local_58 == 0) {
    if (*(char *)((int)local_30 + 5) == '\0') {
      puts("Disable");
      local_58 = 0;
    }
    else if ((char)local_30[5] == '\0') {
      if ((local_30[4] == 3) && ((bVar2 || (bVar3)))) {
        puts("Unsupport");
        local_58 = 0;
      }
      else {
        if ((bVar2) && (*(char *)((int)local_30 + 0xb) == '\0')) {
          puts("Remote data have not ready, please run this command again");
          bVar3 = true;
        }
        else if ((bVar3) && (*(char *)((int)local_30 + 0xb) != '\0')) {
          puts("Local data have not ready, please run command \'proxd_find\' to get it");
        }
        else {
          local_28 = 2;
          iVar7 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
          puVar5 = local_30;
          if (iVar7 != 0) {
            return iVar7;
          }
          uVar1 = *local_30;
          if ((uVar1 == 0) && (*(char *)((int)puVar4 + 5) == '\x01')) {
            puts("Enable");
            local_58 = 0;
          }
          else {
            uVar6 = FUN_00402de8((ushort)*(undefined4 *)(local_30 + 4));
            FUN_004c02bc(uVar6,acStack_20);
            printf("d_ref %5.1f\n",in_f12_13);
            FUN_004d5878(puVar5);
            local_50 = fopen(local_54,"wb");
            if (local_50 == (FILE *)0x0) {
              fprintf(stderr,"Problem opening file %s\n",local_54);
              return 0;
            }
            param2 = fwrite(local_30,1,0x81,local_50);
            if (param2 == 0x81) {
              for (local_4c = 0; local_4c < (int)(uint)uVar1; local_4c = local_4c + 1) {
                local_58 = FUN_004d6354(param_1,param_2,local_50,(short)local_4c);
                if (local_58 != 0) goto LAB_004d6c6c;
              }
              local_4c = 0;
              while ((local_4c < 0x100 &&
                     (iVar7 = FUN_004d5364(param_1,param_2,local_4c), iVar7 == 0))) {
                local_4c = local_4c + 1;
              }
              local_58 = 0;
              if (!bVar3) {
                local_28 = 6;
                FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
              }
            }
            else {
              fprintf(stderr,"Error writing to file rc %d\n",param2);
              local_58 = -1;
            }
          }
        }
LAB_004d6c6c:
        if ((local_58 == 0) && (bVar3)) {
          local_28 = 5;
          local_58 = FUN_00445198(param_1,(char *)*param_2,&local_2c,0xc,&local_30);
        }
        if (local_50 != (FILE *)0x0) {
          fclose(local_50);
        }
      }
    }
    else {
      puts("Busy");
      local_58 = 0;
    }
  }
  return local_58;
}



undefined4 FUN_004d6cf0(int param_1)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  long lVar8;
  undefined4 uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  char *local_38;
  uint local_30;
  uint local_2c;
  int local_28;
  int local_24;
  uint local_20;
  uint local_18;
  char *local_c;
  
  bVar2 = false;
  bVar3 = false;
  bVar4 = false;
  local_30 = 0;
  local_2c = 0;
  local_28 = 0;
  local_24 = 0;
  bVar5 = false;
  bVar6 = false;
  bVar7 = false;
  local_20 = 0;
  local_38 = *(char **)(param_1 + 0x94);
  local_c = (char *)0x0;
  if ((*local_38 != 'h') && (*local_38 != 'v')) {
    lVar8 = strtol(local_38,&local_c,10);
    if (lVar8 == 0) {
      return 0xffffffff;
    }
    local_30 = lVar8 * 2;
    if ((*local_c == '.') && (local_c[1] == '5')) {
      local_30 = local_30 + 1;
      local_c = local_c + 2;
    }
    local_38 = local_c;
    bVar2 = true;
  }
  while (local_38 != (char *)0x0) {
    cVar1 = *local_38;
    local_38 = local_38 + 1;
    if (cVar1 == '\0') break;
    if (cVar1 == 'h') {
      bVar3 = true;
      local_2c = strtol(local_38,&local_c,10);
      if (((int)local_2c < 0) || (0x17 < (int)local_2c)) {
        printf("HT MCS index %d out of range [0-23].\n",local_2c);
        return 0xffffffff;
      }
      local_38 = local_c;
    }
    else if (cVar1 == 'v') {
      bVar4 = true;
      local_2c = strtol(local_38,&local_c,10);
      if (((int)local_2c < 0) || (9 < (int)local_2c)) {
        printf("HT MCS index %d out of range [0-9].\n",local_2c);
        return 0xffffffff;
      }
      local_38 = local_c;
    }
    else if (cVar1 == 'x') {
      local_28 = strtol(local_38,&local_c,10);
      if ((local_28 < 1) || (8 < local_28)) {
        printf("Nss %d out of range [1-8].\n",local_28);
        return 0xffffffff;
      }
      local_38 = local_c;
    }
    else if (cVar1 == 'e') {
      local_24 = strtol(local_38,&local_c,10);
      if ((local_24 < 0) || (3 < local_24)) {
        printf("tx expansion %d out of range [0-3].\n",local_24);
        return 0xffffffff;
      }
      local_38 = local_c;
    }
    else if (cVar1 == 's') {
      bVar5 = true;
    }
    else if (cVar1 == 'l') {
      bVar6 = true;
    }
    else if (cVar1 == 'g') {
      bVar7 = true;
    }
    else if (cVar1 == 'b') {
      lVar8 = strtol(local_38,&local_c,10);
      if (lVar8 == 0x14) {
        local_20 = 0x10000;
      }
      else if (lVar8 == 0x28) {
        local_20 = 0x20000;
      }
      else if (lVar8 == 0x50) {
        local_20 = 0x30000;
      }
      else {
        if (lVar8 != 0xa0) {
          printf("unexpected bandwidth specified \"%d\", expected 20, 40, 80, or 160\n",lVar8);
          return 0xffffffff;
        }
        local_20 = 0x40000;
      }
      local_38 = local_c;
    }
  }
  if (((bVar2) || (bVar3)) || (bVar4)) {
    if ((bVar2) && ((bVar3 || (bVar4)))) {
      puts("cannot use legacy rate and HT rate or VHT rate at the same time");
      uVar9 = 0xffffffff;
    }
    else if ((bVar3) && (bVar4)) {
      puts("cannot use HT rate hM and HT rate vM[xS] at the same time");
      uVar9 = 0xffffffff;
    }
    else if ((bVar4) || (local_28 == 0)) {
      if ((((!bVar5) && ((!bVar6 && (!bVar7)))) || (bVar3)) || (bVar4)) {
        if (bVar2) {
          local_18 = local_30;
        }
        else if (bVar3) {
          local_18 = local_2c | 0x1000000;
        }
        else {
          if (local_28 == 0) {
            local_28 = 1;
          }
          local_18 = local_28 << 4 | local_2c | 0x2000000;
        }
        if (bVar5) {
          uVar10 = 0x100000;
        }
        else {
          uVar10 = 0;
        }
        if (bVar6) {
          uVar11 = 0x400000;
        }
        else {
          uVar11 = 0;
        }
        if (bVar7) {
          uVar12 = 0x800000;
        }
        else {
          uVar12 = 0;
        }
        *(uint *)(param_1 + 0x98) = local_18 | local_24 << 8 | local_20 | uVar10 | uVar11 | uVar12;
        uVar9 = 0;
      }
      else {
        puts("cannot use STBC/LDPC/SGI options with non HT/VHT rates");
        uVar9 = 0xffffffff;
      }
    }
    else {
      puts("cannot use xS option with non VHT rate");
      uVar9 = 0xffffffff;
    }
  }
  else {
    puts("must specify one of legacy rate, HT (11n) rate hM, or VHT (11ac) rate vM[xS]");
    uVar9 = 0xffffffff;
  }
  return uVar9;
}



undefined4 FUN_004d73f4(undefined4 *param_1,int param_2,short *param_3)

{
  ushort uVar1;
  
  if (*(char *)(param_2 + 0x12) == 'c') {
    uVar1 = FUN_004c0638(*(char **)(param_2 + 0x94));
    if (uVar1 == 0) {
      fprintf(stderr,"%s: could not parse \"%s\" as a channel\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xfffffffe;
    }
    uVar1 = FUN_00402c2c(uVar1);
    *(char *)param_3 = (char)uVar1;
    *(char *)((int)param_3 + 1) = (char)(uVar1 >> 8);
    if (*param_3 == 0xff) {
      fprintf(stderr,"%s: wl_chspec_to_driver() error \"%s\" \n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xfffffffe;
    }
  }
  else {
    if (*(char *)(param_2 + 0x12) != 't') {
      return 0xffffffd4;
    }
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as a timeout\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(char *)(param_3 + 3) = (char)uVar1;
    *(char *)((int)param_3 + 7) = (char)(uVar1 >> 8);
  }
  return 0;
}



undefined4 FUN_004d7644(undefined4 *param_1,int param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  undefined3 extraout_var;
  int iVar3;
  undefined4 local_10;
  undefined1 local_c;
  undefined1 local_b;
  
  if (*(char *)(param_2 + 0x12) == 'g') {
    bVar1 = FUN_0041d6ac(*(char **)(param_2 + 0x94),&local_10);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      fprintf(stderr,"%s: could not parse \"%s\" as MAC address\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    *(undefined4 *)(param_3 + 0xc) = local_10;
    *(undefined1 *)(param_3 + 0x10) = local_c;
    *(undefined1 *)(param_3 + 0x11) = local_b;
  }
  else if (*(char *)(param_2 + 0x12) == 'f') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as FTM frame count\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar2 = uVar2 << 8 | uVar2 >> 8;
    }
    *(char *)(param_3 + 0x12) = (char)uVar2;
    *(char *)(param_3 + 0x13) = (char)(uVar2 >> 8);
  }
  else if (*(char *)(param_2 + 0x12) == 'y') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as Retry Count\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar2 = uVar2 << 8 | uVar2 >> 8;
    }
    *(char *)(param_3 + 0x14) = (char)uVar2;
    *(char *)(param_3 + 0x15) = (char)(uVar2 >> 8);
  }
  else {
    if (*(char *)(param_2 + 0x12) != 'r') {
      return 0xffffffd4;
    }
    if (*(char *)(param_2 + 0x11) == '\0') {
      iVar3 = strcmp(*(char **)(param_2 + 0x94),"5.5");
      if (iVar3 == 0) {
        *(undefined4 *)(param_2 + 0x98) = 0xb;
      }
      else {
        iVar3 = FUN_004d6cf0(param_2);
        if (iVar3 != 0) {
          fprintf(stderr,"%s: could not parse \"%s\" as a rate\n",(char *)*param_1,
                  *(char **)(param_2 + 0x94));
          return 0xffffffd4;
        }
      }
    }
    else {
      *(int *)(param_2 + 0x98) = *(int *)(param_2 + 0x98) << 1;
    }
    if (DAT_0055c140 == '\0') {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x98);
    }
    else {
      uVar2 = (ushort)*(undefined4 *)(param_2 + 0x98);
      uVar2 = uVar2 << 8 | uVar2 >> 8;
    }
    *(char *)(param_3 + 4) = (char)uVar2;
    *(char *)(param_3 + 5) = (char)(uVar2 >> 8);
    if (DAT_0055c140 == '\0') {
      uVar2 = (ushort)((uint)*(undefined4 *)(param_2 + 0x98) >> 0x10);
    }
    else {
      uVar2 = (ushort)((uint)*(undefined4 *)(param_2 + 0x98) >> 0x10);
      uVar2 = uVar2 << 8 | uVar2 >> 8;
    }
    *(char *)(param_3 + 0x16) = (char)uVar2;
    *(char *)(param_3 + 0x17) = (char)(uVar2 >> 8);
  }
  return 0;
}



undefined4 FUN_004d7b00(undefined4 *param_1,int param_2,int param_3)

{
  ushort uVar1;
  int iVar2;
  
  if (*(char *)(param_2 + 0x12) == 'i') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as an interval\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 8) = uVar1;
  }
  else if (*(char *)(param_2 + 0x12) == 'd') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as a duration\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 10) = uVar1;
  }
  else if (*(char *)(param_2 + 0x12) == 'p') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as a power\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 2) = uVar1;
  }
  else if (*(char *)(param_2 + 0x12) == 's') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as a RSSI\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 0xc) = uVar1;
  }
  else if (*(char *)(param_2 + 0x12) == 'm') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as a maxconvergetime\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 0xe) = uVar1;
  }
  else {
    if (*(char *)(param_2 + 0x12) != 'r') {
      return 0xffffffd4;
    }
    if (*(char *)(param_2 + 0x11) == '\0') {
      iVar2 = strcmp(*(char **)(param_2 + 0x94),"5.5");
      if (iVar2 != 0) {
        fprintf(stderr,"%s: could not parse \"%s\" as a rate\n",(char *)*param_1,
                *(char **)(param_2 + 0x94));
        return 0xffffffd4;
      }
      *(undefined4 *)(param_2 + 0x9c) = 0xb;
    }
    else {
      *(int *)(param_2 + 0x9c) = *(int *)(param_2 + 0x9c) << 1;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar1 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar1 = uVar1 << 8 | uVar1 >> 8;
    }
    *(ushort *)(param_3 + 4) = uVar1;
  }
  return 0;
}



int FUN_004d8048(int *param_1,undefined4 *param_2,int param_3)

{
  void *pvVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  ushort uVar5;
  int iVar6;
  uint uVar7;
  char *pcVar8;
  int *local_res8;
  int local_18c;
  ushort local_150;
  short asStack_14e [4];
  ushort local_146;
  ushort local_144;
  void *local_104;
  undefined4 auStack_100 [3];
  int local_f4;
  uchar local_ee;
  char acStack_60 [20];
  char acStack_4c [68];
  
  local_104 = (void *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("missing mandatory parameter \'method\'\n",1,0x25,stderr);
    iVar6 = -0x2c;
  }
  else {
    uVar7 = atoi(*(char **)(param_3 + 4));
    uVar3 = (ushort)uVar7;
    if (uVar3 == 0) {
      fwrite("invalid parameter \'method\'\n",1,0x1b,stderr);
      iVar6 = -0x2c;
    }
    else {
      bzero(&local_150,0x4a);
      local_150 = uVar3;
      if (DAT_0055c140 != '\0') {
        local_150 = uVar3 << 8 | uVar3 >> 8;
      }
      iVar6 = FUN_0044527c(param_1,(char *)*param_2,&local_150,0x4a,&local_104);
      pvVar1 = local_104;
      if (iVar6 == 0) {
        local_res8 = (int *)(param_3 + 8);
        if (*local_res8 == 0) {
          printf("bf proxd_params.method:%d\n",(uint)local_150);
          if (local_150 == 1) {
            uVar3 = FUN_00402de8(*(ushort *)((int)pvVar1 + 2));
            if (DAT_0055c140 == '\0') {
              uVar2 = *(ushort *)((int)pvVar1 + 6);
            }
            else {
              uVar2 = *(ushort *)((int)pvVar1 + 6) << 8 | *(ushort *)((int)pvVar1 + 6) >> 8;
            }
            FUN_004c02bc(uVar3,acStack_60);
            printf("channel=%s\n",acStack_60);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 10);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 10) << 8 | *(ushort *)((int)pvVar1 + 10) >> 8;
            }
            printf("interval=%d TU\n",(uint)uVar3);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 0xc);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 0xc) << 8 | *(ushort *)((int)pvVar1 + 0xc) >> 8;
            }
            printf("duration=%d ms\n",(uint)uVar3);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 0xe);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 0xe) << 8 | *(ushort *)((int)pvVar1 + 0xe) >> 8;
            }
            printf("rssi_thresh=%d dBm\n",(int)(short)uVar3);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 0x10);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 0x10) << 8 | *(ushort *)((int)pvVar1 + 0x10) >> 8;
            }
            printf("maxconvergetime=%d ms\n\n",(uint)uVar3);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 4);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 4) << 8 | *(ushort *)((int)pvVar1 + 4) >> 8;
            }
            printf("tx_power=%d dBm\n",(int)(short)uVar3);
            if ((uVar2 & 1) == 0) {
              pcVar8 = "";
            }
            else {
              pcVar8 = ".5";
            }
            printf("tx_rate=%d%s Mbps\n",(uint)(uVar2 >> 1),pcVar8);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 8);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 8) << 8 | *(ushort *)((int)pvVar1 + 8) >> 8;
            }
            printf("timeout=%d ms\n",(uint)uVar3);
          }
          else if (local_150 == 2) {
            uVar3 = FUN_00402de8(*(ushort *)((int)pvVar1 + 2));
            if (DAT_0055c140 == '\0') {
              uVar4 = *(ushort *)((int)pvVar1 + 6);
              uVar2 = *(ushort *)((int)pvVar1 + 0x18);
            }
            else {
              uVar4 = *(ushort *)((int)pvVar1 + 6) << 8 | *(ushort *)((int)pvVar1 + 6) >> 8;
              uVar2 = *(ushort *)((int)pvVar1 + 0x18) << 8 | *(ushort *)((int)pvVar1 + 0x18) >> 8;
            }
            FUN_004c02bc(uVar3,acStack_60);
            FUN_00415e70(acStack_4c,CONCAT22(uVar2,uVar4));
            pcVar8 = FUN_0041d780((int)pvVar1 + 0xe);
            printf("tgt_mac=%s \n",pcVar8);
            if (DAT_0055c140 == '\0') {
              uVar5 = *(ushort *)((int)pvVar1 + 0x14);
            }
            else {
              uVar5 = *(ushort *)((int)pvVar1 + 0x14) << 8 | *(ushort *)((int)pvVar1 + 0x14) >> 8;
            }
            printf("ftm_cnt= %d\n",(uint)uVar5);
            printf("channel=%s (0x%04x)\n",acStack_60,(uint)uVar3);
            printf("tx_rate=%s (0x%08x)\n",acStack_4c,CONCAT22(uVar2,uVar4));
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 8);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 8) << 8 | *(ushort *)((int)pvVar1 + 8) >> 8;
            }
            printf("timeout=%d ms\n",(uint)uVar3);
            if (DAT_0055c140 == '\0') {
              uVar3 = *(ushort *)((int)pvVar1 + 0x16);
            }
            else {
              uVar3 = *(ushort *)((int)pvVar1 + 0x16) << 8 | *(ushort *)((int)pvVar1 + 0x16) >> 8;
            }
            printf("retry_cnt=%d \n",(uint)uVar3);
          }
          else {
            fprintf(stderr,"%s: ERROR undefined method \n",(char *)*param_2);
            iVar6 = -2;
          }
        }
        else {
          memcpy(&local_150,local_104,0x4a);
          local_150 = uVar3;
          FUN_004cbd80(auStack_100,*param_2,0,0);
          do {
            iVar6 = FUN_004cbe18(auStack_100,local_res8);
            if (iVar6 == -1) {
              if (DAT_0055c140 != '\0') {
                local_146 = local_146 << 8 | local_146 >> 8;
                local_144 = local_144 << 8 | local_144 >> 8;
              }
              if (local_146 < local_144) {
                fprintf(stderr,"%s: \'interval\' cannot be shorter than \'duration\'\n",
                        (char *)*param_2);
                return -2;
              }
              iVar6 = FUN_00445444(param_1,(char *)*param_2,&local_150,0x4a);
              return iVar6;
            }
            if (iVar6 == 1) {
              return -0x2c;
            }
            local_res8 = local_res8 + local_f4;
            iVar6 = FUN_004d73f4(param_2,(int)auStack_100,asStack_14e);
            if (uVar3 == 1) {
              local_18c = FUN_004d7b00(param_2,(int)auStack_100,(int)asStack_14e);
            }
            else {
              if (uVar3 != 2) {
                puts("ERROR: unsupported method");
                return -0x2c;
              }
              local_18c = FUN_004d7644(param_2,(int)auStack_100,(int)asStack_14e);
              if (local_18c == -2) {
                return -2;
              }
            }
          } while ((iVar6 == 0) || (local_18c == 0));
          printf(">>>> Method:%d doesn\'t support cmd option:\'%c\'\n",uVar7 & 0xffff,local_ee);
          iVar6 = -0x2c;
        }
      }
    }
  }
  return iVar6;
}



void FUN_004d8b4c(char *param_1,int *param_2,long *param_3,undefined4 *param_4)

{
  char *pcVar1;
  size_t sVar2;
  long lVar3;
  int *local_res4;
  long *local_res8;
  undefined4 *local_resc;
  
  local_res8 = param_3;
  local_resc = param_4;
  for (local_res4 = param_2; *local_res4 != 0; local_res4 = local_res4 + 1) {
    pcVar1 = strstr(param_1,(char *)*local_res4);
    if (pcVar1 == (char *)0x0) {
      *local_resc = 0;
    }
    else {
      sVar2 = strlen((char *)*local_res4);
      *local_resc = 1;
      lVar3 = strtol(pcVar1 + sVar2,(char **)0x0,10);
      *local_res8 = lVar3;
    }
    local_resc = local_resc + 1;
    local_res8 = local_res8 + 1;
  }
  return;
}



undefined4 FUN_004d8c44(undefined4 *param_1,int param_2,uint *param_3)

{
  bool bVar1;
  undefined1 uVar2;
  ushort uVar3;
  char *pcVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  int local_b0;
  char *local_ac;
  int local_a8;
  char *local_a4;
  int local_a0;
  char *local_9c;
  int local_98;
  undefined *local_58;
  undefined *local_54;
  undefined *local_50;
  undefined4 local_4c;
  long local_48 [3];
  int local_3c;
  int local_38;
  int local_34;
  undefined *local_30;
  undefined *local_2c;
  undefined *local_28;
  undefined4 local_24;
  long local_20 [3];
  int local_14;
  int local_10;
  int local_c;
  
  if (*(char *)(param_2 + 0x12) == 'k') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      pcVar4 = strchr(*(char **)(param_2 + 0x94),0x2c);
      if (pcVar4 == (char *)0x0) {
        fprintf(stderr,"%s: could not parse \"%s\" as K\n",(char *)*param_1,
                *(char **)(param_2 + 0x94));
        return 0xffffffd4;
      }
      if (DAT_0055c140 == '\0') {
        uVar5 = atoi(*(char **)(param_2 + 0x94));
      }
      else {
        uVar5 = atoi(*(char **)(param_2 + 0x94));
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      *param_3 = uVar5;
      if (DAT_0055c140 == '\0') {
        uVar5 = atoi(pcVar4 + 1);
      }
      else {
        uVar5 = atoi(pcVar4 + 1);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      param_3[1] = uVar5;
    }
    else {
      if (DAT_0055c140 == '\0') {
        uVar5 = *(uint *)(param_2 + 0x9c);
      }
      else {
        uVar5 = *(uint *)(param_2 + 0x9c);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      *param_3 = uVar5;
      if (DAT_0055c140 == '\0') {
        uVar5 = *(uint *)(param_2 + 0x9c);
      }
      else {
        uVar5 = *(uint *)(param_2 + 0x9c);
        uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
      }
      param_3[1] = uVar5;
    }
    *(byte *)(param_3 + 0xc) = (byte)param_3[0xc] | 1;
  }
  else if (*(char *)(param_2 + 0x12) == 'b') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as bcm ack\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar3 = uVar3 << 8 | uVar3 >> 8;
    }
    *(char *)(param_3 + 2) = (char)uVar3;
    *(char *)((int)param_3 + 9) = (char)(uVar3 >> 8);
  }
  else if (*(char *)(param_2 + 0x12) == 'c') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as core\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar2 = (undefined1)*(undefined4 *)(param_2 + 0x9c);
    }
    else {
      uVar2 = (undefined1)((uint)*(undefined4 *)(param_2 + 0x9c) >> 8);
    }
    *(undefined1 *)((int)param_3 + 0x2f) = uVar2;
  }
  else if (*(char *)(param_2 + 0x12) == 'A') {
    local_58 = &DAT_0053cac0;
    local_54 = &DAT_0053cac4;
    local_50 = &DAT_0053cac8;
    local_4c = 0;
    local_48[0] = 0;
    local_48[1] = 0;
    local_48[2] = 0;
    local_3c = 0;
    local_38 = 0;
    local_34 = 0;
    FUN_004d8b4c(*(char **)(param_2 + 0x94),(int *)&local_58,local_48,&local_3c);
    if (local_3c != 0) {
      *(char *)((int)param_3 + 0x3b) = (char)local_48[0];
    }
    if (local_38 != 0) {
      *(char *)(param_3 + 0xf) = (char)local_48[1];
    }
    if (local_34 != 0) {
      *(char *)((int)param_3 + 0x3d) = (char)local_48[2];
    }
    if ((local_3c == 0 && local_38 == 0) && local_34 == 0) {
      fprintf(stderr,"%s: could not parse \"%s\" as hw/sw adjustment enable params\n",
              (char *)*param_1,*(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
  }
  else if (*(char *)(param_2 + 0x12) == 'n') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as min time difference limitation\n",
              (char *)*param_1,*(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar5 = *(uint *)(param_2 + 0x9c);
    }
    else {
      uVar5 = *(uint *)(param_2 + 0x9c);
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    param_3[9] = uVar5;
  }
  else if (*(char *)(param_2 + 0x12) == 'x') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as max time difference limitation\n",
              (char *)*param_1,*(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar5 = *(uint *)(param_2 + 0x9c);
    }
    else {
      uVar5 = *(uint *)(param_2 + 0x9c);
      uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
    }
    param_3[8] = uVar5;
  }
  else if (*(char *)(param_2 + 0x12) == 'N') {
    local_b0 = 0;
    if (*(char *)(param_2 + 0x11) == '\0') {
      local_ac = *(char **)(param_2 + 0x94);
      while ((local_ac != (char *)0x0 && (local_b0 < 5))) {
        if (DAT_0055c140 == '\0') {
          uVar5 = atoi(local_ac);
          bVar1 = (uVar5 & 0xffff) != 0;
        }
        else {
          uVar5 = atoi(local_ac);
          bVar1 = (uVar5 & 0xff) != 0 || (ushort)((ushort)uVar5 >> 8) != 0;
        }
        if (bVar1) {
          if (DAT_0055c140 == '\0') {
            iVar6 = atoi(local_ac);
            uVar3 = (ushort)iVar6;
          }
          else {
            iVar6 = atoi(local_ac);
            uVar3 = (ushort)iVar6 << 8 | (ushort)iVar6 >> 8;
          }
          *(char *)((int)param_3 + (local_b0 + 4) * 2 + 2) = (char)uVar3;
          *(char *)((int)param_3 + (local_b0 + 4) * 2 + 3) = (char)(uVar3 >> 8);
        }
        local_b0 = local_b0 + 1;
        local_ac = strchr(local_ac,0x2c);
        if (local_ac != (char *)0x0) {
          local_ac = local_ac + 1;
        }
      }
      if (local_ac != (char *)0x0) {
        if (DAT_0055c140 == '\0') {
          iVar6 = atoi(local_ac);
          uVar3 = (ushort)iVar6;
        }
        else {
          iVar6 = atoi(local_ac);
          uVar3 = (ushort)iVar6 << 8 | (ushort)iVar6 >> 8;
        }
        *(char *)((int)param_3 + 0x43) = (char)uVar3;
        *(char *)(param_3 + 0x11) = (char)(uVar3 >> 8);
      }
    }
    else {
      for (; local_b0 < 5; local_b0 = local_b0 + 1) {
        if (DAT_0055c140 == '\0') {
          uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
        }
        else {
          uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
          uVar3 = uVar3 << 8 | uVar3 >> 8;
        }
        *(char *)((int)param_3 + (local_b0 + 4) * 2 + 2) = (char)uVar3;
        *(char *)((int)param_3 + (local_b0 + 4) * 2 + 3) = (char)(uVar3 >> 8);
      }
      if (DAT_0055c140 == '\0') {
        uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      }
      else {
        uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
        uVar3 = uVar3 << 8 | uVar3 >> 8;
      }
      *(char *)((int)param_3 + 0x43) = (char)uVar3;
      *(char *)(param_3 + 0x11) = (char)(uVar3 >> 8);
    }
    *(byte *)(param_3 + 0xc) = (byte)param_3[0xc] | 2;
  }
  else if (*(char *)(param_2 + 0x12) == 'S') {
    local_a8 = 0;
    if (*(char *)(param_2 + 0x11) == '\0') {
      local_a4 = *(char **)(param_2 + 0x94);
      while ((local_a4 != (char *)0x0 && (local_a8 < 5))) {
        if (DAT_0055c140 == '\0') {
          uVar5 = atoi(local_a4);
          bVar1 = (uVar5 & 0xffff) != 0;
        }
        else {
          uVar5 = atoi(local_a4);
          bVar1 = (uVar5 & 0xff) != 0 || (ushort)((ushort)uVar5 >> 8) != 0;
        }
        if (bVar1) {
          if (DAT_0055c140 == '\0') {
            iVar6 = atoi(local_a4);
            uVar3 = (ushort)iVar6;
          }
          else {
            iVar6 = atoi(local_a4);
            uVar3 = (ushort)iVar6 << 8 | (ushort)iVar6 >> 8;
          }
          *(char *)((int)param_3 + (local_a8 + 0x18) * 2 + 1) = (char)uVar3;
          *(char *)((int)param_3 + (local_a8 + 0x18) * 2 + 2) = (char)(uVar3 >> 8);
        }
        local_a8 = local_a8 + 1;
        local_a4 = strchr(local_a4,0x2c);
        if (local_a4 != (char *)0x0) {
          local_a4 = local_a4 + 1;
        }
      }
      if (local_a4 != (char *)0x0) {
        if (DAT_0055c140 == '\0') {
          iVar6 = atoi(local_a4);
          uVar3 = (ushort)iVar6;
        }
        else {
          iVar6 = atoi(local_a4);
          uVar3 = (ushort)iVar6 << 8 | (ushort)iVar6 >> 8;
        }
        *(char *)((int)param_3 + 0x45) = (char)uVar3;
        *(char *)((int)param_3 + 0x46) = (char)(uVar3 >> 8);
      }
    }
    else {
      for (; local_a8 < 5; local_a8 = local_a8 + 1) {
        if (DAT_0055c140 == '\0') {
          uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
        }
        else {
          uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
          uVar3 = uVar3 << 8 | uVar3 >> 8;
        }
        *(char *)((int)param_3 + (local_a8 + 0x18) * 2 + 1) = (char)uVar3;
        *(char *)((int)param_3 + (local_a8 + 0x18) * 2 + 2) = (char)(uVar3 >> 8);
      }
      if (DAT_0055c140 == '\0') {
        uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      }
      else {
        uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
        uVar3 = uVar3 << 8 | uVar3 >> 8;
      }
      *(char *)((int)param_3 + 0x45) = (char)uVar3;
      *(char *)((int)param_3 + 0x46) = (char)(uVar3 >> 8);
    }
    *(byte *)(param_3 + 0xc) = (byte)param_3[0xc] | 4;
  }
  else if (*(char *)(param_2 + 0x12) == 'F') {
    local_a0 = 0;
    if (*(char *)(param_2 + 0x11) == '\0') {
      local_9c = *(char **)(param_2 + 0x94);
      while ((local_9c != (char *)0x0 && (local_a0 < 5))) {
        if (DAT_0055c140 == '\0') {
          uVar5 = atoi(local_9c);
          bVar1 = (uVar5 & 0xffff) != 0;
        }
        else {
          uVar5 = atoi(local_9c);
          bVar1 = (uVar5 & 0xff) != 0 || (ushort)((ushort)uVar5 >> 8) != 0;
        }
        if (bVar1) {
          if (DAT_0055c140 == '\0') {
            iVar6 = atoi(local_9c);
            uVar2 = (undefined1)iVar6;
          }
          else {
            iVar6 = atoi(local_9c);
            uVar2 = (undefined1)((uint)iVar6 >> 8);
          }
          *(undefined1 *)((int)param_3 + local_a0 + 0x3e) = uVar2;
        }
        local_a0 = local_a0 + 1;
        local_9c = strchr(local_9c,0x2c);
        if (local_9c != (char *)0x0) {
          local_9c = local_9c + 1;
        }
      }
    }
    else {
      for (; local_a0 < 5; local_a0 = local_a0 + 1) {
        if (DAT_0055c140 == '\0') {
          uVar2 = (undefined1)*(undefined4 *)(param_2 + 0x9c);
        }
        else {
          uVar2 = (undefined1)((uint)*(undefined4 *)(param_2 + 0x9c) >> 8);
        }
        *(undefined1 *)((int)param_3 + local_a0 + 0x3e) = uVar2;
      }
    }
  }
  else if (*(char *)(param_2 + 0x12) == 't') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as total frmcnt\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    *(char *)(param_3 + 10) = (char)*(undefined4 *)(param_2 + 0x9c);
  }
  else if (*(char *)(param_2 + 0x12) == 'r') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as media reserve value\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    uVar7 = *(undefined4 *)(param_2 + 0x9c);
    *(char *)((int)param_3 + 0x29) = (char)uVar7;
    *(char *)((int)param_3 + 0x2a) = (char)((uint)uVar7 >> 8);
  }
  else if (*(char *)(param_2 + 0x12) == 'f') {
    if (*(char *)(param_2 + 0x11) == '\0') {
      fprintf(stderr,"%s: could not parse \"%s\" as flags\n",(char *)*param_1,
              *(char **)(param_2 + 0x94));
      return 0xffffffd4;
    }
    if (DAT_0055c140 == '\0') {
      uVar5 = *(uint *)(param_2 + 0x9c) & 0xffff;
    }
    else {
      uVar3 = (ushort)*(undefined4 *)(param_2 + 0x9c);
      uVar5 = (uint)(ushort)(uVar3 << 8 | uVar3 >> 8);
    }
    *(uint *)((int)param_3 + 0x2b) = uVar5;
  }
  else {
    if (*(char *)(param_2 + 0x12) != 'W') {
      return 0xffffffd4;
    }
    local_30 = &DAT_0053cc04;
    local_2c = &DAT_0053cc08;
    local_28 = &DAT_0053cc0c;
    local_24 = 0;
    local_20[0] = 0;
    local_20[1] = 0;
    local_20[2] = 0;
    local_14 = 0;
    local_10 = 0;
    local_c = 0;
    FUN_004d8b4c(*(char **)(param_2 + 0x94),(int *)&local_30,local_20,&local_14);
    if (local_14 != 0) {
      if (local_20[0] == 0x50) {
        local_98 = 2;
      }
      else if (local_20[0] == 0x28) {
        local_98 = 1;
      }
      else {
        if (local_20[0] != 0x14) {
          fprintf(stderr,"%s: could not parse \"%s\" as window params\n",(char *)*param_1,
                  *(char **)(param_2 + 0x94));
          return 0xffffffd4;
        }
        local_98 = 0;
      }
      if (local_10 != 0) {
        *(char *)((int)param_3 + (local_98 + 0xc) * 2 + 2) = (char)local_20[1];
        *(char *)((int)param_3 + (local_98 + 0xc) * 2 + 3) = (char)((uint)local_20[1] >> 8);
      }
      if (local_c != 0) {
        *(char *)((int)param_3 + (local_98 + 8) * 2 + 4) = (char)local_20[2];
        *(char *)((int)param_3 + (local_98 + 8) * 2 + 5) = (char)((uint)local_20[2] >> 8);
      }
    }
  }
  return 0;
}



int FUN_004da180(int *param_1,undefined4 *param_2,int param_3)

{
  void *pvVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  uint uVar5;
  uint param1;
  uint param2;
  uint param3;
  int iVar6;
  ushort uVar7;
  ushort uVar8;
  uint param5;
  uint param6;
  int *local_res8;
  uint local_13c;
  int local_138;
  ushort local_fc;
  uint auStack_fa [18];
  void *local_b0;
  undefined4 auStack_ac [3];
  int local_a0;
  uchar local_9a;
  
  local_b0 = (void *)0x0;
  if (*(int *)(param_3 + 4) == 0) {
    fwrite("missing mandatory parameter \'method\'\n",1,0x25,stderr);
    local_138 = -0x2c;
  }
  else {
    uVar5 = atoi(*(char **)(param_3 + 4));
    uVar2 = (ushort)uVar5;
    if (uVar2 == 0) {
      fwrite("invalid parameter \'method\'\n",1,0x1b,stderr);
      local_138 = -0x2c;
    }
    else {
      bzero(&local_fc,0x4a);
      local_fc = uVar2;
      if (DAT_0055c140 != '\0') {
        local_fc = uVar2 << 8 | uVar2 >> 8;
      }
      local_138 = FUN_0044527c(param_1,(char *)*param_2,&local_fc,0x4a,&local_b0);
      pvVar1 = local_b0;
      if (local_138 == 0) {
        local_res8 = (int *)(param_3 + 8);
        if (*local_res8 == 0) {
          printf("bf proxd_params.method:%d\n",(uint)local_fc);
          if (local_fc != 1) {
            if (local_fc == 2) {
              if (DAT_0055c140 == '\0') {
                uVar5 = *(uint *)((int)pvVar1 + 2);
              }
              else {
                uVar5 = *(uint *)((int)pvVar1 + 2);
                uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
              }
              printf("Ki=%d \n",uVar5);
              if (DAT_0055c140 == '\0') {
                uVar5 = *(uint *)((int)pvVar1 + 6);
              }
              else {
                uVar5 = *(uint *)((int)pvVar1 + 6);
                uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                        uVar5 >> 0x18;
              }
              printf("Kt=%d \n",uVar5);
              if (DAT_0055c140 == '\0') {
                uVar2 = *(ushort *)((int)pvVar1 + 10);
              }
              else {
                uVar2 = *(ushort *)((int)pvVar1 + 10) << 8 | *(ushort *)((int)pvVar1 + 10) >> 8;
              }
              printf("bcmack=%d \n",(uint)uVar2);
              if (DAT_0055c140 == '\0') {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3f);
              }
              else {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3f) << 8;
              }
              printf("seq_en=%d\n",uVar5);
              printf("core=%d\n",(uint)*(byte *)((int)pvVar1 + 0x31));
              if (DAT_0055c140 == '\0') {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3d);
              }
              else {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3d) << 8;
              }
              printf("sw_adj=%d\n",uVar5);
              if (DAT_0055c140 == '\0') {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3e);
              }
              else {
                uVar5 = (uint)*(byte *)((int)pvVar1 + 0x3e) << 8;
              }
              printf("hw_adj=%d\n",uVar5);
              printf("minDT = %d\n",*(int *)((int)pvVar1 + 0x26));
              printf("maxDT = %d\n",*(int *)((int)pvVar1 + 0x22));
              if (DAT_0055c140 == '\0') {
                uVar2 = *(ushort *)((int)pvVar1 + 0xc);
              }
              else {
                uVar2 = *(ushort *)((int)pvVar1 + 0xc) << 8 | *(ushort *)((int)pvVar1 + 0xc) >> 8;
              }
              if (DAT_0055c140 == '\0') {
                uVar3 = *(ushort *)((int)pvVar1 + 0xe);
              }
              else {
                uVar3 = *(ushort *)((int)pvVar1 + 0xe) << 8 | *(ushort *)((int)pvVar1 + 0xe) >> 8;
              }
              if (DAT_0055c140 == '\0') {
                uVar4 = *(ushort *)((int)pvVar1 + 0x10);
              }
              else {
                uVar4 = *(ushort *)((int)pvVar1 + 0x10) << 8 | *(ushort *)((int)pvVar1 + 0x10) >> 8;
              }
              if (DAT_0055c140 == '\0') {
                uVar7 = *(ushort *)((int)pvVar1 + 0x12);
              }
              else {
                uVar7 = *(ushort *)((int)pvVar1 + 0x12) << 8 | *(ushort *)((int)pvVar1 + 0x12) >> 8;
              }
              if (DAT_0055c140 == '\0') {
                uVar8 = *(ushort *)((int)pvVar1 + 0x14);
              }
              else {
                uVar8 = *(ushort *)((int)pvVar1 + 0x14) << 8 | *(ushort *)((int)pvVar1 + 0x14) >> 8;
              }
              if (DAT_0055c140 == '\0') {
                uVar5 = (*(ushort *)((int)pvVar1 + 0x46) & 0xff) << 8 |
                        (uint)(*(ushort *)((int)pvVar1 + 0x44) >> 8);
              }
              else {
                uVar5 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x44) & 0xff00 |
                                      (ushort)((*(ushort *)((int)pvVar1 + 0x46) & 0xff) << 8) >> 8);
              }
              printf("threshold_log2=%d %d %d seqtx %d seqrx %d 2g %d\n",(uint)uVar2,(uint)uVar3,
                     (uint)uVar4,(uint)uVar7,(uint)uVar8,uVar5);
              if (DAT_0055c140 == '\0') {
                param1 = (*(ushort *)((int)pvVar1 + 0x34) & 0xff) << 8 |
                         (uint)(*(ushort *)((int)pvVar1 + 0x32) >> 8);
                param2 = (*(ushort *)((int)pvVar1 + 0x36) & 0xff) << 8 |
                         (uint)(*(ushort *)((int)pvVar1 + 0x34) >> 8);
                param3 = (*(ushort *)((int)pvVar1 + 0x38) & 0xff) << 8 |
                         (uint)(*(ushort *)((int)pvVar1 + 0x36) >> 8);
                uVar5 = (*(ushort *)((int)pvVar1 + 0x3a) & 0xff) << 8 |
                        (uint)(*(ushort *)((int)pvVar1 + 0x38) >> 8);
                param5 = (*(ushort *)((int)pvVar1 + 0x3c) & 0xff) << 8 |
                         (uint)(*(ushort *)((int)pvVar1 + 0x3a) >> 8);
                param6 = (*(ushort *)((int)pvVar1 + 0x48) & 0xff) << 8 |
                         (uint)(*(ushort *)((int)pvVar1 + 0x46) >> 8);
              }
              else {
                param1 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x32) & 0xff00 |
                                       (ushort)((*(ushort *)((int)pvVar1 + 0x34) & 0xff) << 8) >> 8)
                ;
                param2 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x34) & 0xff00 |
                                       (ushort)((*(ushort *)((int)pvVar1 + 0x36) & 0xff) << 8) >> 8)
                ;
                param3 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x36) & 0xff00 |
                                       (ushort)((*(ushort *)((int)pvVar1 + 0x38) & 0xff) << 8) >> 8)
                ;
                uVar5 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x38) & 0xff00 |
                                      (ushort)((*(ushort *)((int)pvVar1 + 0x3a) & 0xff) << 8) >> 8);
                param5 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x3a) & 0xff00 |
                                       (ushort)((*(ushort *)((int)pvVar1 + 0x3c) & 0xff) << 8) >> 8)
                ;
                param6 = (uint)(ushort)(*(ushort *)((int)pvVar1 + 0x46) & 0xff00 |
                                       (ushort)((*(ushort *)((int)pvVar1 + 0x48) & 0xff) << 8) >> 8)
                ;
              }
              printf("threshold_scale=%d %d %d seqtx %d seqrx %d 2g %d\n",param1,param2,param3,uVar5
                     ,param5,param6);
              printf("total_frmcnt=%d \n",(uint)*(byte *)((int)pvVar1 + 0x2a));
              printf("reserve_media=%d \n",
                     (*(ushort *)((int)pvVar1 + 0x2c) & 0xff) << 8 |
                     (uint)(*(ushort *)((int)pvVar1 + 0x2a) >> 8));
              if (DAT_0055c140 == '\0') {
                uVar5 = *(uint *)((int)pvVar1 + 0x2d) & 0xffff;
              }
              else {
                uVar2 = (ushort)*(undefined4 *)((int)pvVar1 + 0x2d);
                uVar5 = (uint)(ushort)(uVar2 << 8 | uVar2 >> 8);
              }
              printf("flags=0x%x \n",uVar5);
              for (local_13c = 0; (int)local_13c < 3; local_13c = local_13c + 1) {
                printf("window length %dMHz = %d\n",0x14 << (local_13c & 0x1f),
                       (int)*(short *)((int)pvVar1 + (local_13c + 0xc) * 2 + 4));
                printf("window offset %dMHz = %d\n",0x14 << (local_13c & 0x1f),
                       (int)*(short *)((int)pvVar1 + (local_13c + 8) * 2 + 6));
              }
              printf("frame count=%d %d %d seq %d\n",(uint)*(byte *)((int)pvVar1 + 0x40),
                     (uint)*(byte *)((int)pvVar1 + 0x41),(uint)*(byte *)((int)pvVar1 + 0x42),
                     (uint)*(byte *)((int)pvVar1 + 0x43));
            }
            else {
              fprintf(stderr,"%s: ERROR undefined method \n",(char *)*param_2);
              local_138 = -2;
            }
          }
        }
        else {
          memcpy(&local_fc,local_b0,0x4a);
          local_fc = uVar2;
          FUN_004cbd80(auStack_ac,*param_2,0,0);
          do {
            iVar6 = FUN_004cbe18(auStack_ac,local_res8);
            if (iVar6 == -1) {
              iVar6 = FUN_00445444(param_1,(char *)*param_2,&local_fc,0x4a);
              return iVar6;
            }
            local_138 = -0x2c;
            if (iVar6 == 1) {
              return -0x2c;
            }
            local_res8 = local_res8 + local_a0;
            if (uVar2 != 1) {
              if (uVar2 != 2) {
                puts("ERROR: unsupported method");
                return -0x2c;
              }
              local_138 = FUN_004d8c44(param_2,(int)auStack_ac,auStack_fa);
            }
          } while (local_138 == 0);
          printf(">>>> Method:%d doesn\'t support cmd option:\'%c\'\n",uVar5 & 0xffff,local_9a);
        }
      }
    }
  }
  return local_138;
}



undefined * FUN_004db0b0(byte param_1)

{
  byte local_res0;
  
  local_res0 = param_1;
  if (3 < param_1) {
    local_res0 = 4;
  }
  return (&PTR_s_Undetected_00557654)[local_res0];
}



undefined * FUN_004db108(char param_1)

{
  undefined *puVar1;
  
  puVar1 = PTR_DAT_00557634;
  if ((((((param_1 != '\0') && (puVar1 = PTR_s_Pairing_00557638, param_1 != '\x01')) &&
        (param_1 != '\x02')) &&
       ((puVar1 = PTR_s_Handshake_0055763c, param_1 != '\x03' && (param_1 != '\x04')))) &&
      ((puVar1 = PTR_s_Detected_00557640, param_1 != '\x05' &&
       ((puVar1 = PTR_s_Pipeline_00557644, param_1 != '\x06' &&
        (puVar1 = PTR_s_NegMode_00557648, param_1 != '\a')))))) &&
     (puVar1 = PTR_s_Unknown_00557650, param_1 == '\b')) {
    puVar1 = PTR_s_Monitor_0055764c;
  }
  return puVar1;
}



undefined * FUN_004db250(char param_1)

{
  undefined *puVar1;
  
  puVar1 = PTR_DAT_0055761c;
  if (((((param_1 != '\0') && (puVar1 = PTR_DAT_00557620, param_1 != '\x01')) && (param_1 != '\x02')
       ) && ((param_1 != '\x04' && (param_1 != '\x05')))) &&
     ((puVar1 = PTR_s_LegacyWait_00557624, param_1 != '\x03' &&
      ((puVar1 = PTR_s_Confirmed_00557628, param_1 != '\x06' &&
       (puVar1 = PTR_s_Unknown_0055762c, param_1 == '\a')))))) {
    puVar1 = PTR_s_Report_00557630;
  }
  return puVar1;
}



undefined * FUN_004db360(byte param_1)

{
  byte local_res0;
  
  local_res0 = param_1;
  if (4 < param_1) {
    local_res0 = 0;
  }
  return (&PTR_DAT_00557608)[local_res0];
}



undefined * FUN_004db3b4(byte param_1)

{
  byte local_res0;
  
  local_res0 = param_1;
  if (3 < param_1) {
    local_res0 = 0;
  }
  return (&PTR_s_Unknown_005575f8)[local_res0];
}



int FUN_004db408(int *param_1,undefined4 *param_2,int param_3)

{
  char *pcVar1;
  int local_40;
  short local_38;
  byte local_36;
  byte local_35;
  char local_34;
  byte local_33;
  uint local_30;
  int local_2c;
  int local_28;
  undefined1 auStack_24 [6];
  char local_1e;
  char local_1d;
  char local_1c;
  int local_18;
  ushort local_14;
  ushort local_12;
  ushort local_10;
  ushort local_e;
  byte local_c;
  byte local_b;
  byte local_a;
  byte local_9;
  
  local_40 = -2;
  if (*(int *)(param_3 + 4) == 0) {
    bzero(&local_38,0x30);
    local_40 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)&local_38,0x30);
    if (-1 < local_40) {
      if (local_38 == 1) {
        pcVar1 = FUN_004db0b0(local_36);
        printf("mode=%s\n",pcVar1);
        pcVar1 = FUN_004db108(local_34);
        printf("state=%s\n",pcVar1);
        pcVar1 = FUN_004db0b0(local_35);
        printf("peer mode=%s\n",pcVar1);
        pcVar1 = FUN_0041d780((int)auStack_24);
        printf("peer=%s\n",pcVar1);
        printf("lowest rssi=%d\n",(int)local_1c);
        printf("highest rssi=%d\n",(int)local_1d);
        printf("tx pkts=%d\n",local_2c);
        printf("rx pkts=%d\n",local_28);
        pcVar1 = FUN_004db3b4(local_33);
        printf("reason=%s\n\n",pcVar1);
      }
      else if (local_38 == 2) {
        pcVar1 = FUN_004db0b0(local_36);
        printf("mode=%s\n",pcVar1);
        pcVar1 = FUN_004db250(local_34);
        printf("state=%s\n",pcVar1);
        if (local_30 == 0xffffffff) {
          puts("distance=-1");
        }
        else {
          printf("distance=%d.%04d\n",local_30 >> 4,(local_30 & 0xf) * 0x271);
        }
        pcVar1 = FUN_0041d780((int)auStack_24);
        printf("peer=%s\n",pcVar1);
        printf("avg rssi=%d\n",(int)local_1e);
        printf("tx pkts=%d\n",local_2c);
        printf("rx pkts=%d\n",local_28);
        printf("frame types = CCK %d OFDM %d 11N %d 11AC %d\n",(uint)local_14,(uint)local_12,
               (uint)local_10,(uint)local_e);
        printf("adj types = SW %d HW %d SEQ %d NONE %d\n",(uint)local_c,(uint)local_b,(uint)local_a,
               (uint)local_9);
        printf("report status= %d\n",local_18);
        pcVar1 = FUN_004db360(local_33);
        printf("reason=%s\n",pcVar1);
        printf("frmcnt=%d\n",(int)local_1c);
        if (local_1d == '\x01') {
          puts("measure=OneSide\n");
        }
        else {
          puts("measure=TwoSide\n");
        }
      }
      else {
        puts("ERROR: unsupported method");
        local_40 = -0x2c;
      }
    }
  }
  else {
    puts("Cannot set proxd_status");
  }
  return local_40;
}



int FUN_004db8c8(int *param_1,undefined4 *param_2,int param_3)

{
  ushort uVar1;
  ushort *__s;
  ushort *puVar2;
  uint uVar3;
  size_t sVar4;
  ulong uVar5;
  int local_40;
  ushort *local_3c;
  int local_38;
  char *local_34;
  ushort *local_30;
  char local_18 [12];
  
  __s = (ushort *)malloc(0x402);
  if (__s == (ushort *)0x0) {
    fprintf(stderr,"Failed to allocate buffer of %d bytes\n",0x402);
    return -1;
  }
  bzero(__s,0x402);
  if (*(int *)(param_3 + 4) == 0) {
    local_40 = FUN_004ba1f8(param_1,(char *)*param_2,(char *)__s,0x402);
    if (local_40 < 0) {
      free(__s);
      return local_40;
    }
    if (DAT_0055c140 == '\0') {
      uVar1 = *__s;
    }
    else {
      uVar1 = *__s << 8 | *__s >> 8;
    }
    if (uVar1 != 0) {
      local_3c = __s + 1;
      puVar2 = (ushort *)((int)local_3c + (uint)uVar1);
      local_38 = 0;
      printf("Payload Length %d\n",(uint)uVar1);
      while (local_3c < puVar2) {
        uVar1 = *local_3c;
        local_3c = (ushort *)((int)local_3c + 1);
        printf("%02X",(uint)(byte)uVar1);
        local_38 = local_38 + 1;
        if (local_38 == 0x28) {
          putchar(10);
          local_38 = 0;
        }
      }
      if (local_38 != 0) {
        putchar(10);
      }
    }
  }
  else {
    uVar3 = atoi(*(char **)(param_3 + 4));
    if ((short)uVar3 != 0) {
      if (*(int *)(param_3 + 8) == 0) {
        puts("Payload content is missing");
        free(__s);
        return -1;
      }
      local_34 = *(char **)(param_3 + 8);
      local_18[0] = 'X';
      local_18[1] = 'X';
      local_18[2] = 0;
      sVar4 = strlen(local_34);
      local_30 = __s;
      if ((sVar4 & 0xffff) != (uVar3 & 0xffff) << 1) {
        sVar4 = strlen(local_34);
        printf("Payload length mismatch %d %d\n",uVar3 & 0xffff,(int)sVar4 / 2);
        free(__s);
        return -1;
      }
      for (; *local_34 != '\0'; local_34 = local_34 + 2) {
        strncpy(local_18,local_34,2);
        uVar5 = strtoul(local_18,(char **)0x0,0x10);
        *(char *)local_30 = (char)uVar5;
        local_30 = (ushort *)((int)local_30 + 1);
      }
    }
    local_40 = FUN_00445444(param_1,(char *)*param_2,__s,uVar3 & 0xffff);
  }
  free(__s);
  return local_40;
}



int FUN_004dbc94(int *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  uint local_c;
  
  local_c = 0;
  if (*(int *)(param_3 + 4) == 0) {
    iVar1 = FUN_004ba35c(param_1,(char *)*param_2,&local_c);
    if (iVar1 < 0) {
      return iVar1;
    }
    printf("Local AVB Time %u\n",local_c);
  }
  return -1;
}



int FUN_004dbd40(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  char *param1;
  undefined3 extraout_var;
  int *local_res8;
  int local_48;
  char acStack_3c [52];
  
  local_res8 = (int *)(param_3 + 4);
  if (*local_res8 == 0) {
    bzero(acStack_3c,0x30);
    iVar2 = FUN_004ba1f8(param_1,(char *)*param_2,acStack_3c,0x30);
    if (-1 < iVar2) {
      local_48 = 0;
      while ((local_48 < 8 &&
             (((((acStack_3c[local_48 * 6] != '\0' || acStack_3c[local_48 * 6 + 1] != '\0') ||
                acStack_3c[local_48 * 6 + 2] != '\0') || acStack_3c[local_48 * 6 + 3] != '\0') ||
              acStack_3c[local_48 * 6 + 4] != '\0') || acStack_3c[local_48 * 6 + 5] != '\0'))) {
        param1 = FUN_0041d780((int)(acStack_3c + local_48 * 6));
        printf("%s ",param1);
        local_48 = local_48 + 1;
      }
      putchar(10);
    }
  }
  else {
    local_48 = 0;
    for (; *local_res8 != 0; local_res8 = local_res8 + 1) {
      if (7 < local_48) {
        printf("Over the maxium report number %d\n",8);
        return -0xf;
      }
      bVar1 = FUN_0041d6ac((char *)*local_res8,acStack_3c + local_48 * 6);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        if (local_48 == 0) {
          return -0x15;
        }
        break;
      }
      local_48 = local_48 + 1;
    }
    iVar2 = FUN_00445444(param_1,(char *)*param_2,acStack_3c,local_48 * 6);
  }
  return iVar2;
}



void FUN_004dc050(int param_1)

{
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  uint param1;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int local_90;
  char local_34 [44];
  
  uVar5 = *(uint *)(param_1 + 0x10);
  uVar3 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 | uVar5 >> 0x18;
  uVar6 = *(uint *)(param_1 + 0x20);
  uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 | uVar6 >> 0x18;
  param1 = (uint)(ushort)(*(ushort *)(param_1 + 0x3e) << 8 | *(ushort *)(param_1 + 0x3e) >> 8);
  uVar1 = *(ushort *)(param_1 + 0x28);
  uVar2 = *(ushort *)(param_1 + 0x2a);
  uVar7 = *(uint *)(param_1 + 0x14);
  uVar8 = *(uint *)(param_1 + 0x18);
  uVar9 = *(uint *)(param_1 + 0x1c);
  uVar10 = *(uint *)(param_1 + 0x30);
  uVar11 = *(uint *)(param_1 + 0x34);
  uVar12 = *(uint *)(param_1 + 0x38);
  uVar12 = uVar12 << 0x18 | (uVar12 & 0xff00) << 8 | (uVar12 & 0xff0000) >> 8 | uVar12 >> 0x18;
  bzero(local_34,0x28);
  if (uVar3 == 0xffffffff) {
    builtin_strncpy(local_34,"distance=-1m\n",0xe);
  }
  else {
    sprintf(local_34,"distance=%d.%04dm\n",uVar3 >> 4,(uVar5 >> 0x18 & 0xf) * 0x271);
  }
  if ((ushort)(*(ushort *)(param_1 + 2) << 8 | *(ushort *)(param_1 + 2) >> 8) == 3) {
    if (*(char *)(param_1 + 7) == '\x02') {
      pcVar4 = FUN_0041d780(param_1 + 10);
      printf("Report:(%s) and ",pcVar4);
      pcVar4 = FUN_0041d780(param_1 + 0x2c);
      printf("(%s); %s",pcVar4,local_34);
    }
    else {
      pcVar4 = FUN_0041d780(param_1 + 10);
      printf("Target:(%s); %s; ",pcVar4,local_34);
    }
    printf("mean %d mode %d median %d\n",
           uVar7 << 0x18 | (uVar7 & 0xff00) << 8 | (uVar7 & 0xff0000) >> 8 | uVar7 >> 0x18,
           uVar8 << 0x18 | (uVar8 & 0xff00) << 8 | (uVar8 & 0xff0000) >> 8 | uVar8 >> 0x18,
           uVar9 << 0x18 | (uVar9 & 0xff00) << 8 | (uVar9 & 0xff0000) >> 8 | uVar9 >> 0x18);
  }
  else {
    pcVar4 = FUN_0041d780(param_1 + 10);
    printf("Initiator:(%s); %s; ",pcVar4,local_34);
  }
  printf("sigma:%d.%d;",uVar6 / 10,uVar6 % 10);
  printf("rssi:%d validfrmcnt %d\n",(int)(short)(uVar1 << 8 | uVar1 >> 8),
         (int)(short)(uVar2 << 8 | uVar2 >> 8));
  if (*(char *)(param_1 + 7) == '\x02') {
    printf("var3: %d\n",uVar12);
  }
  else {
    printf("var: %d %d %d\n",
           uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | (uVar10 & 0xff0000) >> 8 | uVar10 >> 0x18,
           uVar11 << 0x18 | (uVar11 & 0xff00) << 8 | (uVar11 & 0xff0000) >> 8 | uVar11 >> 0x18,
           uVar12);
  }
  if (1 < param1) {
    printf("event contains %d rtd samples for host side calculation:\n",param1);
    for (local_90 = 0; local_90 < (int)param1; local_90 = local_90 + 1) {
      uVar3 = *(uint *)(param_1 + (local_90 + 8) * 8);
      printf("ftm[%d] --> value:%d rssi:%d\n",local_90,
             uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18,
             (int)*(char *)(param_1 + (local_90 + 8) * 8 + 4));
    }
    puts("host side calculation result: TBD");
  }
  return;
}



void FUN_004dc7b0(ushort *param_1)

{
  uint param1;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int local_28;
  
  param1 = (uint)(ushort)(param_1[4] << 8 | param_1[4] >> 8);
  if (((ushort)(*param_1 << 8 | *param_1 >> 8) == 2) &&
     (printf("Frame Count %d\n Timestamps:\n",param1), param1 != 0)) {
    for (local_28 = 0; local_28 < (int)param1; local_28 = local_28 + 1) {
      uVar1 = *(uint *)(param_1 + local_28 * 8 + 5);
      uVar2 = *(uint *)(param_1 + local_28 * 8 + 7);
      uVar3 = *(uint *)(param_1 + (local_28 + 1) * 8 + 1);
      uVar4 = *(uint *)(param_1 + (local_28 + 1) * 8 + 3);
      printf("t1[%d]=%u : t2[%d]=%u : t3[%d]=%u : t4[%d]=%u\n",local_28,
             uVar1 << 0x18 | (uVar1 & 0xff00) << 8 | (uVar1 & 0xff0000) >> 8 | uVar1 >> 0x18,
             local_28,uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | (uVar2 & 0xff0000) >> 8 |
                      uVar2 >> 0x18,local_28,
             uVar3 << 0x18 | (uVar3 & 0xff00) << 8 | (uVar3 & 0xff0000) >> 8 | uVar3 >> 0x18,
             local_28,uVar4 << 0x18 | (uVar4 & 0xff00) << 8 | (uVar4 & 0xff0000) >> 8 |
                      uVar4 >> 0x18);
    }
  }
  return;
}



undefined * FUN_004dca70(byte param_1)

{
  byte local_res0;
  
  local_res0 = param_1;
  if (4 < param_1) {
    local_res0 = 0;
  }
  return (&PTR_s_Unknown_005575e4)[local_res0];
}



void FUN_004dcac4(char *param_1)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  char *pcVar4;
  byte *local_48;
  int local_44;
  char local_34 [44];
  
  local_48 = (byte *)(param_1 + 4);
  for (local_44 = 0; local_44 < (int)(uint)(byte)param_1[3]; local_44 = local_44 + 1) {
    uVar2 = *(uint *)(local_48 + 0x10);
    uVar3 = *(uint *)(local_48 + 0x14);
    bVar1 = local_48[1];
    bzero(local_34,0x28);
    if (uVar2 == 0xffffffff) {
      builtin_strncpy(local_34,"distance=-1m\n",0xe);
    }
    else {
      sprintf(local_34,"distance=%d.%dm\n",uVar2 >> 4,(uVar2 & 0xf) * 0x271);
    }
    if (*param_1 == '\x03') {
      if (((((local_48[0x18] == 0 && local_48[0x19] == 0) && local_48[0x1a] == 0) &&
           local_48[0x1b] == 0) && local_48[0x1c] == 0) && local_48[0x1d] == 0) {
        pcVar4 = FUN_0041d780((int)(local_48 + 2));
        printf("Target:(%s); %s; ",pcVar4,local_34);
      }
      else {
        pcVar4 = FUN_0041d780((int)(local_48 + 2));
        printf("Report:(%s) and ",pcVar4);
        pcVar4 = FUN_0041d780((int)(local_48 + 0x18));
        printf("(%s); %s",pcVar4,local_34);
      }
    }
    else {
      pcVar4 = FUN_0041d780((int)(local_48 + 2));
      printf("Initiator:(%s); %s",pcVar4,local_34);
    }
    pcVar4 = FUN_004dca70(*local_48);
    printf("%s sigma:%d.%d validfrmcnt %d\n",pcVar4,uVar3 / 10,uVar3 % 10,(uint)bVar1);
    local_48 = local_48 + 0x20;
  }
  return;
}



int FUN_004dcdf4(int *param_1,undefined4 param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  void *__buf;
  ssize_t sVar4;
  char *param1;
  uint uVar5;
  uint uVar6;
  int local_9c;
  ushort local_98;
  int local_94;
  byte *local_90;
  ushort *local_8c;
  sockaddr local_5c;
  char acStack_48 [16];
  char local_38 [16];
  undefined4 local_28;
  undefined1 local_24;
  undefined1 local_23;
  undefined1 local_22;
  undefined1 local_21;
  undefined1 local_20;
  undefined1 local_1f;
  undefined1 local_1e;
  undefined1 local_1d;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 local_1a;
  undefined1 local_19;
  char acStack_18 [13];
  byte local_b;
  
  bVar1 = false;
  local_28 = 0x30687465;
  local_24 = 0;
  local_23 = 0;
  local_22 = 0;
  local_21 = 0;
  local_20 = 0;
  local_1f = 0;
  local_1e = 0;
  local_1d = 0;
  local_1c = 0;
  local_1b = 0;
  local_1a = 0;
  local_19 = 0;
  if (*(int *)(param_3 + 4) == 0) {
    puts("<ifname> param is missing");
    local_9c = -1;
  }
  else {
    if (*(int *)(param_3 + 4) != 0) {
      strncpy((char *)&local_28,*(char **)(param_3 + 4),0xf);
    }
    bzero(acStack_48,0x20);
    strncpy(acStack_48,(char *)&local_28,0xf);
    local_9c = FUN_004ba1f8(param_1,"event_msgs",acStack_18,0x10);
    if (local_9c == 0) {
      local_b = local_b | 0x20;
      local_9c = FUN_004ba2e4(param_1,"event_msgs",acStack_18,0x10);
      if (local_9c == 0) {
        if ((*(int *)(param_3 + 8) != 0) &&
           (iVar2 = strcmp(*(char **)(param_3 + 8),"osh"), iVar2 == 0)) {
          bVar1 = true;
        }
        iVar2 = socket(0x11,3,0x6c88);
        if (iVar2 < 0) {
          printf("Cannot create socket %d\n",iVar2);
          local_9c = -1;
        }
        else {
          iVar3 = ioctl(iVar2,0x8933,acStack_48);
          if (iVar3 < 0) {
            printf("Cannot get iface:%s index \n",acStack_48);
          }
          else {
            bzero(&local_5c,0x14);
            local_5c.sa_family = 0x11;
            local_5c.sa_data[0] = -0x78;
            local_5c.sa_data[1] = 'l';
            local_5c.sa_data[2] = local_38[0];
            local_5c.sa_data[3] = local_38[1];
            local_5c.sa_data[4] = local_38[2];
            local_5c.sa_data[5] = local_38[3];
            iVar3 = bind(iVar2,&local_5c,0x14);
            if (iVar3 < 0) {
              printf("Cannot bind %d\n",iVar3);
            }
            else {
              __buf = malloc(0x800);
              if (__buf == (void *)0x0) {
                printf("Cannot not allocate %d bytes for events receive buffer\n",0x800);
              }
              else {
                printf("wating for LBS events :%s\n",acStack_48);
                while( true ) {
                  fflush(stdout);
                  sVar4 = recv(iVar2,__buf,0x800,0);
                  if (sVar4 < 1) break;
                  uVar5 = *(uint *)((int)__buf + 0x1c);
                  uVar5 = uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | (uVar5 & 0xff0000) >> 8 |
                          uVar5 >> 0x18;
                  uVar6 = *(uint *)((int)__buf + 0x24);
                  uVar6 = uVar6 << 0x18 | (uVar6 & 0xff00) << 8 | (uVar6 & 0xff0000) >> 8 |
                          uVar6 >> 0x18;
                  if (uVar5 == 0x6d) {
                    iVar3 = FUN_004e46f8((int)__buf);
                    if (iVar3 != 0) {
                      if (uVar6 == 0xb) {
                        local_90 = (byte *)((int)__buf + 0x48);
                        local_98 = (ushort)*local_90;
                      }
                      else if (uVar6 == 0xc) {
                        local_8c = (ushort *)((int)__buf + 0x48);
                        local_98 = *(ushort *)((int)__buf + 0x4a) << 8 |
                                   *(ushort *)((int)__buf + 0x4a) >> 8;
                      }
                      else {
                        local_94 = (int)__buf + 0x48;
                        local_98 = *(ushort *)((int)__buf + 0x4a) << 8 |
                                   *(ushort *)((int)__buf + 0x4a) >> 8;
                      }
                      if (local_98 == 2) {
                        param1 = "initiator";
                      }
                      else {
                        param1 = "target";
                      }
                      printf("mode:%s; event:",param1);
                      switch(uVar6) {
                      default:
                        printf("ERROR: unsupported EVENT reason code:%d; ",uVar6);
                        break;
                      case 1:
                        printf("WLC_E_PROXD_FOUND; ");
                        FUN_004dc050(local_94);
                        break;
                      case 2:
                        printf("WLC_E_PROXD_GONE; ");
                        break;
                      case 3:
                        printf("WLC_E_PROXD_START; ");
                        break;
                      case 4:
                        printf("WLC_E_PROXD_STOP; ");
                        break;
                      case 5:
                        printf("WLC_E_PROXD_COMPLETED; ");
                        FUN_004dc050(local_94);
                        goto joined_r0x004dd4c8;
                      case 6:
                        printf("WLC_E_PROXD_ERROR:%d;",(uint)*(byte *)(local_94 + 6));
                        FUN_004dc050(local_94);
                        goto joined_r0x004dd4c8;
                      case 7:
                        printf("WLC_E_PROXD_COLLECT_START; ");
                        break;
                      case 8:
                        printf("WLC_E_PROXD_COLLECT_STOP; ");
                        break;
                      case 9:
                        printf("WLC_E_PROXD_COLLECT_COMPLETED; ");
                        break;
                      case 10:
                        printf("WLC_E_PROXD_COLLECT_ERROR; ");
                        break;
                      case 0xb:
                        printf("WLC_E_NAN_EVENT; ");
                        FUN_004dcac4((char *)local_90);
                        break;
                      case 0xc:
                        printf("WLC_E_PROXD_TS_RESULTS; ");
                        FUN_004dc7b0(local_8c);
joined_r0x004dd4c8:
                        if (bVar1) goto LAB_004dd5f8;
                      }
                      putchar(10);
                    }
                  }
                  else {
                    printf("WARNING: not a proxd BCM_EVENT:%d\n",uVar5);
                  }
                }
LAB_004dd5f8:
                free(__buf);
              }
            }
          }
          close(iVar2);
          local_9c = FUN_004ba1f8(param_1,"event_msgs",acStack_18,0x10);
          if (local_9c == 0) {
            local_b = local_b & 0xdf;
            local_9c = FUN_004ba2e4(param_1,"event_msgs",acStack_18,0x10);
          }
          fflush(stdout);
        }
      }
    }
    else {
      puts("couldn\'t read event_msgs");
    }
  }
  return local_9c;
}



int FUN_004dd6a8(int *param_1,undefined4 *param_2,int param_3)

{
  uint *puVar1;
  bool bVar2;
  ushort uVar3;
  int iVar4;
  int *piVar5;
  undefined2 extraout_var_00;
  ulong uVar6;
  undefined3 extraout_var;
  int local_30;
  ushort local_2c;
  ushort local_2a;
  undefined4 local_28;
  undefined1 local_24;
  undefined1 local_23;
  undefined2 local_22;
  char acStack_20 [20];
  uint *local_c;
  
  local_c = (uint *)0x0;
  iVar4 = FUN_0040192c(param_3);
  piVar5 = (int *)(param_3 + 4);
  if (*piVar5 == 0) {
    iVar4 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
    puVar1 = local_c;
    if (-1 < iVar4) {
      FUN_004c02bc((ushort)*local_c,acStack_20);
      printf("chanspec:           %s(0x%04x)\n",acStack_20,*puVar1);
      printf("timeslot:           %d\n",(uint)(ushort)puVar1[1]);
      printf("duration:           %d\n",(uint)*(ushort *)((int)puVar1 + 6));
      printf("allowed mac:        %02x:%02x:%02x:%02x:%02x:%02x\n",(uint)(byte)puVar1[2],
             (uint)*(byte *)((int)puVar1 + 9),(uint)*(byte *)((int)puVar1 + 10),
             (uint)*(byte *)((int)puVar1 + 0xb),(uint)(byte)puVar1[3],
             (uint)*(byte *)((int)puVar1 + 0xd));
      printf("flags:              0x%04x\n",(uint)*(ushort *)((int)puVar1 + 0xe));
    }
  }
  else if (iVar4 < 4) {
    iVar4 = -0x2c;
  }
  else {
    uVar3 = FUN_004c0638((char *)*piVar5);
    if (uVar3 == 0) {
      fprintf(stderr,"%s: could not parse \"%s\" as a channel\n",(char *)*param_2,(char *)*piVar5);
      iVar4 = -2;
    }
    else {
      uVar3 = FUN_00402c2c(uVar3);
      local_30 = CONCAT22(extraout_var_00,uVar3);
      if (local_30 == 0xff) {
        fprintf(stderr,"%s: wl_chspec_to_driver() error \"%s\" \n",(char *)*param_2,(char *)*piVar5)
        ;
        iVar4 = -2;
      }
      else {
        uVar6 = strtoul(*(char **)(param_3 + 8),(char **)0x0,0);
        local_2c = (ushort)uVar6;
        if ((local_2c == 0) || (0x1ff < local_2c)) {
          fprintf(stderr,"Invalid timeslot \"%s\" \n",*(char **)(param_3 + 8));
          iVar4 = -2;
        }
        else {
          uVar6 = strtoul(*(char **)(param_3 + 0xc),(char **)0x0,0);
          local_2a = (ushort)uVar6;
          if ((local_2a == 0) || (0x1ff < local_2a)) {
            fprintf(stderr,"Invalid duration \"%s\" \n",*(char **)(param_3 + 0xc));
            iVar4 = -2;
          }
          else {
            if (*(int *)(param_3 + 0x10) == 0) {
              local_28 = 0xffffffff;
              local_24 = 0xff;
              local_23 = 0xff;
              local_22 = 0;
            }
            else {
              bVar2 = FUN_0041d6ac(*(char **)(param_3 + 0x10),&local_28);
              if (CONCAT31(extraout_var,bVar2) == 0) {
                fwrite("nan ranging config mac addr err\n",1,0x20,stderr);
                return -2;
              }
              if (*(int *)(param_3 + 0x14) == 0) {
                local_22 = 0;
              }
              else {
                uVar6 = strtoul(*(char **)(param_3 + 0x14),(char **)0x0,0);
                local_22 = (undefined2)uVar6;
              }
            }
            iVar4 = FUN_00445444(param_1,(char *)*param_2,&local_30,0x10);
          }
        }
      }
    }
  }
  return iVar4;
}



int FUN_004ddb98(int *param_1,undefined4 *param_2,int param_3)

{
  bool bVar1;
  ushort uVar2;
  int iVar3;
  char *__s;
  size_t __n;
  byte *pbVar4;
  ulong uVar5;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined4 *local_res8;
  int local_30;
  byte *local_10 [2];
  
  local_10[0] = (byte *)0x0;
  iVar3 = FUN_0040192c(param_3);
  if (*(int *)(param_3 + 4) == 0) {
    iVar3 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,local_10);
    pbVar4 = local_10[0];
    if (-1 < iVar3) {
      printf("num peers:       %d \n",(uint)*local_10[0]);
      printf("num peers done:  %d \n",(uint)pbVar4[1]);
      printf("num dws:         %d \n",(uint)pbVar4[2]);
      puts("----------------------------------------------------------------------");
      puts("Address \t\tchanspec\tcount\tretry\tabitmap\tflags");
      for (local_30 = 0; local_30 < (int)(uint)*pbVar4; local_30 = local_30 + 1) {
        printf("%02x:%02x:%02x:%02x:%02x:%02x\t0x%04x\t\t%d\t%d\t0x%x\t0x%x\n",
               (uint)pbVar4[local_30 * 0x14 + 0xc],(uint)pbVar4[local_30 * 0x14 + 0xd],
               (uint)pbVar4[local_30 * 0x14 + 0xe],(uint)pbVar4[local_30 * 0x14 + 0xf],
               (uint)pbVar4[local_30 * 0x14 + 0x10],(uint)pbVar4[local_30 * 0x14 + 0x11],
               *(uint *)(pbVar4 + local_30 * 0x14 + 4),(uint)pbVar4[local_30 * 0x14 + 0x12],
               (uint)pbVar4[local_30 * 0x14 + 0x13],*(uint *)(pbVar4 + local_30 * 0x14 + 8),
               (uint)*(ushort *)(pbVar4 + local_30 * 0x14 + 0x14));
      }
    }
  }
  else if (iVar3 % 6 == 2) {
    __s = (char *)*param_2;
    __n = strlen(__s);
    strncpy(PTR_DAT_00551644,__s,__n);
    PTR_DAT_00551644[__n] = 0;
    pbVar4 = PTR_DAT_00551644 + __n + 1;
    *pbVar4 = (char)((ulonglong)((longlong)iVar3 * 0x2aaaaaab) >> 0x20) - (char)(iVar3 >> 0x1f);
    pbVar4[1] = 0;
    local_res8 = (undefined4 *)(param_3 + 8);
    uVar5 = strtoul(*(char **)(param_3 + 4),(char **)0x0,0);
    pbVar4[2] = (byte)uVar5;
    for (local_30 = 0; local_30 < (int)(uint)*pbVar4; local_30 = local_30 + 1) {
      uVar2 = FUN_004c0638((char *)*local_res8);
      if (uVar2 == 0) {
        fprintf(stderr,"%s: could not parse \"%s\" as a channel\n",(char *)*param_2,
                (char *)*local_res8);
        return -2;
      }
      uVar2 = FUN_00402c2c(uVar2);
      *(uint *)(pbVar4 + local_30 * 0x14 + 4) = CONCAT22(extraout_var_00,uVar2);
      if (*(int *)(pbVar4 + local_30 * 0x14 + 4) == 0xff) {
        fprintf(stderr,"%s: wl_chspec_to_driver() error \"%s\" \n",(char *)*param_2,
                (char *)*local_res8);
        return -2;
      }
      bVar1 = FUN_0041d6ac((char *)local_res8[1],pbVar4 + local_30 * 0x14 + 0xc);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        fwrite("ranging mac addr err\n",1,0x15,stderr);
        return -0x15;
      }
      uVar5 = strtoul((char *)local_res8[2],(char **)0x0,0);
      *(ulong *)(pbVar4 + local_30 * 0x14 + 8) = uVar5;
      uVar5 = strtoul((char *)local_res8[3],(char **)0x0,0);
      pbVar4[local_30 * 0x14 + 0x12] = (byte)uVar5;
      if (pbVar4[local_30 * 0x14 + 0x12] == 0xff) {
        fprintf(stderr,"Invalid frame count \"%s\" \n",(char *)local_res8[3]);
        return -2;
      }
      uVar5 = strtoul((char *)local_res8[4],(char **)0x0,0);
      pbVar4[local_30 * 0x14 + 0x13] = (byte)uVar5;
      uVar5 = strtoul((char *)local_res8[5],(char **)0x0,0);
      *(short *)(pbVar4 + local_30 * 0x14 + 0x14) = (short)uVar5;
      local_res8 = local_res8 + 6;
    }
    fprintf(stderr,"count %d\n",(uint)*pbVar4);
    iVar3 = FUN_004ba050(param_1,0x107,PTR_DAT_00551644,(*pbVar4 - 1) * 0x14 + __n + 0x19);
  }
  else {
    iVar3 = -0x2c;
  }
  return iVar3;
}



int FUN_004de33c(int *param_1,undefined4 *param_2)

{
  int iVar1;
  int iVar2;
  char *__s;
  int local_18;
  int local_c;
  
  local_c = 0;
  iVar2 = FUN_00445198(param_1,(char *)*param_2,(void *)0x0,0,&local_c);
  iVar1 = local_c;
  if (-1 < iVar2) {
    printf("num results:       %d \n",(uint)*(byte *)(local_c + 3));
    printf("num good results:  %d \n",(uint)*(byte *)(iVar1 + 2));
    puts("------------------------------------------------------------------------------");
    puts("Address\t\t\tchanspec\tvalidcnt\tts\t\tdist\tstatus");
    for (local_18 = 0; local_18 < (int)(uint)*(byte *)(iVar1 + 3); local_18 = local_18 + 1) {
      printf("%02x:%02x:%02x:%02x:%02x:%02x\t",(uint)*(byte *)(iVar1 + local_18 * 0x20 + 6),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 7),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 8),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 9),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 10),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 0xb));
      printf("%04x\t\t%d\t\t%u\t",*(uint *)(iVar1 + local_18 * 0x20 + 0xc),
             (uint)*(byte *)(iVar1 + local_18 * 0x20 + 5),*(uint *)(iVar1 + local_18 * 0x20 + 0x10))
      ;
      if (*(int *)(iVar1 + local_18 * 0x20 + 0x14) == -1) {
        printf("-1\t");
      }
      else {
        printf("%d.%04d\t",*(uint *)(iVar1 + local_18 * 0x20 + 0x14) >> 4,
               (*(uint *)(iVar1 + local_18 * 0x20 + 0x14) & 0xf) * 0x271);
      }
      __s = FUN_004dca70(*(byte *)(iVar1 + local_18 * 0x20 + 4));
      puts(__s);
    }
  }
  return iVar2;
}



undefined ** FUN_004de61c(char *param_1)

{
  int iVar1;
  int local_10;
  undefined **local_c;
  
  local_c = &PTR_DAT_0053db50;
  local_10 = 0;
  while( true ) {
    if (0x11 < local_10) {
      return (undefined **)0x0;
    }
    iVar1 = strcasecmp(*local_c,param_1);
    if (iVar1 == 0) break;
    local_c = local_c + 5;
    local_10 = local_10 + 1;
  }
  return local_c;
}



undefined4 FUN_004de6b8(undefined4 param_1,undefined4 param_2,undefined4 *param_3)

{
  int iVar1;
  undefined4 uVar2;
  undefined **ppuVar3;
  int *local_res8;
  short local_10;
  
  iVar1 = strcasecmp((char *)*param_3,"-h");
  if ((iVar1 == 0) || (iVar1 = strcasecmp((char *)*param_3,"help"), iVar1 == 0)) {
    uVar2 = FUN_004e4500(param_3 + 1);
  }
  else {
    iVar1 = strcasecmp((char *)*param_3,"ftm");
    if (iVar1 == 0) {
      local_10 = 0;
      local_res8 = param_3 + 1;
      if ((*local_res8 != 0) && ((*(ushort *)(__ctype_b + *(char *)*local_res8 * 2) & 8) != 0)) {
        iVar1 = atoi((char *)*local_res8);
        local_10 = (short)iVar1;
        local_res8 = param_3 + 2;
      }
      if (*local_res8 == 0) {
        puts("error: proxd ftm-method cmdname is not specified");
        uVar2 = 0xffffffd4;
      }
      else {
        ppuVar3 = FUN_004de61c((char *)*local_res8);
        if (ppuVar3 == (undefined **)0x0) {
          printf("error: invalid proxd ftm command \'%s\'\n",(char *)*local_res8);
          uVar2 = 0xffffffd4;
        }
        else if (ppuVar3[2] == (undefined *)0x0) {
          uVar2 = 0;
        }
        else if (((((uint)ppuVar3[3] & 1) == 0) || (((uint)ppuVar3[3] & 2) != 0)) || (local_10 == 0)
                ) {
          if (((((uint)ppuVar3[3] & 1) == 0) && (((uint)ppuVar3[3] & 2) != 0)) && (local_10 == 0)) {
            printf("proxd ftm %s: error, please specify a valid session-id\n",*ppuVar3);
            uVar2 = 0xffffffd4;
          }
          else {
            uVar2 = (*(code *)ppuVar3[2])(param_1,ppuVar3,4,local_10,local_res8 + 1);
          }
        }
        else {
          printf("proxd ftm %s: error, does not accept non-zero session-id\n",*ppuVar3);
          uVar2 = 0xffffffd4;
        }
      }
    }
    else {
      printf("error: proxd-method \'%s\' is not supported\n",(char *)*param_3);
      uVar2 = 0xffffffd4;
    }
  }
  return uVar2;
}



int * FUN_004de9a0(int param_1,int *param_2,int param_3)

{
  int local_10;
  int *local_c;
  
  local_10 = 0;
  local_c = param_2;
  while( true ) {
    if (param_3 <= local_10) {
      return (int *)0x0;
    }
    if (*local_c == param_1) break;
    local_c = local_c + 2;
    local_10 = local_10 + 1;
  }
  return local_c;
}



int FUN_004dea30(char *param_1,int param_2,int param_3)

{
  int iVar1;
  int local_10;
  int local_c;
  
  local_10 = 0;
  local_c = param_2;
  while( true ) {
    if (param_3 <= local_10) {
      return 0;
    }
    iVar1 = strcasecmp(*(char **)(local_c + 4),param_1);
    if (iVar1 == 0) break;
    local_c = local_c + 8;
    local_10 = local_10 + 1;
  }
  return local_c;
}



char * FUN_004dead4(int param_1,int *param_2,int param_3)

{
  int *piVar1;
  char *pcVar2;
  
  piVar1 = FUN_004de9a0(param_1,param_2,param_3);
  if (piVar1 == (int *)0x0) {
    pcVar2 = "invalid";
  }
  else {
    pcVar2 = (char *)piVar1[1];
  }
  return pcVar2;
}



void FUN_004deb44(ushort param_1)

{
  FUN_004dead4((uint)param_1,(int *)&DAT_0053dfc8,0x2b);
  return;
}



void FUN_004deb90(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e158,5);
  return;
}



void FUN_004debdc(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e198,6);
  return;
}



void FUN_004dec28(ushort param_1)

{
  FUN_004dead4((uint)param_1,(int *)&DAT_0053e1c8,2);
  return;
}



undefined * FUN_004dec74(int param_1)

{
  undefined *puVar1;
  int *piVar2;
  
  if ((param_1 < 1) && (-0x35 < param_1)) {
    puVar1 = (&PTR_DAT_00557510)[-param_1];
  }
  else {
    piVar2 = FUN_004de9a0(param_1,(int *)&DAT_0053e2e8,0x16);
    if (piVar2 == (int *)0x0) {
      memset(&DAT_0055c144,0,0x20);
      snprintf(&DAT_0055c144,0x20,"Undefined status %d",param_1);
      puVar1 = &DAT_0055c144;
    }
    else {
      puVar1 = (undefined *)piVar2[1];
    }
  }
  return puVar1;
}



void FUN_004ded60(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e728,0xb);
  return;
}



void FUN_004dedac(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e7a0,4);
  return;
}



void FUN_004dedf8(ushort param_1)

{
  FUN_004dead4((uint)param_1,(int *)&DAT_0053e7dc,3);
  return;
}



void FUN_004dee44(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e810,3);
  return;
}



void FUN_004dee90(short param_1)

{
  FUN_004dead4((int)param_1,(int *)&DAT_0053e840,4);
  return;
}



undefined2 *
FUN_004deedc(undefined2 param_1,undefined2 param_2,undefined2 param_3,short param_4,ushort *param_5)

{
  ushort uVar1;
  undefined2 *puVar2;
  
  *param_5 = 0;
  uVar1 = param_4 + 0x12;
  puVar2 = (undefined2 *)calloc(1,(uint)uVar1);
  if (puVar2 == (undefined2 *)0x0) {
    printf("error: failed to allocate %d bytes of memory\n",(uint)uVar1);
    puVar2 = (undefined2 *)0x0;
  }
  else {
    *puVar2 = 0x300;
    puVar2[1] = uVar1;
    puVar2[2] = param_3;
    puVar2[3] = param_1;
    puVar2[4] = param_2;
    puVar2[6] = 0;
    puVar2[7] = 0;
    *param_5 = uVar1;
  }
  return puVar2;
}



void FUN_004defec(ushort *param_1,ushort param_2)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  ushort uVar5;
  size_t sVar6;
  char *pcVar7;
  char *pcVar8;
  int local_198;
  char *local_194;
  ushort *local_190;
  char acStack_11c [264];
  
  uVar1 = param_1[1];
  memset(acStack_11c,0,0x100);
  local_194 = acStack_11c;
  if ((uVar1 & 1) != 0) {
    sVar6 = strlen(acStack_11c);
    strncpy(local_194,"NLOS",0xff - sVar6);
    sVar6 = strlen(acStack_11c);
    local_194 = acStack_11c + sVar6;
  }
  if ((uVar1 & 2) != 0) {
    sVar6 = strlen(acStack_11c);
    strncpy(local_194," LOS",0xff - sVar6);
  }
  if ((uVar1 & 4) != 0) {
    sVar6 = strlen(acStack_11c);
    strncpy(local_194," Fatal error",0xff - sVar6);
  }
  pcVar7 = (char *)FUN_004deb44(param_2);
  uVar2 = *param_1;
  pcVar8 = FUN_0041d780((int)(param_1 + 4));
  printf("> %s:\n>\tsessionId=%d, flags=0x%04x(\'%s\'), peer=%s\n",pcVar7,(uint)uVar2,
         (int)(short)uVar1,acStack_11c,pcVar8);
  uVar1 = param_1[7];
  iVar3 = *(int *)(param_1 + 2);
  pcVar7 = (char *)FUN_004ded60(uVar1);
  pcVar8 = FUN_004dec74(iVar3);
  printf(">\tsession state=%d(%s), status=%d(%s)\n",(int)(short)uVar1,pcVar7,iVar3,pcVar8);
  if (iVar3 == -0x40c) {
    iVar3 = *(int *)(param_1 + 8);
    pcVar7 = (char *)FUN_004debdc(param_1[10]);
    printf(">\tretry_after: %d%s\n",iVar3,pcVar7);
  }
  else {
    iVar3 = *(int *)(param_1 + 8);
    pcVar7 = (char *)FUN_004debdc(param_1[10]);
    printf(">\tburst_duration: %d%s\n",iVar3,pcVar7);
  }
  uVar4 = *(uint *)(param_1 + 0x14);
  if (uVar4 == 0xffffffff) {
    printf(">\tavg_dist=-1m, burst_num=%d, valid_measure_cnt=%d num_ftm=%d\n",(uint)param_1[0x18],
           (uint)(byte)param_1[0x17],(uint)*(byte *)((int)param_1 + 0x2f));
  }
  else {
    printf(">\tavg_dist=%d.%04dm, burst_num=%d, valid_measure_cnt=%d num_ftm=%d\n",uVar4 >> 8,
           (uVar4 & 0xff) * 0x271 >> 4,(uint)param_1[0x18],(uint)(byte)param_1[0x17],
           (uint)*(byte *)((int)param_1 + 0x2f));
  }
  uVar1 = param_1[0xd];
  iVar3 = *(int *)(param_1 + 0xe);
  pcVar7 = (char *)FUN_004debdc(param_1[0x10]);
  printf(">\tavg_rtt sample: rssi=%d rtt=%d%s std_deviation =%d.%d ratespec=0x%08x\n",
         (int)(short)uVar1,iVar3,pcVar7,param_1[0x16] / 10,(uint)param_1[0x16] % 10,
         *(uint *)(param_1 + 0x12));
  uVar1 = param_1[0x19];
  if (uVar1 != 0) {
    printf(">\tnum rtt: %d samples\n",(uint)uVar1);
    local_190 = param_1 + 0x1a;
    for (local_198 = 0; local_198 < (int)(uint)uVar1; local_198 = local_198 + 1) {
      uVar5 = *local_190;
      uVar2 = local_190[1];
      iVar3 = *(int *)(local_190 + 2);
      pcVar7 = (char *)FUN_004debdc(local_190[4]);
      if ((*local_190 & 0x100) == 0) {
        pcVar8 = "";
      }
      else {
        pcVar8 = "Discard";
      }
      printf(">\t    sample[%d]: id=%d rssi=%d rtt=%d%s ratespec=0x%08x %s\n",local_198,
             (uint)(byte)uVar5,(int)(short)uVar2,iVar3,pcVar7,*(uint *)(local_190 + 6),pcVar8);
      local_190 = local_190 + 8;
    }
  }
  return;
}



void FUN_004df984(ushort *param_1,ushort param_2)

{
  int param4;
  ushort uVar1;
  ushort uVar2;
  char *pcVar3;
  char *pcVar4;
  
  pcVar3 = (char *)FUN_004deb44(param_2);
  uVar2 = param_1[1];
  pcVar4 = FUN_0041d780((int)(param_1 + 2));
  printf("> %s: bssidx=%d, bssid=%s\n",pcVar3,(uint)(byte)uVar2,pcVar4);
  uVar2 = param_1[5];
  param4 = *(int *)(param_1 + 6);
  uVar1 = *param_1;
  pcVar3 = (char *)FUN_004ded60(uVar2);
  pcVar4 = FUN_004dec74(param4);
  printf("\tsessionId=%d, state=%d(%s), status=%d(%s), burst_num=%d\n",(uint)uVar1,(int)(short)uVar2
         ,pcVar3,param4,pcVar4,(uint)param_1[8]);
  return;
}



void FUN_004dfb64(ushort *param_1,ushort param_2)

{
  ushort uVar1;
  int param5;
  ushort uVar2;
  char *param1;
  char *param4;
  char *param6;
  
  uVar1 = param_1[1];
  param5 = *(int *)(param_1 + 2);
  param1 = (char *)FUN_004deb44(param_2);
  uVar2 = *param_1;
  param4 = (char *)FUN_004ded60(uVar1);
  param6 = FUN_004dec74(param5);
  printf("> %s: sessionId=%d, state=%d(%s), status=%d(%s), burst_num=%d\n",param1,(uint)uVar2,
         (int)(short)uVar1,param4,param5,param6,(uint)param_1[4]);
  return;
}



void FUN_004dfd14(undefined4 *param_1,ushort param_2)

{
  char *param1;
  
  param1 = (char *)FUN_004deb44(param_2);
  printf("> %s:\n\ttx-frame-count=%d, rx-frame_count=%d\n",param1,*param_1,param_1[1]);
  printf("\tnoack=%d, txfail=%d\n",param_1[8],param_1[9]);
  printf("\tburst=%d, sessions=%d, max_sessions=%d\n",param_1[2],param_1[3],param_1[4]);
  printf("\tsched_fail=%d, timeouts=%d, protocol errors=%d\n",param_1[5],param_1[6],param_1[7]);
  printf("\tLCI: tx request=%d, rx request=%d, tx report=%d, rx report=%d\n",param_1[10],
         param_1[0xb],param_1[0xc],param_1[0xd]);
  printf("\tcivic: tx request=%d, rx request=%d, tx report=%d, rx report=%d\n",param_1[0xe],
         param_1[0xf],param_1[0x10],param_1[0x11]);
  printf("\tranging: created=%d, done=%d\n",param_1[0x12],param_1[0x13]);
  return;
}



void FUN_004e04ac(ushort *param_1,ushort param_2)

{
  ushort uVar1;
  char *param1;
  int local_20;
  
  uVar1 = *param_1;
  param1 = (char *)FUN_004deb44(param_2);
  printf("> %s: total %d id(s)\n",param1,(uint)uVar1);
  for (local_20 = 0; local_20 < (int)(uint)uVar1; local_20 = local_20 + 1) {
    printf(">\tsession[%d]: %d\n",local_20,(uint)param_1[local_20 + 1]);
  }
  return;
}



void FUN_004e05cc(short *param_1,ushort param_2)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  int param4;
  ushort uVar4;
  char *pcVar5;
  char *pcVar6;
  char *param5;
  int iVar7;
  int *local_158;
  int local_154;
  char acStack_118 [256];
  
  sVar1 = *param_1;
  sVar2 = param_1[1];
  uVar3 = param_1[3];
  pcVar5 = (char *)FUN_004deb44(param_2);
  pcVar6 = (char *)FUN_004dee44(sVar1);
  param5 = (char *)FUN_004dee90(sVar2);
  printf("> %s:\n>\tflags=0x%04x(\'%s\'), time-ref=0x%04x(\'%s\'), num_slots=%d, max_slots=%d\n",
         pcVar5,(int)sVar1,pcVar6,(int)sVar2,param5,(uint)uVar3,(uint)(ushort)param_1[2]);
  local_158 = (int *)(param_1 + 4);
  for (local_154 = 0; local_154 < (int)(uint)uVar3; local_154 = local_154 + 1) {
    iVar7 = *local_158;
    pcVar5 = (char *)FUN_004debdc((short)local_158[1]);
    param4 = local_158[2];
    pcVar6 = (char *)FUN_004debdc((short)local_158[3]);
    printf(">\tslots[%d]: start: %d%s duration: %d%s",local_154,iVar7,pcVar5,param4,pcVar6);
    uVar4 = *(ushort *)(local_158 + 4);
    iVar7 = FUN_004c0fc0(uVar4);
    if (iVar7 == 0) {
      printf(" chanspec: 0x%04x(invalid)\n",(uint)uVar4);
    }
    else {
      memset(acStack_118,0,0x100);
      FUN_004c02bc(uVar4,acStack_118);
      printf(" chanspec: 0x%04x(%s)\n",(uint)uVar4,acStack_118);
    }
    local_158 = local_158 + 5;
  }
  return;
}



void FUN_004e09c4(int *param_1,ushort param_2)

{
  int param1;
  ushort uVar1;
  int iVar2;
  char *pcVar3;
  char *param4;
  char *param6;
  
  pcVar3 = (char *)FUN_004deb44(param_2);
  printf("> %s:\n",pcVar3);
  param1 = *param_1;
  iVar2 = param_1[1];
  uVar1 = *(ushort *)((int)param_1 + 6);
  pcVar3 = FUN_004dec74(param1);
  param4 = (char *)FUN_004dedac((short)iVar2);
  param6 = (char *)FUN_004dedf8(uVar1);
  printf("\tstatus=%d(%s), state=%d(%s), flags=0x%04x(%s), num_sids=%d, num_done=%d\n",param1,pcVar3
         ,(int)(short)iVar2,param4,(uint)uVar1,param6,(uint)*(ushort *)(param_1 + 2),
         (uint)*(ushort *)((int)param_1 + 10));
  return;
}



undefined4 FUN_004e0bcc(undefined4 param_1,ushort *param_2,ushort param_3,ushort param_4)

{
  ushort uVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  char acStack_214 [256];
  char local_114 [260];
  
  memset(acStack_214,0,0x100);
  if (param_3 == 0x13) {
    pcVar4 = (char *)FUN_004deb44(0x13);
    printf("> %s: data-len=%d byte(s)\n",pcVar4,(uint)param_4);
    if (param_4 != 0) {
      FUN_004be9f4((char *)0x0,(int)param_2,(uint)param_4);
      return 0;
    }
    return 0;
  }
  if (0x13 < param_3) {
    if (param_3 == 0x200) goto LAB_004e0e9c;
    if (0x200 < param_3) {
      if (param_3 == 0x205) {
        FUN_004df984(param_2,0x205);
        return 0;
      }
      if (param_3 < 0x206) {
        if (param_3 == 0x202) {
          pcVar4 = (char *)FUN_004deb44(0x202);
          pcVar2 = (char *)FUN_004dec28(*param_2);
          printf("> %s: capabilities=%s, max sessions=%d, num sessions=%d,rx_max_burst=%d\n",pcVar4,
                 pcVar2,(uint)param_2[1],(uint)param_2[2],(uint)param_2[3]);
          return 0;
        }
        if (param_3 < 0x202) {
          FUN_004dfd14((undefined4 *)param_2,param_3);
          return 0;
        }
        if (param_3 == 0x203) {
          FUN_004defec(param_2,0x203);
          return 0;
        }
      }
      else {
        if (param_3 == 0x207) {
          FUN_004e04ac(param_2,0x207);
          return 0;
        }
        if (param_3 < 0x207) {
          FUN_004dfb64(param_2,param_3);
          return 0;
        }
        if (param_3 == 0x400) goto LAB_004e0f20;
        if (param_3 == 0x402) {
          if (param_4 != 0) {
            pcVar4 = (char *)FUN_004deb44(0x402);
            printf("> %s:\n%s\n",pcVar4,(char *)param_2);
            return 0;
          }
          return 0;
        }
      }
      goto LAB_004e156c;
    }
    if (param_3 == 0x1b) {
LAB_004e0e40:
      pcVar4 = (char *)FUN_004deb44(param_3);
      printf("> %s: %d\n",pcVar4,(uint)*param_2);
      return 0;
    }
    if (param_3 < 0x1c) {
      if (param_3 == 0x18) {
        FUN_004e05cc((short *)param_2,0x18);
        return 0;
      }
      if (param_3 < 0x18) {
LAB_004e156c:
        pcVar4 = (char *)FUN_004deb44(param_3);
        printf("> Unsupported %s: %d\n",pcVar4,(uint)param_3);
        return 0xffffffff;
      }
    }
    else {
      if (0x1e < param_3) {
        if (param_3 == 0x23) goto LAB_004e0e40;
        goto LAB_004e156c;
      }
      if (param_3 < 0x1d) {
        FUN_004e09c4((int *)param_2,param_3);
        return 0;
      }
    }
    goto LAB_004e0f20;
  }
  if (0xb < param_3) {
    if (param_3 < 0x10) {
      if (0xd < param_3) {
LAB_004e11c4:
        pcVar4 = (char *)FUN_004deb44(param_3);
        iVar3 = *(int *)param_2;
        pcVar2 = (char *)FUN_004debdc(param_2[2]);
        printf("> %s: %d%s\n",pcVar4,iVar3,pcVar2);
        return 0;
      }
      if (param_3 == 0xc) {
        pcVar4 = (char *)FUN_004deb44(0xc);
        printf("> %s: %d\n",pcVar4,(uint)(byte)*param_2);
        return 0;
      }
      if (param_3 != 0xd) goto LAB_004e156c;
    }
    else {
      if (param_3 == 0x11) goto LAB_004e0f20;
      if (param_3 < 0x12) {
        uVar1 = *param_2;
        local_114[0] = '\0';
        pcVar4 = (char *)FUN_004deb44(param_3);
        printf("> %s: 0x%x %s\n",pcVar4,(int)(short)uVar1,local_114);
        return 0;
      }
    }
    pcVar4 = (char *)FUN_004deb44(param_3);
    pcVar2 = FUN_0041d780((int)param_2);
    printf("> %s: %s\n",pcVar4,pcVar2);
    return 0;
  }
  if (8 < param_3) goto LAB_004e0e40;
  if (param_3 == 3) {
    uVar1 = *param_2;
    iVar3 = FUN_004c0fc0(uVar1);
    if (iVar3 == 0) {
      pcVar4 = (char *)FUN_004deb44(3);
      printf("> %s: invalid 0x%04x\n",pcVar4,(uint)uVar1);
      return 0;
    }
    FUN_004c02bc(uVar1,acStack_214);
    pcVar4 = (char *)FUN_004deb44(3);
    printf("> %s: %s 0x%04x\n",pcVar4,acStack_214,(uint)uVar1);
    return 0;
  }
  if (param_3 < 4) {
    if (param_3 == 1) {
      pcVar4 = (char *)FUN_004deb44(1);
      pcVar2 = (char *)FUN_004deb90(*param_2);
      printf("> %s: %s\n",pcVar4,pcVar2);
      return 0;
    }
    if (param_3 < 2) {
      if (param_3 != 0) goto LAB_004e156c;
LAB_004e0e9c:
      pcVar4 = (char *)FUN_004deb44(param_3);
      printf("> %s: %d\n",pcVar4,*(int *)param_2);
      return 0;
    }
  }
  else if (param_3 != 5) {
    if (5 < param_3) goto LAB_004e11c4;
    goto LAB_004e0e9c;
  }
LAB_004e0f20:
  pcVar4 = (char *)FUN_004deb44(param_3);
  printf("> %s: 0x%x\n",pcVar4,*(uint *)param_2);
  return 0;
}



int FUN_004e15e0(int *param_1,void *param_2,ushort param_3,int param_4)

{
  int iVar1;
  int local_14;
  ushort *local_10 [2];
  
  local_10[0] = (ushort *)0x0;
  iVar1 = FUN_00445198(param_1,"proxd",param_2,(uint)param_3,local_10);
  if ((iVar1 == 0) && (local_10[0] != (ushort *)0x0)) {
    local_14 = local_10[0][1] - 0xc;
    if (local_14 < 0) {
      local_14 = 0;
    }
    if (*(short *)(param_4 + 4) == 1) {
      printf("> version: 0x%x\n",(uint)*local_10[0]);
    }
    if (0 < local_14) {
      iVar1 = FUN_004d3f1c(param_2,local_10[0] + 6,(ushort)local_14,1,FUN_004e0bcc);
      putchar(10);
    }
  }
  return iVar1;
}



int FUN_004e1714(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,int *param_5
                )

{
  undefined2 *__ptr;
  int local_18;
  ushort local_10 [4];
  
  local_10[0] = 0;
  __ptr = FUN_004deedc(param_3,param_4,*(undefined2 *)(param_2 + 1),0,local_10);
  if (__ptr == (undefined2 *)0x0) {
    local_18 = -0x1b;
  }
  else {
    if (*param_5 == 0) {
      local_18 = FUN_004e15e0(param_1,__ptr,local_10[0],(int)param_2);
    }
    else {
      printf("error: proxd ftm %s cmd doesn\'t accept any parameters\n",(char *)*param_2);
      local_18 = -1;
    }
    free(__ptr);
  }
  return local_18;
}



void FUN_004e1810(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1878(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e18e0(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1948(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e19b0(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1a18(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1a80(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1ae8(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1714(param_1,param_2,param_3,param_4,param_5);
  return;
}



int FUN_004e1b50(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,int *param_5
                )

{
  int param1;
  undefined2 *__ptr;
  ushort local_10 [4];
  
  if (*param_5 == 0) {
    local_10[0] = 0;
    __ptr = FUN_004deedc(param_3,param_4,*(undefined2 *)(param_2 + 1),0,local_10);
    if (__ptr == (undefined2 *)0x0) {
      param1 = -0x1b;
    }
    else {
      param1 = FUN_00445444(param_1,"proxd",__ptr,(uint)local_10[0]);
      if (param1 != 0) {
        printf("error: IOVAR failed, status=%d\n",param1);
      }
      free(__ptr);
    }
  }
  else {
    printf("error: proxd ftm %s cmd doesn\'t accept any parameters\n",(char *)*param_2);
    param1 = -0x2c;
  }
  return param1;
}



void FUN_004e1c68(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1cd0(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1d38(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1da0(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1e08(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1e70(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



void FUN_004e1ed8(int *param_1,undefined4 *param_2,undefined2 param_3,undefined2 param_4,
                 int *param_5)

{
  FUN_004e1b50(param_1,param_2,param_3,param_4,param_5);
  return;
}



undefined4 FUN_004e1f40(char *param_1,undefined2 *param_2)

{
  int iVar1;
  
  iVar1 = strcasecmp(param_1,"tu");
  if (iVar1 == 0) {
    *param_2 = 0;
  }
  else {
    iVar1 = strcasecmp(param_1,"s");
    if (iVar1 == 0) {
      *param_2 = 1;
    }
    else {
      iVar1 = strcasecmp(param_1,"ms");
      if (iVar1 == 0) {
        *param_2 = 2;
      }
      else {
        iVar1 = strcasecmp(param_1,"us");
        if (iVar1 == 0) {
          *param_2 = 3;
        }
        else {
          iVar1 = strcasecmp(param_1,"ns");
          if (iVar1 == 0) {
            *param_2 = 4;
          }
          else {
            iVar1 = strcasecmp(param_1,"ps");
            if (iVar1 != 0) {
              return 0;
            }
            *param_2 = 5;
          }
        }
      }
    }
  }
  return 1;
}



undefined ** FUN_004e209c(char *param_1,short param_2)

{
  uint uVar1;
  int iVar2;
  int local_18;
  undefined **local_14;
  
  if (param_2 == 0) {
    uVar1 = 1;
  }
  else {
    uVar1 = 2;
  }
  local_14 = &PTR_s_bssidx_0053f1c8;
  local_18 = 0;
  while( true ) {
    if (0x12 < local_18) {
      return (undefined **)0x0;
    }
    iVar2 = strcasecmp(param_1,*local_14);
    if (iVar2 == 0) break;
    local_14 = local_14 + 4;
    local_18 = local_18 + 1;
  }
  if (((uint)local_14[3] & uVar1) != 0) {
    return local_14;
  }
  return (undefined **)0x0;
}



undefined ** FUN_004e2184(char *param_1,char param_2)

{
  int iVar1;
  int local_18;
  undefined **local_14;
  int local_10;
  
  if (param_2 == '\0') {
    local_14 = &PTR_s_initiator_0053f8dc;
    local_10 = 0x14;
  }
  else {
    local_14 = &PTR_s_rx_enable_0053f5d0;
    local_10 = 7;
  }
  local_18 = 0;
  while( true ) {
    if (local_10 <= local_18) {
      return (undefined **)0x0;
    }
    iVar1 = strcasecmp(param_1,*local_14);
    if (iVar1 == 0) break;
    local_14 = local_14 + 3;
    local_18 = local_18 + 1;
  }
  return local_14;
}



int FUN_004e225c(short param_1,int *param_2,int *param_3,ushort *param_4)

{
  bool bVar1;
  bool bVar2;
  undefined2 uVar3;
  int iVar4;
  undefined **ppuVar5;
  int *local_res4;
  char *local_24;
  undefined *local_20;
  uint local_10;
  uint local_c;
  
  local_10 = 0;
  local_c = 0;
  if (*param_2 == 0) {
    iVar4 = -0x2c;
  }
  else {
    bVar1 = param_1 == 0;
    for (local_res4 = param_2; *local_res4 != 0; local_res4 = local_res4 + 1) {
      bVar2 = true;
      if ((*(char *)*local_res4 == '-') || (*(char *)*local_res4 == '+')) {
        bVar2 = *(char *)*local_res4 != '-';
        local_24 = (char *)(*local_res4 + 1);
        if (*local_24 == '\0') {
          return -0x2c;
        }
      }
      else {
        local_24 = (char *)*local_res4;
      }
      ppuVar5 = FUN_004e2184(local_24,bVar1);
      if (ppuVar5 == (undefined **)0x0) {
        local_20 = (undefined *)strtoul(local_24,(char **)0x0,0);
        if (local_20 == (undefined *)0x0) {
          printf("error: invalid param-value(%s)\n",local_24);
          return -0x2c;
        }
      }
      else {
        local_20 = ppuVar5[1];
      }
      local_c = local_c | (uint)local_20;
      if (bVar2) {
        local_10 = local_10 | (uint)local_20;
      }
      else {
        local_10 = ~(uint)local_20 & local_10;
      }
    }
    if (bVar1) {
      uVar3 = 0x11;
    }
    else {
      uVar3 = 0x1a;
    }
    iVar4 = FUN_004d3d98(param_3,param_4,uVar3,4,&local_c,1);
    if (iVar4 == 0) {
      if (bVar1) {
        uVar3 = 2;
      }
      else {
        uVar3 = 0x19;
      }
      iVar4 = FUN_004d3d98(param_3,param_4,uVar3,4,&local_10,1);
      if (iVar4 == 0) {
        iVar4 = 0;
      }
    }
  }
  return iVar4;
}



undefined4 FUN_004e2514(ushort param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  ushort local_20;
  uint local_18;
  int local_10;
  
  local_20 = 0;
  local_18 = (uint)param_1;
  for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
    if ((local_18 & 1) != 0) {
      local_20 = (ushort)local_10;
    }
    local_18 = local_18 >> 1;
  }
  if (local_20 < 0xf) {
    if ((uint)param_1 == 1 << (local_20 & 0x1f)) {
      uVar1 = 0;
    }
    else {
      printf("error: \'%s\' value must be power of 2\n",(char *)*param_2);
      uVar1 = 0xffffffe3;
    }
  }
  else {
    printf("error:\' %s\' value is out of range (should not exceed 0x%x)\n",(char *)*param_2,0x4000)
    ;
    uVar1 = 0xffffffe3;
  }
  return uVar1;
}



int FUN_004e264c(undefined4 *param_1,undefined4 *param_2,uint param_3,uint param_4,ulong *param_5)

{
  ulong uVar1;
  int iVar2;
  
  uVar1 = strtoul((char *)*param_1,(char **)0x0,0);
  if ((uVar1 < param_3) || (param_4 < uVar1)) {
    printf("error: \'%s\' value is out of range\n",(char *)*param_2);
    iVar2 = -0x1d;
  }
  else if (((*(short *)(param_2 + 1) != 10) && (*(short *)(param_2 + 1) != 0x1b)) ||
          (iVar2 = FUN_004e2514((ushort)uVar1,param_2), iVar2 == 0)) {
    *param_5 = uVar1;
    iVar2 = 0;
  }
  return iVar2;
}



undefined4 FUN_004e2764(char *param_1,int *param_2)

{
  ushort uVar1;
  undefined2 extraout_var;
  undefined4 local_10;
  int local_c;
  
  local_10 = 0;
  local_c = 0;
  if (param_1 != (char *)0x0) {
    uVar1 = FUN_004c0638(param_1);
    local_c = CONCAT22(extraout_var,uVar1);
  }
  if (local_c == 0) {
    puts("error: invalid chanspec");
    local_10 = 0xfffffffe;
  }
  *param_2 = local_c;
  return local_10;
}



undefined4 FUN_004e27ec(char *param_1,void *param_2)

{
  undefined4 uVar1;
  int *piVar2;
  int iVar3;
  ulong local_18;
  undefined2 local_14 [2];
  char *local_10 [2];
  
  memset(param_2,0,8);
  if (param_1 == (char *)0x0) {
    puts("error: time-interval value is not specified");
    uVar1 = 0xfffffffe;
  }
  else {
    piVar2 = __errno_location();
    *piVar2 = 0;
    memset(&local_18,0,8);
    local_10[0] = (char *)0x0;
    local_18 = strtoul(param_1,local_10,10);
    piVar2 = __errno_location();
    if (*piVar2 == 0) {
      local_14[0] = 0;
      if ((*local_10[0] == '\0') || (iVar3 = FUN_004e1f40(local_10[0],local_14), iVar3 != 0)) {
        memcpy(param_2,&local_18,8);
        uVar1 = 0;
      }
      else {
        printf("error: invalid time-unit %s\n",local_10[0]);
        uVar1 = 0xfffffffe;
      }
    }
    else {
      piVar2 = __errno_location();
      printf("error: invalid time interval (errno=%d)\n",*piVar2);
      uVar1 = 0xfffffffe;
    }
  }
  return uVar1;
}



int FUN_004e2958(char *param_1,void *param_2)

{
  size_t sVar1;
  int local_a0;
  char *local_9c;
  char *local_98;
  int local_94;
  char acStack_8c [132];
  
  local_94 = 0;
  if (param_1 == (char *)0x0) {
    puts("error: slot value is not specified");
    local_94 = -2;
  }
  else {
    local_9c = param_1;
    for (local_a0 = 0; local_a0 < 3; local_a0 = local_a0 + 1) {
      local_98 = strchr(local_9c,0x3a);
      if (local_98 == (char *)0x0) {
        if ((local_a0 != 2) || (*local_9c == '\0')) {
          local_94 = -2;
          goto LAB_004e2b68;
        }
        sVar1 = strlen(local_9c);
        local_98 = local_9c + sVar1;
      }
      sVar1 = (int)local_98 - (int)local_9c;
      if (0x7f < (int)sVar1) {
        local_94 = -2;
        goto LAB_004e2b68;
      }
      memcpy(acStack_8c,local_9c,sVar1);
      acStack_8c[sVar1] = '\0';
      if (local_a0 == 0) {
        local_94 = FUN_004e2764(acStack_8c,(int *)((int)param_2 + 0x10));
      }
      else if (local_a0 == 1) {
        local_94 = FUN_004e27ec(acStack_8c,param_2);
      }
      else {
        local_94 = FUN_004e27ec(acStack_8c,(void *)((int)param_2 + 8));
      }
      if (local_94 != 0) goto LAB_004e2b68;
      local_9c = local_98 + 1;
    }
    if (*local_98 != '\0') {
      printf("error: invalid \'slot\' value \'%s\'\n",local_98);
      local_94 = -2;
    }
LAB_004e2b68:
    if (local_94 == -2) {
      puts("error: invalid value for slot");
    }
  }
  return local_94;
}



undefined4 FUN_004e2ba4(char *param_1,undefined2 *param_2)

{
  undefined4 uVar1;
  undefined4 *puVar2;
  
  if (param_1 == (char *)0x0) {
    puts("error: time-ref value is not specified");
    uVar1 = 0xfffffffe;
  }
  else {
    puVar2 = (undefined4 *)FUN_004dea30(param_1,0x53e840,4);
    if (puVar2 == (undefined4 *)0x0) {
      puts("error: invalid time-ref value");
      uVar1 = 0xfffffffe;
    }
    else {
      *param_2 = (short)*puVar2;
      uVar1 = 0;
    }
  }
  return uVar1;
}



int FUN_004e2c5c(int *param_1,int param_2,ushort *param_3)

{
  int iVar1;
  int *local_res0;
  int local_18;
  ushort local_14;
  void *local_10;
  
  *param_3 = 0;
  local_14 = 0;
  local_10 = (void *)(param_2 + 8);
  local_res0 = param_1;
  while( true ) {
    local_18 = 0;
    if (*local_res0 == 0) {
      if (local_14 == 0) {
        puts("error: slot-value is not specified");
        local_18 = -2;
      }
      else {
        *param_3 = local_14;
      }
      return local_18;
    }
    if (0x1f < local_14) break;
    iVar1 = FUN_004e2958((char *)*local_res0,local_10);
    if (iVar1 != 0) {
      return iVar1;
    }
    local_14 = local_14 + 1;
    local_10 = (void *)((int)local_10 + 0x14);
    local_res0 = local_res0 + 1;
  }
  printf("error: number of slots exceed the limit (%d)\n",0x20);
  return -2;
}



undefined4 FUN_004e2d8c(undefined4 *param_1)

{
  undefined2 *puVar1;
  undefined4 uVar2;
  
  *param_1 = 0;
  puVar1 = (undefined2 *)calloc(1,0x288);
  if (puVar1 == (undefined2 *)0x0) {
    printf("error: failed to allocate %d bytes of memory for avail\n",0x288);
    uVar2 = 0xffffffe5;
  }
  else {
    *puVar1 = 0;
    puVar1[1] = 0;
    puVar1[3] = 0;
    *param_1 = puVar1;
    uVar2 = 0;
  }
  return uVar2;
}



int FUN_004e2e38(undefined4 param_1,int *param_2,int *param_3,ushort *param_4)

{
  int iVar1;
  int *local_res4;
  int local_18;
  void *local_10;
  short local_c;
  ushort local_a;
  
  local_10 = (void *)0x0;
  if (*param_2 == 0) {
    local_18 = -0x2c;
  }
  else {
    local_18 = FUN_004e2d8c(&local_10);
    if (local_18 == 0) {
      local_a = 0;
      local_c = 0;
      for (local_res4 = param_2; *local_res4 != 0; local_res4 = local_res4 + 1) {
        iVar1 = strcasecmp((char *)*local_res4,"none");
        if (iVar1 == 0) {
          local_c = 0;
        }
        else {
          iVar1 = strcasecmp((char *)*local_res4,"time-ref");
          if (iVar1 != 0) {
            iVar1 = strcasecmp((char *)*local_res4,"slot");
            if (iVar1 != 0) {
              printf("error: invalid param-name (%s)\n",(char *)*local_res4);
              local_18 = -0x2c;
              goto LAB_004e30c0;
            }
            if (local_c == 0) {
              puts("error: time-ref is missing or invalid for slot");
              local_18 = -2;
              goto LAB_004e30c0;
            }
            local_18 = FUN_004e2c5c(local_res4 + 1,(int)local_10,&local_a);
            if (local_18 != 0) goto LAB_004e30c0;
            break;
          }
          local_res4 = local_res4 + 1;
          local_18 = FUN_004e2ba4((char *)*local_res4,&local_c);
          if (local_18 != 0) goto LAB_004e30c0;
        }
      }
      *(short *)((int)local_10 + 2) = local_c;
      *(ushort *)((int)local_10 + 6) = local_a;
      local_18 = FUN_004d3d98(param_3,param_4,0x18,local_a * 0x14 + 8,local_10,1);
      if (local_18 != 0) {
        printf("%s: failed to pack TLVs for availability, status=%d\n","ftm_handle_config_avail",
               local_18);
      }
    }
LAB_004e30c0:
    if (local_10 != (void *)0x0) {
      free(local_10);
    }
  }
  return local_18;
}



undefined4 FUN_004e30f8(char *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = strcasecmp(param_1,"options");
  if (iVar1 == 0) {
    uVar2 = 2;
  }
  else {
    iVar1 = strcasecmp(param_1,"avail");
    if (iVar1 == 0) {
      uVar2 = 3;
    }
    else {
      uVar2 = 1;
    }
  }
  return uVar2;
}



int FUN_004e3178(short param_1,int *param_2,int *param_3,ushort *param_4)

{
  ushort uVar1;
  bool bVar2;
  undefined **ppuVar3;
  int *piVar4;
  int *piVar5;
  undefined3 extraout_var;
  int iVar6;
  int *local_res4;
  int local_38;
  ulong *local_34;
  ushort local_30;
  ulong local_28;
  undefined1 local_24 [2];
  undefined2 local_22;
  ulong local_20;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 local_1a;
  undefined1 local_19;
  undefined1 local_18;
  undefined1 local_17;
  ulong auStack_14 [3];
  
  local_1c = 0;
  local_1b = 0;
  local_1a = 0;
  local_19 = 0;
  local_18 = 0;
  local_17 = 0;
  local_res4 = param_2;
  do {
    local_38 = 0;
    if (*local_res4 == 0) {
      return 0;
    }
    ppuVar3 = FUN_004e209c((char *)*local_res4,param_1);
    if (ppuVar3 == (undefined **)0x0) {
      printf("error: invalid param-name (%s)\n",(char *)*local_res4);
      return -0x2c;
    }
    if (local_res4[1] == 0) {
      puts("error: invalid param-value");
      return -0x2c;
    }
    piVar4 = local_res4 + 1;
    piVar5 = __errno_location();
    *piVar5 = 0;
    local_34 = (ulong *)0x0;
    local_30 = 0;
    uVar1 = *(ushort *)(ppuVar3 + 1);
    if (uVar1 == 0xc) {
      iVar6 = atoi((char *)*piVar4);
      local_24[0] = (undefined1)iVar6;
      local_34 = (ulong *)local_24;
      local_30 = 1;
    }
    else if (uVar1 < 0xd) {
      if (8 < uVar1) goto LAB_004e3370;
      if (uVar1 < 6) {
        if (uVar1 != 3) {
          if (uVar1 < 3) goto LAB_004e3510;
          goto LAB_004e33c4;
        }
        local_38 = FUN_004e2764((char *)*piVar4,(int *)&local_20);
        if (local_38 == 0) {
          local_34 = &local_20;
          local_30 = 4;
        }
      }
      else {
LAB_004e34cc:
        local_38 = FUN_004e27ec((char *)*piVar4,auStack_14);
        if (local_38 == 0) {
          local_34 = auStack_14;
          local_30 = 8;
        }
      }
    }
    else if (uVar1 == 0x10) {
LAB_004e33c4:
      local_38 = FUN_004e264c(piVar4,ppuVar3,0,0xffffffff,&local_28);
      if (local_38 == 0) {
        local_20 = local_28;
        local_34 = &local_20;
        local_30 = 4;
      }
    }
    else if (uVar1 < 0x11) {
      if (uVar1 != 0xd) goto LAB_004e34cc;
LAB_004e3458:
      local_1c = 0;
      local_1b = 0;
      local_1a = 0;
      local_19 = 0;
      local_18 = 0;
      local_17 = 0;
      bVar2 = FUN_0041d6ac((char *)*piVar4,&local_1c);
      if (CONCAT31(extraout_var,bVar2) == 0) {
        puts("error: invalid MAC address parameter");
        local_38 = -0x2c;
      }
      else {
        local_34 = (ulong *)&local_1c;
        local_30 = 6;
      }
    }
    else if (uVar1 == 0x1b) {
LAB_004e3370:
      local_38 = FUN_004e264c(piVar4,ppuVar3,0,0xffff,&local_28);
      if (local_38 == 0) {
        local_22 = (undefined2)local_28;
        local_34 = (ulong *)&local_22;
        local_30 = 2;
      }
    }
    else {
      if (uVar1 < 0x1c) {
        if (uVar1 == 0x12) goto LAB_004e3458;
      }
      else {
        if (uVar1 == 0x23) goto LAB_004e3370;
        if (uVar1 == 0x400) goto LAB_004e33c4;
      }
LAB_004e3510:
      local_38 = -0x2c;
    }
    if (local_38 != 0) {
      return local_38;
    }
    iVar6 = FUN_004d3d98(param_3,param_4,*(undefined2 *)(ppuVar3 + 1),local_30,local_34,1);
    if (iVar6 != 0) {
      return iVar6;
    }
    local_res4 = local_res4 + 2;
  } while( true );
}



int FUN_004e35ec(int *param_1,int param_2,undefined2 param_3,ushort param_4,int *param_5)

{
  ushort uVar1;
  undefined2 *__ptr;
  int iVar2;
  int local_28;
  ushort local_16;
  undefined2 *local_14;
  ushort local_10 [4];
  
  if (*param_5 == 0) {
    puts("error: config command requires parameters");
    FUN_004e40a4();
    local_28 = 0;
  }
  else {
    __ptr = FUN_004deedc(param_3,param_4,*(undefined2 *)(param_2 + 4),0x800,&local_16);
    if (__ptr == (undefined2 *)0x0) {
      local_28 = -0x1b;
    }
    else {
      local_14 = __ptr + 6;
      local_10[0] = local_16 - 0xc;
      iVar2 = FUN_004e30f8((char *)*param_5);
      if (iVar2 == 2) {
        local_28 = FUN_004e225c(param_4,param_5 + 1,(int *)&local_14,local_10);
      }
      else if (iVar2 == 3) {
        local_28 = FUN_004e2e38((uint)param_4,param_5 + 1,(int *)&local_14,local_10);
      }
      else {
        local_28 = FUN_004e3178(param_4,param_5,(int *)&local_14,local_10);
      }
      if (local_28 == 0) {
        uVar1 = (local_16 - 0xc) - local_10[0];
        __ptr[1] = uVar1 + 0xc;
        local_28 = FUN_00445444(param_1,"proxd",__ptr,uVar1 + 0xc);
      }
      else if (local_28 == -0x2c) {
        if (iVar2 == 2) {
          FUN_004e41a0();
        }
        else if (iVar2 == 3) {
          FUN_004e4364();
        }
        else {
          FUN_004e40a4();
        }
        local_28 = 0;
      }
      free(__ptr);
    }
  }
  return local_28;
}



void FUN_004e3864(undefined4 *param_1,undefined *param_2)

{
  if ((param_1 != (undefined4 *)0x0) && (param_1[4] != 0)) {
    printf("\n\t%s\n",(char *)param_1[4]);
    printf("\tUsage: wl proxd ftm ");
    if ((param_1[3] & 2) != 0) {
      if ((param_1[3] & 1) == 0) {
        printf("<session-id> ");
      }
      else {
        printf("[<session-id>] ");
      }
    }
    if (param_2 == (undefined *)0x0) {
      param_2 = "";
    }
    printf("%s%s\n\n",(char *)*param_1,param_2);
  }
  return;
}



int FUN_004e3984(int *param_1,int *param_2,ushort *param_3)

{
  uint uVar1;
  int iVar2;
  int *local_res0;
  int *local_20;
  ushort local_1c;
  int local_18;
  ushort *local_14;
  ushort local_10;
  
  local_14 = (ushort *)0x0;
  local_1c = 0;
  for (local_20 = param_1; *local_20 != 0; local_20 = local_20 + 1) {
    local_1c = local_1c + 1;
  }
  if (local_1c == 0) {
    local_18 = -0x2c;
  }
  else {
    uVar1 = (local_1c + 1 & 0xffff) << 1;
    local_14 = (ushort *)calloc(1,uVar1 & 0xffff);
    if (local_14 == (ushort *)0x0) {
      printf("error: failed to allocate %d bytes of memory for ranging\n",uVar1 & 0xffff);
      local_18 = -0x1b;
    }
    else {
      local_10 = 0;
      for (local_res0 = param_1; *local_res0 != 0; local_res0 = local_res0 + 1) {
        iVar2 = atoi((char *)*local_res0);
        local_14[local_10 + 1] = (ushort)iVar2;
        local_10 = local_10 + 1;
      }
      *local_14 = local_1c;
      local_18 = FUN_004d3d98(param_2,param_3,0x207,(ushort)uVar1,local_14,1);
      if (local_18 != 0) {
        printf("%s: failed to pack ranging-ids in xtlv, err=%d\n","ftm_pack_sids_from_cmdarg",
               local_18);
      }
    }
  }
  if (local_14 != (ushort *)0x0) {
    free(local_14);
  }
  return local_18;
}



// WARNING: Type propagation algorithm not settling

int FUN_004e3b60(int *param_1,int *param_2,ushort *param_3)

{
  int iVar1;
  int *local_res0;
  int local_10;
  short local_c [2];
  
  local_c[0] = 0;
  local_res0 = param_1;
  while ((*local_res0 != 0 && (iVar1 = strcasecmp((char *)*local_res0,"-d"), iVar1 == 0))) {
    local_c[0] = 1;
    local_res0 = local_res0 + 1;
  }
  if (local_c[0] != 0) {
    local_10 = FUN_004d3d98(param_2,param_3,0x1d,2,local_c,1);
    if (local_10 != 0) {
      printf("%s: failed to pack ranging-flags in xtlv, err=%d\n",
             "ftm_pack_ranging_config_from_cmdarg",local_10);
      goto LAB_004e3cc4;
    }
    local_c[1] = 0xffff;
    local_10 = FUN_004d3d98(param_2,param_3,0x1e,2,local_c + 1,1);
    if (local_10 != 0) {
      printf("%s: failed to pack ranging flags_mask in xtlv, err=%d\n",
             "ftm_pack_ranging_config_from_cmdarg",local_10);
      goto LAB_004e3cc4;
    }
  }
  local_10 = FUN_004e3984(local_res0,param_2,param_3);
LAB_004e3cc4:
  if (local_10 != 0) {
    printf("%s failed, err = %d\n","ftm_pack_ranging_config_from_cmdarg",local_10);
  }
  return local_10;
}



int FUN_004e3d08(int *param_1,undefined4 *param_2,undefined2 param_3,short param_4,int *param_5)

{
  ushort uVar1;
  undefined2 *local_20;
  int local_1c;
  ushort local_14 [2];
  undefined2 *local_10;
  ushort local_c [2];
  
  local_20 = (undefined2 *)0x0;
  if ((*param_5 == 0) || (param_4 != 0)) {
    puts("error: start-ranging command requires parameters");
    local_1c = -0x2c;
  }
  else {
    local_20 = FUN_004deedc(param_3,0,*(undefined2 *)(param_2 + 1),0x800,local_14);
    if (local_20 == (undefined2 *)0x0) {
      local_1c = -0x1b;
    }
    else {
      local_10 = local_20 + 6;
      local_c[0] = local_14[0] - 0xc;
      local_1c = FUN_004e3b60(param_5,(int *)&local_10,local_c);
      if (local_1c == 0) {
        uVar1 = (local_14[0] - 0xc) - local_c[0];
        local_20[1] = uVar1 + 0xc;
        local_1c = FUN_00445444(param_1,"proxd",local_20,uVar1 + 0xc);
      }
    }
  }
  if (local_20 != (undefined2 *)0x0) {
    free(local_20);
  }
  if (local_1c == -0x2c) {
    FUN_004e3864(param_2,"[-d] <sid1> <sid2> ...");
    local_1c = 0;
  }
  return local_1c;
}



int FUN_004e3ec0(int *param_1,undefined4 *param_2,undefined2 param_3,short param_4,int *param_5)

{
  int iVar1;
  
  if (param_4 == 0) {
    iVar1 = FUN_004e1b50(param_1,param_2,param_3,0,param_5);
  }
  else {
    puts("error: no session-id is allowed for stop-ranging");
    FUN_004e3864(param_2,&DAT_00534dc0);
    iVar1 = 0;
  }
  return iVar1;
}



void FUN_004e3f64(void)

{
  int local_18;
  undefined **local_14;
  
  puts("\n\tProximity Detection using FTM");
  puts("\tUsage: wl proxd ftm [<session-id>] <cmd> [<param-name> <param-value>]*");
  puts("\t\t<session-id>: specify a session; If omitted, <cmd> applies to FTM method");
  puts("\t\t<cmd>: specify a command from the following list,");
  local_14 = &PTR_DAT_0053db50;
  for (local_18 = 0; local_18 < 0x12; local_18 = local_18 + 1) {
    printf("\t\t  %*s: %s\n",0x14,*local_14,local_14[4]);
    local_14 = local_14 + 5;
  }
  puts("\t\t<param-name> <param-value>: <cmd>-specific parameters\n");
  puts("\t\ttype \'wl proxd -h ftm config\' for configuration command usage.");
  puts("\t\ttype \'wl proxd -h ftm config options\' for options-configuration command usage.");
  puts("\t\ttype \'wl proxd -h ftm config avail\' for availability-configuration command usage.");
  puts("\t\ttype \'wl proxd -h ftm <cmd>\' for others command usage.\n");
  puts("\tExample: wl proxd ftm enable\n");
  return;
}



void FUN_004e40a4(void)

{
  int local_18;
  undefined **local_14;
  
  puts("\n\tConfigure Proximity Detection using FTM");
  puts("\tUsage: wl proxd ftm [<session-id>] config { <param-name> <param-value> }+ ");
  puts("\t\t<session-id>: specify a session id; If omitted, configure global items");
  puts("\t\t<param-name> <param-value>: configuration parameters from the following");
  local_14 = &PTR_s_bssidx_0053f1c8;
  for (local_18 = 0; local_18 < 0x13; local_18 = local_18 + 1) {
    printf("\t\t  %*s: %s\n",0x14,*local_14,local_14[2]);
    local_14 = local_14 + 4;
  }
  puts("\n\tExample: wl proxd ftm config retries 10");
  puts("\t         wl proxd ftm 1 config retries 10");
  return;
}



void FUN_004e41a0(void)

{
  int local_18;
  undefined **local_14;
  
  puts("\n\tConfigure-Options Proximity Detection using FTM");
  puts("\tUsage: wl proxd ftm [<session-id>] config options { [+|-]<param-value> }+ ");
  puts("\t\t<session-id>: specify a session id; If omitted, set the global options");
  puts("\t\t+|- prefix: to add or remove an option");
  puts("\t\t<param-value>: specify an option");
  puts("\t\t\tConfigurable options for a FTM method:");
  local_14 = &PTR_s_rx_enable_0053f5d0;
  for (local_18 = 0; local_18 < 7; local_18 = local_18 + 1) {
    printf("\t\t  %*s (0x%08x): %s\n",0x14,*local_14,(uint)local_14[1],local_14[2]);
    local_14 = local_14 + 3;
  }
  puts("\n\t\t\tConfigurable options for a specific session:");
  local_14 = &PTR_s_initiator_0053f8dc;
  for (local_18 = 0; local_18 < 0x14; local_18 = local_18 + 1) {
    printf("\t\t  %*s (0x%08x): %s\n",0x14,*local_14,(uint)local_14[1],local_14[2]);
    local_14 = local_14 + 3;
  }
  puts("\n\tExample: wl proxd ftm config options +rx-enable");
  puts("\t         wl proxd ftm config options +0x00000001");
  puts("\t         wl proxd ftm 1 config options +rx-auto-burst -rtt-detail\n");
  return;
}



void FUN_004e4364(void)

{
  puts("\n\tConfigure-availability Proximity Detection using FTM");
  puts("\t\tUsage: wl proxd ftm [<session-id>] config avail");
  puts("\t\t              { [time-ref] none |");
  puts("\t\t                time-ref <time-ref-value> slot {<slot-value>}+ }");
  puts("\t\t<session-id>: a session id; If omitted, set the local availability");
  puts("\t\t              otherwise, set the peer availability");
  puts("\t\tnone or time-ref none: to clear availability");
  puts("\t\t<time-ref-value>: a timer reference. Possible values are:");
  puts("\t\t              dev-tsf | nan-dw | tbtt");
  puts("\t\t<slot-value>: a time slot in channel:start-tmu:duration-tmu");
  puts("\t\t              channel   -- a channel (see \'wl chanspec\')");
  puts("\t\t              start-tmu -- start time in time-interval format");
  puts("\t\t                           (a number followed by a time unit)");
  puts("\t\t              duration-tmu -- duration in time-interval format");
  puts("\t\t              Time uints are:");
  puts("\t\t                s (seconds) | ms (milliseconds) | us (microseconds)");
  puts("\t\t                ns (nanoseconds) | ps (picoseconds) | tu (for TUs,default)");
  puts("\t\tMore than one <slot-value>\' can be specified for setting");
  puts("\t\tmultiple time slots");
  puts("\n\tExample: wl proxd ftm config avail none");
  puts("\t         wl proxd ftm config avail time-ref dev-tsf slot 11:100s:100tu");
  printf("\t         wl proxd ftm 1 config avail time-ref dev-tsf slot 11:200s:300tu");
  puts(" 11:600s:400tu");
  return;
}



undefined4 FUN_004e4500(int *param_1)

{
  undefined4 uVar1;
  int iVar2;
  undefined **ppuVar3;
  int *piVar4;
  
  if (*param_1 == 0) {
    uVar1 = 0xffffffd4;
  }
  else {
    iVar2 = strcasecmp((char *)*param_1,"ftm");
    if (iVar2 == 0) {
      if (param_1[1] == 0) {
        FUN_004e3f64();
        uVar1 = 0;
      }
      else {
        ppuVar3 = FUN_004de61c((char *)param_1[1]);
        if (ppuVar3 == (undefined **)0x0) {
          FUN_004e3f64();
          uVar1 = 0;
        }
        else if (*(short *)(ppuVar3 + 1) == 4) {
          piVar4 = param_1 + 2;
          if (*piVar4 != 0) {
            iVar2 = strcasecmp((char *)*piVar4,"options");
            if (iVar2 == 0) {
              FUN_004e41a0();
              return 0;
            }
            iVar2 = strcasecmp((char *)*piVar4,"avail");
            if (iVar2 == 0) {
              FUN_004e4364();
              return 0;
            }
          }
          FUN_004e40a4();
          uVar1 = 0;
        }
        else {
          FUN_004e3864(ppuVar3,&DAT_00534dc0);
          uVar1 = 0;
        }
      }
    }
    else {
      uVar1 = 0xffffffd4;
    }
  }
  return uVar1;
}



void FUN_004e46ac(short param_1)

{
  FUN_004de9a0((int)param_1,(int *)&DAT_00540af0,0xf);
  return;
}



undefined4 FUN_004e46f8(int param_1)

{
  ushort uVar1;
  short sVar2;
  ushort uVar3;
  undefined4 uVar4;
  int iVar5;
  int param6;
  char *param4;
  char *param1;
  
  uVar1 = *(ushort *)(param_1 + 0x48);
  if (uVar1 < 0x300) {
    uVar4 = 0xffffffff;
  }
  else {
    sVar2 = *(short *)(param_1 + 0x4c);
    iVar5 = FUN_004e46ac(sVar2);
    if (iVar5 == 0) {
      printf("receive an invalid FTM event %d\n",(int)sVar2);
      uVar4 = 0;
    }
    else {
      param6 = *(ushort *)(param_1 + 0x4a) - 0xc;
      param1 = *(char **)(iVar5 + 4);
      uVar3 = *(ushort *)(param_1 + 0x4a);
      param4 = (char *)FUN_004deb90(*(short *)(param_1 + 0x4e));
      printf("receive \'%s\' event: version=0x%x len=%d method=%s sid=%d tlvs_len=%d\n",param1,
             (uint)uVar1,(uint)uVar3,param4,(uint)*(ushort *)(param_1 + 0x50),param6);
      if (0 < param6) {
        iVar5 = FUN_004d3f1c(0,(undefined2 *)(param_1 + 0x54),(ushort)param6,1,FUN_004e0bcc);
        if (iVar5 != 0) {
          puts("Failed to unpack xtlv for an event");
        }
      }
      uVar4 = 0;
    }
  }
  return uVar4;
}



void FUN_004e48a0(void)

{
  undefined4 *puVar1;
  code *pcVar2;
  
  if (DAT_00551330 != (code *)0xffffffff) {
    puVar1 = (undefined4 *)&DAT_0055132c;
    pcVar2 = DAT_00551330;
    do {
      (*pcVar2)();
      pcVar2 = (code *)*puVar1;
      puVar1 = puVar1 + -1;
    } while (pcVar2 != (code *)0xffffffff);
  }
  return;
}



void _DT_FINI(void)

{
  FUN_004012c4();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

speed_t cfgetospeed(termios *__termios_p)

{
  speed_t sVar1;
  
  sVar1 = cfgetospeed(__termios_p);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t recv(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = recv(__fd,__buf,__n,__flags);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
  int iVar1;
  
  iVar1 = snprintf(__s,__maxlen,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int usleep(__useconds_t __useconds)

{
  int iVar1;
  
  iVar1 = usleep(__useconds);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void perror(char *__s)

{
  perror(__s);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcflush(int __fd,int __queue_selector)

{
  int iVar1;
  
  iVar1 = tcflush(__fd,__queue_selector);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tolower(int __c)

{
  int iVar1;
  
  iVar1 = tolower(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncasecmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncasecmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bzero(void *__s,size_t __n)

{
  bzero(__s,__n);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t send(int __fd,void *__buf,size_t __n,int __flags)

{
  ssize_t sVar1;
  
  sVar1 = send(__fd,__buf,__n,__flags);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
  int iVar1;
  
  iVar1 = accept(__fd,__addr,__addr_len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int cfsetispeed(termios *__termios_p,speed_t __speed)

{
  int iVar1;
  
  iVar1 = cfsetispeed(__termios_p,__speed);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = fstat(__fd,__buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ffs(int __i)

{
  int iVar1;
  
  iVar1 = ffs(__i);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = bind(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

in_addr_t inet_addr(char *__cp)

{
  in_addr_t iVar1;
  
  iVar1 = inet_addr(__cp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t __optlen)

{
  int iVar1;
  
  iVar1 = setsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int cfsetospeed(termios *__termios_p,speed_t __speed)

{
  int iVar1;
  
  iVar1 = cfsetospeed(__termios_p,__speed);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t wait(void *__stat_loc)

{
  __pid_t _Var1;
  
  _Var1 = wait(__stat_loc);
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void bcopy(void *__src,void *__dest,size_t __n)

{
  bcopy(__src,__dest,__n);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int listen(int __fd,int __n)

{
  int iVar1;
  
  iVar1 = listen(__fd,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncat(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncat(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



void __uClibc_main(void)

{
  __uClibc_main();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void srand(uint __seed)

{
  srand(__seed);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * inet_ntoa(in_addr __in)

{
  char *pcVar1;
  
  pcVar1 = inet_ntoa(__in);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcgetattr(int __fd,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcgetattr(__fd,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

hostent * gethostbyname(char *__name)

{
  hostent *phVar1;
  
  phVar1 = gethostbyname(__name);
  return phVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sprintf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strcspn(char *__s,char *__reject)

{
  size_t sVar1;
  
  sVar1 = strcspn(__s,__reject);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strsep(char **__stringp,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strsep(__stringp,__delim);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = stat(__file,__buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int atoi(char *__nptr)

{
  int iVar1;
  
  iVar1 = atoi(__nptr);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strspn(char *__s,char *__accept)

{
  size_t sVar1;
  
  sVar1 = strspn(__s,__accept);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open(__file,__oflag);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int toupper(int __c)

{
  int iVar1;
  
  iVar1 = toupper(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
  int iVar1;
  
  iVar1 = fcntl(__fd,__cmd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



void __fputc_unlocked(void)

{
  __fputc_unlocked();
  return;
}


